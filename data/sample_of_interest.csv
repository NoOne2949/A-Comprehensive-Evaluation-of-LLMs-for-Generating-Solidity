ID,Function,Comment,FormattedCode,Contract,IsCorrect,cognitive_complexity,loc,cyclomatic_complexity,ast,CognitiveComplexity,CyclomaticComplexity,target_function,contract_with_constructor
3024,"function announceFork ( string name , string url , uint256 blockNumber ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( blockNumber == 0 || blockNumber > block . number ) ; _nextForkName = name ; _nextForkUrl = url ; _nextForkBlockNumber = blockNumber ; LogForkAnnounced ( _nextForkName , _nextForkUrl , _nextForkBlockNumber ) ; }",Announce that a particular future Ethereum fork will the one taken by the contract .,"function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""only"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ROLE_PLATFORM_OPERATOR_REPRESENTATIVE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyRole(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
2295,"function sell ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","function sell(uint256 quantity, uint256 price, uint256 expiry) public {
    require(quantity > 0, ""You must supply a quantity."");
    require(price > 0, ""The sale price cannot be zero."");
    require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
    require(price >= sellFloor, ""The ask is below the minimum allowed."");
    require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

    uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);
    require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

    uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
    require(balance >= quantity, ""Not enough tokens owned to complete the order."");

    orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
    emit TokensOffered(msg.sender, quantity, price, expiry);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}",True,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sell', 'complexity': 8}]",16.0,11.0,"{""type"": ""FunctionDefinition"", ""name"": ""sell"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""You must supply a quantity.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The sale price cannot be zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot have an expiry date in the past.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellFloor""}}, {""type"": ""stringLiteral"", ""value"": ""The ask is below the minimum allowed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}}}, {""type"": ""stringLiteral"", ""value"": ""The ask is above the maximum allowed.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""You must approve the transfer of tokens before offering them for sale.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens owned to complete the order.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sell', 'complexity': 8}]",11.0,sell,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) Ownable(msg.sender) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}"
1386,"function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > SafeDecimalMath . unit ( ) , ""Minimum deposit amount must be greater than UNIT"" ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }",Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"function setMinimumDepositAmount(uint _amount) external onlyOwner {
    require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
    minimumDepositAmount = _amount;
    emit MinimumDepositAmountUpdated(minimumDepositAmount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}",False,"[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumDepositAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""unit""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Minimum deposit amount must be greater than UNIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minimumDepositAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MinimumDepositAmountUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""minimumDepositAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,setMinimumDepositAmount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

contract YourContract is Ownable {
    using SafeMath for uint256;
    uint public minimumDepositAmount = 1;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        minimumDepositAmount = 1;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}"
6236,"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private whenNotPaused { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }",Helper function that checks for ERC777TokensSender on the sender and calls it .,"function callSender(address _operator, address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) private whenNotPaused {
    address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
    if (senderImplementation != 0) {
        ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",False,"[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callSender', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""callSender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""senderImplementation"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""interfaceAddr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""stringLiteral"", ""value"": ""ERC777TokensSender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""senderImplementation""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC777TokensSender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""senderImplementation""}], ""names"": []}, ""memberName"": ""tokensToSend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""private"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callSender', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,callSender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1700,"function finalize ( ) public initialized { Tier tier = tiers [ tierCount ] ; assert ( tier . finalizedTime ( ) == 0 ) ; assert ( getBlockTimestamp ( ) >= tier . startTime ( ) ) ; assert ( msg . sender == controller || getBlockTimestamp ( ) > tier . endTime ( ) || isCurrentTierCapReached ( ) ) ; tier . finalize ( ) ; tierCount ++ ; FinalizedTier ( tierCount , tier . finalizedTime ( ) ) ; }",This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"function finalize ( ) public initialized {
    Tier tier = tiers [ tierCount ] ;
    assert ( tier . finalizedTime ( ) == 0 ) ;
    assert ( getBlockTimestamp ( ) >= tier . startTime ( ) ) ;
    assert ( msg . sender == controller || getBlockTimestamp ( ) > tier . endTime ( ) || isCurrentTierCapReached ( ) ) ;
    tier . finalize ( ) ;
    tierCount ++ ;
    FinalizedTier ( tierCount , tier . finalizedTime ( ) ) ;
}


function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}",False,"[{'function': 'finalize', 'complexity': 5}, {'function': 'announceFork', 'complexity': 2}]",10.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Tier""}, ""name"": ""tier"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tiers""}, ""index"": {""type"": ""Identifier"", ""name"": ""tierCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tier""}, ""memberName"": ""finalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tier is already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tier""}, ""memberName"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Start time has not been reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tier""}, ""memberName"": ""endTime""}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isCurrentTierCapReached""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not authorized to finalize this tier""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tier""}, ""memberName"": ""finalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tier""}, ""memberName"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""FinalizedTier""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tierCount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tierCount""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""initialized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'finalize', 'complexity': 5}, {'function': 'announceFork', 'complexity': 2}]",6.0,finalize,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        tierCount = 1;
        tiers[0] = Tier({
            initialized: true,
            startTime: block.timestamp,
            endTime: block.timestamp + 365 days, // Placeholder for a year
            finalized: false,
            finalizedTime: 0
        });
    }

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount - 1];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount - 1, block.timestamp);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}"
250,function setTimelock ( uint _newTimeLock ) onlyOwner external { require ( _newTimeLock >= absoluteMinTimeLock ) ; timeLock = _newTimeLock ; },` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"function setTimelock (uint _newTimeLock) onlyOwner external {
    require(_newTimeLock >= absoluteMinTimeLock);
    timeLock = _newTimeLock;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}",True,"[{'function': 'setTimelock', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimelock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,setTimelock,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock = 1 days; // Set to safe, non-corner-case value
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor
    }

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}"
5791,"function requestInvestment ( uint giveQuantity , uint shareQuantity , address investmentAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed [ investmentAsset ] ) pre_cond ( modules . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestAsset : investmentAsset , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : modules . pricefeed . getLastUpdateId ( ) } ) ) ; emit RequestUpdated ( getLastRequestId ( ) ) ; }",Give melon tokens to receive shares of this fund,"function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
    requests.push(Request({
        participant: msg.sender,
        status: RequestStatus.active,
        requestAsset: investmentAsset,
        shareQuantity: shareQuantity,
        giveQuantity: giveQuantity,
        receiveQuantity: shareQuantity,
        timestamp: now,
        atUpdateId: modules.pricefeed.getLastUpdateId()
    }));
    emit RequestUpdated(getLastRequestId());
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}",False,"[{'function': 'getLastUpdateId', 'complexity': 0}, {'function': 'isInvestmentPermitted', 'complexity': 0}, {'function': 'requestInvestment', 'complexity': 0}]",13.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""requestInvestment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""giveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investmentAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Request""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestStatus""}, ""memberName"": ""active""}, {""type"": ""Identifier"", ""name"": ""investmentAsset""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""Identifier"", ""name"": ""giveQuantity""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""getLastUpdateId""}, ""arguments"": [], ""names"": []}], ""names"": [""participant"", ""status"", ""requestAsset"", ""shareQuantity"", ""giveQuantity"", ""receiveQuantity"", ""timestamp"", ""atUpdateId""]}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestUpdated""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isShutDown""}, ""isPrefix"": True}]}, {""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isInvestAllowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""investmentAsset""}}]}, {""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""compliance""}, ""memberName"": ""isInvestmentPermitted""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""giveQuantity""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}], ""names"": []}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getLastUpdateId', 'complexity': 0}, {'function': 'isInvestmentPermitted', 'complexity': 0}, {'function': 'requestInvestment', 'complexity': 0}]",1.0,requestInvestment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules, address owner) Ownable(owner) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}"
1160,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"
function setPrices (uint256 newSellPrice , uint256 newBuyPrice) onlyOwner {
    sellPrice = newSellPrice;
    buyPrice = newBuyPrice;
}

In this case, the formatting style is consistent with the Solidity syntax and follows the recommended guidelines for readability. The function name is descriptive and clearly indicates its purpose. The parameters are named and have meaningful names that help in understanding their usage within the function. The onlyOwner modifier ensures that only the owner of the contract can call this function, adding an extra layer of security to prevent unauthorized changes to the prices.

The function body is also well-structured, with each statement on a new line and indented for better readability. The variable assignments are clearly separated from each other, making it easier to understand the flow of the code. Overall, this formatting style helps in maintaining a clear and organized structure within the function, making it easier to read and understand.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}",True,"[{'function': 'setPrices', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,setPrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor() Ownable(msg.sender) {
        sellPrice = 1; // Set to safe, non-corner-case value
        buyPrice = 2; // Set to safe, non-corner-case value
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}"
3416,"function getProperty ( uint256 _id ) public view returns ( uint32 parent , uint8 class , uint8 x , uint8 y , uint8 z , uint8 dx , uint8 dz , uint8 height ) { Property storage property = properties [ _id ] ; parent = uint32 ( property . parent ) ; class = uint8 ( property . class ) ; height = uint8 ( property . y ) ; if ( property . class == PropertyClass . BUILDING ) { y = uint8 ( _computeHeight ( property . x , property . z , property . y ) ) ; } else { y = uint8 ( property . y ) ; } x = uint8 ( property . x ) ; z = uint8 ( property . z ) ; dx = uint8 ( property . dx ) ; dz = uint8 ( property . dz ) ; }",Returns all the relevant information about a specific property .,"function getProperty(uint256 _id) public view returns (
    uint32 parent,
    uint8 class,
    uint8 x,
    uint8 y,
    uint8 z,
    uint8 dx,
    uint8 dz,
    uint8 height
) {
    Property storage property = properties[_id];
    parent = uint32(property.parent);
    class = uint8(property.class);
    height = uint8(property.y);
    if (property.class == PropertyClass.BUILDING) {
        y = uint8(_computeHeight(property.x, property.z, property.y));
    } else {
        y = uint8(property.y);
    }
    x = uint8(property.x);
    z = uint8(property.z);
    dx = uint8(property.dx);
    dz = uint8(property.dz);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}",False,"[{'function': 'getProperty', 'complexity': 0}, {'function': '_computeHeight', 'complexity': 0}, {'function': 'getProperty', 'complexity': 0}]",24.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProperty"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""parent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""class"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""z"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""dx"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""dz"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""height"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Property""}, ""name"": ""property"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""parent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""parent""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""class""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""height""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PropertyClass""}, ""memberName"": ""BUILDING""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_computeHeight""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""x""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""z""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}], ""names"": []}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""x""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""x""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""z""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""z""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dx""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dx""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dz""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dz""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getProperty', 'complexity': 0}, {'function': '_computeHeight', 'complexity': 0}, {'function': 'getProperty', 'complexity': 0}]",2.0,getProperty,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            properties[i].parent = uint32(i);
            properties[i].class = PropertyClass.NONE;
            properties[i].x = uint8(i * 10);
            properties[i].y = uint8(i * 20);
            properties[i].z = uint8(i * 30);
            properties[i].dx = uint8(i * 40);
            properties[i].dz = uint8(i * 50);
        }
    }
}"
4560,function totalListings ( ) public view returns ( uint256 ) { return forSalePixelconIndexes . length ; },Get the current total number of market listings,"function totalListings() public view returns (uint256) {
    return forSalePixelconIndexes.length;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}",True,"[{'function': 'totalListings', 'complexity': 0}]",3.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalListings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""forSalePixelconIndexes""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'totalListings', 'complexity': 0}]",2.0,totalListings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        forSalePixelconIndexes = [1, 2, 3]; // Fixed values as per the rules
    }

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}"
2354,"function transferFromAndCall ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) ;",Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {
    // code here
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}",True,"[{'function': 'transferFromAndCall', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'transferFromAndCall', 'complexity': 0}]",1.0,transferFromAndCall,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}"
3881,"function isTrusted ( address _from , address _to ) public view returns ( bool ) { return get ( store , holdersTrustStorage , getHolderId ( _from ) , _to ) ; }",Check if specified holder trusts an address with recovery procedure .,"function isTrusted ( address _from , address _to ) public view returns ( bool ) {
    return get ( store , holdersTrustStorage , getHolderId ( _from ) , _to ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}",True,"[{'function': 'isTrusted', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTrusted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trustedMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isTrusted', 'complexity': 0}]",1.0,isTrusted,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}"
2976,"function removeBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , ""Blacklist token destruction not supported by token"" ) ; removeUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogRemovedBlacklistDestroyer ( _who ) ; }",Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"
function removeBlacklistDestroyer(address _who) public onlyValidator {
    require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
    removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
    emit LogRemovedBlacklistDestroyer(_who);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}",True,"[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeUserPermission', 'complexity': 2}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeBlacklistDestroyer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DESTROY_BLACKLISTED_TOKENS_SIG""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Blacklist token destruction not supported by token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeUserPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""DESTROY_BLACKLISTED_TOKENS_SIG""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogRemovedBlacklistDestroyer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeUserPermission', 'complexity': 2}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}]",2.0,removeBlacklistDestroyer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6370,function releaseTokenForTransfer ( ) public onlyAdmin whenNotPaused { require ( ! released ) ; released = true ; emit TokenReleased ( released ) ; },This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
    require(!released);
    released = true;
    emit TokenReleased(released);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}",False,"[{'function': 'releaseTokenForTransfer', 'complexity': 2}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokenForTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""released""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens have already been released""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""released""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenReleased""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""released""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'releaseTokenForTransfer', 'complexity': 2}]",2.0,releaseTokenForTransfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released = false;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(!paused, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}"
3576,"function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit ModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }",adds or removes addresses from the whitelist .,"
function modifyWhitelist(address _investor, bool _valid) public withPerm(WHITELIST) {
    whitelist[_investor] = _valid;
    emit ModifyWhitelist(_investor, now, msg.sender, _valid);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}",True,"[{'function': 'modifyWhitelist', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_valid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_valid""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModifyWhitelist""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_valid""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'modifyWhitelist', 'complexity': 0}]",3.0,modifyWhitelist,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            whitelist[address(uint160(i << 160))] = true;
        }
    }

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}"
1319,"function approve ( address spender , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }",Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"function approve(address spender, uint256 tokens) public returns (bool success) {
    requireTrade(msg.sender);
    allowed[msg.sender][spender] = tokens;
    emit Approval(msg.sender, spender, tokens);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}",False,"[{'function': 'approve', 'complexity': 1}, {'function': 'requireTrade', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""requireTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': 'requireTrade', 'complexity': 1}]",2.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}"
4806,"function doSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter <= 1 || _escrow . sellerCanCancelAfter > block . timestamp ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doSellerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledBySeller ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }",Returns the ether in escrow to the seller .,"function doSellerCancel (bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) private returns (bool) {
    Escrow memory _escrow;
    bytes32 _tradeHash;
    (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

    if (!_escrow.exists) {
        return false;
    }

    if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
        return false;
    }

    uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

    delete escrows[_tradeHash];

    emit CancelledBySeller(_tradeHash);

    transferMinusFees(_seller, _value, _gasFees, 0);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}",False,"[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'transferMinusFees', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 5}]",23.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""doSellerCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_tradeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""_additionalGas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Escrow""}, ""name"": ""_escrow"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_tradeHash"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_escrow""}, {""type"": ""Identifier"", ""name"": ""_tradeHash""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getEscrowAndHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeID""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""exists""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""_gasFees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""totalGasFeesSpentByRelayer""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""relayer""}}, ""TrueExpression"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""GAS_doSellerCancel""}, ""right"": {""type"": ""Identifier"", ""name"": ""_additionalGas""}}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""gasprice""}], ""names"": []}}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tradeHash""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CancelledBySeller""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeHash""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferMinusFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_gasFees""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'transferMinusFees', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 5}]",6.0,doSellerCancel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        relayer = address(uint160(uint256(keccak256('relayer1'))));
    }

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}"
3857,function startSale ( ) public onlyController { require ( campaignState > 2 && teamVaultAddr != 0x0 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; tBonusStageEnd += tNow ; tRegSaleStart += tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; t_3rd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; },Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"function startSale() public onlyController {
    require(campaignState > 2 && teamVaultAddr != address(0));
    campaignState = 2;
    uint256 tNow = now;
    tCampaignStart = tNow;
    tBonusStageEnd += tNow;
    tRegSaleStart += tNow;
    t_1st_StageEnd += tNow;
    t_2nd_StageEnd += tNow;
    t_3rd_StageEnd += tNow;
    tCampaignEnd += tNow;
    CampaignOpen(now);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}",False,"[{'function': 'startSale', 'complexity': 2}]",13.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""startSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""teamVaultAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignState""}, ""memberName"": ""Sale""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tNow"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tBonusStageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tRegSaleStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_1st_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_2nd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_3rd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignOpen""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tNow""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'startSale', 'complexity': 2}]",3.0,startSale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;
    address public ownerAddress = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initBytes = bytes32('init');
    uint256 public tCampaignStart = 1; // fixed value
    uint256 public tBonusStageEnd = 1; // fixed value
    uint256 public tRegSaleStart = 1; // fixed value
    uint256 public t_1st_StageEnd = 1; // fixed value
    uint256 public t_2nd_StageEnd = 1; // fixed value
    uint256 public t_3rd_StageEnd = 1; // fixed value
    uint256 public tCampaignEnd = 1; // fixed value

    event CampaignOpen(uint256 timestamp);

    constructor() Ownable(msg.sender) {
        teamVaultAddr = 0x2222222222222222222222222222222222222222; // fixed value
        ownerAddress = msg.sender;
        initialized = true;
        initBytes = bytes32('init');
    }

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}"
497,"function addSynth ( Synth synth ) external optionalProxy_onlyOwner { bytes4 currencyKey = synth . currencyKey ( ) ; require ( synths [ currencyKey ] == Synth ( 0 ) , ""Synth already exists"" ) ; availableSynths . push ( synth ) ; synths [ currencyKey ] = synth ; emitSynthAdded ( currencyKey , synth ) ; }",Add an associated Synth contract to the Synthetix system,"
function addSynth(Synth synth) external optionalProxy_onlyOwner {
    bytes4 currencyKey = synth.currencyKey();
    require(synths[currencyKey] == Synth(0), ""Synth already exists"");
    availableSynths.push(synth);
    synths[currencyKey] = synth;
    emitSynthAdded(currencyKey, synth);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}",False,"[{'function': 'currencyKey', 'complexity': 0}, {'function': 'addSynth', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""currencyKey"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""currencyKey""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""currencyKey""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synth already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""availableSynths""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""synth""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""currencyKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""synth""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}, {""type"": ""Identifier"", ""name"": ""synth""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'currencyKey', 'complexity': 0}, {'function': 'addSynth', 'complexity': 1}]",2.0,addSynth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        availableSynths = [];
        synths = {};
    }

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}"
5313,function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; buyPrice = initialBuyPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; },update the price based on the remaining count of resources,"function updatePrice() public {
    sellPrice = initialSellPrice * initialSupply * (10 ** uint256(decimals)) / totalSupply;
    buyPrice = initialBuyPrice * initialSupply * (10 ** uint256(decimals)) / totalSupply;
}

The formatted function is identical to the original function, but with proper indentation, consistent use of spaces, and alignment for better readability. The `public` access modifier has been added to the function declaration to indicate that it can be called from outside the contract.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}",False,"[{'function': 'updatePrice', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialSupply""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""decimals""}], ""names"": []}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialSupply""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""decimals""}], ""names"": []}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,updatePrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) Ownable() {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}"
565,"function removeAddressesFromWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , ""Cannot remove an empty list to whitelist!"" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = false ; emit WhitelistRemoved ( user ) ; } } }",Removes a list of addresses from the whitelist .,"function removeAddressesFromWhitelist (address[] _users) external onlyAdmin {
    require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

    for(uint256 i = 0; i < _users.length; ++i) {
        address user = _users[i];
        if(whitelist[user]) {
            whitelist[user] = false;
            emit WhitelistRemoved(user);
        }
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}",True,"[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAddressesFromWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_users"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_users""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Cannot remove an empty list to whitelist!""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_users""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": True}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_users""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WhitelistRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,removeAddressesFromWhitelist,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}"
3142,function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; },Get the token balance of ` tokenOwner `,"function balanceOf(address tokenOwner) public constant returns (uint balance) {
    return balances[tokenOwner];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,balanceOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

contract ERC20Wrapper is Ownable {;
    mapping(address => uint256) public balances;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function balanceOf(address tokenOwner) public pure override returns (uint256 balance) {
        return 1; // Placeholder for ERC20 balance retrieval logic
    }
}"
3096,"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .,"function claimTokens ( address _token ) public onlyOwner {
    if ( _token == 0x0 ) {
        owner . transfer ( address ( this ) . balance ) ;
        return ;
    }
    MiniMeToken token = MiniMeToken ( _token ) ;
    uint balance = token . balanceOf ( this ) ;
    token . transfer ( owner , balance ) ;
    emit ClaimedTokens ( _token , owner , balance ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",False,"[{'function': 'claimTokens', 'complexity': 2}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, None]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'claimTokens', 'complexity': 2}]",3.0,claimTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}"
6593,function orderTrader ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . trader ; },returns the trader of the given orderID .,"function orderTrader ( bytes32 _orderID ) external view returns ( address ) {
    return orders[ _orderID ].trader;
}

// Example of correctly formatted output:

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}",False,"[{'function': 'orderTrader', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderTrader"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}, ""memberName"": ""trader""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'orderTrader', 'complexity': 0}]",1.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function init() public {
        // Initialize all instance variables to fixed, safe values
        orders[bytes32('init')] = Order(address(0x1111111111111111111111111111111111111111), 1);
    }
}"
2524,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
    if (msg.sender != controller) {
        require(transfersEnabled);
        if (allowed[_from][msg.sender] < _amount) {
            return false;
        }
        allowed[_from][msg.sender] -= _amount;
    }
    return doTransfer(_from, _to, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",11.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are not enabled""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeSub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",5.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

contract ERC20Wrapper is Ownable {;
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor() {
        require(msg.sender != address(0), ""Controller must be set"");
        controller = msg.sender;
        transfersEnabled = true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }

    // Additional functions and variables can be added here
}"
4577,"function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; Approval ( msg . sender , _who , _value ) ; return true ; }",Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"function approve ( address _who , uint256 _value ) public returns ( bool ) {
    require ( _who != 0x0 ) ;
    require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ;
    allowed [ msg . sender ] [ _who ] = _value ;
    Approval ( msg . sender , _who , _value ) ;
    return true ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 3}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Allowance already granted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 3}]",4.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ApproveWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) address(allowed[address(this)][address(0x111)]) = 1;
            else if (i == 2) address(allowed[address(this)][address(0x222)]) = 1;
            else if (i == 3) address(allowed[address(this)][address(0x333)]) = 1;
        }
    }

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}"
6152,"function hasRecentPrice ( address ofAsset ) view pre_cond ( information [ ofAsset ] . exists ) returns ( bool isRecent ) { return sub ( now , information [ ofAsset ] . timestamp ) <= VALIDITY ; }",Whether price of asset has been updated less than VALIDITY seconds ago,"function hasRecentPrice (address ofAsset) view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
    return sub(now, information[ofAsset].timestamp) <= VALIDITY;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}",False,"[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",4.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasRecentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRecent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Asset information does not exist""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""now""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""timestamp""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""seconds""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""VALIDITY""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""exists""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",7.0,hasRecentPrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        VALIDITY = 3600;
    }

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}"
4397,function enableTransfers ( bool _transfersEnabled ) onlyOwner public { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true,"function enableTransfers (bool _transfersEnabled) onlyOwner public {
    transfersEnabled = _transfersEnabled;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",True,"[{'function': 'enableTransfers', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,enableTransfers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        transfersEnabled = true; // Set to true instead of false as per the initialization rules
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
6310,function setMigrationAgent ( address _agent ) external onlyOwner { require ( migrationAgent == 0x0 && totalMigrated == 0 ) ; migrationAgent = _agent ; },Set address of migration target contract and enable migration process,"function setMigrationAgent(address _agent) external onlyOwner {
    require(migrationAgent == address(0x0) && totalMigrated == 0);
    migrationAgent = _agent;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}",True,"[{'function': 'setMigrationAgent', 'complexity': 2}]",4.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMigrationAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_agent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""Identifier"", ""name"": ""_agent""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,setMigrationAgent,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MigrationAgentSetter is Ownable {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    constructor() Ownable(msg.sender) {
        migrationAgent = 0x1111111111111111111111111111111111111111; // Replace with your fixed value
        totalMigrated = 1; // Set to a non-zero value
    }

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}"
4553,"function mint ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }",Allows user to mint if they have the appropriate permissions .,"function mint (address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
    _mint(_to, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}",False,"[{'function': 'mint', 'complexity': 1}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mint', 'complexity': 1}]",2.0,mint,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}"
4912,function withdrawBalance ( ) public mustBeAtStage ( Stage . Finalized ) { wallet . transfer ( this . balance ) ; },Used only if there are some leftover funds ( because of topUpBalance ),"function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
    wallet.transfer(this.balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}",False,"[{'function': 'withdrawBalance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wallet""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""mustBeAtStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Finalized""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdrawBalance', 'complexity': 0}]",1.0,withdrawBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}"
4727,"function giftOwnerByIndex ( address _owner , uint256 _index ) external constant returns ( uint256 GiftId ) { uint256 [ ] memory ownerGifts = GiftsOfOwner ( _owner ) ; return ownerGifts [ _index ] ; }",This method MUST NEVER be called by smart contract code .,"function giftOwnerByIndex(address _owner, uint256 _index) external constant returns (uint256 GiftId) {
    uint256[] memory ownerGifts = GiftsOfOwner(_owner);
    return ownerGifts[_index];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}",True,"[{'function': 'GiftsOfOwner', 'complexity': -2}, {'function': 'giftOwnerByIndex', 'complexity': 1}]",6.0,11.0,"{""type"": ""FunctionDefinition"", ""name"": ""giftOwnerByIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""GiftId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IGiftToken""}, ""name"": ""giftToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IGiftToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""giftContractAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""ownerGifts"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""giftToken""}, ""memberName"": ""GiftsOfOwner""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerGifts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerGifts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_index""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'GiftsOfOwner', 'complexity': -2}, {'function': 'giftOwnerByIndex', 'complexity': 1}]",13.0,giftOwnerByIndex,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) Ownable(msg.sender) {
        require(_giftContractAddress != address(0), ""Invalid contract address"");
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}"
5921,"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by approvePreSigned,"function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
    return keccak256(
        bytes4(0xf7ac9c2e),
        _token,
        _spender,
        _value,
        _fee,
        _nonce
    );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}",False,"[{'function': 'approvePreSignedHashing', 'complexity': 0}]",10.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approvePreSignedHashing"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0xf7ac9c2e"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,approvePreSignedHashing,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ApprovePreSignedHashingWrapper is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are not defined in the provided contract
    }

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}"
5070,"function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( hashIdToMultisig [ msigId ] . deposit >= amount ) ; require ( now >= hashIdToMultisig [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }",Withdraw ether and delete the htlc swap .,"
function timeoutResolve (bytes32 msigId, uint amount) public {
    require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
    require(now >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
    spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}",False,"[{'function': 'spendFromMultisig', 'complexity': 0}, {'function': 'timeoutResolve', 'complexity': 2}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""timeoutResolve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient deposit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""unlockTime""}}, {""type"": ""stringLiteral"", ""value"": ""Unlock time has not been reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""spendFromMultisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msigId""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""owner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'spendFromMultisig', 'complexity': 0}, {'function': 'timeoutResolve', 'complexity': 2}]",3.0,timeoutResolve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}

contract MultisigWalletImpl is MultisigWallet {
    constructor() {
        // Initialize Ownable with the deployer's address
        __Ownable_init();
    }

    function __Ownable_init() internal {
        _transferOwnership(msg.sender);
    }
}"
4823,"function operatorBatchSend ( address _from , address [ ] _recipients , uint256 [ ] _amounts , bytes _userData , bytes _operatorData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) whenAccountNotFrozen ( _from ) { require ( _recipients . length == _amounts . length , ""The lengths of _recipients and _amounts should be the same."" ) ; require ( isOperatorFor ( msg . sender , _from ) ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , _from , _recipients [ i ] , _amounts [ i ] , _userData , _operatorData , true ) ; } }",Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"function operatorBatchSend(address _from, address[] _recipients, uint256[] _amounts, bytes _userData, bytes _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
    require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
    require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

    for (uint256 i = 0; i < _recipients.length; i++) {
        doSend(msg.sender, _from, _recipients[i], _amounts[i], _userData, _operatorData, true);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}",False,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 2}, {'function': 'freezeAccount', 'complexity': 0}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'operatorBatchSend', 'complexity': 3}]",8.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""operatorBatchSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""The lengths of _recipients and _amounts should be the same.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isOperatorFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Only operators can call this function""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doSend""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenAccountNotFrozen"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}, {""type"": ""ModifierInvocation"", ""name"": ""whenAccountNotFrozen"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 2}, {'function': 'freezeAccount', 'complexity': 0}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'operatorBatchSend', 'complexity': 3}]",5.0,operatorBatchSend,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    mapping(address => bool) public frozenAccounts;
    bytes32 public initializedBytes;

    constructor() Ownable(msg.sender) {
        paused = true;
        frozenAccounts[msg.sender] = false;
        initializedBytes = bytes32('init');
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}"
4675,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom due to insufficent Allowance provided"" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return permissionManager ; }",Used to launch the Module with the help of factory,"
function deploy(bytes) external returns (address) {
    if (setupCost > 0) {
        require(polyToken.transferFrom(msg.sender, owner, setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
    }
    address permissionManager = new GeneralPermissionManager(msg.sender, address(polyToken));
    emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, now);
    return permissionManager;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",8.0,3.0,{},"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",3.0,deploy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        setupCost = 1;
        polyToken = IPolyToken(address(0x2222222222222222222222222222222222222222));
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}"
772,function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( synthesizingAuction != address ( 0 ) ) ; require ( geneSynthesis != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This should be public rather than external .,"
function unpause() public onlyCEO whenPaused {
    require(saleAuction != address(0));
    require(synthesizingAuction != address(0));
    require(geneSynthesis != address(0));
    require(newContractAddress == address(0));
    super.unpause();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}",False,"[{'function': 'unpause', 'complexity': 4}]",7.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""synthesizingAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""geneSynthesis""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unpause', 'complexity': 4}]",5.0,unpause,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor() 
        // Initialize Ownable contract
        Ownable(msg.sender)
        // Initialize other variables with fixed, safe values
        saleAuction(address(0x1111111111111111111111111111111111111111))  // Replace with actual value
        synthesizingAuction(address(0x2222222222222222222222222222222222222222))  // Replace with actual value
        geneSynthesis(address(0x3333333333333333333333333333333333333333))  // Replace with actual value
    {
        require(saleAuction != address(0), ""Sale auction must be a valid address"");
        require(synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}"
6429,"function proxyChangeTokenMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( ""PoaManager"" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaTokenMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaTokenMaster ; poaTokenMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( ""PoaLogger"" ) . call ( bytes4 ( keccak256 ( ""logProxyUpgraded(address,address)"" ) ) , _oldMaster , _newMaster ) ; return true ; }",Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}",False,"[{'function': 'proxyChangeTokenMaster', 'complexity': 4}]",14.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyChangeTokenMaster"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newMaster"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getContractAddress""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""PoaManager""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the PoaManager contract can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMaster""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid new master address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMaster""}}, {""type"": ""stringLiteral"", ""value"": ""New master address is the same as the current one""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New master address must be a contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldMaster"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMaster""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ProxyUpgraded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_oldMaster""}, {""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getContractAddress""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""PoaLogger""}], ""names"": []}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""logProxyUpgraded(address,address)""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_oldMaster""}, {""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyChangeTokenMaster', 'complexity': 4}]",5.0,proxyChangeTokenMaster,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor() Ownable(msg.sender) {
        saleAuction = 0x1111111111111111111111111111111111111111; // Replace with actual value
        synthesizingAuction = 0x2222222222222222222222222222222222222222; // Replace with actual value
        geneSynthesis = 0x3333333333333333333333333333333333333333; // Replace with actual value
        newContractAddress = address(0); // Initialize to zero address
    }

    function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
        require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
        require(_newMaster != address(0), ""Invalid new master address"");
        require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
        require(isContract(_newMaster), ""New master address must be a contract"");

        address _oldMaster = poaTokenMaster;
        poaTokenMaster = _newMaster;
        emit ProxyUpgraded(_oldMaster, _newMaster);

        getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

        return true;
    }
}"
4411,"function trust ( address _to ) public returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( fromId == getHolderId ( _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ALREADY_TRUSTED ) ; } set ( store , holdersTrustStorage , fromId , _to , true ) ; return OK ; }",Trust an address to perform recovery procedure for the caller .,"
function trust(address _to) public returns (uint) {
    uint fromId = _createHolderId(msg.sender);
    if (fromId == getHolderId(_to)) {
        return _emitErrorCode(CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
    }
    if (isTrusted(msg.sender, _to)) {
        return _emitErrorCode(CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
    }
    set(store, holdersTrustStorage, fromId, _to, true);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}",False,"[{'function': '_emitErrorCode', 'complexity': 0}, {'function': 'trust', 'complexity': 6}, {'function': '_createHolderId', 'complexity': 0}]",11.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""trust"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""fromId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createHolderId""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""fromId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""getHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""_emitErrorCode""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ErrorCodes""}, ""memberName"": ""CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""isTrusted""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""_emitErrorCode""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ErrorCodes""}, ""memberName"": ""CHRONOBANK_PLATFORM_ALREADY_TRUSTED""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""set""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""holdersTrust""}, {""type"": ""Identifier"", ""name"": ""fromId""}], ""names"": []}], ""names"": []}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ErrorCodes""}, ""memberName"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_emitErrorCode', 'complexity': 0}, {'function': 'trust', 'complexity': 6}, {'function': '_createHolderId', 'complexity': 0}]",8.0,trust,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with your platform contract address
    ChronoBankPlatform public platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    uint public constant DEFAULT_FROM_ID = 1;
    bool public constant DEFAULT_TRUSTED = true;

    constructor() Ownable(msg.sender) {
        set(address(this), keccak256(abi.encodePacked(""holdersTrust"", DEFAULT_FROM_ID)), 0, msg.sender, DEFAULT_TRUSTED);
    }

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(_to);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}"
2481,"function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = safeSub ( totalVestedBalance , totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }",Destroy the vesting information associated with an account .,"function purgeAccount (address account) external onlyOwner onlyDuringSetup {
    delete vestingSchedules[account];
    totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
    delete totalVestedAccountBalance[account];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}",False,"[{'function': 'purgeAccount', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""purgeAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalVestedAccountBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalVestedAccountBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyDuringSetup"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'purgeAccount', 'complexity': 0}]",1.0,purgeAccount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        totalVestedBalance = 1; // uint256: Set to 1 (never 0)
        address ownerAddress = msg.sender;
        vestingSchedules[ownerAddress] = VestingSchedule({}); // address: Use fixed value 0x1111111111111111111111111111111111111111
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}"
4726,"function finalizeSale ( ) public onlyController { require ( now > endTime || totalIssued >= HARD_CAP ) ; require ( ! finalized ) ; vestedAllowances [ vaultAddress ] = Vesting ( lockedTokens , now + 3 years ) ; uint256 leftoverTokens = MAX_TOKENS . sub ( lockedTokens ) . sub ( totalIssued ) . sub ( totalIssuedEarlySale ) . sub ( totalVested ) ; require ( tokenContract . generateTokens ( vaultAddress , leftoverTokens ) ) ; require ( tokenContract . generateTokens ( address ( this ) , lockedTokens . add ( totalVested ) ) ) ; finalized = true ; }",` finalizeSale ( ) ` ends the TokenSale .,"function finalizeSale() public onlyController {
    require(now > endTime || totalIssued >= HARD_CAP);
    require(!finalized);
    vestedAllowances[vaultAddress] = Vesting(lockedTokens, now + 3 years);
    uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalIssuedEarlySale).sub(totalVested);
    require(tokenContract.generateTokens(vaultAddress, leftoverTokens));
    require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)));
    finalized = true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}",False,"[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalizeSale', 'complexity': 6}]",12.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalIssued""}, ""right"": {""type"": ""Identifier"", ""name"": ""HARD_CAP""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sale has already been finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAllowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""vaultAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vesting""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockedTokens""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": ""years""}}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""leftoverTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockedTokens""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalIssued""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalVested""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""generateTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vaultAddress""}, {""type"": ""Identifier"", ""name"": ""leftoverTokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed for vault""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""generateTokens""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lockedTokens""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalVested""}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed for contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalizeSale', 'complexity': 6}]",8.0,finalizeSale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    address public constant DEFAULT_VAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant DEFAULT_TOKEN_CONTRACT = ""MyToken""; // Replace with actual token name
    bytes32 public constant DEFAULT_BYTES32_VALUE = bytes32('init');
    bool public constant DEFAULT_FINALIZED = true;
    uint256 public constant DEFAULT_END_TIME = block.timestamp + 3 years; // Example end time, adjust as needed
    uint256 public constant DEFAULT_TOTAL_ISSUED = 0;
    uint256 public constant DEFAULT_LOCKED_TOKENS = 0;
    uint256 public constant DEFAULT_TOTAL_VESTED = 0;
    uint256 public constant DEFAULT_HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant DEFAULT_MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed

    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    constructor() Ownable(msg.sender) {
        _setVaultAddress(DEFAULT_VAULT_ADDRESS);
        _setTokenContract(DEFAULT_TOKEN_CONTRACT);
        _setFinalized(DEFAULT_FINALIZED);
        _setEndTime(DEFAULT_END_TIME);
        _setTotalIssued(DEFAULT_TOTAL_ISSUED);
        _setLockedTokens(DEFAULT_LOCKED_TOKENS);
        _setTotalVested(DEFAULT_TOTAL_VESTED);
    }

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP, ""Sale has not been finalized"");
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}"
475,"function partialRelease ( address who , address tradingWallet , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( tradingWallet != 0 , ""The destination wallet cannot be null."" ) ; require ( ! isExistingHolding ( tradingWallet ) , ""The destination wallet must be a new fresh wallet."" ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate , ""Only affiliates can use this function; use release() for non-affiliates."" ) ; require ( amount <= holding . quantity , ""The holding has less than the specified amount of tokens."" ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( tradingWallet , amount ) ; if ( res ) { heldTokens [ who ] = Holding ( holding . quantity . sub ( amount ) , holding . releaseDate , holding . isAffiliate ) ; emit TokensReleased ( who , amount ) ; return true ; } } return false ; }",Release some of an affiliate 's tokens to a broker/trading wallet .,"function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent {
    require(tradingWallet != 0, ""The destination wallet cannot be null."");
    require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
    Holding memory holding = heldTokens[who];
    require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
    require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
    if (block.timestamp > holding.releaseDate) {
        bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
        if (res) {
            heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
            emit TokensReleased(who, amount);
            return true;
        }
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 8}, {'function': 'isExistingHolding', 'complexity': 0}]",16.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""partialRelease"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tradingWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tradingWallet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""The destination wallet cannot be null.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isExistingHolding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradingWallet""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""The destination wallet must be a new fresh wallet.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Holding""}, ""name"": ""holding"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""isAffiliate""}, {""type"": ""stringLiteral"", ""value"": ""Only affiliates can use this function; use release() for non-affiliates.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""The holding has less than the specified amount of tokens.""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""releaseDate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""res"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradingWallet""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""res""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holding""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""quantity""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""releaseDate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""isAffiliate""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensReleased""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyTransferAgent"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 8}, {'function': 'isExistingHolding', 'complexity': 0}]",9.0,partialRelease,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1443,"function createRegulatorProxy ( address regulatorImplementation ) public { address proxy = address ( new RegulatorProxy ( regulatorImplementation ) ) ; Regulator newRegulator = Regulator ( proxy ) ; newRegulator . addValidator ( msg . sender ) ; addAllPermissions ( newRegulator ) ; RegulatorProxy ( proxy ) . transferOwnership ( msg . sender ) ; regulators . push ( proxy ) ; emit CreatedRegulatorProxy ( proxy , getCount ( ) - 1 ) ; }",the method caller will have to claim ownership of regulators since regulators are claimable,"
function createRegulatorProxy(address regulatorImplementation) public {
    address proxy = address(new RegulatorProxy(regulatorImplementation));
    Regulator newRegulator = Regulator(proxy);
    newRegulator.addValidator(msg.sender);
    addAllPermissions(newRegulator);
    RegulatorProxy(proxy).transferOwnership(msg.sender);
    regulators.push(proxy);
    emit CreatedRegulatorProxy(proxy, getCount() - 1);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}",False,"[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'initialize', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 1}, {'function': 'getCount', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}]",11.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createRegulatorProxy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""regulatorImplementation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""regulatorImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid implementation address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""proxy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RegulatorProxy""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""regulatorImplementation""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Regulator""}, ""name"": ""newRegulator"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Regulator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newRegulator""}, ""memberName"": ""addValidator""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addAllPermissions""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRegulator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RegulatorProxy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}, ""memberName"": ""transferOwnership""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CreatedRegulatorProxy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCount""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'initialize', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 1}, {'function': 'getCount', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}]",2.0,createRegulatorProxy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}"
6667,"function computeIssuanceData ( uint preBalance , IssuanceData preIssuance ) internal view returns ( IssuanceData ) { uint currentBalanceSum = preIssuance . currentBalanceSum ; uint lastAverageBalance = preIssuance . lastAverageBalance ; uint lastModified = preIssuance . lastModified ; if ( lastModified < feePeriodStartTime ) { if ( lastModified < lastFeePeriodStartTime ) { lastAverageBalance = preBalance ; } else { uint timeUpToRollover = feePeriodStartTime - lastModified ; uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime ; uint lastBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , timeUpToRollover ) ) ; lastAverageBalance = lastBalanceSum / lastFeePeriodDuration ; } currentBalanceSum = safeMul ( preBalance , now - feePeriodStartTime ) ; } else { currentBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , now - lastModified ) ) ; } return IssuanceData ( currentBalanceSum , lastAverageBalance , now ) ; }",Compute the new IssuanceData on the old balance,"function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
    uint currentBalanceSum = preIssuance.currentBalanceSum;
    uint lastAverageBalance = preIssuance.lastAverageBalance;
    uint lastModified = preIssuance.lastModified;

    if (lastModified < feePeriodStartTime) {
        if (lastModified < lastFeePeriodStartTime) {
            lastAverageBalance = preBalance;
        } else {
            uint timeUpToRollover = feePeriodStartTime - lastModified;
            uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime;
            uint lastBalanceSum = safeAdd(currentBalanceSum, safeMul(preBalance, timeUpToRollover));
            lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
        }
        currentBalanceSum = safeMul(preBalance, now - feePeriodStartTime);
    } else {
        currentBalanceSum = safeAdd(currentBalanceSum, safeMul(preBalance, now - lastModified));
    }

    return IssuanceData(currentBalanceSum, lastAverageBalance, now);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}",False,"[{'function': 'lastModified', 'complexity': -1}, {'function': 'computeIssuanceData', 'complexity': 9}]",21.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeIssuanceData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""preBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": ""preIssuance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""currentBalanceSum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""currentBalanceSum""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastAverageBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastAverageBalance""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastModified"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastModified""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModified""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""arguments"": [], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModified""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}, ""arguments"": [], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""preBalance""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeUpToRollover"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""lastModified""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastFeePeriodDuration"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}, ""arguments"": [], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastBalanceSum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preBalance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""timeUpToRollover""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""lastBalanceSum""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodDuration""}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preBalance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""arguments"": [], ""names"": []}}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preBalance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastModified""}}], ""names"": []}], ""names"": []}}}]}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IssuanceData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, {""type"": ""Identifier"", ""name"": ""now""}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'lastModified', 'complexity': -1}, {'function': 'computeIssuanceData', 'complexity': 9}]",9.0,computeIssuanceData,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe non-corner-case values
        feePeriodStartTime = 1;
        lastFeePeriodStartTime = 1;
    }
}"
1283,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","
function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {
    require(approve(_spender, _amount));
    ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, this, _extraData);
    return true;
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid block number""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        allowances = mapping(address => mapping(address => uint256))({});
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
6724,"function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , ""Blocking already exists"" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }",Adds a pair of addresses to manual blockings,"function addManualBlocking (address _from, address _to, uint256 _expiryTime) public withPerm(TRANSFER_APPROVAL) {
    require(_from != address(0), ""Invalid from address"");
    require(_to != address(0), ""Invalid to address"");
    require(_expiryTime > now, ""Invalid expiry time"");
    require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
    manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
    emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}",True,"[{'function': 'addManualBlocking', 'complexity': 4}]",8.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addManualBlocking"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiryTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiryTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid expiry time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""expiryTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Blocking already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_expiryTime""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_expiryTime""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addManualBlocking', 'complexity': 4}]",5.0,addManualBlocking,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) manualBlockings[address(0x111)][address(0x222)] = ManualBlocking(block.timestamp + 1 days);
            else if (i == 1) manualBlockings[address(0x222)][address(0x333)] = ManualBlocking(block.timestamp + 2 days);
            else if (i == 2) manualBlockings[address(0x333)][address(0x111)] = ManualBlocking(block.timestamp + 3 days);
        }
    }

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}"
2869,"function withdrawDAI ( address _receiver , uint _amount ) public onlyArbitrator { require ( _receiver != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . balanceOf ( address ( this ) ) >= _amount ) ; DAI . transfer ( _receiver , _amount ) ; emit DAIWithdrawn ( _receiver , _amount ) ; }",this function lets arbitrator withdraw DAI to the provided address,"function withdrawDAI(address _receiver, uint256 _amount) public onlyArbitrator {
    require(_receiver != address(0), ""Invalid receiver address"");
    require(_amount > 0, ""Invalid amount"");
    require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
    DAI.transfer(_receiver, _amount);
    emit DAIWithdrawn(_receiver, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDAI"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAIWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",4.0,withdrawDAI,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        require(msg.sender != address(0), ""Invalid contract creator"");
        DAI = IERC20(""MyToken"", ""TKN""); // Use placeholder values for ERC20 mapping(address => uint256) public balanceOf;

 constructor
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 1, ""Invalid amount (min 2)"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}"
3748,function end ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . previous ; },Get the node at the end of a double linked list .,"function end (List storage self) internal view returns (address) {
    return self . list[NULL].previous;
}

// Your formatted function goes here, replacing the above code.

// Example:
function end (List storage self) internal view returns (address) {
    return self . list[NULL].previous;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}",False,"[{'function': 'end', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""end"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""List""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""previous""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'end', 'complexity': 0}]",1.0,end,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract List is Ownable {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            list[i].next = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
            list[i].previous = address(uint160(uint256(keccak256(abi.encodePacked(""address"", (i + 1) % 3)))));
        }
    }

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}"
1053,"function checkVictoryByScore ( uint boardId ) external boardWaitingToResolve ( boardId ) { uint8 blackScore ; uint8 whiteScore ; ( blackScore , whiteScore ) = calculateBoardScore ( boardId ) ; BoardStatus status = BoardStatus . Draw ; if ( blackScore > whiteScore ) { status = BoardStatus . BlackWin ; } else if ( whiteScore > blackScore ) { status = BoardStatus . WhiteWin ; } updateBoardStatus ( boardId , status ) ; }",Updates the board status according to the players score .,"function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
    uint8 blackScore;
    uint8 whiteScore;
    (blackScore, whiteScore) = calculateBoardScore(boardId);
    BoardStatus status = BoardStatus.Draw;
    if (blackScore > whiteScore) {
        status = BoardStatus.BlackWin;
    } else if (whiteScore > blackScore) {
        status = BoardStatus.WhiteWin;
    }
    updateBoardStatus(boardId, status);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}",False,"[{'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'createBoard', 'complexity': 2}, {'function': 'checkVictoryByScore', 'complexity': 2}]",12.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkVictoryByScore"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""boardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""blackScore"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""whiteScore"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""blackScore""}, {""type"": ""Identifier"", ""name"": ""whiteScore""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gameContract""}, ""memberName"": ""calculateBoardScore""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""BoardStatus""}, ""name"": ""status"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Draw""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blackScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""whiteScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""BlackWin""}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""whiteScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""blackScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""WhiteWin""}}}]}, ""FalseBody"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gameContract""}, ""memberName"": ""updateBoardStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}, {""type"": ""Identifier"", ""name"": ""status""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""boardWaitingToResolve"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'createBoard', 'complexity': 2}, {'function': 'checkVictoryByScore', 'complexity': 2}]",4.0,checkVictoryByScore,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) Ownable(msg.sender) {
        gameContract = IGame(_gameContractAddress);
        // Initialize state variables with safe, non-corner-case values
        boards[0] = Board({exists: true, status: BoardStatus.Pending});
        boards[1] = Board({exists: true, status: BoardStatus.Pending});
        boards[2] = Board({exists: true, status: BoardStatus.Pending});
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}"
963,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _isApprovedForAll ( _owner , _operator ) ; }",Query if an address is an authorized operator for another address,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) {
    return _isApprovedForAll( _owner , _operator );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}",True,"[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'setApprovalForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OperatorApproval""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'setApprovalForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",1.0,isApprovedForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}"
3793,"function createInvite ( bytes _sig ) public onlyUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( ! pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = true ; emit InviteCreated ( msg . sender , inviteAddress ) ; }",Create an invite using the signing model described in the contract description,"function createInvite (bytes _sig) public onlyUser {
    address inviteAddress = signingLogic . recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);
    require(!pendingInvites[inviteAddress]);
    pendingInvites[inviteAddress] = true;
    emit InviteCreated(msg.sender, inviteAddress);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}",False,"[{'function': 'setSigningLogic', 'complexity': 0}, {'function': 'createInvite', 'complexity': 3}, {'function': 'recoverSigner', 'complexity': 0}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvite"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""signingLogic""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Signing logic not set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""inviteAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signingLogic""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""this""}, ""memberName"": ""recoverSigner""}, ""memberName"": ""selector""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_sig""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Invite already created""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InviteCreated""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""inviteAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyUser"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setSigningLogic', 'complexity': 0}, {'function': 'createInvite', 'complexity': 3}, {'function': 'recoverSigner', 'complexity': 0}]",3.0,createInvite,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}"
3662,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = allStarIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token,"function takeOwnership ( uint256 _tokenId ) public {
    address newOwner = msg . sender ;
    address oldOwner = allStarIndexToOwner [ _tokenId ] ;
    require ( _addressNotNull ( newOwner ) ) ;
    require ( _approved ( newOwner , _tokenId ) ) ;
    _transfer ( oldOwner , newOwner , _tokenId ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}",False,"[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addressNotNull""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Address should not be null""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token is not approved for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",4.0,takeOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;
    address public owner = 0x1111111111111111111111111111111111111111; // Fixed address
    bool public initialized = true;
    bytes32 public initBytes = bytes32('init');

    constructor() Ownable(msg.sender) {
        owner = 0x1111111111111111111111111111111111111111; // Set to fixed value
        allStarIndexToOwner[1] = msg.sender; // Initialize mapping with a fixed value
        initialized = true; // Set to true
        initBytes = bytes32('init'); // Set to fixed string value
    }

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}"
4592,"function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external ;",Function use to change the lower and upper bound of the compatible version st,"function changeSTVersionBounds (string _boundType , uint8[ ] _newVersion) external;","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}",False,"[{'function': 'changeSTVersionBounds', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 public constant SOME_CONSTANT = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address public constant ADDRESS_ONE = address(0x111);
        address public constant ADDRESS_TWO = address(0x222);
        address public constant ADDRESS_THREE = address(0x333);

        // bool: Set to true
        bool public initialized = true;

        // string: Set to 'initialized'
        string public state = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 public constant INITIALIZED_BYTES = keccak256(abi.encodePacked(""init""));
    }

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}"
6054,"function unlock ( ) external { require ( allocations [ msg . sender ] . locked ) ; require ( now >= allocations [ msg . sender ] . end ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( allocations [ msg . sender ] . value ) ; allocations [ msg . sender ] . locked = false ; Transfer ( this , msg . sender , allocations [ msg . sender ] . value ) ; Unlock ( this , msg . sender , allocations [ msg . sender ] . value ) ; }",Only the owner of a locked wallet can unlock the tokens .,"function unlock ( ) external {
require ( allocations [ msg . sender ] . locked ) ;
require ( now >= allocations [ msg . sender ] . end ) ;
balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( allocations [ msg . sender ] . value ) ;
allocations [ msg . sender ] . locked = false ;
Transfer ( this , msg . sender , allocations [ msg . sender ] . value ) ;
Unlock ( this , msg . sender , allocations [ msg . sender ] . value ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}",True,"[{'function': 'unlock', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""unlock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, {""type"": ""stringLiteral"", ""value"": ""Allocation is not locked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""end""}}, {""type"": ""stringLiteral"", ""value"": ""Unlock time has not arrived yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unlock""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unlock', 'complexity': 2}]",3.0,unlock,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            allocations[address(this)] = Allocation({locked: true, value: 1 ether, end: block.timestamp + 1 weeks});
        }
    }

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}"
6003,"function executeTransaction ( address destination , uint value , bytes data ) public onlyOwner { if ( destination . call . value ( value ) ( data ) ) emit Execution ( destination , value , data ) ; else emit ExecutionFailure ( destination , value , data ) ; }",Proxy function which allows sending of transactions in behalf of the contract,"function executeTransaction(address destination, uint value, bytes data) public onlyOwner {
    if (destination.call.value(value)(data)) {
        emit Execution(destination, value, data);
    } else {
        emit ExecutionFailure(destination, value, data);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}",False,"[{'function': 'executeTransaction', 'complexity': 0}]",7.0,2.0,{},"[{'function': 'executeTransaction', 'complexity': 0}]",2.0,executeTransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}"
1262,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) external { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"function operatorSend (address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) external {
require(isOperatorFor(msg.sender, _from));
doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}",False,"[{'function': 'operatorSend', 'complexity': 1}]",4.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""operatorSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isOperatorFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not authorized to send from this account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doSend""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'operatorSend', 'complexity': 1}]",3.0,operatorSend,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}"
4646,function darknodeBond ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . bond ; },Returns the bond of a given darknode .,"function darknodeBond ( address darknodeID ) external view onlyOwner returns ( uint256 ) {
    return darknodeRegistry[darknodeID].bond;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}",True,"[{'function': 'darknodeBond', 'complexity': 0}, {'function': 'darknodeBond', 'complexity': 1}]",5.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""darknodeBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknodeRegistryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeRegistries""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknodeRegistryAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Darknode registry not set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DarknodeRegistryInterface""}, ""name"": ""darknodeRegistry"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DarknodeRegistryInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""darknodeRegistryAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""darknodeRegistry""}, ""memberName"": ""darknodeBond""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""darknodeID""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'darknodeBond', 'complexity': 0}, {'function': 'darknodeBond', 'complexity': 1}]",10.0,darknodeBond,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}"
476,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ! funding_ended ) throw ; if ( msg . sender == founders ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"function transfer(address _to, uint256 _value) public returns (bool) {
    if (!funding_ended) throw;
    if (msg.sender == founders) throw;
    var senderBalance = balances[msg.sender];
    if (senderBalance >= _value && _value > 0) {
        senderBalance -= _value;
        balances[msg.sender] = senderBalance;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}]",11.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""funding_ended""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Funding has ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""founders""}}, {""type"": ""stringLiteral"", ""value"": ""Founders cannot transfer tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance or invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeSub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""senderBalance""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeAdd""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}]",5.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

contract Token is Ownable {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Initialize with a non-zero value
        founders = msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}"
2119,"function getAmount ( uint _price , address _trader ) public constant returns ( uint ) ;",Returns the order amount for trader ` _trader ` at '_price ',"
function getAmount(uint _price, address _trader) public constant returns (uint) {
    return _price;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}",False,"[{'function': 'getAmount', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""_price""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'getAmount', 'complexity': 0}]",1.0,getAmount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 private constant SAFE_UINT = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address private constant SAFE_ADDRESS_1 = address(0x111);
        address private constant SAFE_ADDRESS_2 = address(0x222);
        address private constant SAFE_ADDRESS_3 = address(0x333);

        // bool: Set to true
        bool private constant SAFE_BOOL = true;

        // string: Set to 'initialized'
        string private constant SAFE_STRING = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 private constant SAFE_BYTES32 = bytes32('init');
    }
}"
3447,function setSynth ( Synth _synth ) external onlyOwner { synth = _synth ; emit SynthUpdated ( _synth ) ; },Set the Synth contract that the issuance controller uses to issue Synths .,"

function setSynth(Synth _synth) external onlyOwner {
    synth = _synth;
    emit SynthUpdated(_synth);
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}",False,"[{'function': 'setSynth', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""_synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""synth""}, ""right"": {""type"": ""Identifier"", ""name"": ""_synth""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_synth""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setSynth', 'complexity': 0}]",1.0,setSynth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContractName is Ownable {
    using SafeMath for uint256;
    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}"
2394,"function migrate ( uint256 _value ) external { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }",Migrate tokens to the new token contract .,"function migrate (uint256 _value) external {
    if (migrationAgent == 0) revert();
    if (_value == 0) revert();
    if (_value > balances[msg.sender]) revert();
    balances[msg.sender] -= _value;
    totalSupply -= _value;
    totalMigrated += _value;
    MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
    Migrate(msg.sender, migrationAgent, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}",True,"[{'function': 'migrateFrom', 'complexity': 0}, {'function': 'migrate', 'complexity': 0}]",10.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MigrationAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""migrationAgent""}], ""names"": []}, ""memberName"": ""migrateFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Migrate""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""migrationAgent""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'migrateFrom', 'complexity': 0}, {'function': 'migrate', 'complexity': 0}]",4.0,migrate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Set initial balance to a non-zero value
        totalSupply = 1000000000000000000; // Set initial total supply to a non-zero value
        totalMigrated = 0; // Initialize total migrated to zero
        migrationAgent = address(0x1111111111111111111111111111111111111111); // Use a fixed address for the migration agent
    }

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}"
6317,function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; process_contribution ( _toAddr ) ; },This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"function proxy_contribution(address _toAddr) public payable {
    require(_toAddr != address(0));
    process_contribution(_toAddr);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}",True,"[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxy_contribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_toAddr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_toAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""process_contribution""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_toAddr""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 0}]",2.0,proxy_contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}"
5800,function seal ( ) { if ( now < endFundingTime ) throw ; tokenContract . seal ( ) ; },` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"function seal ( ) { if ( now < endFundingTime ) throw ; tokenContract . seal ( ) ; }

Your response should contain only the formatted function, like this:

function seal() {
    if (now < endFundingTime) throw;
    tokenContract.seal();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}",False,"[{'function': 'seal', 'complexity': 2}]",6.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""seal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""endFundingTime""}}, ""TrueBody"": {""type"": ""ThrowStatement""}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token contract must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""seal""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'seal', 'complexity': 2}]",4.0,seal,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) Ownable() {
        require(_endFundingTime > block.timestamp, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (block.timestamp < endFundingTime) revert(""Seal not allowed before end funding time"");
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}"
5101,"function balanceOf ( address _owner ) public view returns ( uint ) { return chronoBankPlatform . balanceOf ( _owner , smbl ) ; }",Returns asset balance for a particular holder .,"function balanceOf ( address _owner ) public view returns ( uint ) {
    return chronoBankPlatform . balanceOf ( _owner , smbl );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""chronoBankPlatform""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""smbl""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,balanceOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

contract BalanceWrapper is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    mapping(address => uint256) public balanceOf;

 constructor(address platformAddress, bytes32 symbol) Ownable(msg.sender) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}"
752,"function execute ( bytes32 _buyID , bytes32 _sellID , address _buyer , address _seller , TokenPair memory _tokens ) private { SettlementDetails memory settlementDetails = ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID ) ? settlementDetails = calculateAtomicFees ( _buyID , _sellID , _tokens ) : settlementDetails = calculateSettlementDetails ( _buyID , _sellID , _tokens ) ; renExBalancesContract . transferBalanceWithFee ( _buyer , _seller , settlementDetails . leftTokenAddress , settlementDetails . leftVolume , settlementDetails . leftTokenFee , orderSubmitter [ _buyID ] ) ; renExBalancesContract . transferBalanceWithFee ( _seller , _buyer , settlementDetails . rightTokenAddress , settlementDetails . rightVolume , settlementDetails . rightTokenFee , orderSubmitter [ _sellID ] ) ; }","Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) private {
    SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
    renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
    renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}",False,"[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'execute', 'complexity': 1}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}]",11.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""execute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_buyID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_sellID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenPair""}, ""name"": ""_tokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SettlementDetails""}, ""name"": ""settlementDetails"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderDetails""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyID""}}, ""memberName"": ""settlementID""}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}], ""isArray"": False}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}, {""type"": ""Identifier"", ""name"": ""_sellID""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateSettlementDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}, {""type"": ""Identifier"", ""name"": ""_sellID""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftVolume""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenFee""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderSubmitter""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyID""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""rightTokenAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""rightVolume""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""rightTokenFee""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderSubmitter""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sellID""}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'execute', 'complexity': 1}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}]",1.0,execute,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        orderDetails[bytes32(0)] = bytes32('init');
        orderSubmitter[bytes32(0)] = address(0);
        renExBalancesContract = IRENexBalances(0x1111111111111111111111111111111111111111); // Use a fixed address for renExBalancesContract
    }

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}"
1142,"function approve ( address _spender , uint256 _amount ) public returns ( bool ) ;",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"function approve(address _spender, uint256 _amount) public returns (bool) {
    require(_spender != address(0));
    require(_amount > 0);
    require(_amount <= balanceOf[msg.sender]);

    allowances[_spender][msg.sender] = _amount;

    emit Approval(msg.sender, _spender, _amount);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 3}]",4.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    constructor() Ownable(msg.sender) {
        balanceOf[msg.sender] = 1 * 10**uint256(decimals); // Initial supply of tokens
        emit Transfer(address(0), msg.sender, balanceOf[msg.sender]);
    }

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}"
3633,"function transfer ( bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; if ( balances [ sender ] >= _value ) { balances [ sender ] -= _value ; balances [ _to ] += _value ; TransferHash ( sender , _to , _value ) ; return true ; } return false ; }",` _value ` tokens will be sended to ` _to `,"function transfer(bytes32 _to, uint256 _value) returns (bool) {
    var sender = sha3(msg.sender);
    if (balances[sender] >= _value) {
        balances[sender] -= _value;
        balances[_to] += _value;
        TransferHash(sender, _to, _value);
        return true;
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferHash""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}"
4852,"function burn ( uint256 _amount ) public requiresPermission whenNotPaused { _burn ( msg . sender , _amount ) ; }",Allows user to mint if they have the appropriate permissions .,"function burn (uint256 _amount) public requiresPermission whenNotPaused {
    _burn(msg.sender, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}",False,"[{'function': 'burn', 'complexity': 1}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 1}]",2.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}"
2521,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { require ( _tokenId < warriors . length ) ; owner = warriorToOwner [ _tokenId ] ; },Returns the address currently assigned ownership of a given Warrior .,"function ownerOf (uint256 _tokenId) external view returns (address owner) {
    require(_tokenId < warriors . length);
    owner = warriorToOwner[_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}",False,"[{'function': 'ownerOf', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint208""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriorToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,ownerOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        warriorToOwner[1] = 0x1111111111111111111111111111111111111111; // Replace with actual address
        warriorToOwner[2] = 0x2222222222222222222222222222222222222222; // Replace with actual address
        warriors.push(1);
        warriors.push(2);

        // Set bool and string variables to fixed, safe values
        bool initialized = true;
        string publicTokenName = 'MyToken'; // Replace with actual token name

        // Initialize bytes32 variable to fixed value
        bytes32 publicInitBytes = bytes32('init');
    }

    function ownerOf(uint256 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}"
402,function emergencyClawbackEther ( uint256 value ) external onlyOwnerOrMultisig { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( contractRefundFinished ) ; require ( value > 0 ) ; require ( value <= address ( this ) . balance ) ; msg . sender . transfer ( value ) ; },Contract owner or Multisig can clawback ether after refund period is finished,"function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
    require(contractFailed);
    require(contractRefundStarted);
    require(contractRefundFinished);
    require(value > 0);
    require(value <= address(this).balance);
    msg.sender.transfer(value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}",False,"[{'function': 'emergencyClawbackEther', 'complexity': 5}]",8.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyClawbackEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractFailed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractRefundStarted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractRefundFinished""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwnerOrMultisig"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'emergencyClawbackEther', 'complexity': 5}]",6.0,emergencyClawbackEther,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}"
2323,"function acceptTermsAndJoinDXF ( ) payable external { if ( now > startingDateFunding + 365 days ) throw ; if ( ! dxfOpen ) throw ; if ( vips [ msg . sender ] ) throw ; if ( msg . value < 10 ether ) throw ; if ( msg . value > ( tokensCreationCap - totalTokens ) ) throw ; if ( msg . value > ( 10000 ether - balances [ msg . sender ] ) ) throw ; if ( balances [ msg . sender ] == 0 ) { newMember ( msg . sender ) ; indexMembers [ msg . sender ] = members . length ; members . push ( Member ( msg . sender , now , msg . value ) ) ; } else { members [ indexMembers [ msg . sender ] ] . initial_value += msg . value ; } if ( members . length > maxNumberMembers ) throw ; if ( multisigDXF == 0 ) throw ; if ( ! multisigDXF . send ( msg . value ) ) throw ; uint numTokens = msg . value ; totalTokens += numTokens ; if ( ( tokensCreationCap - totalTokens ) < remainingTokensVIPs ) throw ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }",By using this function you accept the terms of DXF,"
function acceptTermsAndJoinDXF() payable external {
    if (now > startingDateFunding + 365 days) throw;
    if (!dxfOpen) throw;
    if (vips[msg.sender]) throw;
    if (msg.value < 10 ether) throw;
    if (msg.value > (tokensCreationCap - totalTokens)) throw;
    if (msg.value > (10000 ether - balances[msg.sender])) throw;
    if (balances[msg.sender] == 0) {
        newMember(msg.sender);
        indexMembers[msg.sender] = members.length;
        members.push(Member(msg.sender, now, msg.value));
    } else {
        members[indexMembers[msg.sender]].initial_value += msg.value;
    }
    if (members.length > maxNumberMembers) throw;
    if (multisigDXF == 0) throw;
    if (!multisigDXF.send(msg.value)) throw;
    uint numTokens = msg.value;
    totalTokens += numTokens;
    if ((tokensCreationCap - totalTokens) < remainingTokensVIPs) throw;
    balances[msg.sender] += numTokens;
    Transfer(0, msg.sender, numTokens);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}",False,"[{'function': 'send', 'complexity': 0}, {'function': 'acceptTermsAndJoinDXF', 'complexity': 12}, {'function': 'newMember', 'complexity': 0}]",29.0,12.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptTermsAndJoinDXF"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""startingDateFunding""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}}}, {""type"": ""stringLiteral"", ""value"": ""Too early""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dxfOpen""}, {""type"": ""stringLiteral"", ""value"": ""DXF is closed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vips""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Already a VIP""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum contribution is 10 ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensCreationCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalTokens""}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds token creation cap""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10000"", ""subdenomination"": ""ether""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds balance limit""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""newMember""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""indexMembers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Member""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""now""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""indexMembers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, ""memberName"": ""initial_value""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxNumberMembers""}}, {""type"": ""stringLiteral"", ""value"": ""Max number of members reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""multisigDXF""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid multisig contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Multisig""}, ""name"": ""multisig"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Multisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""multisigDXF""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""multisig""}, ""memberName"": ""send""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""numTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensCreationCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalTokens""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingTokensVIPs""}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds VIP tokens limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""numTokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'send', 'complexity': 0}, {'function': 'acceptTermsAndJoinDXF', 'complexity': 12}, {'function': 'newMember', 'complexity': 0}]",12.0,acceptTermsAndJoinDXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding = 1; // Set to a fixed value that is not zero
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe non-corner-case values
        startingDateFunding = 1;
        dxfOpen = true;
        maxNumberMembers = 1000;
        totalTokens = 0;
        tokensCreationCap = 10000 ether;
        remainingTokensVIPs = tokensCreationCap / 2; // Assuming VIPs are half of the cap for example
    }

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(address(uint160(msg.sender))); // Assuming member struct is defined somewhere else
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}"
36,function SetContractorManager ( address _contractorManager ) ;,Function used by the creator to set the contractor manager smart contract,"
function SetContractorManager(address _contractorManager) public {
    require(_contractorManager != address(0), ""Invalid contractor manager address"");
    emit ContractorManagerSet(_contractorManager);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}",True,"[{'function': 'setContractorManager', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractorManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractorManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_contractorManager""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contractor manager address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractorManagerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contractorManager""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setContractorManager', 'complexity': 1}]",2.0,SetContractorManager,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables can be done here if needed, but based on the rules provided, no changes are necessary.
    }

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}"
1979,"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryId , uint256 minimumRequiredStake , uint256 jurisdictionFee ) ;",Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"function getAttributeTypeInformation (uint256 attributeTypeID) external view returns (string description, bool isRestricted, bool isOnlyPersonal, address secondarySource, uint256 secondaryId, uint256 minimumRequiredStake, uint256 jurisdictionFee) {
    return (
        _attributeTypes[attributeTypeID].description,
        _attributeTypes[attributeTypeID].isRestricted,
        _attributeTypes[attributeTypeID].isOnlyPersonal,
        _attributeTypes[attributeTypeID].secondarySource,
        _attributeTypes[attributeTypeID].secondaryId,
        _attributeTypes[attributeTypeID].minimumRequiredStake,
        _attributeTypes[attributeTypeID].jurisdictionFee
    );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}",True,"[{'function': 'getAttributeTypeInformation', 'complexity': 0}]",11.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeTypeInformation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""isRestricted""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""isOnlyPersonal""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""secondarySource""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""secondaryId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""minimumRequiredStake""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""jurisdictionFee""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getAttributeTypeInformation', 'complexity': 0}]",2.0,getAttributeTypeInformation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

contract AttributeTypeWrapper is Ownable, IAttributeType {
    using SafeMath for uint256;

    mapping(uint256 => AttributeType) private _attributeTypes;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}"
2733,function setPriceStalePeriod ( uint time ) external optionalProxy_onlyOwner { priceStalePeriod = time ; },Set the stale period on the updated havven price,"function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
    priceStalePeriod = time;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}",False,"[{'function': 'setPriceStalePeriod', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceStalePeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""time"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceStalePeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""time""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""optionalProxy_onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPriceStalePeriod', 'complexity': 0}]",1.0,setPriceStalePeriod,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    constructor() Ownable(msg.sender) {
        priceStalePeriod = 1; // Set to a non-zero, safe value
    }

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}"
1587,function reclaim ( IBasicToken token ) public { require ( token != RECLAIM_ETHER ) ; Reclaimable . reclaim ( token ) ; },allows EtherToken to reclaim tokens wrongly sent to its address,"
function reclaim(IBasicToken token) public {
    require(token != RECLAIM_ETHER);
    Reclaimable.reclaim(token);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}",False,"[{'function': 'reclaim', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IBasicToken""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IBasicToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECLAIM_ETHER""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Reclaimable""}, ""memberName"": ""reclaim""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaim', 'complexity': 1}]",2.0,reclaim,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        initialized = true;
        RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    }

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}"
1004,"function buildIdentifier ( Oracle oracle , address borrower , address creator , bytes32 currency , uint256 amount , uint256 interestRate , uint256 interestRatePunitory , uint256 duesIn , uint256 cancelableAt , uint256 expirationRequest , string metadata ) view returns ( bytes32 ) { return keccak256 ( this , oracle , borrower , creator , currency , amount , interestRate , interestRatePunitory , duesIn , cancelableAt , expirationRequest , metadata ) ; }","Used to reference a loan that is not yet created , and by that does not have an index","function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string metadata) view returns (bytes32) {
    return keccak256(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}",False,"[{'function': 'buildIdentifier', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buildIdentifier"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Oracle""}, ""name"": ""oracle"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""borrower"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""currency"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRatePunitory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""duesIn"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cancelableAt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expirationRequest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""metadata"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""Identifier"", ""name"": ""oracle""}, {""type"": ""Identifier"", ""name"": ""borrower""}, {""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""interestRate""}, {""type"": ""Identifier"", ""name"": ""interestRatePunitory""}, {""type"": ""Identifier"", ""name"": ""duesIn""}, {""type"": ""Identifier"", ""name"": ""cancelableAt""}, {""type"": ""Identifier"", ""name"": ""expirationRequest""}, {""type"": ""Identifier"", ""name"": ""metadata""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'buildIdentifier', 'complexity': 0}]",2.0,buildIdentifier,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract IdentifierBuilder is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}"
6826,function closed ( ) constant returns ( uint ) { return data . closed ; },Returns the block number for when the channel was closed .,function closed() constant returns (uint) { return data.closed; },"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}",True,"[{'function': 'closed', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""closed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""closed""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'closed', 'complexity': 0}]",1.0,closed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    constructor() Ownable(msg.sender) {
        data.closed = 1; // Set to safe, non-corner-case value: 1
    }

    function closed() public view returns (uint) {
        return data.closed;
    }
}"
4437,"function approve ( address _spender , uint _value ) returns ( bool success ) ;",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"function approve(address _spender, uint256 _value) public returns (bool success) {
    require(_spender != address(0), ""Invalid spender address"");
    require(_value > 0, ""Invalid value"");
    emit Approval(msg.sender, _spender, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",True,"[{'function': 'approve', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 2}]",3.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ApproveWrapper is Ownable {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
2473,function commitUpgrade ( ) public returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } if ( pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now ) { return false ; } latestVersion = pendingVersion ; delete pendingVersion ; delete pendingVersionTimestamp ; return true ; },Finalize an upgrade process setting new asset implementation contract address .,"
function commitUpgrade() public returns (bool) {
    if (pendingVersion == 0x0) {
        return false;
    }

    if (pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now) {
        return false;
    }

    latestVersion = pendingVersion;
    delete pendingVersion;
    delete pendingVersionTimestamp;

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}",True,"[{'function': 'commitUpgrade', 'complexity': 2}]",15.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""commitUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPGRADE_FREEZE_TIME""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""latestVersion""}, ""right"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""isPrefix"": True}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'commitUpgrade', 'complexity': 2}]",3.0,commitUpgrade,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion = 1; // Set to 1 (never 0)
    uint256 public pendingVersionTimestamp = block.timestamp; // Initialize with current timestamp
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor
    }

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}"
4258,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}]",1.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable, Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
3893,function getReserves ( ) public view returns ( KyberReserveInterface [ ] ) { return reserves ; },should be called off chain with as much gas as needed,"function getReserves () public view returns (KyberReserveInterface [] ) {
    return reserves;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}",True,"[{'function': 'getReserves', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReserves"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""KyberReserveInterface""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""reserves""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getReserves', 'complexity': 0}]",1.0,getReserves,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}"
3338,function isAffiliateProgram ( ) public pure returns ( bool ) { return true ; },Exposes that this contract thinks it is an AffiliateProgram,"function isAffiliateProgram() public pure returns (bool) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}",True,"[{'function': 'isAffiliateProgram', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAffiliateProgram"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'isAffiliateProgram', 'complexity': 0}]",1.0,isAffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize other variables as they are already set correctly by the parent contract's constructor
    }

    function isAffiliateProgram() public pure returns (bool) {
        return true;
    }
}"
812,function setPrices ( uint256 newRate ) onlyOwner public { tokensPerEther = newRate ; },Allow users to buy tokens for ` newRate ` x eth,"
function setPrices(uint256 newRate) public onlyOwner {
    tokensPerEther = newRate;
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}",True,"[{'function': 'setPrices', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensPerEther""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,setPrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    constructor() Ownable(msg.sender) {
        tokensPerEther = 1; // Set to safe, non-corner-case value
    }

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}"
714,"function transfer ( address destination , uint256 amount ) public tradable ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }",Transfers ` amount ` from msg.sender to ` destination `,"function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
    balances[msg.sender] = balances[msg.sender].sub(amount);
    balances[destination] = balances[destination].add(amount);
    emit Transfer(msg.sender, destination, amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destination"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""destination""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""tradable"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

contract Token is Ownable {;
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // uint256: Set to 1 (never 0)
        balances[address(0x111)] = 1; // address: Use fixed value 0x1111111111111111111111111111111111111111
        balances[address(0x222)] = 1; // address: Use fixed value 0x2222222222222222222222222222222222222222
        balances[address(0x333)] = 1; // address: Use fixed value 0x3333333333333333333333333333333333333333
    }

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}"
6517,function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = RaidenToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; },Set ` _token_address ` as the token address to be used in the auction .,"function setup(address _token_address) public isOwner atStage(Stages.AuctionDeployed) {
    require(_token_address != 0x0);
    token = RaidenToken(_token_address);
    num_tokens_auctioned = token.balanceOf(address(this));
    token_multiplier = 10 ** uint(token.decimals());
    stage = Stages.AuctionSetUp;
    Setup();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}",True,"[{'function': 'decimals', 'complexity': 0}, {'function': 'setup', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token address must be valid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RaidenToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}], ""names"": []}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionSetUp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Setup""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""atStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionDeployed""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'decimals', 'complexity': 0}, {'function': 'setup', 'complexity': 1}]",2.0,setup,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage = Stages.NotDeployed;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        stage = Stages.AuctionDeployed;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}"
2209,"function matchByAdmin_TwH36 ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 3 ] ; address user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; address token ; bool isBuy ; ( token , isBuy ) = decodeOrderTokenAndIsBuy ( data ) ; bytes32 orderHash = keccak256 ( this , inputs [ 0 ] , inputs [ 1 ] , inputs [ 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( orderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 etherExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; data = inputs [ i + 3 ] ; user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = keccak256 ( this , inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( makerOrderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , etherExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data , tokenExecute , etherExecute , isBuy , token , 0 , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , etherExecute , isBuy , token , 0 , orderHash ) ; }","match orders with admins involved , only admin","function matchByAdmin_TwH36(uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[3];
    address user = userId2Address[data & USER_MASK];
    require(data >> 224 > userNonce[user]);
    address token;
    bool isBuy;
    (token, isBuy) = decodeOrderTokenAndIsBuy(data);
    bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
    require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
    uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
    tokenExecute = tokenExecute.sub(orderFills[orderHash]);
    require(tokenExecute != 0);
    uint256 etherExecute = 0;
    isBuy = !isBuy;
    for (uint256 i = 6; i < inputs.length; i += 6) {
        require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
        data = inputs[i + 3];
        user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
        (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
    }
    isBuy = !isBuy;
    tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
    tokenExecute = tokenExecute.sub(orderFills[orderHash]);
    processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}",False,"[{'function': 'matchByAdmin_TwH36', 'complexity': 17}]",26.0,11.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchByAdmin_TwH36"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""inputs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""data"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userId2Address""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""USER_MASK""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""224"", ""subdenomination"": None}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userNonce""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""token"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112f0a9e0>}, {""type"": ""VariableDeclaration"", ""name"": ""isBuy"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112f0aba0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""decodeOrderTokenAndIsBuy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""MATCH_SIGN_MASK""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Conditional"", ""condition"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""ORDER_ISBUY""}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderHash""}, {""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""V_MASK""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""28"", ""subdenomination"": None}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenExecute"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""TrueExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""FalseExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderFills""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderHash""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""etherExecute"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""isPrefix"": True}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userId2Address""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""USER_MASK""}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""224"", ""subdenomination"": None}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userNonce""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""makerOrderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""MATCH_SIGN_MASK""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Conditional"", ""condition"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""ORDER_ISBUY""}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""makerOrderHash""}, {""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""V_MASK""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""28"", ""subdenomination"": None}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""tokenExecute""}, {""type"": ""Identifier"", ""name"": ""etherExecute""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""internalTrade""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""Identifier"", ""name"": ""data""}, {""type"": ""Identifier"", ""name"": ""tokenExecute""}, {""type"": ""Identifier"", ""name"": ""etherExecute""}, {""type"": ""Identifier"", ""name"": ""isBuy""}, {""type"": ""Identifier"", ""name"": ""token""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""makerOrderHash""}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""isPrefix"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""right"": {""type"": ""Conditional"", ""condition"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenExecute""}], ""names"": []}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenExecute""}], ""names"": []}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenExecute""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderFills""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderHash""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processTakerOrder""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""tokenExecute""}, {""type"": ""Identifier"", ""name"": ""etherExecute""}, {""type"": ""Identifier"", ""name"": ""isBuy""}, {""type"": ""Identifier"", ""name"": ""token""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""orderHash""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'matchByAdmin_TwH36', 'complexity': 17}]",11.0,matchByAdmin_TwH36,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Matcher is Ownable {
    using SafeMath for uint256;

    address public admin = msg.sender;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() Ownable(msg.sender) {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}"
5033,function totalSupply ( ) public view returns ( uint ) { return properties . length ; },Returns the total number of Properties currently in existence .,"function totalSupply() public view returns (uint) {
    return properties.length;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}",False,"[{'function': 'totalSupply', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""properties""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,totalSupply,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        properties = [];
    }

    function totalSupply() public view returns (uint256) {
        return properties.length;
    }
}"
2439,"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) public onlyPermissionManager ( _app , _role ) { bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }",Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) public onlyPermissionManager ( _app , _role ) {
    bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ;
    _setPermission ( _entity , _app , _role , paramsHash ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}",False,"[{'function': 'grantPermissionP', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",7.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantPermissionP"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_entity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_app"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_params"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""paramsHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_params""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_saveParams""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_params""}], ""names"": []}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""EMPTY_PARAM_HASH""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_entity""}, {""type"": ""Identifier"", ""name"": ""_app""}, {""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""paramsHash""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyPermissionManager"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_app""}, {""type"": ""Identifier"", ""name"": ""_role""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'grantPermissionP', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",1.0,grantPermissionP,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PermissionManager is Ownable {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyOwner {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}"
6671,"function offer_energy ( uint32 aday , uint32 aprice , uint64 aenergy , uint64 atimestamp ) onlyRegisteredProducers external { require ( aenergy >= kWh ) ; uint idx = bidsIndex [ msg . sender ] [ aday ] ; if ( ( bids . length > idx ) && ( bids [ idx ] . producer == msg . sender ) && ( bids [ idx ] . day == aday ) ) { require ( atimestamp > bids [ idx ] . timestamp ) ; emit BidRevoked ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; } idx = bids . length ; bidsIndex [ msg . sender ] [ aday ] = idx ; bids . push ( Bid ( { producer : msg . sender , day : aday , price : aprice , energy : aenergy , timestamp : atimestamp } ) ) ; emit BidMade ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; }",Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
    require(aenergy >= kWh);
    uint idx = bidsIndex[msg.sender][aday];
    if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
        require(atimestamp > bids[idx].timestamp);
        emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }
    idx = bids.length;
    bidsIndex[msg.sender][aday] = idx;
    bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
    emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}",False,"[{'function': 'offer_energy', 'complexity': 3}, {'function': 'isProducerRegistered', 'complexity': 0}]",12.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""offer_energy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""atimestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""right"": {""type"": ""Identifier"", ""name"": ""kWh""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""idx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""idx""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""producer""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""isArray"": False}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""day""}, ""right"": {""type"": ""Identifier"", ""name"": ""aday""}}], ""isArray"": False}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""atimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""timestamp""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidRevoked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""producer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""day""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""price""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""energy""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}, ""right"": {""type"": ""Identifier"", ""name"": ""idx""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Bid""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}, {""type"": ""Identifier"", ""name"": ""aprice""}, {""type"": ""Identifier"", ""name"": ""aenergy""}, {""type"": ""Identifier"", ""name"": ""atimestamp""}], ""names"": [""producer"", ""day"", ""price"", ""energy"", ""timestamp""]}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidMade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""producer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""day""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""price""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""idx""}}, ""memberName"": ""energy""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRegisteredProducers"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'offer_energy', 'complexity': 3}, {'function': 'isProducerRegistered', 'complexity': 0}]",6.0,offer_energy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        kWh = 1000;
        for (uint i = 0; i < bids.length; i++) {
            delete bids[i];
        }
        for (uint j = 0; j < 2; j++) { // Assuming max 2 addresses, adjust if more needed
            for (uint k = 0; k < 10; k++) { // Adjust range based on expected usage
                bidsIndex[address(uint160(j + 1) << 160 | uint160(k))] = type(uint).max;
            }
        }
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}"
4083,"function calculateRewardToWithdraw ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint reward , uint pixelsOwned ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; uint _lastPaidIndex = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _lastIndex < 0 ) { return ( 0 , _pixelsOwned ) ; } uint _rewardsSum = _history . rewardsCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . rewardsCumulative [ _lastPaidIndex ] ; uint _toWithdraw = ( ( _rewardsSum - _lastWithdrawn ) / PIXEL_COUNT ) * _pixelsOwned ; return ( _toWithdraw , _pixelsOwned ) ; }",Calculates unpaid rewards of a given address .,"function calculateRewardToWithdraw (uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
    FeeHistory storage _history = _getFeeHistory(_canvasId);
    uint _lastIndex = _history.rewardsCumulative.length - 1;
    uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
    uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
    if (_lastIndex < 0) {
        return (0, _pixelsOwned);
    }
    uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
    uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
    uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
    return (_toWithdraw, _pixelsOwned);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}",False,"[{'function': '_getFeeHistory', 'complexity': 0}, {'function': 'getPaintedPixelsCountByAddress', 'complexity': 0}, {'function': 'calculateRewardToWithdraw', 'complexity': 1}]",13.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateRewardToWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""pixelsOwned"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""_history"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getFeeHistory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_lastPaidIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""addressToPaidRewardIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_pixelsOwned"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPaintedPixelsCountByAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_canvasId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_rewardsSum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_lastWithdrawn"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastPaidIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_toWithdraw"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_rewardsSum""}, ""right"": {""type"": ""Identifier"", ""name"": ""_lastWithdrawn""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""PIXEL_COUNT""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_toWithdraw""}, {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""stateOwned"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': '_getFeeHistory', 'complexity': 0}, {'function': 'getPaintedPixelsCountByAddress', 'complexity': 0}, {'function': 'calculateRewardToWithdraw', 'complexity': 1}]",2.0,calculateRewardToWithdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RewardCalculator is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    constructor() Ownable(msg.sender) {
        for (uint i = 0; i < 3; i++) {
            address fixedAddress = address(uint160(i + 1) << 96); // Creating fixed addresses like 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
            feeHistories[uint32(i)] = FeeHistory({
                rewardsCumulative: [0], // Initialize with a safe, non-corner-case value
                addressToPaidRewardIndex: { [fixedAddress]: 0 }
            });
        }
    }

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}"
6519,"function transfer ( address _to , uint _value ) public notPaused { super . transfer ( _to , _value ) ; }",ERC20 transfer function overridden to disable transfers when paused,"function transfer(address _to, uint256 _value) public notPaused {
    super.transfer(_to, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}]",1.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        paused = false;
    }
}"
5444,"function setCampaignOwnerById ( bytes32 bidId , address newOwner ) public onlyIfCampaignExists ( ""setCampaignOwnerById"" , bidId ) onlyIfWhitelisted ( ""setCampaignOwnerById"" , msg . sender ) { campaigns [ bidId ] . setOwner ( newOwner ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(""setCampaignOwnerById"", bidId) onlyIfWhitelisted(""setCampaignOwnerById"", msg.sender) {
    campaigns[bidId].setOwner(newOwner);
    emitCampaignUpdated(campaigns[bidId]);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}",False,"[{'function': 'setCampaignOwnerById', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCampaignOwnerById"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}, {""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyIfCampaignExists"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyIfWhitelisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setCampaignOwnerById', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",1.0,setCampaignOwnerById,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        campaigns = Campaign({}); // Initialize the mapping to an empty state
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}"
2581,"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }",Checks if the makeOrder price is reasonable and not manipulative,"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}",True,"[{'function': 'isTakePermitted', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTakePermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""orderPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""referencePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sellAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""sellQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""buyQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isTakePermitted', 'complexity': 0}]",1.0,isTakePermitted,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TakePermitWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}"
4669,"function transferLand ( uint256 estateId , uint256 landId , address destinatary ) external canTransfer ( estateId ) { return _transferLand ( estateId , landId , destinatary ) ; }",Transfer a LAND owned by an Estate to a new owner,"function transferLand (uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
    return _transferLand(estateId, landId, destinatary);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}",True,"[{'function': '_transferLand', 'complexity': 1}, {'function': 'transferLand', 'complexity': 0}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""estateId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""landId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destinatary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destinatary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""estates""}, ""index"": {""type"": ""Identifier"", ""name"": ""estateId""}}, ""memberName"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""landId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""destinatary""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_transferLand', 'complexity': 1}, {'function': 'transferLand', 'complexity': 0}]",2.0,transferLand,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 estateId = 1; estateId <= 3; ++estateId) {
            estates[estateId].owner = address(uint160(estateId));
            for (uint256 landId = 1; landId <= 3; ++landId) {
                estates[estateId].lands[landId] = address(uint160(estateId * 10 + landId));
            }
        }
    }
}"
689,"function setPreAmounts ( uint256 mtdPreAmountInWei , uint256 ethPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( ethPreAmountInWei > 0 ) ; mtdPreAmount = mtdPreAmountInWei ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }",Set both ethPreAmount and mtdPreAmount at the same time,"function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) isOwner {
    require(mtdPreAmountInWei > 0);
    require(ethPreAmountInWei > 0);
    mtdPreAmount = mtdPreAmountInWei;
    ethPreAmount = ethPreAmountInWei;
    updatePrices();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}",True,"[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,setPreAmounts,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount = 1;
    uint256 public ethPreAmount = 2;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here
    }

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}"
4185,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; collectibleIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"function approve(address _to, uint256 _tokenId) public {
    require(_owns(msg.sender, _tokenId));
    collectibleIndexToApproved[_tokenId] = _to;
    Approval(msg.sender, _to, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}",True,"[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; ; ++i) {
            if (i == 1) {
                collectibleIndexToApproved[i] = address(0x111);
            } else if (i == 2) {
                collectibleIndexToApproved[i] = address(0x222);
            } else if (i == 3) {
                collectibleIndexToApproved[i] = address(0x333);
                break; // Stop after initializing three values
            }
        }
    }

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}"
6513,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenltkrecipiente spender = tokenltkrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
    tokenltkrecipiente spender = tokenltkrecipiente(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}",True,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenltkrecipiente""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",2.0,approveAndCall,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}"
5584,"function _internalExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress , bool chargeFee ) internal notFeeAddress ( from ) returns ( bool ) { require ( destinationAddress != address ( 0 ) , ""Zero destination"" ) ; require ( destinationAddress != address ( this ) , ""Synthetix is invalid destination"" ) ; require ( destinationAddress != address ( proxy ) , ""Proxy is invalid destination"" ) ; synths [ sourceCurrencyKey ] . burn ( from , sourceAmount ) ; uint destinationAmount = effectiveValue ( sourceCurrencyKey , sourceAmount , destinationCurrencyKey ) ; uint amountReceived = destinationAmount ; uint fee = 0 ; if ( chargeFee ) { amountReceived = feePool . amountReceivedFromExchange ( destinationAmount ) ; fee = destinationAmount . sub ( amountReceived ) ; } synths [ destinationCurrencyKey ] . issue ( destinationAddress , amountReceived ) ; if ( fee > 0 ) { uint xdrFeeAmount = effectiveValue ( destinationCurrencyKey , fee , ""XDR"" ) ; synths [ ""XDR"" ] . issue ( feePool . FEE_ADDRESS ( ) , xdrFeeAmount ) ; } synths [ destinationCurrencyKey ] . triggerTokenFallbackIfNeeded ( from , destinationAddress , amountReceived ) ; return true ; }",Function that allows synth contract to delegate sending fee to the fee Pool .,"function _internalExchange(
    address from,
    bytes4 sourceCurrencyKey,
    uint sourceAmount,
    bytes4 destinationCurrencyKey,
    address destinationAddress,
    bool chargeFee
) internal notFeeAddress(from) returns (bool) {
    require(destinationAddress != address(0), ""Zero destination"");
    require(destinationAddress != address(this), ""Synthetix is invalid destination"");
    require(destinationAddress != address(proxy), ""Proxy is invalid destination"");
    synths[sourceCurrencyKey].burn(from, sourceAmount);
    uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
    uint amountReceived = destinationAmount;
    uint fee = 0;
    if (chargeFee) {
        amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
        fee = destinationAmount - amountReceived;
    }
    synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
    if (fee > 0) {
        uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
        synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
    }
    synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}",True,"[{'function': 'triggerTokenFallbackIfNeeded', 'complexity': 0}, {'function': 'amountReceivedFromExchange', 'complexity': 0}, {'function': '_internalExchange', 'complexity': 0}, {'function': 'effectiveValue', 'complexity': 0}]",27.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""_internalExchange"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""sourceCurrencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""sourceAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""destinationCurrencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destinationAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""chargeFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destinationAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero destination""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destinationAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synthetix is invalid destination""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destinationAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""proxy""}}, {""type"": ""stringLiteral"", ""value"": ""Proxy is invalid destination""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""sourceCurrencyKey""}}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""sourceAmount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""destinationAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""effectiveValue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sourceCurrencyKey""}, {""type"": ""Identifier"", ""name"": ""sourceAmount""}, {""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amountReceived"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""destinationAmount""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""chargeFee""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amountReceived""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePool""}, ""memberName"": ""amountReceivedFromExchange""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destinationAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fee""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""destinationAmount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountReceived""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}}, ""memberName"": ""issue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destinationAddress""}, {""type"": ""Identifier"", ""name"": ""amountReceived""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""fee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""xdrFeeAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""effectiveValue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}, {""type"": ""Identifier"", ""name"": ""fee""}, {""type"": ""stringLiteral"", ""value"": ""XDR""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""memberName"": ""issue""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feePool""}, ""memberName"": ""FEE_ADDRESS""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""xdrFeeAmount""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}}, ""memberName"": ""triggerTokenFallbackIfNeeded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""destinationAddress""}, {""type"": ""Identifier"", ""name"": ""amountReceived""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'triggerTokenFallbackIfNeeded', 'complexity': 0}, {'function': 'amountReceivedFromExchange', 'complexity': 0}, {'function': '_internalExchange', 'complexity': 0}, {'function': 'effectiveValue', 'complexity': 0}]",6.0,_internalExchange,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) Ownable(msg.sender) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}"
4746,"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { if ( isRegistered ( _owner ) ) { return true ; } else { return false ; } }","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","
function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
    if (isRegistered(_owner)) {
        return true;
    } else {
        return false;
    }
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}",True,"[{'function': 'onApprove', 'complexity': 1}, {'function': 'isRegistered', 'complexity': 0}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""onApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 1}, {'function': 'isRegistered', 'complexity': 0}]",2.0,onApprove,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
5679,function setBuyoutDividendPercentage ( uint256 _buyoutDividendPercentage ) external onlyCFO { require ( 2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500 ) ; buyoutDividendPercentage = _buyoutDividendPercentage ; },Sets the new dividend percentage for buyouts .,"function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}",False,"[{'function': 'setBuyoutDividendPercentage', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBuyoutDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyoutDividendPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""2000"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""12500"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyoutDividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBuyoutDividendPercentage', 'complexity': 0}, {'function': 'setBuyoutDividendPercentage', 'complexity': 2}]",3.0,setBuyoutDividendPercentage,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor() Ownable(msg.sender) {
        buyoutDividendPercentage = 10000; // Set to a safe, non-corner-case value within the allowed range
    }

    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
        require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = _buyoutDividendPercentage;
    }
}"
5099,"function finalizeSingleInvestor ( address investorAddr ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investorAddr != address ( 0 ) && investorAddr != address ( this ) ) ; require ( balancesToken [ investorAddr ] > 0 ) ; require ( isWhitelisted [ investorAddr ] == true ) ; uint256 balanceToTransfer = balancesToken [ investorAddr ] ; balancesToken [ investorAddr ] = 0 ; isWhitelisted [ investorAddr ] = false ; require ( token . transfer ( investorAddr , balanceToTransfer ) ) ; tokensFinalized = tokensFinalized . add ( balanceToTransfer ) ; assert ( tokensFinalized <= MAX_TOKENS ) ; }",This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"function finalizeSingleInvestor(address investorAddr) public onlyOwner {
    require(investorAddr != address(0) && investorAddr != address(this));
    require(balancesToken[investorAddr] > 0);
    require(isWhitelisted[investorAddr] == true);
    uint256 balanceToTransfer = balancesToken[investorAddr];
    balancesToken[investorAddr] = 0;
    isWhitelisted[investorAddr] = false;
    require(token.transfer(investorAddr, balanceToTransfer));
    tokensFinalized = tokensFinalized.add(balanceToTransfer);
    assert(tokensFinalized <= MAX_TOKENS);
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizeSingleInvestor', 'complexity': 6}, {'function': 'announceFork', 'complexity': 2}]",11.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSingleInvestor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investorAddr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceToTransfer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investorAddr""}, {""type"": ""Identifier"", ""name"": ""balanceToTransfer""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balanceToTransfer""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizeSingleInvestor', 'complexity': 6}, {'function': 'announceFork', 'complexity': 2}]",7.0,finalizeSingleInvestor,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
        // Initialize state variables with safe, non-corner-case values
        balancesToken[address(1)] = 1; // Example value for a single investor balance
        isWhitelisted[address(1)] = true;
        tokensFinalized = 1; // Example initial value for tokens finalized
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
1617,"function _suspendMarket ( address asset ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUSPEND_MARKET_OWNER_CHECK ) ; } if ( ! markets [ asset ] . isSupported ) { return uint ( Error . NO_ERROR ) ; } markets [ asset ] . isSupported = false ; emit SuspendedMarket ( asset ) ; return uint ( Error . NO_ERROR ) ; }",Suspends a given supported market ( asset ) from use with Compound .,"function _suspendMarket(address asset) public returns (uint) {
    if (msg.sender != admin) {
        return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);
    }
    if (!markets[asset].isSupported) {
        return uint(Error.NO_ERROR);
    }
    markets[asset].isSupported = false;
    emit SuspendedMarket(asset);
    return uint(Error.NO_ERROR);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}",False,"[{'function': 'isSupported', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 3}]",11.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""UNAUTHORIZED""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""markets""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""memberName"": ""isSupported""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""markets""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""memberName"": ""isSupported""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SuspendedMarket""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isSupported', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 3}]",3.0,_suspendMarket,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}"
4581,function setBeneficiary ( address newBeneficiary ) external only ( owner ) { beneficiary = newBeneficiary ; },set beneficiary - the account receiving platform fees .,"solidity
function setBeneficiary(address newBeneficiary) external onlyOwner {
    beneficiary = newBeneficiary;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}",True,"[{'function': 'setBeneficiary', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBeneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBeneficiary', 'complexity': 0}]",1.0,setBeneficiary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        beneficiary = 0x1111111111111111111111111111111111111111; // Replace with actual address
        initialized = true;
        initValue = bytes32('initialized');
    }

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}"
5894,"function getChannelWith ( Data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != 0 ) { return self . all_channels [ channel_pos - 1 ] ; } }",Get the address of channel with a partner,"function getChannelWith (Data storage self , address partner) constant returns (address) {
    bytes32 party_hash = partyHash(msg.sender, partner);
    uint channel_pos = self.partyhash_to_channelpos[party_hash];
    if (channel_pos != 0) {
        return self.all_channels[channel_pos - 1];
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}",False,"[{'function': 'getChannelWith', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getChannelWith"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""channel_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getChannelWith', 'complexity': 1}]",2.0,getChannelWith,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ChannelWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    Data private data;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        data = Data({
            partyhash_to_channelpos: {},
            all_channels: []
        });
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}"
1558,"function mint ( address target , uint256 mintedAmount ) public onlyManager whenNotPaused { require ( target != 0 ) ; require ( mintedAmount > 0 ) ; require ( balanceOf [ target ] + mintedAmount >= balanceOf [ target ] ) ; require ( totalSupply + mintedAmount >= totalSupply ) ; balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }",function mint to be executed by Manager of token,"
function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
    require(target != 0);
    require(mintedAmount > 0);
    require(balanceOf[target] + mintedAmount >= balanceOf[target]);
    require(totalSupply + mintedAmount >= totalSupply);
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    emit Transfer(0, this, mintedAmount);
    emit Transfer(this, target, mintedAmount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",10.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid target address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Mint amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",5.0,mint,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor() Ownable(msg.sender) {
        balanceOf[address(0x111)] = 1;
        balanceOf[address(0x222)] = 1;
        balanceOf[address(0x333)] = 1;
        totalSupply = 1000000000000000000;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}"
2515,function findAdmin ( uint64 idAdmin ) internal returns ( PledgeAdmin storage ) { require ( idAdmin < admins . length ) ; return admins [ idAdmin ] ; },A getter to look up a Admin 's details,"
function findAdmin (uint64 idAdmin) internal returns (PledgeAdmin storage) {
    require(idAdmin < admins.length);
    return admins[idAdmin];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}",False,"[{'function': 'findAdmin', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""findAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": None, ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""idAdmin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admins""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""idAdmin""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'findAdmin', 'complexity': 1}]",2.0,findAdmin,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PledgeAdminStorage is Ownable {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        admins = [PledgeAdmin({ /* initialize fields if needed */ })];
    }
}"
4942,function enableWithdrawal ( ) public onlyOwner whenStopped whenWithdrawalDisabled { withdrawalEnabled = true ; emit WithdrawalEnabled ( owner ) ; },"enables withdrawals , only callable by the owner when the withdrawals are disabled","function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
    withdrawalEnabled = true;
    emit WithdrawalEnabled(owner);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}",True,"[{'function': 'enableWithdrawal', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawalEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawalEnabled""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenStopped"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenWithdrawalDisabled"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableWithdrawal', 'complexity': 0}]",1.0,enableWithdrawal,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    constructor() Ownable(msg.sender) {
        withdrawalEnabled = false;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}"
3452,function registerModule ( address _moduleFactory ) external returns ( bool ) ;,Called by moduleFactory owner to register new modules for SecurityToken to use,"function registerModule(address _moduleFactory) external returns (bool) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}",True,"[{'function': 'registerModule', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'registerModule', 'complexity': 0}]",1.0,registerModule,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}"
1228,"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == owner || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint CROWDSALE_PCT = 62 ; uint TEAMHOLDER_PCT = 20 ; uint COMMUNITYHOLDER_PCT = 15 ; uint FUTUREHOLDER_PCT = 3 ; assert ( CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100 ) ; uint256 tokenCap = wpr . totalSupply ( ) . mul ( 100 ) . div ( CROWDSALE_PCT ) ; wpr . mint ( teamHolder , tokenCap . mul ( TEAMHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( communityHolder , tokenCap . mul ( COMMUNITYHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( futureHolder , tokenCap . mul ( FUTUREHOLDER_PCT ) . div ( 100 ) ) ; require ( wpr . finishMinting ( ) ) ; wpr . transferOwnership ( owner ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }",This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"function finalize() public initialized {
    require(finalizedBlock == 0);
    require(finalizedTime == 0);
    require(getBlockTimestamp() >= startTime);
    require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

    uint CROWDSALE_PCT = 62;
    uint TEAMHOLDER_PCT = 20;
    uint COMMUNITYHOLDER_PCT = 15;
    uint FUTUREHOLDER_PCT = 3;
    assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

    uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
    wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
    wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
    wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

    require(wpr.finishMinting());
    wpr.transferOwnership(owner);

    finalizedBlock = getBlockNumber();
    finalizedTime = getBlockTimestamp();

    Finalized(finalizedBlock);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}",False,"[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'getBlockTimestamp', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",25.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""CROWDSALE_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""62"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""TEAMHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""20"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""COMMUNITYHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""15"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""FUTUREHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""CROWDSALE_PCT""}, ""right"": {""type"": ""Identifier"", ""name"": ""TEAMHOLDER_PCT""}}, ""right"": {""type"": ""Identifier"", ""name"": ""COMMUNITYHOLDER_PCT""}}, ""right"": {""type"": ""Identifier"", ""name"": ""FUTUREHOLDER_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""CROWDSALE_PCT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""teamHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TEAMHOLDER_PCT""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""communityHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""COMMUNITYHOLDER_PCT""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""futureHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""FUTUREHOLDER_PCT""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""finishMinting""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""transferOwnership""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalizedBlock""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""initialized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'getBlockTimestamp', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",9.0,finalize,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    uint256 public totalSupply;

 constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) Ownable(msg.sender) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}"
6786,"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .,"function decreaseApprovalPreSigned(bytes _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
    require(_spender != address(0));
    require(!nonces[_signature]);
    bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
    address from = recover(hashedTx, _signature);
    require(from != address(0));
    nonces[_signature] = true;
    uint oldValue = allowed[from][_spender];
    if (_subtractedValue > oldValue) {
        allowed[from][_spender] = 0;
    } else {
        allowed[from][_spender] = oldValue.sub(_subtractedValue);
    }
    balances[from] = balances[from].sub(_fee);
    balances[msg.sender] = balances[msg.sender].add(_fee);
    emit Approval(from, _spender, _subtractedValue);
    emit Transfer(from, msg.sender, _fee);
    emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}",False,"[{'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'decreaseApprovalPreSigned', 'complexity': 5}]",20.0,5.0,{},"[{'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'decreaseApprovalPreSigned', 'complexity': 5}]",5.0,decreaseApprovalPreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // uint256: Set to 1 (never 0)
        allowed[msg.sender][address(this)] = type(uint256).max; // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
    }

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}"
3195,function getDarknodePublicKey ( address _darknodeID ) external view returns ( bytes ) { return store . darknodePublicKey ( _darknodeID ) ; },Retrieves the encryption public key of the darknode .,"function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {
    return store.darknodePublicKey(_darknodeID);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}",True,"[{'function': 'darknodePublicKey', 'complexity': 0}, {'function': 'getDarknodePublicKey', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDarknodePublicKey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""store""}, ""memberName"": ""darknodePublicKey""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_darknodeID""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'darknodePublicKey', 'complexity': 0}, {'function': 'getDarknodePublicKey', 'complexity': 0}]",1.0,getDarknodePublicKey,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) Ownable(msg.sender) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}"
761,function enableTransfers ( bool _transfersEnabled ) onlyController { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true,"
function enableTransfers (bool _transfersEnabled) onlyController {
    transfersEnabled = _transfersEnabled;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",True,"[{'function': 'enableTransfers', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,enableTransfers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = false;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
3170,"function setUpgradeAgent ( UpgradeAgent _upgradeAgent ) external onlyOwner { require ( canUpgrade ( ) , ""Ensure the token is upgradeable in the first place"" ) ; require ( _upgradeAgent != address ( 0 ) , ""Ensure upgrade agent address is not blank"" ) ; require ( getUpgradeState ( ) != UpgradeState . Upgrading , ""Ensure upgrade has not started"" ) ; upgradeAgent = _upgradeAgent ; require ( upgradeAgent . isUpgradeAgent ( ) , ""New upgradeAgent must be UpgradeAgent"" ) ; require ( upgradeAgent . originalSupply ( ) == totalSupply_ , ""Make sure that token supplies match in source and target token contracts"" ) ; emit UpgradeAgentSet ( upgradeAgent ) ; }",Set an upgrade agent contract to process the upgrade .,"function setUpgradeAgent ( UpgradeAgent _upgradeAgent ) external onlyOwner {
require ( canUpgrade ( ) , ""Ensure the token is upgradeable in the first place"" );
require ( _upgradeAgent != address ( 0 ) , ""Ensure upgrade agent address is not blank"" );
require ( getUpgradeState ( ) != UpgradeState . Upgrading , ""Ensure upgrade has not started"" );
upgradeAgent = _upgradeAgent;
require ( upgradeAgent . isUpgradeAgent ( ) , ""New upgradeAgent must be UpgradeAgent"" );
require ( upgradeAgent . originalSupply ( ) == totalSupply_ , ""Make sure that token supplies match in source and target token contracts"" );
emit UpgradeAgentSet ( upgradeAgent );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}",False,"[{'function': 'originalSupply', 'complexity': 0}, {'function': 'canUpgrade', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",11.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradeAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""UpgradeAgent""}, ""name"": ""_upgradeAgent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""canUpgrade""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Ensure the token is upgradeable in the first place""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Ensure upgrade agent address is not blank""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUpgradeState""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""Upgrading""}}, {""type"": ""stringLiteral"", ""value"": ""Ensure upgrade has not started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""upgradeAgent""}], ""names"": []}, ""memberName"": ""isUpgradeAgent""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New upgradeAgent must be UpgradeAgent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""upgradeAgent""}], ""names"": []}, ""memberName"": ""originalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}}, {""type"": ""stringLiteral"", ""value"": ""Make sure that token supplies match in source and target token contracts""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgentSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""upgradeAgent""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'originalSupply', 'complexity': 0}, {'function': 'canUpgrade', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",6.0,setUpgradeAgent,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() {
        // Initialize state variables with safe, non-corner-case values
        upgradeAgent = address(1);
        totalSupply_ = 1;
    }

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}"
3368,function isRegularAddress ( address _addr ) internal view returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; },Check whether an address is a regular address or not .,"function isRegularAddress ( address _addr ) internal view returns ( bool ) {
    if ( _addr == 0 ) {
        return false;
    }
    uint size ;
    assembly {
        size := extcodesize ( _addr )
    }
    return size == 0 ;
}



","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}",True,"[{'function': 'isRegularAddress', 'complexity': 1}]",10.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegularAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,isRegularAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}

contract MyContract is Ownable, Wrapper {
    using SafeMath for uint256;

    address public addr1 = address(0x111);
    address public addr2 = address(0x222);
    address public addr3 = address(0x333);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 safeUint = 1;
        bool safeBool = true;
        string memory initializedString = 'initialized';
        bytes32 safeBytes32 = bytes32('init');
    }
}"
5919,"function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) , ""to address cannot be 0x0"" ) ; require ( _amount <= balanceOf ( msg . sender ) , ""not enough balance to transfer"" ) ; tokenStorage . subBalance ( msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }",Initiates a `` send '' operation towards another user .,"function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
    require(_to != address(0), ""to address cannot be 0x0"");
    require(_amount <= balanceOf(msg.sender), ""not enough balance to transfer"");
    tokenStorage.subBalance(msg.sender, _amount);
    tokenStorage.addBalance(_to, _amount);
    emit Transfer(msg.sender, _to, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}",False,"[{'function': 'addBalance', 'complexity': 0}, {'function': 'transfer', 'complexity': 2}, {'function': 'setTokenStorage', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'blacklistUser', 'complexity': 0}, {'function': 'removeFromBlacklist', 'complexity': 0}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""to address cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""not enough balance to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""memberName"": ""subBalance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""memberName"": ""addBalance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addBalance', 'complexity': 0}, {'function': 'transfer', 'complexity': 2}, {'function': 'setTokenStorage', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'blacklistUser', 'complexity': 0}, {'function': 'removeFromBlacklist', 'complexity': 0}]",3.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}"
4803,"function cancelSale ( uint256 _tokenId ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .,"
function cancelSale (uint256 _tokenId) public {
    Sale storage sale = tokenIdToSale[_tokenId];
    require(_isOnSale(sale));
    address seller = sale.seller;
    require(msg.sender == seller);
    _cancelSale(_tokenId, seller);
}

function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Sale""}, ""name"": ""sale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIdToSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isOnSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sale""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""seller"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sale""}, ""memberName"": ""seller""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""seller""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_cancelSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""Identifier"", ""name"": ""seller""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,cancelSale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}

contract YourContractInstance is YourContract {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            tokenIdToSale[i] = Sale({seller: address(uint160(uint256(keccak256(abi.encodePacked('seller', i)))))});
        }
    }
}"
2141,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS , ""answerer must be provided"" ) ; emit LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }","Submit the answer for a question , for use by the arbitrator .","function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}",False,"[{'function': 'submitAnswerByArbitrator ', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswerByArbitrator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""answerer""}, ""right"": {""type"": ""Identifier"", ""name"": ""NULL_ADDRESS""}}, {""type"": ""stringLiteral"", ""value"": ""answerer must be provided""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogFinalize""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""is_pending_arbitration""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addAnswerToHistory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateCurrentAnswer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyArbitrator"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}]}, {""type"": ""ModifierInvocation"", ""name"": ""statePendingArbitration"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}]}, {""type"": ""ModifierInvocation"", ""name"": ""bondMustBeZero"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'submitAnswerByArbitrator ', 'complexity': 1}]",2.0,submitAnswerByArbitrator,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    // State variables initialization
    bytes32 public constant NULL_ADDRESS = bytes32('init');
    mapping(bytes32 => Question) public questions;

    struct Question {
        bool is_pending_arbitration;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        NULL_ADDRESS = bytes32('init');
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) 
        onlyArbitrator(question_id) 
        statePendingArbitration(question_id) 
        bondMustBeZero 
        external 
    {
        require(answerer != address(0), ""answerer must be provided"");
        emit LogFinalize(question_id, answer);
        questions[question_id].is_pending_arbitration = false;
        _addAnswerToHistory(question_id, answer, answerer, 0, false);
        _updateCurrentAnswer(question_id, answer, 0);
    }
}"
381,function remainingFundsToEndAuction ( ) constant public returns ( uint256 ) { uint256 required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; },"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","function remainingFundsToEndAuction() constant public returns (uint256) {
    uint256 required_wei_at_price = num_tokens_auctioned * price() / token_multiplier;
    if (required_wei_at_price <= received_wei) {
        return 0;
    }
    return required_wei_at_price - received_wei;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}",False,"[{'function': 'remainingFundsToEndAuction', 'complexity': 6}]",9.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""remainingFundsToEndAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Number of tokens auctioned must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token multiplier must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""required_wei_at_price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""price_per_token""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""required_wei_at_price""}, ""right"": {""type"": ""Identifier"", ""name"": ""received_wei""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""required_wei_at_price""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""received_wei""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'remainingFundsToEndAuction', 'complexity': 6}]",7.0,remainingFundsToEndAuction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    constructor() Ownable(0x1111111111111111111111111111111111111111 , 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333) {
        num_tokens_auctioned = 1;
        received_wei = 1 ether;
        price_per_token = 1 ether;
        token_multiplier = 1;
    }

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}"
242,function proxyWithdraw ( address receiverAddress ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint amount = bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; receiverAddress . transfer ( amount ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; },Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
    require(receiverAddress != address(0));
    if (bids[receiverAddress] == 0) {
        return false;
    }
    uint amount = bids[receiverAddress];
    bids[receiverAddress] = 0;
    receiverAddress.transfer(amount);
    assert(bids[receiverAddress] == 0);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}",False,"[{'function': 'proxyWithdraw', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiverAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""atStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionCanceled""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,proxyWithdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        stage = Stages.AuctionCreated;
    }

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}"
1926,function proxyPayment ( address _owner ) payable returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract,"function proxyPayment ( address _owner ) payable returns ( bool ) ;


function proxyPayment ( address _owner ) payable returns ( bool ) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}",False,"[{'function': 'proxyPayment', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,proxyPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ProxyContract is Ownable {
    using SafeMath for uint2atural;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}"
6311,"function vote ( uint _proposalId , bool _yes ) public { require ( _proposalId < proposals . length ) ; require ( checkIfCurrentlyActive ( _proposalId ) ) ; Proposal memory p = proposals [ _proposalId ] ; uint amount = MiniMeToken ( p . token ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( MiniMeToken ( p . token ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; if ( _yes ) { proposals [ _proposalId ] . yesVotes += amount ; } else { proposals [ _proposalId ] . noVotes += amount ; } emit Vote ( _proposalId , msg . sender , _yes , amount ) ; }",Vote for specific proposal with yes or no,"function vote(_proposalId uint, _yes bool) public {
require(_proposalId < proposals.length);
require(checkIfCurrentlyActive(_proposalId));
Proposal memory p = proposals[_proposalId];
uint amount = MiniMeToken(p.token).balanceOf(msg.sender);
require(amount > 0);
require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount));
if (_yes) {
proposals[_proposalId].yesVotes += amount;
} else {
proposals[_proposalId].noVotes += amount;
}
emit Vote(_proposalId, msg.sender, _yes, amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",14.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_yes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_proposalId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid proposal ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkIfCurrentlyActive""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_proposalId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Proposal is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""p"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to vote with""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""token""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""_yes""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""yesVotes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""yesVotes""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""noVotes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""noVotes""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_proposalId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_yes""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",6.0,vote,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

contract Proposal is Ownable {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        proposals = [Proposal({token: 0x1111111111111111111111111111111111111111, noVotes: 0, yesVotes: 0}), Proposal({token: 0x2222222222222222222222222222222222222222, noVotes: 0, yesVotes: 0}), Proposal({token: 0x3333333333333333333333333333333333333333, noVotes: 0, yesVotes: 0})];
    }

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}"
2268,"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; require ( module . pricefeed . hasRecentPrice ( address ( request . requestAsset ) ) ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }","Executes active investment and redemption requests , in a way that minimises information advantages of investor","function executeRequest(uint id) external pre_cond(!isShutDown) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (now >= add(requests[id].timestamp, module.pricefeed.getInterval()) && module.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
    Request request = requests[id];
    require(module.pricefeed.hasRecentPrice(address(request.requestAsset)));
    uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
    if (request.requestAsset == address(NATIVE_ASSET)) {
        var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.pricefeed.getInvertedPrice(address(NATIVE_ASSET));
        if (!isPriceRecent) {
            revert();
        }
        costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
    }
    if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
        request.status = RequestStatus.executed;
        assert(AssetInterface(request.requestAsset).transferFrom(request.participant, this, costQuantity));
        createShares(request.participant, request.shareQuantity);
    } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
        request.status = RequestStatus.executed;
        assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
        annihilateShares(request.participant, request.shareQuantity);
    } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
        request.status = RequestStatus.executed;
        assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
        annihilateShares(this, request.shareQuantity);
    } else {
        revert();
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'getInvertedPrice', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 10}]",25.0,18.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeRequest"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Request""}, ""name"": ""request"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""hasRecentPrice""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestAsset""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""costQuantity"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""toWholeShareUnit""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""shareQuantity""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calcSharePriceAndAllocateFees""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestAsset""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""NATIVE_ASSET""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""isPriceRecent"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x112b2fb60>}, {""type"": ""VariableDeclaration"", ""name"": ""invertedNativeAssetPrice"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x112b2cc20>}, {""type"": ""VariableDeclaration"", ""name"": ""nativeAssetDecimal"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x112b2d780>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""getInvertedPrice""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""NATIVE_ASSET""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isPriceRecent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""costQuantity""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""costQuantity""}, {""type"": ""Identifier"", ""name"": ""invertedNativeAssetPrice""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""nativeAssetDecimal""}}}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""isInvestAllowed""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestType""}, ""memberName"": ""invest""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""costQuantity""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""giveQuantity""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestStatus""}, ""memberName"": ""executed""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AssetInterface""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestAsset""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""participant""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""costQuantity""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""createShares""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""participant""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""shareQuantity""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""isRedeemAllowed""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestType""}, ""memberName"": ""redeem""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""receiveQuantity""}, ""right"": {""type"": ""Identifier"", ""name"": ""costQuantity""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestStatus""}, ""memberName"": ""executed""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AssetInterface""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestAsset""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""participant""}, {""type"": ""Identifier"", ""name"": ""costQuantity""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""annihilateShares""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""participant""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""shareQuantity""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""isRedeemAllowed""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestType""}, ""memberName"": ""tokenFallbackRedeem""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""receiveQuantity""}, ""right"": {""type"": ""Identifier"", ""name"": ""costQuantity""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestStatus""}, ""memberName"": ""executed""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AssetInterface""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""requestAsset""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""participant""}, {""type"": ""Identifier"", ""name"": ""costQuantity""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""annihilateShares""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""request""}, ""memberName"": ""shareQuantity""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}]}}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isShutDown""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}]}, {""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestStatus""}, ""memberName"": ""active""}}]}, {""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""requestType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestType""}, ""memberName"": ""redeem""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""shareQuantity""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""participant""}}}}]}, {""type"": ""ModifierInvocation"", ""name"": ""pre_cond"", ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""timestamp""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""getInterval""}, ""arguments"": [], ""names"": []}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""getLastUpdateId""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""atUpdateId""}, {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}}], ""isArray"": False}}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getInvertedPrice', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 10}]",21.0,executeRequest,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(PriceFeedInterface _module) {
        module = _module;
        // Initialize instance variables to fixed, safe values
        totalSupply = 1000000000000000000;
        isInvestAllowed = true;
        isRedeemAllowed = true;
        NATIVE_ASSET = 0x1111111111111111111111111111111111111111; // Replace with actual value
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        // ... rest of the function remains the same ...
    }

    // Initialize Ownable uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
2205,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) external { }","Submit the answer for a question , for use by the arbitrator .","function submitAnswerByArbitrator (bytes32 question_id , bytes32 answer , address answerer) external { }

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external {}

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external
{}

function submitAnswerByArbitrator (bytes32 question_id , bytes32 answer , address answerer ) external { }

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external {}

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external
{}

function submitAnswerByArbitrator (bytes32 question_id , bytes32 answer , address answerer ) external { }

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external {}

function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external
{}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}",True,"[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswerByArbitrator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""answered""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Question already answered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Question""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""questionId"", ""answer"", ""answerer"", ""answered""]}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",2.0,submitAnswerByArbitrator,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}"
6381,"function safeTransferFrom ( address token , address from , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , ""transferFrom failed"" ) ; }",Calls transferFrom on the token and reverts if the call fails .,"function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
    CompatibleERC20(token).transferFrom(from, to, amount);
    require(previousReturnValue(), ""transferFrom failed"");
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFrom', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeTransferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CompatibleERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousReturnValue""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""transferFrom failed""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFrom', 'complexity': 1}]",2.0,safeTransferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract WrappedToken is Ownable {
    using SafeMath for uint256;

    // Fixed values
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT = 1;

    constructor() Ownable(DEFAULT_ADDRESS) {
        _setOwner(DEFAULT_ADDRESS);
    }

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}"
5030,"function slash ( bytes32 _guiltyOrderID ) external onlySlasher { require ( orderDetails [ _guiltyOrderID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID , ""slashing non-atomic trade"" ) ; bytes32 innocentOrderID = orderbookContract . orderMatch ( _guiltyOrderID ) ; require ( orderStatus [ _guiltyOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; require ( orderStatus [ innocentOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; orderStatus [ _guiltyOrderID ] = OrderStatus . Slashed ; ( bytes32 buyID , bytes32 sellID ) = isBuyOrder ( _guiltyOrderID ) ? ( _guiltyOrderID , innocentOrderID ) : ( innocentOrderID , _guiltyOrderID ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ buyID ] . tokens ) ; SettlementDetails memory settlementDetails = calculateAtomicFees ( buyID , sellID , tokens ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , orderbookContract . orderTrader ( innocentOrderID ) , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , slasherAddress , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; }",Slashes the bond of a guilty trader .,"function slash(bytes32 _guiltyOrderID) external onlySlasher {
    require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
    bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
    require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
    require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
    orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
    (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
    TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
    SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
    renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}",False,"[{'function': 'orderTrader', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'slash', 'complexity': 4}]",12.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""slash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_guiltyOrderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderDetails""}, ""index"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}}, ""memberName"": ""settlementID""}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}, {""type"": ""stringLiteral"", ""value"": ""slashing non-atomic trade""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderStatus""}, ""index"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Settled""}}, {""type"": ""stringLiteral"", ""value"": ""invalid order status""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""innocentOrderID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderbookContract""}, ""memberName"": ""orderMatch""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderStatus""}, ""index"": {""type"": ""Identifier"", ""name"": ""innocentOrderID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Settled""}}, {""type"": ""stringLiteral"", ""value"": ""invalid order status""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderStatus""}, ""index"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Slashed""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""buyID"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112e9a6d0>}, {""type"": ""VariableDeclaration"", ""name"": ""sellID"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112e9a5f0>}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isBuyOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}, ""TrueExpression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}, {""type"": ""Identifier"", ""name"": ""innocentOrderID""}], ""isArray"": False}, ""FalseExpression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""innocentOrderID""}, {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenPair""}, ""name"": ""tokens"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTokenDetails""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderDetails""}, ""index"": {""type"": ""Identifier"", ""name"": ""buyID""}}, ""memberName"": ""tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SettlementDetails""}, ""name"": ""settlementDetails"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""buyID""}, {""type"": ""Identifier"", ""name"": ""sellID""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderbookContract""}, ""memberName"": ""orderTrader""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderbookContract""}, ""memberName"": ""orderTrader""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""innocentOrderID""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenFee""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderbookContract""}, ""memberName"": ""orderTrader""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""slasherAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementDetails""}, ""memberName"": ""leftTokenFee""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'orderTrader', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'slash', 'complexity': 4}]",4.0,slash,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    constructor() Ownable(msg.sender) {
        slasherAddress = msg.sender;
        RENEX_ATOMIC_SETTLEMENT_ID = 0x11111111bcb9d95f0c4e6ab0c5a4208eb8b3f7c2;
    }

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}"
3520,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitycheck . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }",Submit the arbitrator 's answer to a question .,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public {
    delete arbitration_bounties[question_id];
    realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}",True,"[{'function': 'submitAnswerByArbitrator', 'complexity': 0}, {'function': 'submitAnswerByArbitrator', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswerByArbitrator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arbitration_bounties""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""realitycheck""}, ""memberName"": ""submitAnswerByArbitrator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'submitAnswerByArbitrator', 'complexity': 0}, {'function': 'submitAnswerByArbitrator', 'complexity': 0}]",1.0,submitAnswerByArbitrator,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) Ownable(msg.sender) {
        realitycheck = RealityCheck(_realityCheckAddress);
        // Initialize state variables with safe, non-corner-case values
        arbitration_bounties[bytes32('init')] = true;
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}"
4614,"function withdrawNomins ( uint amount ) external onlyOwner { nomin . transfer ( owner , amount ) ; }",Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"function withdrawNomins (uint amount) external onlyOwner {
    nomin . transfer (owner , amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}",False,"[{'function': 'withdrawNomins', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawNomins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""nomin""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nomin""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,withdrawNomins,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    address public nomin = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        _setNomins(1);
        _setInitialized(true);
        _setInitValue(bytes32('init'));
    }

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}"
1147,"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash ) ; require ( arbitrator == questions [ question_id ] . arbitrator ) ; require ( min_timeout <= questions [ question_id ] . timeout ) ; require ( min_bond <= questions [ question_id ] . bond ) ; return questions [ question_id ] . best_answer ; }","Return the final answer to the specified question , provided it matches the specified criteria .","function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) stateFinalized(question_id) external constant returns (bytes32) {
    require(content_hash == questions[question_id].content_hash);
    require(arbitrator == questions[question_id].arbitrator);
    require(min_timeout <= questions[question_id].timeout);
    require(min_bond <= questions[question_id].bond);
    return questions[question_id].best_answer;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}",False,"[{'function': 'getFinalAnswerIfMatches', 'complexity': 4}]",7.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalAnswerIfMatches"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""content_hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""arbitrator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""min_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""min_bond"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""content_hash""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""content_hash""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""arbitrator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""arbitrator""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""min_timeout""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""timeout""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""min_bond""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""bond""}}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""best_answer""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""constant""}","[{'function': 'getFinalAnswerIfMatches', 'complexity': 4}]",5.0,getFinalAnswerIfMatches,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    Question[] public questionsArray;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}"
6458,"function setApprovalForAll ( address _operator , bool _approved ) onlyNonZeroAddress ( _operator ) external { ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",This works even if sender does n't own any tokens at the time .,"function setApprovalForAll(address _operator, bool _approved) onlyNonZeroAddress(_operator) external {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}",False,"[{'function': 'setApprovalForAll', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Operator address must be non-zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerToOperators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNonZeroAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,setApprovalForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;
    address public constant DEFAULT_OPERATOR = 0x1111111111111111111111111111111111111111; // Replace with actual default operator value
    bytes32 public constant DEFAULT_INIT_VALUE = bytes32('init');
    bool public constant DEFAULT_IS_INITIALIZED = true;

    constructor() Ownable(DEFAULT_OPERATOR) {
        ownerToOperators[msg.sender][DEFAULT_OPERATOR] = DEFAULT_IS_INITIALIZED;
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}"
732,"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) external ;",Used by a controller to execute a forced transfer,"function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}",True,"[{'function': 'forceTransfer', 'complexity': 3}]",8.0,4.0,{},"[{'function': 'forceTransfer', 'complexity': 3}]",5.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
442,function endAuction ( ) public onlyOwner { require ( status == state . active ) ; status = state . ended ; emit Ended ( block . number ) ; },"Ends the auction , preventing new bids from entering","
function endAuction() public onlyOwner {
    require(status == state.active);
    status = state.ended;
    emit Ended(block.number);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}",True,"[{'function': 'endAuction', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""endAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""state""}, ""memberName"": ""active""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""state""}, ""memberName"": ""ended""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Ended""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'endAuction', 'complexity': 1}]",2.0,endAuction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status = state.active;

    constructor() Ownable(msg.sender) {
        // No need to initialize variables as they are already set in the base class constructor and enum initialization
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}"
3580,"function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;",Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes signature) external view returns (bool) {
    require(account != address(0), ""Invalid account address"");
    require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
    require(value >= 0 && value <= _maxValue, ""Invalid value"");
    require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
    require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
    require(signature.length == _signatureLength, ""Invalid signature length"");

    // Check if the account has enough funds to add the attribute
    uint256 currentBalance = getCurrentBalanceForAccount(account);
    require(currentBalance >= fundsRequired, ""Insufficient funds"");

    // Check if the attribute is already added for the account
    bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
    require(!isAttributeAdded, ""Attribute already added"");

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}",False,"[{'function': 'canAddAttributeFor', 'complexity': 13}, {'function': 'getCurrentBalanceForAccount', 'complexity': 0}, {'function': 'isAttributeAlreadyAddedForAccount', 'complexity': 0}]",16.0,14.0,"{""type"": ""FunctionDefinition"", ""name"": ""canAddAttributeFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fundsRequired"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""validatorFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid account address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totalAttributeTypes""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid attribute type ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxValue""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""fundsRequired""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""fundsRequired""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxFundsRequired""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid funds required""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""validatorFee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""validatorFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxValidatorFee""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid validator fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signature""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""_signatureLength""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature length""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCurrentBalanceForAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""fundsRequired""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isAttributeAdded"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAttributeAlreadyAddedForAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""attributeTypeID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isAttributeAdded""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Attribute already added""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'canAddAttributeFor', 'complexity': 13}, {'function': 'getCurrentBalanceForAccount', 'complexity': 0}, {'function': 'isAttributeAlreadyAddedForAccount', 'complexity': 0}]",14.0,canAddAttributeFor,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeValidator is Ownable {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) Ownable() {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}"
3476,"function burnTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( depositAddress != address ( 0 ) ) ; require ( _tokens != 0 ) ; require ( _tokens <= balances [ depositAddress ] ) ; balances [ depositAddress ] = balances [ depositAddress ] . sub ( _tokens ) ; totalSupply_ = totalSupply_ . sub ( _tokens ) ; emit TokensBurned ( msg . sender , depositAddress , _tokens ) ; }",Called when tokens have to be burned ( only after sale ),"function burnTokens(uint256 _tokens) external {
require(!locked);
require(contractManager.authorize(contractName, msg.sender));
require(depositAddress != address(0));
require(_tokens != 0);
require(_tokens <= balances[depositAddress]);
balances[depositAddress] = balances[depositAddress].sub(_tokens);
totalSupply_ = totalSupply_.sub(_tokens);
emit TokensBurned(msg.sender, depositAddress, _tokens);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}",False,"[{'function': 'burnTokens', 'complexity': 6}]",11.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""locked""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract is locked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractManager""}, ""memberName"": ""authorize""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractName""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized access""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""depositAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Deposit address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Tokens amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositAddress""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to burn tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositAddress""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensBurned""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""depositAddress""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burnTokens', 'complexity': 6}]",6.0,burnTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    bool public locked = true;
    string public contractName = 'MyToken';
    address public depositAddress = 0x1111111111111111111111111111111111111111; // Replace with actual address
    mapping(address => uint256) public balances;
    uint256 public totalSupply_ = 1;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        require(depositAddress != address(0), ""Deposit address not set"");
        require(totalSupply_ > 0, ""Total supply must be greater than zero"");

        balances[msg.sender] = totalSupply_;
    }

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractName == msg.sender, ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}"
1148,"function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }",Reusable code to do sanity check of transfer variables,"function transferCheck (address _sender , address _receiver , uint256 _amount) private constant returns (bool success) {
    require(!tokenTransfersFrozen);
    require(_amount > 0);
    require(_receiver != address(0));
    require(balances[_sender].sub(_amount) >= 0);
    require(balances[_receiver].add(_amount) > 0);
    require(balances[_receiver].add(_amount) > balances[_receiver]);
    return true;
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}",True,"[{'function': 'transferCheck', 'complexity': 6}]",8.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferCheck"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tokenTransfersFrozen""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token transfers are frozen""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver address cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds available balance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'transferCheck', 'complexity': 6}]",6.0,transferCheck,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 for the owner
        tokenTransfersFrozen = false; // Default to not frozen
    }

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}"
5952,"function setInterfaceImplementer ( address addr , bytes32 iHash , address implementer ) public canManage ( addr ) { interfaces [ addr ] [ iHash ] = implementer ; InterfaceImplementerSet ( addr , iHash , implementer ) ; }",Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr) {
    interfaces[addr][iHash] = implementer;
    InterfaceImplementerSet(addr, iHash, implementer);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}",False,"[{'function': 'setInterfaceImplementer', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""iHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""index"": {""type"": ""Identifier"", ""name"": ""iHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""implementer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InterfaceImplementerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""iHash""}, {""type"": ""Identifier"", ""name"": ""implementer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setInterfaceImplementer', 'complexity': 0}]",1.0,setInterfaceImplementer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        interfaces = mapping(address => mapping(bytes32 => address))({0x1111111111111111111111111111111111111111: 0x2222222222222222222222222222222222222222, 0x2222222222222222222222222222222222222222: 0x3333333333333333333333333333333333333333});
    }

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}"
5131,function calculateTokens ( uint256 _amountOfWei ) public view returns ( uint256 ) { require ( _amountOfWei >= 1 szabo ) ; uint256 tokenBought ; uint256 tokenPrice = price . USD ( 0 ) ; tokenPrice = tokenPrice . mul ( 36 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = _amountOfWei . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; if ( _amountOfWei >= 10 ether ) { tokenBought = tokenBought . mul ( 123 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( _amountOfWei >= 1 ether ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } return tokenBought ; },Function to know how many tokens you will receive at current time,"function calculateTokens (uint256 _amountOfWei) public view returns (uint256) {
    require(_amountOfWei >= 1 szabo);
    uint256 tokenBought;
    uint256 tokenPrice = price.USD(0);
    tokenPrice = tokenPrice.mul(36);
    tokenPrice = tokenPrice.div(10 ** 8);
    tokenBought = _amountOfWei.div(tokenPrice);
    tokenBought = tokenBought.mul(10 ** 10);
    if (_amountOfWei >= 10 ether) {
        tokenBought = tokenBought.mul(123);
        tokenBought = tokenBought.div(100);
    } else if (_amountOfWei >= 1 ether) {
        tokenBought = tokenBought.mul(11);
        tokenBought = tokenBought.div(10);
    }
    return tokenBought;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}",False,"[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",14.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountOfWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""szabo""}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be at least 1 szabo""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenBought"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""memberName"": ""USD""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""36"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""8"", ""subdenomination"": None}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenPrice""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""123"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenBought""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""11"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": None}}, {""type"": ""Identifier"", ""name"": ""tokenBought""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",5.0,calculateTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) Ownable(msg.sender) {
        require(_priceAddress != address(0), ""Invalid price address"");
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}"
725,function isCompetitionAllowed ( address user ) view returns ( bool ) { return isWhitelisted [ user ] ; },Checks whether an address is whitelisted in the competition contract and competition is active,"function isCompetitionAllowed (address user) view returns (bool) {
    return isWhitelisted[user];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}",False,"[{'function': 'isCompetitionAllowed', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isCompetitionAllowed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isCompetitionAllowed', 'complexity': 0}]",1.0,isCompetitionAllowed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;
    address public owner = 0x1111111111111111111111111111111111111111; // fixed address
    bool public initialized = true;
    bytes32 public constant initValue = bytes32('init');

    constructor() Ownable(0x1111111111111111111111111111111111111111) {
        _setOwner(0x1111111111111111111111111111111111111111);
        _setInitialized(true);
    }

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}"
3756,"function voteFor ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Yea ; votesFor [ motionID ] = safeAdd ( votesFor [ motionID ] , weight ) ; emit VotedFor ( msg . sender , motionID , weight ) ; }",The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"function voteFor (uint motionID) external {
    uint weight = setupVote(motionID);
    vote[msg.sender][motionID] = Vote.Yea;
    votesFor[motionID] = safeAdd(votesFor[motionID], weight);
    emit VotedFor(msg.sender, motionID, weight);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}",False,"[{'function': 'setupVote', 'complexity': 0}, {'function': 'voteFor', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""voteFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""motionID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""votingContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""votingContractAddress""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""setupVote(uint256)""}, {""type"": ""Identifier"", ""name"": ""motionID""}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Failed to call setupVote""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vote""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""memberName"": ""Yea""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesFor""}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesFor""}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VotedFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""motionID""}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setupVote', 'complexity': 0}, {'function': 'voteFor', 'complexity': 1}]",2.0,voteFor,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized with default values
    }

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}"
4311,function setEnd ( ) external onlyAdmin checkState ( pointsValidationState . WinnersAssigned ) { uint256 balance = address ( this ) . balance ; adminPool = balance . mul ( 10 ) . div ( 100 ) ; prizePool = balance . mul ( 90 ) . div ( 100 ) ; pValidationState = pointsValidationState . Finished ; gameFinishedTime = now ; unSetPause ( ) ; },Sets prizes for last tokens and sets prize pool amount,"
function setEnd ( ) external onlyAdmin checkState ( pointsValidationState . WinnersAssigned ) {
    uint256 balance = address ( this ) . balance ;
    adminPool = balance . mul ( 10 ) . div ( 100 ) ;
    prizePool = balance . mul ( 90 ) . div ( 100 ) ;
    pValidationState = pointsValidationState . Finished ;
    gameFinishedTime = now ;
    unSetPause ( ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}",False,"[{'function': 'setEnd', 'complexity': 0}, {'function': 'checkState', 'complexity': 1}, {'function': 'unSetPause', 'complexity': 0}]",8.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setEnd"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""adminPool""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prizePool""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""90"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pValidationState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""Finished""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""gameFinishedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""unSetPause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""checkState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""WinnersAssigned""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setEnd', 'complexity': 0}, {'function': 'checkState', 'complexity': 1}, {'function': 'unSetPause', 'complexity': 0}]",1.0,setEnd,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    constructor() Ownable(msg.sender) {
        pValidationState = pointsValidationState.NotStarted;
        gameFinishedTime = 0; // Default to zero time
        adminPool = 1; // Set to safe non-zero value
        prizePool = 2; // Set to safe non-zero value
    }

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}"
5253,function renounceOwnership ( ) public contract_onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .,"function renounceOwnership() public contract_onlyOwner {
    emit OwnershipRenounced(_owner);
    _owner = address(0);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}",False,"[{'function': 'renounceOwnership', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""renounceOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRenounced""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferOwnership""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,renounceOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        someUint = 1; // Set to 1 (never 0)
        someAddress = address(uint160(uint256(keccak256('someAddress1')))); // Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someBool = true; // Set to true
        someString = 'initialized'; // Set to 'initialized'
        someBytes32 = bytes32('init'); // Set to bytes32('init')
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}"
86,function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner external { maxSecurityGuardDelay = _maxSecurityGuardDelay ; },` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"function setMaxSecurityGuardDelay (uint _maxSecurityGuardDelay) onlyOwner external {
    maxSecurityGuardDelay = _maxSecurityGuardDelay;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}",True,"[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxSecurityGuardDelay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_maxSecurityGuardDelay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxSecurityGuardDelay""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,setMaxSecurityGuardDelay,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}"
3464,"function _addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) internal { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 moduleType = moduleFactory . getType ( ) ; require ( modules [ moduleType ] . length < MAX_MODULES , ""Limit of MAX MODULES is reached"" ) ; uint256 moduleCost = moduleFactory . setupCost ( ) ; require ( moduleCost <= _maxCost , ""Max Cost is always be greater than module cost"" ) ; require ( ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) , ""Not able to approve the module cost"" ) ; address module = moduleFactory . deploy ( _data ) ; require ( ERC20 ( polyToken ) . approve ( module , _budget ) , ""Not able to approve the budget"" ) ; bytes32 moduleName = moduleFactory . getName ( ) ; modules [ moduleType ] . push ( ModuleData ( moduleName , module ) ) ; emit LogModuleAdded ( moduleType , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }",_addModule handles the attachment ( or replacement ) of modules for the ST,"function _addModule(address _moduleFactory, bytes _data, uint256 _maxCost, uint256 _budget) internal {
    IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
    IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
    uint8 moduleType = moduleFactory.getType();
    require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
    uint256 moduleCost = moduleFactory.setupCost();
    require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
    require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
    address module = moduleFactory.deploy(_data);
    require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
    bytes32 moduleName = moduleFactory.getName();
    modules[moduleType].push(ModuleData(moduleName, module));
    emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, now);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}",False,"[{'function': 'getType', 'complexity': 0}, {'function': 'getName', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': '_addModule', 'complexity': 4}]",14.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""_addModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxCost"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_budget"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IModuleRegistry""}, ""name"": ""moduleRegistry"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleRegistry""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IModuleFactory""}, ""name"": ""moduleFactory"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""moduleType"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""getType""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""moduleType""}}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_MODULES""}}, {""type"": ""stringLiteral"", ""value"": ""Limit of MAX MODULES is reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""moduleCost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""setupCost""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""moduleCost""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxCost""}}, {""type"": ""stringLiteral"", ""value"": ""Max Cost is always be greater than module cost""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""polyToken""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}, {""type"": ""Identifier"", ""name"": ""moduleCost""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not able to approve the module cost""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""module"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""deploy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""polyToken""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""module""}, {""type"": ""Identifier"", ""name"": ""_budget""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not able to approve the budget""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""moduleName"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""getName""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""moduleType""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""moduleName""}, {""type"": ""Identifier"", ""name"": ""module""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogModuleAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""moduleType""}, {""type"": ""Identifier"", ""name"": ""moduleName""}, {""type"": ""Identifier"", ""name"": ""_moduleFactory""}, {""type"": ""Identifier"", ""name"": ""module""}, {""type"": ""Identifier"", ""name"": ""moduleCost""}, {""type"": ""Identifier"", ""name"": ""_budget""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getType', 'complexity': 0}, {'function': 'getName', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': '_addModule', 'complexity': 4}]",8.0,_addModule,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken = 0x1111111111111111111111111111111111111111; // fixed value
    uint8 constant MAX_MODULES = 10;
    bool public initialized = true;
    bytes32 public moduleName = bytes32('initialized');
    address public moduleFactoryAddress = 0x2222222222222222222222222222222222222222; // fixed value

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address indexed module, uint256 cost, uint256 budget, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        polyToken = 0x1111111111111111111111111111111111111111; // fixed value
        moduleFactoryAddress = 0x2222222222222222222222222222222222222222; // fixed value
        initialized = true;
        moduleName = bytes32('initialized');
    }

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}"
2419,function getPermissions ( ) public view returns ( bytes32 [ ] ) ;,Return the permissions flag that are associated with Module,"function getPermissions() public view returns (bytes32[]);

function getPermissions( ) public view returns ( bytes32 [ ] ) ;
{
    return permissions;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}",False,"[{'function': 'getPermissions', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPermissions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""permissions""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPermissions', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        permissions = [bytes32('init')];
    }

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}"
3265,function _unpause ( ) internal whenPaused { paused = false ; emit Unpause ( now ) ; },"Called by the owner to unpause , returns to normal state","function _unpause() internal whenPaused {
    paused = false;
    emit Unpause(now);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}",False,"[{'function': '_unpause', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unpause""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_unpause', 'complexity': 0}]",1.0,_unpause,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pausable is Ownable {
    bool public paused = true; // Initialize to true instead of false
    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}"
1244,"function getGrey ( uint256 _tokenId ) public view returns ( string greyName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Grey storage grey = greys [ _tokenId ] ; greyName = grey . name ; sellingPrice = greyIndexToPrice [ _tokenId ] ; owner = greyIndexToOwner [ _tokenId ] ; previousPrice = greyIndexToPreviousPrice [ _tokenId ] ; previousOwners = greyIndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific grey .,"function getGrey(uint256 _tokenId) public view returns (string greyName, uint256 sellingPrice, address owner, uint256 previousPrice, address[5] previousOwners) {
    Grey storage grey = greys[_tokenId];
    greyName = grey.name;
    sellingPrice = greyIndexToPrice[_tokenId];
    owner = greyIndexToOwner[_tokenId];
    previousPrice = greyIndexToPreviousPrice[_tokenId];
    previousOwners = greyIndexToPreviousOwners[_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}",True,"[{'function': 'getGrey', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getGrey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grey""}, ""name"": ""grey"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greys""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""name""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getGrey', 'complexity': 0}]",1.0,getGrey,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GreyWrapper is Ownable {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            greys[i] = Grey({name: 'initialized'});
            greyIndexToPrice[i] = 1;
            greyIndexToOwner[i] = address(uint160(i) << 160);
            greyIndexToPreviousPrice[i] = 1;
            for (uint256 j = 0; j < 5; j++) {
                if (j == 0) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + j) << 160);
                } else {
                    greyIndexToPreviousOwners[i][j] = address(0);
                }
            }
        }
    }

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}"
1531,"function setTokenXCurrency ( address asset , string currency ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; require ( setAssetCurrency ( asset , currency ) ) ; return true ; }",This method may be deprecated or refactored to allow for multiple interfaces,"function setTokenXCurrency(address asset, string currency) public onlyOwner notDeprecated returns (bool success) {
    bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
    require(lib.Storage.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
    require(setAssetCurrency(asset, currency));
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}",True,"[{'function': 'setBool', 'complexity': 0}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenXCurrency"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tokenx""}, {""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lib""}, ""memberName"": ""setBool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenX""}, ""memberName"": ""setAssetCurrency""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Failed to set asset currency.""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBool', 'complexity': 0}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 2}]",3.0,setTokenXCurrency,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) Ownable(msg.sender) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}"
4775,function capReached ( ) public view returns ( bool ) { return totalTokensSold >= cap ; },Checks whether the cap has been reached .,"function capReached() public view returns (bool) {
    return totalTokensSold >= cap;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}",True,"[{'function': 'capReached', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""capReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'capReached', 'complexity': 0}]",1.0,capReached,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold = 0; // Set to 0 instead of 1
    uint256 public cap = 1000; // Example value, adjust as needed

    constructor() Ownable(msg.sender) {
        // Initialization done in the constructor
    }

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}"
39,"function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , _excluded , _name ) ; }","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","function createDividendWithCheckpointAndExclusions (uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address [] _excluded, bytes32 _name) public payable withPerm(MANAGE) {
    _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}",True,"[{'function': 'createDividendWithCheckpointAndExclusions', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividendWithCheckpointAndExclusions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createDividendWithCheckpointAndExclusions""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_excluded""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'createDividendWithCheckpointAndExclusions', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",1.0,createDividendWithCheckpointAndExclusions,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DividendManager is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    address public constant EXCLUDED_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public initialized = true;
    bytes32 public name = bytes32('init');
    uint256 public maturity;
    uint256 public expiry;
    uint256 public checkpointId;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}"
2566,"function doDisableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; if ( _escrow . sellerCanCancelAfter == 0 ) return false ; escrows [ _tradeHash ] . sellerCanCancelAfter = 0 ; emit SellerCancelDisabled ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doDisableSellerCancel + _additionalGas ) ; } return true ; }",Prevents the seller from cancelling an escrow .,"function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) private returns (bool) {
    Escrow memory _escrow;
    bytes32 _tradeHash;
    (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
    if (!_escrow.exists) return false;
    if (_escrow.sellerCanCancelAfter == 0) return false;
    escrows[_tradeHash].sellerCanCancelAfter = 0;
    emit SellerCancelDisabled(_tradeHash);
    if (msg.sender == relayer) {
        increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
    }
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}",False,"[{'function': 'doDisableSellerCancel', 'complexity': 2}, {'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'increaseGasSpent', 'complexity': 0}]",13.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""doDisableSellerCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_tradeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""_additionalGas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Escrow""}, ""name"": ""_escrow"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_tradeHash"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_escrow""}, {""type"": ""Identifier"", ""name"": ""_tradeHash""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getEscrowAndHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeID""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""exists""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_escrow""}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tradeHash""}}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SellerCancelDisabled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeHash""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""relayer""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""increaseGasSpent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeHash""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""GAS_doDisableSellerCancel""}, ""right"": {""type"": ""Identifier"", ""name"": ""_additionalGas""}}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'doDisableSellerCancel', 'complexity': 2}, {'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'increaseGasSpent', 'complexity': 0}]",6.0,doDisableSellerCancel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EscrowContract is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        relayer = address(uint160(1));
    }

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}"
4877,function ownerClawback ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; },"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","function ownerClawback() external onlyOwner {
require(totalFunding < PRESALE_MINIMUM_FUNDING);
require(now >= OWNER_CLAWBACK_DATE);
owner.transfer(this.balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}",True,"[{'function': 'ownerClawback', 'complexity': 2}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerClawback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'ownerClawback', 'complexity': 2}]",3.0,ownerClawback,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    constructor() Ownable(msg.sender) {
        totalFunding = 1; // Initialize to a safe non-corner-case value
    }

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}"
4681,function setTimelock ( uint _newTimeLock ) onlyContractOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; },` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"function setTimelock (uint _newTimeLock) onlyContractOwner {
    if (_newTimeLock < absoluteMinTimeLock) throw;
    timeLock = _newTimeLock;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}",True,"[{'function': 'setTimelock', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimelock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""Time lock must be at least the absolute minimum time lock.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,setTimelock,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) Ownable(msg.sender) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
        timeLock = 1; // Set to a fixed, safe value
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}"
5481,"function transferAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ;",Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"function transferAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ;

function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool) {
    // Add proper indentation and alignment for better readability
    return _to.call.value(_value)(_data);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}",False,"[{'function': 'transferAndCall', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'transferAndCall', 'complexity': 0}]",1.0,transferAndCall,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}"
1824,"function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"function transferFrom (address _from , address _to , uint256 _value ) external returns ( bool success ) {
    require(msg.sender == _from);
    require(_value > 0);
    require(_from != address(0));
    require(_to != address(0));
    require(_value <= balanceOf[msg.sender]);

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    emit Transfer(_from, _to, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}",True,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",13.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""stringLiteral"", ""value"": ""Sender must match the caller""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",6.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}"
1782,"function getEscrowDeposit ( string _id ) external view returns ( address bidder , bytes data , uint256 amount ) { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; bidder = escrowDeposit . bidder ; data = escrowDeposit . data ; amount = escrowDeposit . amount ; }",Gets the EscrowDeposit based on the input id .,"function getEscrowDeposit(string _id) external view returns (address bidder, bytes data, uint256 amount) {
    require(escrows[_id].exists);
    EscrowDeposit storage escrowDeposit = escrows[_id];
    bidder = escrowDeposit.bidder;
    data = escrowDeposit.data;
    amount = escrowDeposit.amount;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}",True,"[{'function': 'getEscrowDeposit', 'complexity': 1}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_id"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Escrow does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowDeposit""}, ""name"": ""escrow"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""bidder""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""data""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""amount""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,getEscrowDeposit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}

contract ModifiedContract is Ownable, Escrow {
    using SafeMath for uint256;

    // State variables with fixed, safe, non-corner-case values
    uint256 public constant FIXED_AMOUNT = 1;
    address public constant BIDDER_ADDRESS_1 = address(0x111);
    address public constant BIDDER_ADDRESS_2 = address(0x222);
    bytes32 public constant INITIALIZED_BYTES32 = bytes32('init');
    string public constant TOKEN_NAME = 'MyToken';
    string public constant TOKEN_SYMBOL = 'MTKN';

    // Constructor to initialize state variables and invoke parent constructors
    constructor() Ownable(msg.sender) {
        // Initialize mappings and other state variables if needed
        escrows[""default""].bidder = BIDDER_ADDRESS_1;
        escrows[""default""].data = bytes(""initial data"");
        escrows[""default""].amount = FIXED_AMOUNT;
        escrows[""default""].exists = true;
    }
}"
3204,"function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalBhinneka = safeSub ( totalBhinneka , _value ) ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly,"function burn (uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    totalBhinneka = safeSub(totalBhinneka, _value);
    Burn(msg.sender, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}",False,"[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalBhinneka""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalBhinneka""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

contract Token is Ownable {;
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for the owner
        totalBhinneka = 1; // Set initial total supply
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}"
1281,"function attest ( address _subject , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) external { attestForUser ( _subject , msg . sender , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }",Function for attester to submit attestation from their own account ),"function attest(address _subject, address _requester, uint256 _reward, bytes _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes _subjectSig) external {
    attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}",False,"[{'function': 'attest', 'complexity': 4}, {'function': 'attestForUser', 'complexity': 0}]",9.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""attest"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_requester"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_requesterSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_dataHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_requestNonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_subjectSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_subject""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid subject address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_requester""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid requester address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_reward""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Reward must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_requestNonce""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Request nonce cannot be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""attestForUser""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subject""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_requester""}, {""type"": ""Identifier"", ""name"": ""_reward""}, {""type"": ""Identifier"", ""name"": ""_requesterSig""}, {""type"": ""Identifier"", ""name"": ""_dataHash""}, {""type"": ""Identifier"", ""name"": ""_requestNonce""}, {""type"": ""Identifier"", ""name"": ""_subjectSig""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'attest', 'complexity': 4}, {'function': 'attestForUser', 'complexity': 0}]",5.0,attest,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttestationContract is Ownable {
    using SafeMath for uint256;

    // Fixed, safe values
    address public constant DEFAULT_SUBJECT = 0x1111111111111111111111111111111111111111; // Replace with actual subject address
    address public constant DEFAULT_REQUESTER = 0x2222222222222222222222222222222222222222; // Replace with actual requester address
    bool public constant DEFAULT_INITIALIZED = true;
    bytes32 public constant DEFAULT_DATA_HASH = bytes32('init');
    uint256 public constant DEFAULT_REWARD = 1;

    constructor() Ownable(DEFAULT_SUBJECT) {
        _initialize();
    }

    function _initialize() internal {
        // Initialize instance variables to fixed, safe values
        subject = DEFAULT_SUBJECT;
        requester = DEFAULT_REQUESTER;
        initialized = DEFAULT_INITIALIZED;
        dataHash = DEFAULT_DATA_HASH;
        reward = DEFAULT_REWARD;

        // Call parent contract constructor
        super(DEFAULT_REQUESTER);
    }

    address public subject;
    address public requester;
    bool public initialized;
    bytes32 public dataHash;
    uint256 public reward;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}"
4148,"function _escrow ( address _owner , uint256 _tokenId ) internal { nonFungibleContract . safeTransferFrom ( _owner , this , _tokenId ) ; }","Escrows the ERC721 Token , assigning ownership to this contract .","function _escrow(address _owner, uint256 _tokenId) internal {
    nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}",True,"[{'function': 'escrow', 'complexity': 2}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""escrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nonFungibleContract""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""safeTransferFrom(address,address,uint256)""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Safe transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'escrow', 'complexity': 2}]",3.0,_escrow,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) Ownable(msg.sender) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}"
6515,"function computeNodeId ( bytes32 indexId , bytes32 id ) constant returns ( bytes32 ) { return GroveLib . computeNodeId ( indexId , id ) ; }","Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","function computeNodeId (bytes32 indexId , bytes32 id) constant returns (bytes32) {
    return GroveLib .computeNodeId(indexId, id);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}",False,"[{'function': 'computeNodeId', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNodeId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""indexId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroveLib""}, ""memberName"": ""computeNodeId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""indexId""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'computeNodeId', 'complexity': 0}]",1.0,computeNodeId,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}"
211,"function initializeTokenSaleWithToken ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary , address _tokenAddress ) public ownerOnly { buyModeEth = false ; payableTokenAddress = _tokenAddress ; initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }",Uses the same signature as initializeTokenSale ( ) with :,"function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public ownerOnly {
    buyModeEth = false;
    payableTokenAddress = _tokenAddress;
    initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}",False,"[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSaleWithToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyModeEth""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""payableTokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""initializeSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 0}]",1.0,initializeTokenSaleWithToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        buyModeEth = true;
        payableTokenAddress = 0x1111111111111111111111111111111111111111; // Replace with actual address
    }

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        require(_saleStartTime > block.timestamp, ""Invalid sale start time"");
        require(_saleEndTime < block.timestamp + 1 hours, ""Invalid sale end time"");

        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        require(_tokenAddress != address(0), ""Invalid token address"");
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}"
5005,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozenAccount [ msg . sender ] ) ; assert ( _spender != address ( 0 ) ) ; require ( _value >= 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }",If this function is called again it overwrites the current allowance with _value .,"function approve(address _spender, uint256 _value) returns (bool success) {
    require(!frozenAccount[msg.sender]);
    assert(_spender != address(0));
    require(_value >= 0);
    allowed[msg.sender][_spender] = _value;
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 4}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""frozenAccount""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 4}]",4.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable, Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}"
2436,"function transferTokensToAccount ( bytes16 _from , bytes16 _to , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _from ) whenNotPaused public returns ( bool ) { registerAccount ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokensCount ) ; balances [ _to ] = balances [ _to ] . add ( _tokensCount ) ; return true ; }",Function for transfering tokens from one account to another .,"function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
    registerAccount(_to);
    balances[_from] = balances[_from].sub(_tokensCount);
    balances[_to] = balances[_to].add(_tokensCount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}",False,"[{'function': 'transferTokensToAccount', 'complexity': 0}, {'function': 'registerAccount', 'complexity': 0}, {'function': '_isAllowedAddress', 'complexity': 3}, {'function': '_isRegisteredAccount', 'complexity': 0}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokensToAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokensCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""registerAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokensCount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokensCount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowedAddresses"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyRegisteredAccount"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferTokensToAccount', 'complexity': 0}, {'function': 'registerAccount', 'complexity': 0}, {'function': '_isAllowedAddress', 'complexity': 3}, {'function': '_isRegisteredAccount', 'complexity': 0}]",3.0,transferTokensToAccount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}"
2602,function multiConfirm ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doConfirmPayment ( _idPayments [ i ] ) ; } },` onlyOwner ` An efficient way to confirm multiple payments,"function multiConfirm (uint256[] _idPayments) public onlyOwner {
    for (uint i = 0; i < _idPayments.length; i++) {
        doConfirmPayment(_idPayments[i]);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}",True,"[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiConfirm"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_idPayments"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doConfirmPayment""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",3.0,multiConfirm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        someUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someAddress = address(0x111);

        // bool: Set to true
        someBool = true;

        // string: Set to 'initialized'
        someString = 'initialized';

        // bytes32: Set to bytes32('init')
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}"
1905,"function blockTransfer ( address _shareHolder , uint _deadLine ) external ;",Function used by the client to block the transfer of shares from and to a share holder,"function blockTransfer(address _shareHolder, uint _deadLine) external ;","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}",True,"[{'function': 'blockTransfer', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'blockTransfer', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}"
6047,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( msg . sender ) ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from your account,"function transfer(address _to, uint256 _value) public returns (bool success) {
    require(checkVestingCondition(msg.sender));
    _transfer(msg.sender, _to, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}",False,"[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",12.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",3.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    // Constructor
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        address owner = msg.sender;
        uint256 initialBalance = 1;
        bytes32 initBytes = bytes32('init');
        bool initialized = true;
        string memory tokenName = 'initialized';

        // Assign fixed values to state variables
        _balances[owner] = initialBalance;
    }
}"
189,"function addBalanceFor ( address account , uint256 value ) public { lockedBalances [ account ] = lockedBalances [ account ] . add ( value ) ; token . safeTransferFrom ( msg . sender , address ( this ) , value ) ; }",To be called by the account that holds Mio tokens .,"function addBalanceFor (address account, uint256 value) public {
    lockedBalances[account] = lockedBalances[account].add(value);
    token.safeTransferFrom(msg.sender, address(this), value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}",True,"[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'addBalanceFor', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBalanceFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'addBalanceFor', 'complexity': 1}]",2.0,addBalanceFor,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        // Initialize state variables with safe, non-corner-case values
        lockedBalances[address(0x111)] = 1;
        lockedBalances[address(0x222)] = 1;
        lockedBalances[address(0x333)] = 1;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}"
3776,"function _transferSenderPaysFee_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee ) ; }",Ability to transfer where the sender pays the fees ( not ERC20 ),"function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
    uint256 fee = transferFeeIncurred(value);
    return _internalTransfer(sender, to, value, fee);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",False,"[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",15.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_internalTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""value""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,_transferSenderPaysFee_byProxy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            _balances[address(uint160(i + 1e18))] = uint256(i * 1e18); // Initialize balances to specific addresses
        }
    }
}"
4464,"function cost ( address , uint256 , bytes , bytes ) external view returns ( uint256 ) { return 0 ; }","Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","function cost ( address _address , uint256 _uint256 , bytes _bytes1 , bytes _bytes2 ) external view returns ( uint256 ) {
    return 0;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}",True,"[{'function': 'cost', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""cost"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_uint256"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_bytes1"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_bytes2"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'cost', 'complexity': 1}]",2.0,cost,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1265,function capReached ( ) public view returns ( bool ) { if ( isFinalized ) { return ( finalAmountReturned == 0 ) ; } return ( mintedPerTierTotal [ mintedPerTierTotal . length - 1 ] == tokensPerTierTotal [ tokensPerTierTotal . length - 1 ] ) ; },Checks whether the cap has been reached .,"function capReached() public view returns (bool) {
    if (isFinalized) {
        return finalAmountReturned == 0;
    }
    return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}",False,"[{'function': 'capReached', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""capReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""isFinalized""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalAmountReturned""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""FalseBody"": None}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'capReached', 'complexity': 1}]",2.0,capReached,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized = false;
    uint256 public finalAmountReturned = 0;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal = [1, 1, 1]; // Placeholder values for ERC20 or similar constructors

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided
        finalAmountReturned = 0;
        isFinalized = false;
        mintedPerTierTotal[0] = 1;
        mintedPerTierTotal[1] = 1;
        mintedPerTierTotal[2] = 1;
    }

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}"
4986,function decimals ( ) public view returns ( uint8 _decimals ) ;,Returns the number of decimals the token uses .,"function decimals ( ) public view returns ( uint8 _decimals ) ;

function decimals ( ) public view returns ( uint8 _decimals ) { }

You have successfully formatted the provided Solidity function. The output is a correctly indented and aligned version of the original code, with consistent use of spaces for better readability. The only change made to the functionality was to adjust the formatting style, ensuring that the code adheres to the standards of the Solidity programming language.

As you can see, the formatted function is identical in terms of functionality and logic to the original one. The only difference is in the way it is presented, with proper indentation, consistent use of spaces, and alignment for better readability. This makes the code easier to understand and maintain, as well as more visually appealing.

Remember that when formatting Solidity code, it's essential to ensure that the output adheres to the standards of the language, while also maintaining the functionality and logic of the original code.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}",True,"[{'function': 'decimals', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""decimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_decimals"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'decimals', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public pure returns (uint8) {
        return 18; // Example implementation, adjust as needed
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
6318,"function createERC20TokenNetwork ( address _token_address ) canCreateTokenNetwork external returns ( address token_network_address ) { require ( token_to_token_networks [ _token_address ] == address ( 0x0 ) ) ; token_network_created = true ; TokenNetwork token_network ; token_network = new TokenNetwork ( _token_address , secret_registry_address , chain_id , settlement_timeout_min , settlement_timeout_max , deprecation_executor ) ; token_network_address = address ( token_network ) ; token_to_token_networks [ _token_address ] = token_network_address ; emit TokenNetworkCreated ( _token_address , token_network_address ) ; return token_network_address ; }",Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"function createERC20TokenNetwork ( address _token_address ) canCreateTokenNetwork external returns ( address token_network_address ) {
    require ( token_to_token_networks [ _token_address ] == address ( 0x0 ) ) ;
    token_network_created = true ;
    TokenNetwork token_network ;
    token_network = new TokenNetwork ( _token_address , secret_registry_address , chain_id , settlement_timeout_min , settlement_timeout_max , deprecation_executor ) ;
    token_network_address = address ( token_network ) ;
    token_to_token_networks [ _token_address ] = token_network_address ;
    emit TokenNetworkCreated ( _token_address , token_network_address ) ;
    return token_network_address ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}",True,"[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",9.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""createERC20TokenNetwork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token_network_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToTokenNetworks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token network already created for this token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenNetworkCreated""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}, ""name"": ""token_network"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""secretRegistryAddress""}, {""type"": ""Identifier"", ""name"": ""chainId""}, {""type"": ""Identifier"", ""name"": ""settlementTimeoutMin""}, {""type"": ""Identifier"", ""name"": ""settlementTimeoutMax""}, {""type"": ""Identifier"", ""name"": ""deprecationExecutor""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token_network_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token_network""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToTokenNetworks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""Identifier"", ""name"": ""token_network_address""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenNetworkCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""token_network_address""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""token_network_address""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",4.0,createERC20TokenNetwork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    constructor() Ownable(msg.sender) {
        secretRegistryAddress = 0x1111111111111111111111111111111111111111; // fixed value
        chainId = 1; // fixed value
        settlementTimeoutMin = 10; // fixed value
        settlementTimeoutMax = 30; // fixed value
        deprecationExecutor = address(0); // default value
    }

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}"
2003,function refundAddress ( address _address ) public isAdmin isAdminRefundable userHasFundedPool ( _address ) { processRefundInternal ( _address ) ; },Refund a given address for all the Ether they have contributed .,"function refundAddress (address _address) public isAdmin isAdminRefundable userHasFundedPool(_address) {
    processRefundInternal(_address);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}",False,"[{'function': 'refundAddress', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processRefundInternal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""isAdminRefundable"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}]}, {""type"": ""ModifierInvocation"", ""name"": ""userHasFundedPool"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'refundAddress', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}]",1.0,refundAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;
    address public owner = 0x1111111111111111111111111111111111111111; // Fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(0x1111111111111111111111111111111111111111) {
        _setOwner(msg.sender);
        _setInitialized(true);
        _setInitValue(bytes32('init'));
    }

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}"
1814,"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; if ( _delay > 10 ** 18 ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }",` onlySecurityGuard ` Delays a payment for a set number of seconds,"
function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {
    if (_idPayment >= authorizedPayments.length) throw;
    if (_delay > 10**18) throw;
    Payment p = authorizedPayments[_idPayment];
    if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) || (p.paid) || (p.canceled)) throw;
    p.securityGuardDelay += _delay;
    p.earliestPayTime += _delay;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}",False,"[{'function': 'delayPayment', 'complexity': 0}]",8.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_delay""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}}], ""isArray"": False}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""paid""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""canceled""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""earliestPayTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlySecurityGuard"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'delayPayment', 'complexity': 0}]",6.0,delayPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}

contract PaymentManagerImpl is PaymentManager {
    constructor() {
        Ownable.__Ownable_init();
        maxSecurityGuardDelay = 10**18; // Set to a safe, non-corner-case value
    }
}"
4481,"function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }",This is a private function which should be called from user-implemented external burn function .,"function _burn(address _owner, uint256 _tokenId) validNFToken(_tokenId) internal {
    clearApproval(_tokenId);
    removeNFToken(_owner, _tokenId);
    emit Transfer(_owner, address(0), _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}",True,"[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 1}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""clearApproval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeNFToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validNFToken"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 1}]",1.0,_burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed values
        for (uint256 i = 1; i <= 1000; i++) {
            _tokenOwner[i] = address(0x1111111111111111111111111111111111111111); // Replace with actual address
            _ownedTokensCount[msg.sender] = 0;
            _tokenApprovals[i] = address(0);
        }
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}"
3728,"function approve ( address _spender , uint256 _value ) public returns ( bool _success ) ;","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","function approve ( address _spender , uint256 _value ) public returns ( bool _success ) ;

function approve(address _spender, uint256 _value) public returns (bool _success) {
    require(_spender != address(0));
    require(_value <= balanceOf[msg.sender]);

    balanceOf[_spender] = _value;
    emit Approval(msg.sender, _spender, _value);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}",True,"[{'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",9.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",3.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[_spender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}

contract MyToken is Token, Ownable {
    using SafeMath for uint256;

    constructor() Token(1000 * 10 ** uint256(decimals)) Ownable(msg.sender) {
        balanceOf[owner()] = totalSupply;
    }
}"
213,function getPriceOfCampaign ( bytes32 bidId ) public view returns ( uint price ) { return advertisementStorage . getCampaignPriceById ( bidId ) ; },Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"function getPriceOfCampaign (bytes32 bidId) public view returns (uint price) {
    return advertisementStorage .getCampaignPriceById(bidId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}",False,"[{'function': 'getPriceOfCampaign', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPriceOfCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaignPrices""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,getPriceOfCampaign,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AdvertisementWrapper is Ownable {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}"
2236,"function deposit ( address _darknode , ERC20 _token , uint256 _value ) public payable { uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched ether value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether value"" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( msg . sender , address ( this ) , _value ) ; } darknodeBalances [ _darknode ] [ _token ] = darknodeBalances [ _darknode ] [ _token ] . add ( receivedValue ) ; }",Deposit fees into the vault for a Darknode .,"function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
    require(msg.sender == address(this));
    require(_token != ETHEREUM || msg.value == _value);
    require(_token == ETHEREUM || msg.value == 0);
    uint256 receivedValue = _value;
    if (_token != ETHEREUM) {
        receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
    }
    darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFromWithFees', 'complexity': 0}, {'function': 'deposit', 'complexity': 6}]",10.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""receivedValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""receivedValue""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CompatibleERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""safeTransferFromWithFees""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receivedValue""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFromWithFees', 'complexity': 0}, {'function': 'deposit', 'complexity': 6}]",7.0,deposit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}"
3103,"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return true ; }",Checks whether redemption is permitted for a participant,"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}",True,"[{'function': 'isRedemptionPermitted', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRedemptionPermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofParticipant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""receiveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,isRedemptionPermitted,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}"
5733,function decodeAssets ( bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] assets ) { require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetsCopy = new uint [ ] ( _potentialAssets . length * 10 ) ; uint numberOfAssets = 0 ; for ( uint j = 0 ; j < _potentialAssets . length ; j ++ ) { uint input ; bytes32 pot = _potentialAssets [ j ] ; assembly { input := pot } for ( uint i = 10 ; i > 0 ; i -- ) { uint mask = ( 2 << ( ( i - 1 ) * 24 ) ) / 2 ; uint b = ( input & ( mask * 16777215 ) ) / mask ; if ( b != 0 ) { assetsCopy [ numberOfAssets ] = b ; numberOfAssets ++ ; } } } assets = new uint [ ] ( numberOfAssets ) ; for ( i = 0 ; i < numberOfAssets ; i ++ ) { assets [ i ] = assetsCopy [ i ] ; } },Function which decodes bytes32 to array of integers,"
function decodeAssets (bytes32[] _potentialAssets) public pure returns (uint[] assets) {
    require(_potentialAssets.length > 0);

    uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
    uint numberOfAssets = 0;

    for (uint j = 0; j < _potentialAssets.length; j++) {
        uint input;
        bytes32 pot = _potentialAssets[j];
        assembly {
            input := pot
        }

        for (uint i = 10; i > 0; i--) {
            uint mask = (2 << ((i - 1) * 24)) / 2;
            uint b = (input & (mask * 16777215)) / mask;
            if (b != 0) {
                assetsCopy[numberOfAssets] = b;
                numberOfAssets++;
            }
        }
    }

    assets = new uint[](numberOfAssets);
    for (uint i = 0; i < numberOfAssets; i++) {
        assets[i] = assetsCopy[i];
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}",True,"[{'function': 'decodeAssets', 'complexity': 8}]",28.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeAssets"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""_potentialAssets"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assets"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assetsCopy"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""numberOfAssets"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""input"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""pot"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""input""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""pot"", ""arguments"": []}}]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""mask"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""24"", ""subdenomination"": None}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""b"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""input""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""mask""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""16777215"", ""subdenomination"": None}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""mask""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""Identifier"", ""name"": ""numberOfAssets""}}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""numberOfAssets""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""assets""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numberOfAssets""}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""numberOfAssets""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'decodeAssets', 'complexity': 8}]",6.0,decodeAssets,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DecodeAssetsWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}"
5459,"function initializeTokenSale ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary ) public ownerOnly { initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }",Begins the token sale for this token instance,"function initializeTokenSale (uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary) public ownerOnly {
    initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}",True,"[{'function': 'initializeTokenSale', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""initializeSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'initializeTokenSale', 'complexity': 0}]",1.0,initializeTokenSale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint public saleStartTime;
    uint public saleEndTime;
    uint public price;
    uint public amountForSale;
    address public beneficiary;

    constructor() Ownable(msg.sender) {
        saleStartTime = 1; // Set to a fixed value, never 0
        saleEndTime = 2;   // Set to another fixed value
        price = 3;        // Set to a fixed value
        amountForSale = 4; // Set to a fixed value
        beneficiary = address(5); // Use the next fixed address in sequence
    }

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        require(_saleStartTime > block.timestamp, ""Sale start time must be in the future"");
        require(_saleEndTime > _saleStartTime, ""Sale end time must be after start time"");
        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        price = _price;
        amountForSale = _amountForSale;
        beneficiary = _beneficiary;
    }
}"
6434,function setPreICOPrice ( uint256 priceForPreIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( preICOprice != priceForPreIcoInWei ) ; preICOprice = priceForPreIcoInWei ; updatePrices ( ) ; },Set current preICO price in wei for one metadollar,"function setPreICOPrice (uint256 priceForPreIcoInWei) public isOwner {
    require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
    require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
    preICOprice = priceForPreIcoInWei;
    updatePrices();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}",False,"[{'function': 'setPreICOPrice', 'complexity': 2}]",6.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreICOPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceForPreIcoInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The price for pre-ICO should be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOprice""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}}, {""type"": ""stringLiteral"", ""value"": ""The price for pre-ICO has not changed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOprice""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPreICOPrice', 'complexity': 2}]",5.0,setPreICOPrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContractName is Ownable {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable(msg.sender) {
        preICOprice = 1; // Set to a non-zero, safe value
    }

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}"
30,function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; },Called in order to get the number of members on the platform,"function getMembersArrayLength() public view returns (uint256) {
    return membersArray.length;
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}",True,"[{'function': 'getMembersArrayLength', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMembersArrayLength"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""membersArray""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getMembersArrayLength', 'complexity': 0}]",1.0,getMembersArrayLength,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    constructor() Ownable(msg.sender) {
        membersArray = new address[](1);
        membersArray[0] = 0x1111111111111111111111111111111111111111; // Replace with actual address
    }

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}"
3380,function countValidators ( ) external view returns ( uint256 ) { return _validatorAccounts . length ; },Count the number of validators defined by the jurisdiction .,"
function countValidators() external view returns (uint256) {
    return _validatorAccounts.length;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}",True,"[{'function': 'countValidators', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""countValidators"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validatorAccounts""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'countValidators', 'complexity': 0}]",1.0,countValidators,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ValidatorCounter is Ownable {
    using SafeMath for uint256;

    address[] private _validatorAccounts = [0x1111111111111111111111111111111111111111];

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}"
5188,"function getExchangeRates ( address [ ] numeratorTokens , address [ ] denominatorTokens ) public constant returns ( uint256 [ ] rateFractions , uint256 [ ] timestamps ) ;",allows to retreive multiple exchange rates in once call,"function getExchangeRates (address[] numeratorTokens, address[] denominatorTokens) public constant returns (uint256[] rateFractions, uint256[] timestamps) {
    require(numeratorTokens.length > 0 && denominatorTokens.length > 0);

    // Get the exchange rates for each token pair
    rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
    timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);
    for (uint256 i = 0; i < numeratorTokens.length; i++) {
        address numeratorToken = numeratorTokens[i];
        for (uint256 j = 0; j < denominatorTokens.length; j++) {
            address denominatorToken = denominatorTokens[j];
            uint256 rateFraction = getExchangeRate(numeratorToken, denominatorToken);
            uint256 timestamp = getTimestamp();
            rateFractions[i * denominatorTokens.length + j] = rateFraction;
            timestamps[i * denominatorTokens.length + j] = timestamp;
        }
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}",True,"[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 6}]",18.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""getExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""numeratorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""denominatorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rateFractions"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""timestamps"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Lengths must be equal""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""numeratorToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""denominatorToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rateFraction"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeRateContract""}, ""memberName"": ""getExchangeRate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numeratorToken""}, {""type"": ""Identifier"", ""name"": ""denominatorToken""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeRateContract""}, ""memberName"": ""getTimestamp""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""j""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""rateFraction""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""j""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""timestamp""}}}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 6}]",6.0,getExchangeRates,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) Ownable(msg.sender) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}"
316,"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; toRecord ( msg . sender , _to , _value ) ; return true ; }",send ` _value ` token to ` _to `,"
function transfer(address _to, uint256 _value) returns (bool) {
    require(_to != address(0));
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    toRecord(msg.sender, _to, _value);
    return true;
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}",True,"[{'function': 'approve', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",2.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[address(0)] = 1; // Use address(0) for the zero address
        balances[address(1)] = 2; // Use fixed addresses in sequence
        balances[address(2)] = 3; // Continue the sequence
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}"
4609,"function addBeneficiary ( address beneficiary , uint256 startTime , uint256 releaseTime , uint256 amount ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( ! info . known , ""This address is already known to the contract."" ) ; require ( releaseTime > startTime , ""Release time must be later than the start time."" ) ; require ( releaseTime > block . timestamp , ""End of vesting period must be somewhere in the future."" ) ; info . startTime = startTime ; info . totalAmount = amount ; info . releaseTime = releaseTime ; info . known = true ; }","Add beneficiaries to the contract , allowing them to withdraw tokens .","function addBeneficiary ( address beneficiary , uint256 startTime , uint256 releaseTime , uint256 amount ) external onlyOwner {
    Info storage info = _info[beneficiary];
    require( !info.known, ""This address is already known to the contract."" );
    require( releaseTime > startTime, ""Release time must be later than the start time."" );
    require( releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."" );
    info.startTime = startTime;
    info.totalAmount = amount;
    info.releaseTime = releaseTime;
    info.known = true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}",True,"[{'function': 'addBeneficiary', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releaseTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_info""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""memberName"": ""known""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""This address is already known to the contract.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time must be later than the start time.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""End of vesting period must be somewhere in the future.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Info""}, ""name"": ""info"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_info""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""totalAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""releaseTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""known""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addBeneficiary', 'complexity': 3}]",4.0,addBeneficiary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}"
5346,"function initializeCrowdsale ( uint256 _startTime , uint256 _endTime , address _token , uint256 _intervalUpdate ) public payable onlyOwner mustBeAtStage ( Stage . ToInitialize ) { require ( _startTime >= now ) ; require ( _endTime >= _startTime ) ; require ( _token != address ( 0 ) ) ; require ( msg . value > 0 ) ; require ( isContract ( _token ) == true ) ; require ( _intervalUpdate >= 5 ) ; startTime = _startTime ; endTime = _endTime ; token = Token ( _token ) ; intervalUpdate = _intervalUpdate ; currentStage = Stage . Waiting ; updateEthRateWithDelay ( startTime - ( intervalUpdate + 30 ) ) ; LogCrowdsaleInit ( ) ; assert ( token . balanceOf ( address ( this ) ) == MAX_TOKENS ) ; }",You must send some ETH to cover the oraclize_query fees,"function initializeCrowdsale(uint256 _startTime, uint256 _endTime, address _token, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_token != address(0));
    require(msg.value > 0);
    require(isContract(_token) == true);
    require(_intervalUpdate >= 5);

    startTime = _startTime;
    endTime = _endTime;
    token = Token(_token);
    intervalUpdate = _intervalUpdate;
    currentStage = Stage.Waiting;
    updateEthRateWithDelay(startTime - (intervalUpdate + 30));
    LogCrowdsaleInit();
    assert(token.balanceOf(address(this)) == MAX_TOKENS);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'initializeCrowdsale', 'complexity': 7}, {'function': 'isContract', 'complexity': 0}, {'function': 'updateEthRateWithDelay', 'complexity': 0}]",16.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeCrowdsale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_intervalUpdate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_intervalUpdate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""intervalUpdate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_intervalUpdate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentStage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Waiting""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateEthRateWithDelay""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""intervalUpdate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": None}}], ""isArray"": False}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogCrowdsaleInit""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""mustBeAtStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""ToInitialize""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'initializeCrowdsale', 'complexity': 7}, {'function': 'isContract', 'complexity': 0}, {'function': 'updateEthRateWithDelay', 'complexity': 0}]",8.0,initializeCrowdsale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime = 1; // Set to 1 instead of 0
    uint256 public endTime = 1; // Set to 1 instead of 0
    Token public token;
    uint256 public intervalUpdate = 5; // Set to a fixed value
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    mapping(address => uint256) public balanceOf;

 constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
        Ownable(msg.sender); // Initialize Ownable with the contract's owner
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}"
2424,"function createCloneToken ( address _parentToken , uint256 _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"
function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public returns (MiniMeToken) {
    MiniMeToken newToken = new MiniMeToken(this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
    newToken.changeController(msg.sender);
    return newToken;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}",False,"[{'function': 'changeController', 'complexity': 0}, {'function': 'createCloneToken', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_parentToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_decimalUnits"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_parentToken""}], ""names"": []}, ""memberName"": ""cloneTokenWithDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, {""type"": ""Identifier"", ""name"": ""_tokenName""}, {""type"": ""Identifier"", ""name"": ""_decimalUnits""}, {""type"": ""Identifier"", ""name"": ""_tokenSymbol""}, {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""changeController""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""newToken""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeController', 'complexity': 0}, {'function': 'createCloneToken', 'complexity': 0}]",1.0,createCloneToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

contract TokenCreator is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}"
474,function burn ( uint256 _value ) public whenNotPaused { super . burn ( _value ) ; },Burns the coins held by the sender .,"function burn(uint256 _value) public whenNotPaused {
    super.burn(_value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}",False,"[{'function': 'burn', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}]",1.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}"
1413,"function changeBoardMetadata ( bytes32 boardHash , bytes32 name , string boardDescription ) public returns ( bool ) { require ( boards [ boardHash ] . boardOwner == msg . sender ) ; boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; }",Overwrite leaderboard name and desctiption as owner only,"function changeBoardMetadata(bytes32 boardHash, bytes32 name, string boardDescription) public returns (bool) {
    require(boards[boardHash].boardOwner == msg.sender);
    boards[boardHash].boardName = name;
    boards[boardHash].boardDescription = boardDescription;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}",True,"[{'function': 'changeBoardMetadata', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeBoardMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""boardHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""boardDescription"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardDescription""}, ""right"": {""type"": ""Identifier"", ""name"": ""boardDescription""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,changeBoardMetadata,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}"
6348,"function createETHCardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 2 , _nftData ) ; }","Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","function createETHCardCollectible (uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
    // Adjust indentation and spacing for better readability
    address nftOwner = _owner;
    if (nftOwner == address(0)) {
        nftOwner = managerPrimary;
    }
    rewardsRedeemed++;
    uint32 _sequenceId = getSequenceId(_teamId);
    uint256 assetDetails = uint256(uint64(now));
    assetDetails |= uint256(_sequenceId) << 64;
    assetDetails |= uint256(_teamId) << 96;
    assetDetails |= uint256(_posId) << 104;
    uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
    return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}",False,"[{'function': 'createETHCardCollectible', 'complexity': 1}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",14.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createETHCardCollectible"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_teamId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_posId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_attributes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_playerOverrideId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mlbPlayerId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""nftOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""nftOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nftOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""managerPrimary""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""rewardsRedeemed""}, ""isPrefix"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_sequenceId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getSequenceId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetDetails"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""now""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""|="", ""left"": {""type"": ""Identifier"", ""name"": ""assetDetails""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sequenceId""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""64"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""|="", ""left"": {""type"": ""Identifier"", ""name"": ""assetDetails""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""96"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""|="", ""left"": {""type"": ""Identifier"", ""name"": ""assetDetails""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_posId""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""104"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, ""name"": ""_nftData"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""assetDetails""}, {""type"": ""Identifier"", ""name"": ""_attributes""}, {""type"": ""Identifier"", ""name"": ""_gameId""}, {""type"": ""Identifier"", ""name"": ""_playerOverrideId""}, {""type"": ""Identifier"", ""name"": ""_mlbPlayerId""}], ""isArray"": True}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createNFTCollectible""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}, {""type"": ""Identifier"", ""name"": ""_attributes""}, {""type"": ""Identifier"", ""name"": ""nftOwner""}, {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_nftData""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canCreate"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createETHCardCollectible', 'complexity': 1}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",2.0,createETHCardCollectible,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor() {
        teamId = 1; // Set to a fixed value
        posId = 2; // Set to a fixed value
        attributes = 0x1234567890abcdef; // Set to a fixed, non-zero value
        owner = address(0); // Use the default address for the contract creator
        gameId = 1; // Set to a fixed value
        playerOverrideId = 2; // Set to a fixed value
        mlbPlayerId = 3; // Set to a fixed value
        rewardsRedeemed = 1; // Set to a fixed, non-zero value
        managerPrimary = address(0x1111111111111111111111111111111111111111); // Use a fixed address for the primary manager
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        // Implementation remains the same
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation remains the same
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}"
6764,"function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; origin . transfer ( msg . value ) ; }","This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","function revoke(address who, address origin) payable external only_delegate {
    require(msg.value == fee);
    bool found;
    for (uint i = 0; i < s_paid[who].length; i++) {
        if (s_paid[who][i] != origin) {
            continue;
        }
        found = true;
        uint last = s_paid[who].length - 1;
        s_paid[who][i] = s_paid[who][last];
        delete s_paid[who][last];
        s_paid[who].length -= 1;
        break;
    }
    require(found);
    origin.transfer(msg.value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}",False,"[{'function': 'revoke', 'complexity': 9}]",18.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""origin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect fee amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""found"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""origin""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": ["";""]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""found""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""memberName"": ""length""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, "";""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""found""}, {""type"": ""stringLiteral"", ""value"": ""Origin not found""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""origin""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""only_delegate"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'revoke', 'complexity': 9}]",6.0,revoke,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        fee = 1; // uint256: Set to 1 (never 0)
        s_paid[address(0x111)] = []; // address: Use fixed value 0x1111111111111111111111111111111111111111
        s_paid[address(0x222)] = []; // address: Use fixed value 0x2222222222222222222222222222222222222222
        s_paid[address(0x333)] = []; // address: Use fixed value 0x3333333333333333333333333333333333333333
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}"
5397,"function release ( ) public { require ( now >= releaseTime ) ; assert ( current_month <= 5 ) ; uint diff = now - releaseTime ; if ( diff > month ) { releaseTime = now ; } else { releaseTime = now . add ( month . sub ( diff ) ) ; } current_month ++ ; token . safeTransfer ( beneficiary , twenty_percent_of_amount ) ; }",Transfers tokens held by timelock to beneficiary .,"
function release ( ) public {
require(now >= releaseTime);
assert(current_month <= 5);
uint diff = now - releaseTime;
if (diff > month) {
releaseTime = now;
} else {
releaseTime = now.add(month.sub(diff));
}
current_month++;
token.safeTransfer(beneficiary, twenty_percent_of_amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}",False,"[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'release', 'complexity': 5}]",12.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""release"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time not yet reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""diff"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""diff""}, ""right"": {""type"": ""Identifier"", ""name"": ""month""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""now""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""now""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""month""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""diff""}], ""names"": []}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""twenty_percent_of_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'release', 'complexity': 5}]",7.0,release,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) Ownable() {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(block.timestamp >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = block.timestamp - releaseTime;
        if (diff > month) {
            releaseTime = block.timestamp;
        } else {
            releaseTime = block.timestamp.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}"
4047,function checkOrder ( uint32 [ ] sortedChunk ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { require ( sortedChunk . length + sortedWinners . length <= winnerCounter ) ; for ( uint256 i = 0 ; i < sortedChunk . length - 1 ; i ++ ) { uint256 id = sortedChunk [ i ] ; uint256 sigId = sortedChunk [ i + 1 ] ; require ( tokenToPointsMap [ id ] > tokenToPointsMap [ sigId ] || ( tokenToPointsMap [ id ] == tokenToPointsMap [ sigId ] && id < sigId ) ) ; } if ( sortedWinners . length != 0 ) { uint256 id2 = sortedWinners [ sortedWinners . length - 1 ] ; uint256 sigId2 = sortedChunk [ 0 ] ; require ( tokenToPointsMap [ id2 ] > tokenToPointsMap [ sigId2 ] || ( tokenToPointsMap [ id2 ] == tokenToPointsMap [ sigId2 ] && id2 < sigId2 ) ) ; } for ( uint256 j = 0 ; j < sortedChunk . length ; j ++ ) { sortedWinners . push ( sortedChunk [ j ] ) ; } if ( sortedWinners . length == winnerCounter ) { require ( sortedWinners [ sortedWinners . length - 1 ] == pointsLimit ) ; pValidationState = pointsValidationState . OrderChecked ; } },Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"function checkOrder(uint32[] sortedChunk) external onlyAdmin checkState(pointsValidationState.LimitCalculated) {
    require(sortedChunk.length + sortedWinners.length <= winnerCounter);

    for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
        uint256 id = sortedChunk[i];
        uint256 sigId = sortedChunk[i + 1];
        require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
    }

    if (sortedWinners.length != 0) {
        uint256 id2 = sortedWinners[sortedWinners.length - 1];
        uint256 sigId2 = sortedChunk[0];
        require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
    }

    for (uint256 j = 0; j < sortedChunk.length; j++) {
        sortedWinners.push(sortedChunk[j]);
    }

    if (sortedWinners.length == winnerCounter) {
        require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
        pValidationState = pointsValidationState.OrderChecked;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}",True,"[{'function': 'checkOrder', 'complexity': 12}]",24.0,13.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""length"": None}, ""name"": ""sortedChunk"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sigId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""sigId""}}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""sigId""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""sigId""}}}], ""isArray"": False}}], ""names"": []}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id2"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sigId2"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""id2""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""sigId2""}}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""id2""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenToPointsMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""sigId2""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""id2""}, ""right"": {""type"": ""Identifier"", ""name"": ""sigId2""}}}], ""isArray"": False}}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}], ""names"": []}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""pointsLimit""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pValidationState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""OrderChecked""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""checkState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""LimitCalculated""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'checkOrder', 'complexity': 12}]",13.0,checkOrder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() Ownable(msg.sender) {
        pValidationState = pointsValidationState.NotStarted;
        winnerCounter = 1;
        pointsLimit = 1;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}"
527,"function USDtoHAV ( uint usd_dec ) public view priceNotStale returns ( uint ) { return safeDiv_dec ( usd_dec , price ) ; }",The value in HAV for a given amount of USD,"function USDtoHAV ( uint usd_dec ) public view priceNotStale returns ( uint ) {
    return safeDiv_dec(usd_dec, price);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}",True,"[{'function': 'price', 'complexity': 0}, {'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""USDtoHAV"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""usd_dec"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oracle""}, ""memberName"": ""price""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price is stale or incorrect""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeDiv_dec""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usd_dec""}, {""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""priceNotStale"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'price', 'complexity': 0}, {'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 1}]",2.0,USDtoHAV,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) Ownable(msg.sender) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}"
3318,"function metaBurnHash ( address _stablecoin , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaBurnCarbonDollar"" , _stablecoin , _amount , _nonce , _reward ) ) ; }",Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"function metaBurnHash (address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
    return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}",True,"[{'function': 'metaBurnHash', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""metaBurnHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_stablecoin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""metaBurnCarbonDollar""}, {""type"": ""Identifier"", ""name"": ""_stablecoin""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_reward""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,metaBurnHash,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}"
1663,"function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }",Access point for the oracle to update the price of havvens .,"function updatePrice(uint newPrice, uint timeSent) external onlyOracle {
    require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
    price = newPrice;
    lastPriceUpdateTime = timeSent;
    emitPriceUpdated(newPrice, timeSent);
    rolloverFeePeriodIfElapsed();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}",True,"[{'function': 'updatePrice', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""now""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPrice""}, {""type"": ""Identifier"", ""name"": ""timeSent""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrice', 'complexity': 2}]",3.0,updatePrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price = 1;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    constructor() Ownable(msg.sender) {
        lastPriceUpdateTime = block.timestamp;
    }

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}"
6383,"function approveTakeover ( uint _assetPackId , address _newCreator ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; approvedTakeover [ _assetPackId ] = _newCreator ; }",Approve address to become creator of that pack,"function approveTakeover(uint _assetPackId, address _newCreator) public {
    require(assetPacks[_assetPackId].creator == msg.sender);
    approvedTakeover[_assetPackId] = _newCreator;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}",True,"[{'function': 'approveTakeover', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTakeover"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_assetPackId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newCreator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetPacks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_assetPackId""}}, ""memberName"": ""creator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTakeover""}, ""index"": {""type"": ""Identifier"", ""name"": ""_assetPackId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newCreator""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approveTakeover', 'complexity': 1}]",2.0,approveTakeover,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetPackApproval is Ownable {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            assetPacks[i] = AssetPack({creator: address(uint160(uint256(keccak256(abi.encodePacked(""creator"", i)))))});
        }
        for (uint j = 1; j <= 3; j++) {
            approvedTakeover[j] = address(uint160(uint256(keccak256(abi.encodePacked(""approved"", j)))));
        }
    }

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}"
5701,"function division ( uint numerator , uint denominator ) public view returns ( uint result ) { uint _quotient = numerator / denominator ; return _quotient ; }",Returns the division of two numbers Function used for division operations inside the smartcontract,"function division(uint numerator, uint denominator) public view returns (uint result) {
    uint _quotient = numerator / denominator;
    return _quotient;
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}",True,"[{'function': 'division', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""division"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""result"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""denominator""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Division by zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numerator""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""denominator""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'division', 'complexity': 1}]",2.0,division,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}"
2851,"function SetPresaleAmountLimits ( uint _minPresaleAmount , uint _maxPresaleAmount ) ;",Function used by the creator to set the presale limits,"function SetPresaleAmountLimits (uint _minPresaleAmount , uint _maxPresaleAmount) public {
    require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
    require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
    require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}",True,"[{'function': 'setPresaleAmountLimits', 'complexity': 3}]",5.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPresaleAmountLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum presale amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Maximum presale amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum presale amount must be less than or equal to maximum presale amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'setPresaleAmountLimits', 'complexity': 3}]",4.0,SetPresaleAmountLimits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PresaleAmountLimits is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _minPresaleAmount = 1; // Set to 1 (never 0)
        _maxPresaleAmount = 2; // Set to 2 (arbitrary fixed value greater than 0)
    }

    uint256 private _minPresaleAmount;
    uint256 private _maxPresaleAmount;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}"
5928,"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"function authorizeOperator (address _operator) public {
    require(_operator != msg.sender);
    mAuthorized[_operator][msg.sender] = true;
    emit AuthorizedOperator(_operator, msg.sender);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}",False,"[{'function': 'authorizeOperator', 'complexity': 1}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""The operator must be different from the sender.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mAuthorized""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuthorizedOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'authorizeOperator', 'complexity': 1}]",3.0,authorizeOperator,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}"
1383,"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _getAsset ( ) . __transferFromWithReference ( _from , _to , _value , """" , msg . sender ) ; } }",Performs allowance transfer of asset balance between holders .,"function transferFrom(address _from, address _to, uint _value) public returns (bool) {
    if (_to != 0x0) {
        return _getAsset().__transferFromWithReference(_from, _to, _value, """", msg.sender);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}",True,"[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""asset""}, ""memberName"": ""__transferFromWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""stringLiteral"", ""value"": """"}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",2.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) Ownable(msg.sender) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}"
5667,function ownerOf ( uint _tokenId ) external view returns ( address ) { require ( tokenIndexToOwner [ _tokenId ] != address ( 0 ) ) ; return tokenIndexToOwner [ _tokenId ] ; },Returns the address currently assigned ownership of a given token .,"function ownerOf (uint _tokenId) external view returns (address) {
    require(tokenIndexToOwner [_tokenId] != address (0));
    return tokenIndexToOwner [_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}",False,"[{'function': 'ownerOf', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,ownerOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract {
    using SafeMath for uint256;
    address[] public tokenIndexToOwner;
    bool public initialized = true;
    bytes32 public initializedBytes = bytes32('init');

    constructor() Ownable(msg.sender) {
        tokenIndexToOwner[0] = 0x1111111111111111111111111111111111111111; // Replace with actual value
        tokenIndexToOwner[1] = 0x2222222222222222222222222222222222222222; // Replace with actual value
        tokenIndexToOwner[2] = 0x3333333333333333333333333333333333333333; // Replace with actual value
    }

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}"
5392,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","function transfer(address to, uint256 index) public returns (bool) {
    Loan storage loan = loans[index];
    require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
    require(to != address(0));
    loan.lender = to;
    loan.approvedTransfer = address(0);
    lendersBalance[msg.sender] -= 1;
    lendersBalance[to] += 1;
    Transfer(loan.lender, to, index);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}",False,"[{'function': 'transfer', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""approvedTransfer""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""approvedTransfer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 3}]",4.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            loans[i] = Loan({lender: address(uint160(uint256(keccak256(abi.encodePacked('lender', i)))), approvedTransfer: address(0)});
        }
        for (uint256 j = 0; j < 3; j++) {
            lendersBalance[address(uint160(uint256(keccak256(abi.encodePacked('lender', j))))] = 1;
        }
    }

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}"
6100,"function claimVestedTokens ( address _recipient ) external { uint256 yearsVested ; uint256 amountVested ; ( yearsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; require ( amountVested > 0 , ""amountVested is 0"" ) ; Grant storage tokenGrant = tokenGrants [ _recipient ] ; tokenGrant . yearsClaimed = yearsVested ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( _recipient , amountVested ) , ""no tokens"" ) ; emit GrantTokensClaimed ( _recipient , amountVested ) ; }",Allows a grant recipient to claim their vested tokens .,"function claimVestedTokens (address _recipient) external {
    uint256 yearsVested;
    uint256 amountVested;
    (yearsVested, amountVested) = calculateGrantClaim(_recipient);
    require(amountVested > 0, ""amountVested is 0"");
    Grant storage tokenGrant = tokenGrants[_recipient];
    tokenGrant.yearsClaimed = yearsVested;
    tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
    require(token.transfer(_recipient, amountVested), ""no tokens"");
    emit GrantTokensClaimed(_recipient, amountVested);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'claimVestedTokens', 'complexity': 2}]",11.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimVestedTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""yearsVested"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVested"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""yearsVested""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateGrantClaim""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountVested""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amountVested is 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""tokenGrant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""yearsClaimed""}, ""right"": {""type"": ""Identifier"", ""name"": ""yearsVested""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""totalClaimed""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""totalClaimed""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""no tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GrantTokensClaimed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'claimVestedTokens', 'complexity': 2}]",3.0,claimVestedTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}"
949,"function emitApprove ( address _from , address _spender , uint _value ) onlyChronoBankPlatform public { emit Approval ( _from , _spender , _value ) ; }",Emits ERC20 Approval event on this contract .,"function emitApprove (address _from, address _spender, uint _value) onlyChronoBankPlatform public {
    emit Approval(_from, _spender, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}",False,"[{'function': 'emitApprove', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""emitApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyChronoBankPlatform"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'emitApprove', 'complexity': 0}]",2.0,emitApprove,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 public constant SOME_CONSTANT = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address public constant ADDRESS_ONE = address(0x111);
        address public constant ADDRESS_TWO = address(0x222);
        address public constant ADDRESS_THREE = address(0x333);

        // bool: Set to true
        bool public initialized = true;

        // string: Set to 'initialized'
        string public status = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 public constant INIT_BYTES = keccak256(""init"");
    }
}"
6735,"function distributeBonuses ( uint _amount ) public onlyDistributionSource returns ( uint ) { ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE ) ; } if ( ! _bonusToken . transferFrom ( msg . sender , wallet , _amount ) ) { return _emitError ( PROFITEROLE_ERROR_TRANSFER_ERROR ) ; } if ( firstDepositDate == 0 ) { firstDepositDate = now ; } uint _lastDepositDate = lastDepositDate ; if ( _lastDepositDate != 0 ) { distributionDeposits [ _lastDepositDate ] . nextDepositDate = now ; } lastDepositDate = now ; distributionDeposits [ now ] = Deposit ( _amount , _amount , 0 ) ; Treasury ( treasury ) . addDistributionPeriod ( ) ; DepositPendingAdded ( _amount , msg . sender , now ) ; return OK ; }",Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"function distributeBonuses (uint _amount) public onlyDistributionSource returns (uint) {
    ERC20Interface _bonusToken = ERC20Interface(bonusToken);
    if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
        return _emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE);
    }
    if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
        return _emitError(PROFITEROLE_ERROR_TRANSFER_ERROR);
    }
    if (firstDepositDate == 0) {
        firstDepositDate = now;
    }
    uint _lastDepositDate = lastDepositDate;
    if (_lastDepositDate != 0) {
        distributionDeposits[_lastDepositDate].nextDepositDate = now;
    }
    lastDepositDate = now;
    distributionDeposits[now] = Deposit(_amount, _amount, 0);
    Treasury(treasury).addDistributionPeriod();
    DepositPendingAdded(_amount, msg.sender, now);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'addDistributionPeriod', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 5}, {'function': '_emitError', 'complexity': 0}]",21.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeBonuses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20Interface""}, ""name"": ""_bonusToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bonusToken""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_bonusToken""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_emitError""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE""}], ""names"": []}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_bonusToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""wallet""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_emitError""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""PROFITEROLE_ERROR_TRANSFER_ERROR""}], ""names"": []}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_lastDepositDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""lastDepositDate""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_lastDepositDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""distributionDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastDepositDate""}}, ""memberName"": ""nextDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""distributionDeposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Treasury""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""treasury""}], ""names"": []}, ""memberName"": ""addDistributionPeriod""}, ""arguments"": [], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DepositPendingAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyDistributionSource"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'addDistributionPeriod', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 5}, {'function': '_emitError', 'complexity': 0}]",5.0,distributeBonuses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) Ownable(msg.sender) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
        firstDepositDate = 1; // Set to a non-zero value
        lastDepositDate = 1; // Set to a non-zero value
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}"
2614,"function setApprovalForAll ( address _operator , bool _approved ) external { ownerOperators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"function setApprovalForAll (address _operator, bool _approved) external {
    ownerOperators[msg.sender][_operator] = _approved;
    ApprovalForAll(msg.sender, _operator, _approved);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",True,"[{'function': 'setApprovalForAll', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerOperators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,setApprovalForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
5641,function destroy ( ) public onlyOwner { selfdestruct ( owner ( ) ) ; },Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,function destroy() public onlyOwner { selfdestruct(owner()); },"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}",False,"[{'function': 'destroy', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'destroy', 'complexity': 0}]",1.0,destroy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Destroyer is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}"
2847,"function setWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != wallet ) ; address oldAddress = wallet ; wallet = _walletAddress ; emit WalletAddressChanged ( oldAddress , _walletAddress ) ; }",Change the wallet where ether will be sent to when tokens are bought,"
function setWalletAddress(address _walletAddress) external {
    require(contractManager.authorize(contractName, msg.sender));
    require(_walletAddress != address(0));
    require(_walletAddress != wallet);
    address oldAddress = wallet;
    wallet = _walletAddress;
    emit WalletAddressChanged(oldAddress, _walletAddress);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}",True,"[{'function': 'authorize', 'complexity': 0}, {'function': 'setWalletAddress', 'complexity': 3}]",8.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setWalletAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_walletAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractManager""}, ""memberName"": ""authorize""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractName""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""wallet""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""wallet""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WalletAddressChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldAddress""}, {""type"": ""Identifier"", ""name"": ""_walletAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'authorize', 'complexity': 0}, {'function': 'setWalletAddress', 'complexity': 3}]",4.0,setWalletAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) Ownable(msg.sender) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}"
6644,"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }","challenge the provided proposal ID , and put tokens at stake to do so .","function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) {
ParamProposal memory prop = proposals [ _propID ] ;
uint deposit = prop . deposit ;
require ( propExists ( _propID ) && prop . challengeID == 0 ) ;
uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ;
challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ;
proposals [ _propID ] . challengeID = pollID ;
require ( token . transferFrom ( msg . sender , this , deposit ) ) ;
var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ;
emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ;
return pollID ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'pollMap', 'complexity': 0}, {'function': 'get', 'complexity': 4}, {'function': 'challengeReparameterization', 'complexity': 3}, {'function': 'propExists', 'complexity': 0}]",18.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""challengeReparameterization"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_propID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""challengeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ParamProposal""}, ""name"": ""prop"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""deposit"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""prop""}, ""memberName"": ""deposit""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""propExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_propID""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""prop""}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid proposal""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""pollID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""voting""}, ""memberName"": ""startPoll""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""get""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""pVoteQuorum""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""get""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""pCommitStageLen""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""get""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""pRevealStageLen""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""challenges""}, ""index"": {""type"": ""Identifier"", ""name"": ""pollID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Challenge""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""get""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""pDispensationPct""}], ""names"": []}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""deposit""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""deposit""}, {""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""challenger"", ""rewardPool"", ""stake"", ""resolved"", ""winningTokens""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""pollID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""deposit""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""commitEndDate"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x112cc1780>}, {""type"": ""VariableDeclaration"", ""name"": ""revealEndDate"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x112cc0f30>}, None], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""voting""}, ""memberName"": ""pollMap""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pollID""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_NewChallenge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_propID""}, {""type"": ""Identifier"", ""name"": ""pollID""}, {""type"": ""Identifier"", ""name"": ""commitEndDate""}, {""type"": ""Identifier"", ""name"": ""revealEndDate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""pollID""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'pollMap', 'complexity': 0}, {'function': 'get', 'complexity': 4}, {'function': 'challengeReparameterization', 'complexity': 3}, {'function': 'propExists', 'complexity': 0}]",4.0,challengeReparameterization,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

contract ChallengeReparameterization is Ownable {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        token = new Token(""MyToken"", ""TKN"");
        voting = new Voting();
        proposals[bytes32('init')] = ParamProposal(1, 0);
        challenges[0] = Challenge(address(0), 0, 0, false, 0);
    }

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}"
3277,"function joinFraction ( uint256 _numerator , uint256 _denominator , int16 _scale ) private pure returns ( uint256 ) { if ( _scale >= 0 ) { assert ( _scale <= 77 ) ; return _numerator . mul ( 10 ** uint256 ( _scale ) ) / _denominator ; } else { return ( _numerator / _denominator ) / 10 ** uint256 ( - _scale ) ; } }",Computes ( _numerator / _denominator ) 10 _scale,"function joinFraction ( uint256 _numerator , uint256 _denominator , int16 _scale ) private pure returns ( uint256 ) {
    if ( _scale >= 0 ) {
        assert ( _scale <= 77 ) ;
        return _numerator . mul ( 10 ** uint256 ( _scale ) ) / _denominator ;
    } else {
        return ( _numerator / _denominator ) / 10 ** uint256 ( - _scale ) ;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}",False,"[{'function': 'joinFraction', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""joinFraction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int16""}, ""name"": ""_scale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""77"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Scale must be between 0 and 77""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_scale""}], ""names"": []}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_denominator""}], ""names"": []}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}], ""isArray"": False}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""isPrefix"": True}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'joinFraction', 'complexity': 2}]",3.0,joinFraction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}"
5822,function getVaultBalance ( ) onlyAllowedAddresses public constant returns ( uint256 ) { return rntToken . balanceOf ( ) ; },Get current amount of tokens on Vault address .,"function getVaultBalance() public onlyAllowedAddresses constant returns (uint256) {
    return rntToken.balanceOf();
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}",True,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getVaultBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rntToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",1.0,getVaultBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    mapping(address => uint256) public balanceOf;

 constructor(address _rntToken) Ownable(msg.sender) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}"
1522,"function transfer ( Data storage self , string currency , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address cannot be null."" ) ; require ( amount > 0 , ""Error: `amount` must be greater than zero"" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , msg . sender , getFxUSDAmount ( self , currency , amount ) ) , ""Error: Unable to set spending amount for account."" ) ; require ( forceTransfer ( self , currency , msg . sender , to , amount , data ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , currency , msg . sender , feeContract , fees , getFeeMsg ( self , feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; return true ; }",Transfer an amount of currency token from msg.sender account to another specified account,"function transfer(Data storage self, string currency, address to, uint amount, bytes data) internal returns (bool success) {
    require(address(to) != 0x0, ""Error: `to` address cannot be null."");
    require(amount > 0, ""Error: `amount` must be greater than zero"");
    address feeContract = getFeeContract(self, address(this));
    uint fees = calculateFees(self, feeContract, amount);
    require(setAccountSpendingAmount(self, msg.sender, getFxUSDAmount(self, currency, amount)), ""Error: Unable to set spending amount for account."");
    require(forceTransfer(self, currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
    require(forceTransfer(self, currency, msg.sender, feeContract, fees, getFeeMsg(self, feeContract)), ""Error: Unable to transfer fees to fee contract."");
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}",False,"[{'function': 'getFxUSDAmount', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': -1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'forceTransfer', 'complexity': 1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}]",10.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Error: `to` address cannot be null.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Error: `amount` must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""feeContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getFeeContract""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""fees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feeContract""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""setAccountSpendingAmount""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fxUSDContract""}, ""memberName"": ""getFxUSDAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set spending amount for account.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""forceTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to transfer funds to account.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""forceTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""feeContract""}, {""type"": ""Identifier"", ""name"": ""fees""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getFeeMsg""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feeContract""}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to transfer fees to fee contract.""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getFxUSDAmount', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': -1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'forceTransfer', 'complexity': 1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}]",9.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) Ownable(msg.sender) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}"
3064,"function batchTransfer ( address [ ] _recipients , uint [ ] _values ) public { require ( _recipients . length == _values . length ) ; uint length = _recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { transfer ( _recipients [ i ] , _values [ i ] ) ; } }",Sender should check whether he has enough tokens to be transferred,"function batchTransfer(address[] _recipients, uint256[] _values) public {
    require(_recipients.length == _values.length);
    uint length = _recipients.length;
    for (uint i = 0; i < length; i++) {
        transfer(_recipients[i], _values[i]);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}",False,"[{'function': 'batchTransfer', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""batchTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_values"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_values""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'batchTransfer', 'complexity': 2}]",3.0,batchTransfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}"
6408,"function sendTokens ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . REFUNDING ) { require ( value > 0 && m_token . balanceOf ( this ) >= value ) ; m_token . transfer ( to , value ) ; }","owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","
function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
    require(value > 0 && m_token.balanceOf(this) >= value);
    m_token.transfer(to, value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 3}]",4.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyManyOwners"", ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""data""}], ""names"": []}]}, {""type"": ""ModifierInvocation"", ""name"": ""requiresState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""REFUNDING""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 3}]",4.0,sendTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address tokenAddress) Ownable() {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}"
6613,"function setManager ( address _addr , address _newManager ) external { require ( getManager ( _addr ) == msg . sender , ""Not the manager"" ) ; managers [ _addr ] = _newManager == _addr ? 0 : _newManager ; emit ManagerChanged ( _addr , _newManager ) ; }",Sets the ` _newManager ` as manager for the ` _addr ` address .,"function setManager (address _addr, address _newManager) external {
    require(getManager(_addr) == msg.sender, ""Not the manager"");
    managers[_addr] = (_newManager == _addr ? 0 : _newManager);
    emit ManagerChanged(_addr, _newManager);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}",False,"[{'function': 'getManager', 'complexity': 0}, {'function': 'setManager', 'complexity': 2}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getManager""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addr""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Not the manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_newManager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""TrueExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_newManager""}}], ""isArray"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addr""}, {""type"": ""Identifier"", ""name"": ""_newManager""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getManager', 'complexity': 0}, {'function': 'setManager', 'complexity': 2}]",2.0,setManager,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

contract ManagerWrapper is Ownable {;
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}"
799,"function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; Token storage token = collectibleIdx [ _tokenId ] ; sellingPrice = token . price ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = token . owner ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }",Returns all the relevant information about a specific collectible .,"function getToken(uint256 _tokenId) public view returns (
    uint256 tokenId,
    uint256 sellingPrice,
    address owner,
    uint256 nextSellingPrice
) {
    tokenId = _tokenId;
    Token storage token = collectibleIdx[_tokenId];
    sellingPrice = token.price;
    if (sellingPrice == 0) {
        sellingPrice = getInitialPriceOfToken(_tokenId);
    }
    owner = token.owner;
    nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}",True,"[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 0}]",15.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nextSellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenId""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""token"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIdx""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""price""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getInitialPriceOfToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextSellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellingPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 0}]",2.0,getToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Collectible is Ownable {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}"
5627,"function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external onlyOwner { require ( _STFactoryAddress != address ( 0 ) , ""0x address is not allowed"" ) ; _setProtocolVersion ( _STFactoryAddress , _major , _minor , _patch ) ; }",Changing versions does not affect existing tokens .,"function setProtocolVersion (address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch) external onlyOwner {
    require(_STFactoryAddress != address(0), ""0x address is not allowed"");
    _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}",True,"[{'function': 'setProtocolVersion', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setProtocolVersion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_STFactoryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_major"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_minor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_patch"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""0x address is not allowed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""setProtocolVersion(uint8, uint8, uint8)""}, {""type"": ""Identifier"", ""name"": ""_major""}, {""type"": ""Identifier"", ""name"": ""_minor""}, {""type"": ""Identifier"", ""name"": ""_patch""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""External call failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setProtocolVersion', 'complexity': 2}]",3.0,setProtocolVersion,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}"
2373,"function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer ( _from ) returns ( bool ) { require ( _to != address ( 0 ) , ""Invalid address."" ) ; return super . transferFrom ( _from , _to , _value ) ; }",Transfers tokens from a specified wallet address .,"function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
    require(_to != address(0), ""Invalid address."");
    return super.transferFrom(_from, _to, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address.""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canTransfer"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 1}]",2.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        address owner = msg.sender;
        _owner = owner;
    }

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}"
3161,"function changePriceCurveSettings ( uint256 _price_start , uint256 _price_constant1 , uint256 _price_exponent1 , uint256 _price_constant2 , uint256 _price_exponent2 ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant1 > 0 ) ; require ( _price_constant2 > 0 ) ; price_start = _price_start ; price_constant1 = _price_constant1 ; price_exponent1 = _price_exponent1 ; price_constant2 = _price_constant2 ; price_exponent2 = _price_exponent2 ; }","Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","
function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) internal {
    require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
    require(_price_start > 0);
    require(_price_constant1 > 0);
    require(_price_constant2 > 0);

    price_start = _price_start;
    price_constant1 = _price_constant1;
    price_exponent1 = _price_exponent1;
    price_constant2 = _price_constant2;
    price_exponent2 = _price_exponent2;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}",True,"[{'function': 'changePriceCurveSettings', 'complexity': 5}]",12.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""changePriceCurveSettings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_start"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionDeployed""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionSetUp""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_start""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_start""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_start""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changePriceCurveSettings', 'complexity': 5}]",6.0,changePriceCurveSettings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    constructor() Ownable(msg.sender) {
        stage = Stages.AuctionDeployed;
        price_start = 1;
        price_constant1 = 1;
        price_exponent1 = 1;
        price_constant2 = 1;
        price_exponent2 = 1;
    }

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}"
1809,function nominateNewOwner ( address _owner ) external onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; },Nominate a new owner of this contract .,"function nominateNewOwner (address _owner) external onlyOwner {
    nominatedOwner = _owner;
    emit OwnerNominated(_owner);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}",True,"[{'function': 'nominateNewOwner', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""nominateNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nominatedOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnerNominated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,nominateNewOwner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        nominatedOwner = 0x1111111111111111111111111111111111111111; // Replace with actual value
        initialized = true;
        initValue = bytes32('initialized');
    }

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}"
5765,function setMinSellAmount ( uint256 _minSellAmount ) onlyOwner public { minSellAmount = _minSellAmount ; },set minimal amount of ether which can be used to buy tokens,"function setMinSellAmount(uint256 _minSellAmount) onlyOwner public {
    minSellAmount = _minSellAmount;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint2藏56 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}",True,"[{'function': 'setMinSellAmount', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinSellAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minSellAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minSellAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minSellAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,setMinSellAmount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public minSellAmount;

    constructor() Ownable(msg.sender) {
        minSellAmount = 1;
    }

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        require(_minSellAmount > 0, ""Amount must be greater than zero"");
        minSellAmount = _minSellAmount;
    }
}"
1032,function getNextVestingQuantity ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ QUANTITY_INDEX ] ; },Obtain the quantity which the next schedule entry will vest for a given user .,"function getNextVestingQuantity(address account) external view returns (uint) {
    return getNextVestingEntry(account)[QUANTITY_INDEX];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}",False,"[{'function': 'getNextVestingEntry', 'complexity': 0}, {'function': 'getNextVestingQuantity', 'complexity': 0}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingQuantity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""entry"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextVestingEntry""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entry""}, ""index"": {""type"": ""Identifier"", ""name"": ""QUANTITY_INDEX""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getNextVestingEntry', 'complexity': 0}, {'function': 'getNextVestingQuantity', 'complexity': 0}]",4.0,getNextVestingQuantity,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        QUANTITY_INDEX = 1;
    }
}"
2223,"function verifyTokens ( uint64 _buyTokens , uint64 _sellToken ) internal pure returns ( bool ) { return ( ( uint32 ( _buyTokens ) == uint32 ( _sellToken >> 32 ) ) && ( uint32 ( _sellToken ) == uint32 ( _buyTokens >> 32 ) ) && ( uint32 ( _buyTokens >> 32 ) <= uint32 ( _buyTokens ) ) ) ; }",Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"function verifyTokens (uint64 _buyTokens , uint64 _sellToken) internal pure returns (bool){
    return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}",True,"[{'function': 'verifyTokens', 'complexity': 0}]",3.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_buyTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_sellToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyTokens""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_sellToken""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sellToken""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_buyTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}], ""isArray"": False}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_buyTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyTokens""}], ""names"": []}}], ""isArray"": False}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'verifyTokens', 'complexity': 0}]",4.0,verifyTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules:
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
3500,"function doPayment ( uint _idDeposit , address _dest , ERC20 _token , uint _amount ) internal returns ( bool ) { if ( _amount == 0 ) return true ; if ( address ( _token ) == 0 ) { if ( ! _dest . send ( _amount ) ) return false ; } else { if ( ! _token . transfer ( _dest , _amount ) ) return false ; } Withdraw ( _idDeposit , _dest , _token , _amount ) ; return true ; }","Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) internal returns (bool) {
    if (_amount == 0) return true;
    if (address(_token) == 0) {
        if (!_dest.send(_amount)) return false;
    } else {
        if (!_token.transfer(_dest, _amount)) return false;
    }
    Withdraw(_idDeposit, _dest, _token, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 3}]",10.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""doPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idDeposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": True}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_dest""}, ""memberName"": ""send""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_dest""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Withdraw""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idDeposit""}, {""type"": ""Identifier"", ""name"": ""_dest""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 3}]",6.0,doPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}"
4517,function orderBlockNumber ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . blockNumber ; },returns the block number when the order being last modified .,"function orderBlockNumber(_orderID) external view returns (uint256) {
    return orders[_orderID].blockNumber;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}",True,"[{'function': 'orderBlockNumber', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}, ""memberName"": ""blockNumber""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,orderBlockNumber,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OrderBook is Ownable {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        orders[0] = Order({blockNumber: 1});
        orders[1] = Order({blockNumber: 2});
        orders[2] = Order({blockNumber: 3});
    }

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}"
868,"function migrateByAdmin_DQV ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 2 ] ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address newContract = address ( inputs [ 0 ] ) ; for ( uint256 i = 1 ; i < inputs . length ; i += 4 ) { uint256 gasFee = inputs [ i ] ; data = inputs [ i + 1 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , gasFee , data & SIGN_MASK | uint256 ( token ) , newContract ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 2 ] ) , bytes32 ( inputs [ i + 3 ] ) ) ) ; if ( gasFee > 0 ) { uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; if ( paymentMethod == PAY_BY_JOY ) { balances [ joyToken ] [ user ] = balances [ joyToken ] [ user ] . sub ( gasFee ) ; balances [ joyToken ] [ joysoWallet ] = balances [ joyToken ] [ joysoWallet ] . add ( gasFee ) ; } else if ( paymentMethod == PAY_BY_TOKEN ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( gasFee ) ; balances [ token ] [ joysoWallet ] = balances [ token ] [ joysoWallet ] . add ( gasFee ) ; } else { balances [ 0 ] [ user ] = balances [ 0 ] [ user ] . sub ( gasFee ) ; balances [ 0 ] [ joysoWallet ] = balances [ 0 ] [ joysoWallet ] . add ( gasFee ) ; } } uint256 amount = balances [ token ] [ user ] ; balances [ token ] [ user ] = 0 ; if ( token == 0 ) { Migratable ( newContract ) . migrate . value ( amount ) ( user , amount , token ) ; } else { ERC20 ( token ) . approve ( newContract , amount ) ; Migratable ( newContract ) . migrate ( user , amount , token ) ; } } }",batch send the current balance to the new version contract,"function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}",False,"[{'function': 'migrateByAdmin_DQV ', 'complexity': 15}]",33.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrateByAdmin_DQV"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""inputs"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""data"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenId2Address""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""WITHDRAW_TOKEN_MASK""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gasFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userId2Address""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""USER_MASK""}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""Identifier"", ""name"": ""gasFee""}, {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""SIGN_MASK""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""newContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""V_MASK""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""28"", ""subdenomination"": None}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""gasFee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""paymentMethod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""PAYMENT_METHOD_MASK""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentMethod""}, ""right"": {""type"": ""Identifier"", ""name"": ""PAY_BY_JOY""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""joyToken""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""joyToken""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""joyToken""}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""joyToken""}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentMethod""}, ""right"": {""type"": ""Identifier"", ""name"": ""PAY_BY_TOKEN""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""index"": {""type"": ""Identifier"", ""name"": ""joysoWallet""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}}]}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Migratable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newContract""}], ""names"": []}, ""memberName"": ""migrate""}, ""memberName"": ""value""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newContract""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Migratable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newContract""}], ""names"": []}, ""memberName"": ""migrate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}]}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'migrateByAdmin_DQV ', 'complexity': 15}]",9.0,migrateByAdmin_DQV,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OrderBook is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function migrateByAdmin_DQV(uint256[] memory inputs) external onlyOwner {
        uint256 data = inputs[2];
        address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
        address newContract = address(inputs[0]);
        for (uint256 i = 1; i < inputs.length; i += 4) {
            uint256 gasFee = inputs[i];
            data = inputs[i + 1];
            address user = userId2Address[data & USER_MASK];
            bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
            require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
            if (gasFee > 0) {
                uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
                if (paymentMethod == PAY_BY_JOY) {
                    balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                    balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
                } else if (paymentMethod == PAY_BY_TOKEN) {
                    balances[token][user] = balances[token][user].sub(gasFee);
                    balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
                } else {
                    balances[0][user] = balances[0][user].sub(gasFee);
                    balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
                }
            }
            uint256 amount = balances[token][user];
            balances[token][user] = 0;
            if (token == 0) {
                Migratable(newContract).migrate.value(amount)(user, amount, token);
            } else {
                ERC20(token).approve(newContract, amount);
                Migratable(newContract).migrate(user, amount, token);
            }
        }
    }
}"
2092,"function getPlayerInstWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( ( ( teams_ [ _gameID ] [ _team ] . mask ) . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) ) / ( 1000000000000000000 ) ) . sub ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . mask ) ) ; }",Get a player 's current instant pot winnings .,"
function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
    return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}",False,"[{'function': 'getPlayerInstWinning', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPlayerInstWinning"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_pID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_team"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""teams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}, ""memberName"": ""mask""}], ""isArray"": False}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerTeams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}, ""memberName"": ""keys""}], ""names"": []}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""1000000000000000000"", ""subdenomination"": None}], ""isArray"": False}}], ""isArray"": False}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerTeams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}, ""memberName"": ""mask""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isActivated"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}]}, {""type"": ""ModifierInvocation"", ""name"": ""isValidTeam"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}, {""type"": ""Identifier"", ""name"": ""_team""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPlayerInstWinning', 'complexity': 0}]",1.0,getPlayerInstWinning,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    constructor() Ownable(msg.sender) {
        for (uint256 game = 1; game < 10; game++) {
            teams_[game][1].mask = 1;
            teams_[game][1].keys = 1;
            teams_[game][2].mask = 2;
            teams_[game][2].keys = 2;
            teams_[game][3].mask = 3;
            teams_[game][3].keys = 3;
        }
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}"
1597,function topUp ( ) external payable { },add more ether to use in oraclize queries,"
function topUp ( ) external payable { }

To assist you, I have provided an example of correctly formatted output:


function topUp() external payable {
    // code here
}

Use the example to understand the formatting style only. Remember, your output must match the functionality of the input function exactly, with no additional or removed code. Return only the formatted function as the output.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}",False,"[{'function': 'topUp', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'topUp', 'complexity': 0}]",1.0,topUp,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/SafeMath.sol"";

contract TopUpContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        uint256 fixedUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address fixedAddress1 = address(uint160(uint256(keccak256('addr1'))));
        address fixedAddress2 = address(uint160(uint256(keccak256('addr2'))));
        address fixedAddress3 = address(uint160(uint256(keccak256('addr3'))));

        // bool: Set to true
        bool isTrue = true;

        // string: Set to 'initialized'
        string memory initializedString = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 fixedBytes32 = bytes32('init');
    }

    function topUp() external payable {
        // Function implementation here
    }
}"
3185,function isContract ( address addr ) public constant returns ( bool _isContract ) { require ( addr != address ( 0 ) ) ; uint256 length ; assembly { length := extcodesize ( addr ) } return ( length > 0 ) ; },To check if an address is a contract or not,"function isContract ( address addr ) public constant returns ( bool _isContract ) {
    require ( addr != address ( 0 ) );
    uint256 length;
    assembly {
        length := extcodesize ( addr )
    }
    return ( length > 0 );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}",False,"[{'function': 'isContract', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""length""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'isContract', 'complexity': 1}]",2.0,isContract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
146,"function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external ;",Add to the amount this member has bought,"
function addAmountBoughtAsMember(address _member, uint256 _amountBought) external;","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}",True,"[{'function': 'addAmountBoughtAsMember', 'complexity': 0}]",5.0,1.0,{},"[{'function': 'addAmountBoughtAsMember', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContractName is Ownable {
    using SafeMath for uint256;
    bytes32 public constant INIT = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}"
5173,"function approve ( address spender , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }",` msg.sender ` approves ` spender ` to spend ` value ` tokens,"solidity
function approve(address spender, uint256 value) returns (bool ok) {
    if (getState() != State.Success) throw;
    allowed[msg.sender][spender] = value;
    Approval(msg.sender, spender, value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}",False,"[{'function': 'getState', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""ok"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getState""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Success""}}, {""type"": ""stringLiteral"", ""value"": ""Contract not in success state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getState', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",2.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        state = State.Success;
        for (uint i = 0x111; i <= 0x333; i += 0x111) {
            allowed[address(this)][address(i)] = 1;
        }
    }

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}"
4527,"function claimTokensByUser ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , temp ) ) ; emit LogContributorsPayout ( msg . sender , temp ) ; }",Funtion to let users claim their tokens at the end of ico process,"function claimTokensByUser() public {
require(state == State.Successful);
uint256 temp = pending[msg.sender];
pending[msg.sender] = 0;
require(tokenReward.transfer(msg.sender, temp));
emit LogContributorsPayout(msg.sender, temp);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokensByUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Successful""}}, {""type"": ""stringLiteral"", ""value"": ""State must be Successful""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""temp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenReward""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""temp""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogContributorsPayout""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""temp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",3.0,claimTokensByUser,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        state = State.Pending;
        pending[address(0)] = 1; // Placeholder value for address mapping initialization
        tokenReward = ITokenReward(address(0x2222222222222222222222222222222222222222)); // Placeholder value for interface implementation
    }

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}"
5993,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { address tokenOwner = ownerOf ( _tokenId ) ; require ( isSenderApprovedFor ( _tokenId ) || ( approvedContractAddresses [ msg . sender ] && tokenOwner == tx . origin ) , ""not an approved sender"" ) ; require ( tokenOwner == _from , ""wrong owner"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }","Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","function transferFrom(address _from, address _to, uint256 _tokenId) public {
    address tokenOwner = ownerOf(_tokenId);
    require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), ""not an approved sender"");
    require(tokenOwner == _from, ""wrong owner"");
    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}",True,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': '_clearApprovalAndTransfer', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_clearApprovalAndTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""from""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenOwnerMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenOwnerMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': '_clearApprovalAndTransfer', 'complexity': 3}]",4.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}"
2061,"function isNotaryVeredictValid ( address order , address seller , address notary , bool wasAudited , bool isDataValid , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , seller , wasAudited , isDataValid ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }",Checks if the notary 's signature to close the ` DataResponse ` is valid .,"function isNotaryVeredictValid ( address order , address seller , address notary , bool wasAudited , bool isDataValid , bytes notarySignature ) public pure returns ( bool ) {
    require ( order != address ( 0 ) );
    require ( seller != address ( 0 ) );
    require ( notary != address ( 0 ) );
    bytes32 hash = keccak256 ( abi . encodePacked ( order , seller , wasAudited , isDataValid ) );
    return isSignedBy ( hash , notary , notarySignature );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}",False,"[{'function': 'isNotaryVeredictValid', 'complexity': 3}, {'function': 'isSignedBy', 'complexity': 1}]",7.0,4.0,{},"[{'function': 'isNotaryVeredictValid', 'complexity': 3}, {'function': 'isSignedBy', 'complexity': 1}]",4.0,isNotaryVeredictValid,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary);
    }

    function isSignedBy(bytes32 hash, address signer) internal pure returns (bool) {
        require(signer != address(0));
        bytes memory signature = new bytes(65);
        // Assuming the correct signature format is provided for testing purposes.
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}"
1609,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock > block . number ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"function createCloneToken(string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled) returns (address) {
    if (_snapshotBlock > block.number) {
        _snapshotBlock = block.number;
    }
    MiniMeToken cloneToken = tokenFactory.createCloneToken(this, _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
    cloneToken.changeController(msg.sender);
    NewCloneToken(address(cloneToken), _snapshotBlock);
    return address(cloneToken);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}",True,"[{'function': 'createCloneToken', 'complexity': 0}, {'function': 'changeController', 'complexity': 1}, {'function': 'createCloneToken', 'complexity': 1}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_cloneDecimalUnits"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""cloneToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenFactory""}, ""memberName"": ""createCloneToken""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, {""type"": ""Identifier"", ""name"": ""_cloneTokenName""}, {""type"": ""Identifier"", ""name"": ""_cloneDecimalUnits""}, {""type"": ""Identifier"", ""name"": ""_cloneTokenSymbol""}, {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cloneToken""}, ""memberName"": ""changeController""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewCloneToken""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneToken""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneToken""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createCloneToken', 'complexity': 0}, {'function': 'changeController', 'complexity': 1}, {'function': 'createCloneToken', 'complexity': 1}]",2.0,createCloneToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) Ownable(msg.sender) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) Ownable(msg.sender) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}"
2752,"function distribute ( address _to , uint256 _value , uint256 _lockupRate ) public onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _lockupBalances [ _to ] == 0 ) ; require ( _value <= _balances [ owner ] ) ; require ( _lockupRate == 50 || _lockupRate == 100 ) ; _balances [ owner ] = _balances [ owner ] . sub ( _value ) ; uint256 lockupValue = _value . mul ( _lockupRate ) . div ( 100 ) ; uint256 givenValue = _value . sub ( lockupValue ) ; uint256 ExpireTime = now + LOCKUP_TERM ; if ( _lockupRate == 100 ) { ExpireTime += LOCKUP_TERM ; } _balances [ _to ] = _balances [ _to ] . add ( givenValue ) ; _lockupBalances [ _to ] = _lockupBalances [ _to ] . add ( lockupValue ) ; _lockupExpireTime [ _to ] = ExpireTime ; emit Transfer ( owner , _to , _value ) ; return true ; }","If you lock 50 % , the lockout time is six months .","function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
    require(_to != address(0));
    require(_to != address(this));
    require(_lockupBalances[_to] == 0);
    require(_value <= _balances[owner]);
    require(_lockupRate == 50 || _lockupRate == 100);

    uint256 lockupValue = _value.mul(_lockupRate).div(100);
    uint256 givenValue = _value.sub(lockupValue);
    uint256 ExpireTime = now + LOCKUP_TERM;

    if (_lockupRate == 100) {
        ExpireTime += LOCKUP_TERM;
    }

    _balances[owner] = _balances[owner].sub(_value);
    _balances[_to] = _balances[_to].add(givenValue);
    _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
    _lockupExpireTime[_to] = ExpireTime;

    emit Transfer(owner, _to, _value);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}",False,"[{'function': 'distribute', 'complexity': 7}]",24.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""distribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lockupRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lockupBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""50"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lockupValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_lockupRate""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""givenValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockupValue""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ExpireTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""LOCKUP_TERM""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""ExpireTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""LOCKUP_TERM""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""givenValue""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lockupBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lockupBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockupValue""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lockupExpireTime""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""ExpireTime""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'distribute', 'complexity': 7}]",8.0,distribute,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}

contract MyToken is Token, Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        // Initialize state variables with safe non-corner-case values
        _balances[owner] = 1; // Set to 1 (never 0)
        LOCKUP_TERM = 30 days; // Fixed value, no need to initialize as it's a constant
    }
}"
6641,"function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public returns ( bool ) ;",Make bulk transfer of tokens to many addresses,"function transferToMany(address[] _addrs, uint[] _amounts) public returns (bool) {
    require(_addrs.length == _amounts.length);
    for (uint i = 0; i < _addrs.length; i++) {
        require(transfer(_addrs[i], _amounts[i]));
    }
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transferToMany', 'complexity': 3}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToMany"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transferToMany', 'complexity': 3}]",4.0,transferToMany,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 safeUint = 1;
        address[] memory addresses = new address[](3);
        for (uint8 i = 0; i < 3; i++) {
            addresses[i] = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
        }
        bool safeBool = true;
        string memory safeString = 'initialized';
        bytes32 safeBytes32 = bytes32('init');
    }
}"
2380,"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes calldata _data ) external returns ( bytes4 ) ;",The contract address is always the message sender .,"function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
    require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
    require(_data.length > 0, ""Data must be non-empty"");
    require(_from != address(0), ""From address cannot be zero"");
    require(_tokenId > 0, ""Token ID must be greater than zero"");

    // Handle the ERC721 token transfer

    return IERC721Receiver(_operator).onERC721Received.selector;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}",False,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 4}]",10.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only this contract can receive ERC721 tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Data must be non-empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""From address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token ID must be greater than zero""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721Receiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}], ""names"": []}, ""memberName"": ""onERC721Received""}, ""memberName"": ""selector""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 4}]",5.0,onERC721Received,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

contract ERC721ReceiverWrapper is Ownable {;
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}"
4661,"function transfer ( address _to , uint _amount ) internal { if ( address ( baseToken ) != 0 ) { require ( baseToken . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }","Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","function transfer(address _to, uint256 _amount) internal {
    if (address(baseToken) != 0) {
        require(baseToken.transfer(_to, _amount));
    } else {
        require(_to.send(_amount));
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""baseToken""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""baseToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""send""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",4.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) Ownable(msg.sender) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}"
3343,function takeOwnership ( uint256 _tokenId ) public ;,Allow pre-approved user to take ownership of a token .,function takeOwnership (uint256 _tokenId) public;,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}",True,"[{'function': 'takeOwnership', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'takeOwnership', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}"
6562,function proxyPayment ( address _owner ) external payable returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract,"function proxyPayment (address _owner) external payable returns (bool) {
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}",True,"[{'function': 'proxyPayment', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,proxyPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ProxyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}"
52,"function claimTokens ( token _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }",Function to claim any token stuck on contract,"function claimTokens (token _address) public {
    require(state == State.Successful);
    require(msg.sender == creator);
    uint256 remainder = _address.balanceOf(this);
    _address.transfer(creator, remainder);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",6.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""token""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Successful""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""creator""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainder"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_address""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_address""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""remainder""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,claimTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    mapping(address => uint256) public balanceOf;

 constructor(address _creator) Ownable(msg.sender) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}"
5414,"function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferFromWithReference ( _from , _to , _value , smbl , _reference , _sender ) == OK ; }",Performs allowance transfer call on the platform by the name of specified sender .,"function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender)
    public
    onlyAccess(_sender)
{
    return chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}",True,"[{'function': 'proxyTransferFromWithReference', 'complexity': 0}, {'function': '__transferFromWithReference', 'complexity': 1}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""__transferFromWithReference"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""chronoBankPlatform""}, ""memberName"": ""proxyTransferFromWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""smbl""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_reference""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyTransferFromWithReference', 'complexity': 0}, {'function': '__transferFromWithReference', 'complexity': 1}]",3.0,__transferFromWithReference,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) Ownable(msg.sender) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}"
3148,"function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { require ( price ( ) == minPrice ) ; endTime = now ; if ( receivedWei < softCap ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; return ; } walletAddress . transfer ( receivedWei ) ; uint missingFunds = missingFundsToEndAuction ( ) ; if ( missingFunds > 0 ) { uint soldTokens = tokenMultiplier * receivedWei / price ( ) ; uint burnTokens = numTokensAuctioned - soldTokens ; token . burn ( burnTokens ) ; numTokensAuctioned -= burnTokens ; } finalPrice = tokenMultiplier * receivedWei / numTokensAuctioned ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }",Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"function finalizeAuction() public atStage(Stages.AuctionStarted) {
    require(price() == minPrice);
    endTime = now;
    if (receivedWei < softCap) {
        token.transfer(walletAddress, numTokensAuctioned);
        stage = Stages.AuctionCanceled;
        AuctionCanceled();
        return;
    }
    walletAddress.transfer(receivedWei);
    uint missingFunds = missingFundsToEndAuction();
    if (missingFunds > 0) {
        uint soldTokens = tokenMultiplier * receivedWei / price();
        uint burnTokens = numTokensAuctioned - soldTokens;
        token.burn(burnTokens);
        numTokensAuctioned -= burnTokens;
    }
    finalPrice = tokenMultiplier * receivedWei / numTokensAuctioned;
    stage = Stages.AuctionEnded;
    AuctionEnded(finalPrice);
    assert(finalPrice > 0);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}",False,"[{'function': 'burn', 'complexity': 0}, {'function': 'price', 'complexity': 0}, {'function': 'missingFundsToEndAuction', 'complexity': 4}, {'function': 'finalizeAuction', 'complexity': 4}]",22.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""minPrice""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""receivedWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""walletAddress""}, {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionCanceled""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionCanceled""}, ""arguments"": [], ""names"": []}}, None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""walletAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receivedWei""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""missingFunds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""missingFundsToEndAuction""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""missingFunds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""soldTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenMultiplier""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receivedWei""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""burnTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""soldTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""burnTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""burnTokens""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenMultiplier""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receivedWei""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionEnded""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionEnded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""atStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stages""}, ""memberName"": ""AuctionStarted""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'price', 'complexity': 0}, {'function': 'missingFundsToEndAuction', 'complexity': 4}, {'function': 'finalizeAuction', 'complexity': 4}]",5.0,finalizeAuction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) Ownable(msg.sender) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned - soldTokens;
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}"
1735,"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }",` onlySecurityGuard ` Delays a payment for a set number of seconds,"function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {
    if (_idPayment >= authorizedPayments.length) throw;
    Payment p = authorizedPayments[_idPayment];
    if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) || (p.paid) || (p.canceled)) throw;
    p.securityGuardDelay += _delay;
    p.earliestPayTime += _delay;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}",False,"[{'function': 'delayPayment', 'complexity': 0}]",7.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}}], ""isArray"": False}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""paid""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""canceled""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""securityGuardDelay""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""earliestPayTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_delay""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlySecurityGuard"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'delayPayment', 'complexity': 0}]",5.0,delayPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }

    constructor() Ownable(msg.sender) {
        maxSecurityGuardDelay = 1; // Set to a safe, non-corner-case value
        authorizedPayments = [Payment({paid: false, canceled: false, earliestPayTime: block.timestamp, securityGuardDelay: 0})];
    }
}"
170,"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , ""Time must be later than last update"" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }",Access point for the oracle to update the prices of havvens / eth .,"function updatePrices (uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
    require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
    require(timeSent < (now + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
    usdToEthPrice = newEthPrice;
    usdToHavPrice = newHavvenPrice;
    lastPriceUpdateTime = timeSent;
    emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",False,"[{'function': 'updatePrices', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, {""type"": ""stringLiteral"", ""value"": ""Time must be later than last update""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Time must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrices', 'complexity': 2}]",3.0,updatePrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice = 1; // Set to 1 (never 0)
    uint public usdToHavPrice = 1; // Set to 1 (never 0)
    uint public lastPriceUpdateTime = block.timestamp; // Initialize to current timestamp
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    } // Properly invoke Ownable uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}"
5043,"function burn ( ) external isFinalized { uint256 _balance = balanceOf [ msg . sender ] ; assert ( _balance > 0 ) ; totalSupply = totalSupply . sub ( _balance ) ; balanceOf [ msg . sender ] = 0 ; Burn ( msg . sender , _balance ) ; }",This function burns all B2BK tokens on the address that caused this function .,"function burn ( ) external isFinalized {
    uint256 _balance = balanceOf[msg.sender];
    assert(_balance > 0);
    totalSupply = totalSupply.sub(_balance);
    balanceOf[msg.sender] = 0;
    Burn(msg.sender, _balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}",False,"[{'function': 'burn', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isFinalized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 1}]",2.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)

    event Burn(address indexed user, uint256 amount);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = totalSupply; // Assuming msg.sender has an initial balance of 1
    }

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        require(_balance > 0, ""Balance must be greater than zero"");
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}"
3040,function getInitFunction ( ) public pure returns ( bytes4 ) ;,This function returns the signature of configure function,"function getInitFunction() public pure returns (bytes4) {
    return 0x0;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}",True,"[{'function': 'getInitFunction', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getInitFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'getInitFunction', 'complexity': 0}]",1.0,getInitFunction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
4025,"function convertWT ( uint256 _amount ) public requiresPermission whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , ""Conversion amount should be less than balance"" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }",Converts WT0 to CarbonUSD for the user .,"function convertWT (uint256 _amount) public requiresPermission whenNotPaused {
    require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
    _burn(msg.sender, _amount);
    _mintCUSD(msg.sender, _amount);
    emit ConvertedToCUSD(msg.sender, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': '_burn', 'complexity': 1}, {'function': '_mintCUSD', 'complexity': 0}, {'function': 'convertWT', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Conversion amount should be less than balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mintCUSD""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConvertedToCUSD""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_burn', 'complexity': 1}, {'function': '_mintCUSD', 'complexity': 0}, {'function': 'convertWT', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,convertWT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address(balances[address(i)]) = address(uint160(i));
        }
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}"
281,"function announceCancel ( bytes32 _offerHash ) external { Offer memory offer = offers [ _offerHash ] ; require ( offer . maker == msg . sender , ""Invalid sender"" ) ; require ( offer . availableAmount > 0 , ""Offer already cancelled"" ) ; uint256 canCancelAt = now + cancelAnnounceDelay ; announcedCancellations [ _offerHash ] = canCancelAt ; emit CancelAnnounce ( offer . maker , _offerHash , canCancelAt ) ; }",Announces intent to cancel tokens using ` slowCancel `,"function announceCancel (bytes32 _offerHash) external {
    Offer memory offer = offers[_offerHash];
    require(offer.maker == msg.sender, ""Invalid sender"");
    require(offer.availableAmount > 0, ""Offer already cancelled"");
    uint256 canCancelAt = now + cancelAnnounceDelay;
    announcedCancellations[_offerHash] = canCancelAt;
    emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}",False,"[{'function': 'announceCancel', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""maker""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""availableAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Offer already cancelled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canCancelAt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cancelAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedCancellations""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""canCancelAt""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CancelAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""maker""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""canCancelAt""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceCancel', 'complexity': 2}]",3.0,announceCancel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    constructor() Ownable(msg.sender) {
        offers = mapping(bytes32 => Offer)({});
        announcedCancellations = mapping(bytes32 => uint256)({});
        cancelAnnounceDelay = 1; // Set to a safe, non-corner-case value
    }

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}"
5915,function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( siringAuction != address ( 0 ) ) ; require ( geneScience != address ( 0 ) ) ; require ( lottery != address ( 0 ) ) ; require ( variation != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .,"function unpause() public onlyCEO whenPaused {
    require(saleAuction != address(0));
    require(siringAuction != address(0));
    require(geneScience != address(0));
    require(lottery != address(0));
    require(variation != address(0));
    require(newContractAddress == address(0));
    super.unpause();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}",False,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",9.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""siringAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""geneScience""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""lottery""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""variation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCEO"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",7.0,unpause,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pausable is Ownable {
    bool private paused = false;
    address public saleAuction;
    address public siringAuction;
    address public geneScience;
    address public lottery;
    address public variation;
    address public newContractAddress;

    constructor() 
        Ownable(msg.sender)
    {
        saleAuction = 0x1111111111111111111111111111111111111111; // Replace with actual value
        siringAuction = 0x2222222222222222222222222222222222222222; // Replace with actual value
        geneScience = 0x3333333333333333333333333333333333333333; // Replace with actual value
        lottery = 0x444...; // Replace with actual value
        variation = 0x555...; // Replace with actual value
        newContractAddress = 0x666...; // Replace with actual value
    }

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}"
1091,"function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( sha3 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }","owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","function sendEther (address to, uint value) external validAddress(to) onlyManyOwners(sha3(msg.data)) requiresState(State.SUCCEEDED) {
    require(value > 0 && this.balance >= value);
    to.transfer(value);
    EtherSent(to, value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}",True,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sendEther', 'complexity': 4}]",6.0,4.0,{},"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sendEther', 'complexity': 4}]",5.0,sendEther,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            manyOwners[keccak256(abi.encodePacked(""owner"", i))] = true;
        }
        for (uint256 i = 1; i <= 3; i++) {
            states[address(uint160(i + 192))] = State({succeeded: true});
        }
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}"
2215,"function onApprove ( address _owner , address _spender , uint _amount ) external returns ( bool ) ;",Notifies the controller about an approval allowing the controller to react if desired,"function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
    require(_amount > 0);
    require(_owner != address(0));
    require(_spender != address(0));

    emit Approval(_owner, _spender, _amount);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}",False,"[{'function': 'onApprove', 'complexity': 3}]",9.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""onApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_owner is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_spender is zero address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 3}]",4.0,onApprove,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ApprovalWrapper is Ownable, ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}"
5767,"function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner { require ( _address != address ( tokenReward ) ) ; StandardToken token = StandardToken ( _address ) ; token . transfer ( beneficiary , _amount ) ; TokensWithdraw ( beneficiary , _address , _amount ) ; }",Withdraws tokens other than DGZ to beneficiary .,"function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner {
    require ( _address != address ( tokenReward ) );
    StandardToken token = StandardToken ( _address );
    token . transfer ( beneficiary , _amount );
    TokensWithdraw ( beneficiary , _address , _amount );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}",False,"[{'function': 'anyTokenWithdrawal', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""anyTokenWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenReward""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw from the reward token.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""StandardToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""StandardToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'anyTokenWithdrawal', 'complexity': 1}]",2.0,anyTokenWithdrawal,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    address public constant tokenReward = 0x1111111111111111111111111111111111111111; // Replace with actual value
    bool public initialized = true;
    bytes32 public constant initBytes = bytes32('init');

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}"
3863,"function claimTokenFor ( address _beneficiary ) public afterSaleSuccess whenNotPaused { uint256 stake = stakes [ _beneficiary ] ; require ( stake > 0 ) ; stakes [ _beneficiary ] = 0 ; uint256 tokens = stake . mul ( rate ) ; tokenBalance = tokenBalance . sub ( tokens ) ; ethealController . addHodlerStake ( _beneficiary , tokens . mul ( 2 ) ) ; require ( ethealController . ethealToken ( ) . transfer ( _beneficiary , tokens ) ) ; TokenClaimed ( msg . sender , _beneficiary , stake , tokens ) ; }",Claim token after token sale based on stake .,"function claimTokenFor ( address _beneficiary ) public afterSaleSuccess whenNotPaused {
    uint256 stake = stakes [ _beneficiary ];
    require ( stake > 0 );
    stakes [ _beneficiary ] = 0;
    uint256 tokens = stake . mul ( rate );
    tokenBalance = tokenBalance . sub ( tokens );
    ethealController . addHodlerStake ( _beneficiary , tokens . mul ( 2 ) );
    require ( ethealController . ethealToken ( ) . transfer ( _beneficiary , tokens ) );
    TokenClaimed ( msg . sender , _beneficiary , stake , tokens );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}",False,"[{'function': 'claimTokenFor', 'complexity': 2}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokenFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""stake""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealController""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""addHodlerStake(address,uint256)""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealController""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""ethealToken()""}], ""names"": []}], ""names"": []}, ""memberName"": ""delegatecall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transfer(address,uint256)""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenClaimed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""stake""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""afterSaleSuccess"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'claimTokenFor', 'complexity': 2}]",3.0,claimTokenFor,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EthealTokenWrapper is Ownable {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    constructor() Ownable(msg.sender) {
        ethealController = 0x1111111111111111111111111111111111111111; // Replace with your Etheal Controller address
        rate = 1;
        tokenBalance = 0;
        stakes[msg.sender] = 1;
        paused = false;
    }

    modifier afterSaleSuccess() {
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}"
6728,"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) public onlyController { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; bool verified = _updateTransfer ( _from , _to , _value , _data ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ForceTransfer ( msg . sender , _from , _to , _value , verified , _log ) ; emit Transfer ( _from , _to , _value ) ; }",Used by a controller to execute a forced transfer,"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) public onlyController {
    require ( _to != address ( 0 ) ) ;
    require ( _value <= balances [ _from ] ) ;
    bool verified = _updateTransfer ( _from , _to , _value , _data ) ;
    balances [ _from ] = balances [ _from ] . sub ( _value ) ;
    balances [ _to ] = balances [ _to ] . add ( _value ) ;
    emit ForceTransfer ( msg . sender , _from , _to , _value , verified , _log ) ;
    emit Transfer ( _from , _to , _value ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}",False,"[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",9.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_log"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""verified"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ForceTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""verified""}, {""type"": ""Identifier"", ""name"": ""_log""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",6.0,forceTransfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000;
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}"
691,"function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) ;",Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"function canIssueAttributeType (address validator, uint256 attributeTypeID) external view returns (bool) {
    require(validator != address(0), ""Invalid validator address"");
    require(attributeTypeID > 0, ""Invalid attribute type ID"");
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}",False,"[{'function': 'canIssueAttributeType', 'complexity': 2}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""canIssueAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""validator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid validator address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid attribute type ID""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'canIssueAttributeType', 'complexity': 2}]",3.0,canIssueAttributeType,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Validator is Ownable {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}"
876,"function initialize ( Vault _vault , uint64 _periodDuration ) external onlyInit { initialized ( ) ; require ( isContract ( _vault ) , ERROR_VAULT_NOT_CONTRACT ) ; vault = _vault ; require ( _periodDuration >= 1 days , ERROR_INIT_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; payments [ 0 ] . inactive = true ; paymentsNextIndex = 1 ; transactionsNextIndex = 1 ; _newPeriod ( getTimestamp64 ( ) ) ; }",Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"function initialize(Vault _vault, uint64 _periodDuration) external onlyInit {
    initialized();
    require(isContract(_vault), ERROR_VAULT_NOT_CONTRACT);
    vault = _vault;
    require(_periodDuration >= 1 days, ERROR_INIT_PERIOD_TOO_SHORT);
    settings.periodDuration = _periodDuration;
    payments[0].inactive = true;
    paymentsNextIndex = 1;
    transactionsNextIndex = 1;
    _newPeriod(getTimestamp64());
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}",True,"[{'function': 'isContract', 'complexity': 0}, {'function': 'initialize', 'complexity': 1}, {'function': 'getTimestamp64', 'complexity': 0}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Vault""}, ""name"": ""_vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_vault""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ERROR_VAULT_NOT_CONTRACT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vault""}, ""right"": {""type"": ""Identifier"", ""name"": ""_vault""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, ""TrueBody"": {""type"": ""RevertStatement"", ""functionCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InitPeriodTooShort""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""ERROR_INIT_PERIOD_TOO_SHORT""}], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""inactive""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transactionsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_newPeriod""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTimestamp64""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isContract', 'complexity': 0}, {'function': 'initialize', 'complexity': 1}, {'function': 'getTimestamp64', 'complexity': 0}]",3.0,initialize,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() Ownable(msg.sender) {
        settings.periodDuration = 1 days; // Set to a safe non-zero value
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}"
2491,function enableTransfers ( bool _transfersEnabled ) onlyOwner { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true,"function enableTransfers (bool _transfersEnabled) onlyOwner {
    transfersEnabled = _transfersEnabled;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",True,"[{'function': 'enableTransfers', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,enableTransfers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = true; // Set to true instead of false

    constructor() Ownable(msg.sender) {
        // No need to initialize transfersEnabled as it's already initialized in the base contract
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
1924,"function mintToken ( address target , uint256 mintedAmount ) onlyCrowdsaleAgent public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( this , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `,"
function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(this, target, mintedAmount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}",False,"[{'function': 'mintToken', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCrowdsaleAgent"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mintToken', 'complexity': 0}]",1.0,mintToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
        balanceOf[msg.sender] = 1000; // Initialize with a fixed value
        totalSupply = 1000000000000000000; // Initialize with a fixed value
        emit Transfer(address(0), msg.sender, 1); // Emit transfer event for the initial token distribution
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}

contract Token is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
2485,function emergencyWithdraw ( ) external hasFinalized { uint256 balance = STARTING_PRICE * ownedTokens [ msg . sender ] . length ; delete ownedTokens [ msg . sender ] ; msg . sender . transfer ( balance ) ; },"if there is an unresolvable problem , users can call to this function to get a refund .","function emergencyWithdraw() external hasFinalized {
    uint256 balance = STARTING_PRICE * ownedTokens[msg.sender].length;
    delete ownedTokens[msg.sender];
    msg.sender.transfer(balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}",False,"[{'function': 'emergencyWithdraw', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""STARTING_PRICE""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""hasFinalized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'emergencyWithdraw', 'complexity': 0}]",1.0,emergencyWithdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    constructor() Ownable(msg.sender) {
        // Initialize instance variables with fixed, safe values
        ownedTokens[msg.sender].length = 0;
        finalized = true;
    }

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}"
1164,"function triggerRecovery ( uint ein , address newAssociatedAddress , uint8 v , bytes32 r , bytes32 s , uint timestamp ) public _identityExists ( ein ) _hasIdentity ( newAssociatedAddress , false ) ensureSignatureTimeValid ( timestamp ) { require ( canRecover ( ein ) , ""Cannot trigger recovery yet."" ) ; Identity storage _identity = identityDirectory [ ein ] ; if ( canChangeRecoveryAddress ( ein ) ) { require ( msg . sender == _identity . recoveryAddress , ""Only the current recovery address can trigger recovery."" ) ; } else { require ( msg . sender == recoveryAddressChangeLogs [ ein ] . oldRecoveryAddress , ""Only the recently removed recovery address can trigger recovery."" ) ; } require ( isSigned ( newAssociatedAddress , keccak256 ( abi . encodePacked ( byte ( 0x19 ) , byte ( 0 ) , address ( this ) , ""I authorize being added to this Identity via recovery."" , ein , newAssociatedAddress , timestamp ) ) , v , r , s ) , ""Permission denied."" ) ; recoveryLogs [ ein ] = Recovery ( block . timestamp , keccak256 ( abi . encodePacked ( _identity . associatedAddresses . members ) ) ) ; emit RecoveryTriggered ( msg . sender , ein , _identity . associatedAddresses . members , newAssociatedAddress ) ; resetIdentityData ( _identity , msg . sender , false ) ; addAssociatedAddress ( ein , newAssociatedAddress ) ; }",Allows recovery addresses to trigger the recovery process for an Identity .,"function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
    require(_identityExists(ein), ""Identity does not exist."");
    require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
    require(canRecover(ein), ""Cannot trigger recovery yet."");
    require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
    require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein].oldRecoveryAddress, ""Only the current or previously removed recovery address can trigger recovery."");

    Identity storage _identity = identityDirectory[ein];
    recoveryLogs[ein] = Recovery(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
    emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
    resetIdentityData(_identity, msg.sender, false);
    addAssociatedAddress(ein, newAssociatedAddress);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}",False,"[{'function': 'triggerRecovery', 'complexity': 6}, {'function': '_identityExists', 'complexity': 0}, {'function': '_hasIdentity', 'complexity': 0}, {'function': 'canRecover', 'complexity': 0}, {'function': 'isSigned', 'complexity': 1}, {'function': 'canChangeRecoveryAddress', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",13.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""triggerRecovery"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""ein"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAssociatedAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_identityExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Identity does not exist.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_hasIdentity""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New associated address is not a valid identity.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""canRecover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Cannot trigger recovery yet.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""byte""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x19"", ""subdenomination"": None}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""byte""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""I authorize being added to this Identity via recovery.""}, {""type"": ""Identifier"", ""name"": ""ein""}, {""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}, {""type"": ""Identifier"", ""name"": ""timestamp""}], ""names"": []}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Permission denied.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""canChangeRecoveryAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryAddressChangeLogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}}}, {""type"": ""stringLiteral"", ""value"": ""Only the current or previously removed recovery address can trigger recovery.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Identity""}, ""name"": ""_identity"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""identityDirectory""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryLogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RecoveryLog""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_identity""}, ""memberName"": ""associatedAddresses""}, ""memberName"": ""members""}], ""names"": []}], ""names"": []}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RecoveryTriggered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""ein""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_identity""}, ""memberName"": ""associatedAddresses""}, ""memberName"": ""members""}, {""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""resetIdentityData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_identity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addAssociatedAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}, {""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'triggerRecovery', 'complexity': 6}, {'function': '_identityExists', 'complexity': 0}, {'function': '_hasIdentity', 'complexity': 0}, {'function': 'canRecover', 'complexity': 0}, {'function': 'isSigned', 'complexity': 1}, {'function': 'canChangeRecoveryAddress', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",8.0,triggerRecovery,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract IdentityRecovery is Ownable {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            identityDirectory[i] = Identity({associatedAddresses: AssociatedAddresses({members: [address(uint160(uint256(keccak256(abi.encodePacked(""member"", i)))) % 10**40]})});
        }
    }

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(_identity, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}"
461,"function implementsERC165InterfaceNoCache ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { uint256 success ; uint256 result ; ( success , result ) = noThrowCall ( _contract , ERC165ID ) ; if ( success == 0 || result == 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , INVALID_ID ) ; if ( success == 0 || result != 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , _interfaceId ) ; if ( success == 1 && result == 1 ) { return true ; } return false ; }",Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
    uint256 success;
    uint256 result;
    (success, result) = noThrowCall(_contract, ERC165ID);
    if (success == 0 || result == 0) {
        return false;
    }
    (success, result) = noThrowCall(_contract, INVALID_ID);
    if (success == 0 || result != 0) {
        return false;
    }
    (success, result) = noThrowCall(_contract, _interfaceId);
    if (success == 1 && result == 1) {
        return true;
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}",False,"[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'noThrowCall', 'complexity': 0}, {'function': 'implementsERC165InterfaceNoCache', 'complexity': 6}]",17.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""implementsERC165InterfaceNoCache"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""_interfaceId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""result"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""Identifier"", ""name"": ""result""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""noThrowCall""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}, {""type"": ""Identifier"", ""name"": ""ERC165ID""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""Identifier"", ""name"": ""result""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""noThrowCall""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}, {""type"": ""Identifier"", ""name"": ""INVALID_ID""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""Identifier"", ""name"": ""result""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""noThrowCall""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}, {""type"": ""Identifier"", ""name"": ""_interfaceId""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'noThrowCall', 'complexity': 0}, {'function': 'implementsERC165InterfaceNoCache', 'complexity': 6}]",7.0,implementsERC165InterfaceNoCache,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ERC165 {
    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with your owner's address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {}

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}"
3202,function accountIdForAddress ( address _address ) public view returns ( uint256 ) { require ( addressBelongsToAccount ( _address ) ) ; return accountByAddress [ _address ] ; },Retreive account ID associated with a user 's address,"function accountIdForAddress (address _address) public view returns (uint256) {
    require(addressBelongsToAccount(_address));
    return accountByAddress[_address];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}",False,"[{'function': 'accountIdForAddress', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""accountIdForAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressBelongsToAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accountByAddress""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'accountIdForAddress', 'complexity': 1}]",2.0,accountIdForAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}"
5007,function getTokenIndex ( uint256 _tokenId ) public view returns ( uint64 ) ;,Get the index of PixelCon ` ( _tokenId ) `,"
function getTokenIndex(uint256 _tokenId) public view returns (uint64) { }
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}",True,"[{'function': 'getTokenIndex', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTokenIndex', 'complexity': 1}]",2.0,getTokenIndex,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}"
1993,function getApproved ( uint256 _tokenId ) public view validNFToken ( _tokenId ) returns ( address ) { return idToApprovals [ _tokenId ] ; },Throws if ` _tokenId ` is not a valid NFT .,"function getApproved ( uint256 _tokenId ) public view validNFToken ( _tokenId ) returns ( address ) {
    return idToApprovals [ _tokenId ] ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}",False,"[{'function': 'getApproved', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""idToApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validNFToken"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getApproved', 'complexity': 0}]",1.0,getApproved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        idToApprovals[1] = 0x1111111111111111111111111111111111111111; // Replace with actual address
        idToApprovals[2] = 0x2222222222222222222222222222222222222222; // Replace with actual address
        idToApprovals[3] = 0x3333333333333333333333333333333333333333; // Replace with actual address

        // Initialize parent contract's state variables
        _setOwner(msg.sender);
    }

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}"
3377,function totalSupply ( ) external constant returns ( uint256 _totalSupply ) { return totalSupply ; },Check the total supply of the token ~ ERC-20 Standard,"function totalSupply() external constant returns (uint256 _totalSupply) {
    return totalSupply;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}",False,"[{'function': 'totalSupply', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalSupply_""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""constant""}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,totalSupply,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    uint256 public totalSupply;

 constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}

contract MyToken is Token, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) 
        Token(totalSupply, _name, _symbol, _decimals)
        Ownable()
    {
        // Initialize state variables with fixed, safe, non-corner-case values
        totalSupply_ = 1;
        name = 'initialized';
        symbol = 'init';
        decimals = 18;
        balances[msg.sender] = totalSupply_;
    }
}"
1589,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; }",Transfer Spork tokens from ` msg.sender ` to another account .,"function transfer (address _to, uint256 _amount) returns (bool success) {
    if (balances[_to] + _amount <= balances[_to]) return false;
    if (balances[msg.sender] < _amount) return false;
    balances[msg.sender] -= _amount;
    balances[_to] += _amount;
    Transfer(msg.sender, _to, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""memberName"": ""lte""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}], ""names"": []}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""lt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",3.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MyContract is Ownable, ERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[address(1)] = 1;
        balances[address(2)] = 1;
        balances[address(3)] = 1;
    }
}"
1356,"function setUint ( bytes32 _key , uint _value ) public onlyOwner returns ( bool success ) { uIntStorage [ _key ] = _value ; return true ; }",Set value for Uint associated with bytes32 id key,"function setUint (bytes32 _key , uint _value) public onlyOwner returns (bool success) {
    require(msg.sender == owner(), ""Only the contract owner can call this function."");
    uIntStorage[_key] = _value;
    return true;
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'setUint', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""only"", ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setUint', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        uIntStorage[bytes32('init')] = 1; // Initialize uint to 1
        _nextForkName = 'initialized'; // Initialize string to 'initialized'
        _nextForkUrl = 'initialized'; // Initialize string to 'initialized'
        _nextForkBlockNumber = 0; // Initialize uint256 to 0 (not never 0, but a safe non-corner-case value)
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
232,function getPrice ( ) public view returns ( uint ) { for ( uint i = c_priceChangeDates . length - 2 ; i > 0 ; i -- ) { if ( getTime ( ) >= c_priceChangeDates [ i ] ) { return c_tokenPrices [ i ] ; } } return c_tokenPrices [ 0 ] ; },get token price in cents depending on the current date,"function getPrice() public view returns (uint) {
    for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
        if (getTime() >= c_priceChangeDates[i]) {
            return c_tokenPrices[i];
        }
    }
    return c_tokenPrices[0];
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'getPrice', 'complexity': 3}, {'function': 'announceFork', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""only"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ROLE_PLATFORM_OPERATIVE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getPrice', 'complexity': 3}, {'function': 'announceFork', 'complexity': 2}]",3.0,getPrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x1111111111111111111111111111111111111111; // Fixed platform operator representative role
    bool public initialized = true;
    bytes32 public initializedBytes;

    constructor() Ownable(ROLE_PLATFORM_OPERATIVE) {
        _nextForkName = 'MyToken';
        _nextForkUrl = 'https://mytoken.com';
        _nextForkBlockNumber = 1;
        initialized = true;
        initializedBytes = bytes32('init');
    }

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
5169,function setHavven ( Havven _havven ) external onlyOwner { havven = _havven ; emit HavvenUpdated ( _havven ) ; },Set the Havven contract that the issuance controller uses to issue Havvens .,"
function setHavven ( Havven _havven ) external onlyOwner {
    havven = _havven ;
    emit HavvenUpdated ( _havven );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}",False,"[{'function': 'setHavven', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHavven"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Havven""}, ""name"": ""_havven"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havven""}, ""right"": {""type"": ""Identifier"", ""name"": ""_havven""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HavvenUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_havven""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setHavven', 'complexity': 0}]",1.0,setHavven,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}"
277,"function buy ( uint256 x , uint256 y , uint256 sizeA , uint256 sizeB , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . value > 0 ) ; internalBuy ( x , y , sizeA , sizeB ) ; }",sell new tokens during the round 0 all except logo,"
function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 _v, bytes32 _r, bytes32 _s) public notHalted() payable {
    address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);
    require(signers[recoveredSigner] == true);
    require(msg.value > 0);
    internalBuy(x, y, sizeA, sizeB);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}",True,"[{'function': 'setHalted', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'removeSigner', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}]",6.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeA"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeB"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recoveredSigner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signers""}, ""index"": {""type"": ""Identifier"", ""name"": ""recoveredSigner""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""internalBuy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""sizeA""}, {""type"": ""Identifier"", ""name"": ""sizeB""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notHalted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'setHalted', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'removeSigner', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}]",4.0,buy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}"
3181,"function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }",This function is disabled during the funding .,"function transfer(address to, uint256 value) returns (bool ok) {
    if (getState() != State.Success) throw;
    if (to == 0x0) throw;
    if (to == address(upgradeAgent)) throw;
    uint256 senderBalance = balances[msg.sender];
    if (senderBalance >= value && value > 0) {
        senderBalance = safeSub(senderBalance, value);
        balances[msg.sender] = senderBalance;
        balances[to] = safeAdd(balances[to], value);
        Transfer(msg.sender, to, value);
        return true;
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}",False,"[{'function': 'upgradeAgent', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'getState', 'complexity': 0}]",15.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""ok"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getState""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""State is not Success""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""upgradeAgent""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient is upgrade agent""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balances""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balances""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""senderBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balances""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balances""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'upgradeAgent', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'getState', 'complexity': 0}]",6.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}"
4086,"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) ;",Query if an address is an authorized operator for another address,"function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}",True,"[{'function': 'isApprovedForAll', 'complexity': 0}]",2.0,1.0,{},"[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,isApprovedForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;

    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return true; // Placeholder implementation
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 privateVariable = 1; // Safe non-zero value for uint256
        address privateAddress = address(0x111); // Fixed address sequence
        bool privateBool = true; // Set to true
        string memory privateString = 'initialized'; // Set to 'initialized'
        bytes32 privateBytes32 = bytes32('init'); // Set to bytes32('init')
    }
}"
79,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; memeIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"function approve(address _to, uint256 _tokenId) public {
    require(_owns(msg.sender, _tokenId));
    memeIndexToApproved[_tokenId] = _to;
    Approval(msg.sender, _to, _tokenId);
}

Your formatted function matches the input function's functionality exactly with no additional or removed code.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}",False,"[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memeIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 1}]",2.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}

contract MyTokenWrapper is TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            memeIndexToApproved[i] = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
        }
    }

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure override returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}"
3424,"function getCollectionName ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionNames [ _collectionIndex ] ; }",Get the name of collection # ` ( _collectionIndex ) `,"function getCollectionName (uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(bytes8){
require(_collectionIndex < totalCollections(), ""Collection does not exist"");
return collectionNames[_collectionIndex];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}",False,"[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'setTotalCollections', 'complexity': 0}, {'function': 'setCollectionName', 'complexity': 0}]",4.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectionName"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalCollections""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Collection does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validIndex"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'setTotalCollections', 'complexity': 0}, {'function': 'setCollectionName', 'complexity': 0}]",3.0,getCollectionName,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections = 1; // Set to 1 (never 0)
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections, ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections, ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    } // Properly invoke the Ownable uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor
}"
4496,function setICOEndDate ( uint256 _date ) public whenNotPaused onlyWhitelisted { require ( icoEndDate == 0 ) ; icoEndDate = _date ; },This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
    icoEndDate = _date;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}",True,"[{'function': 'setICOEndDate', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOEndDate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_date"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_date""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyWhitelisted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setICOEndDate', 'complexity': 0}]",1.0,setICOEndDate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate = 1; // Set to 1 instead of 0
    bool public paused = true; // Set to true instead of false

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        paused = true; // Corrected the initial value to match the requirement
        whitelistedAddresses[address(0x111)] = true;
        whitelistedAddresses[address(0x222)] = false;
        whitelistedAddresses[address(0x333)] = true;
    }
}"
1334,"function setPrepaid ( address _backer , uint _tokenPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external founderCall returns ( uint ) { if ( _tokenPrice == 0 || _tokenAmount == 0 || claimedPrepaidUnits > 0 || _tokenAmount + prepaidUnits + claimedUnits > promissoryUnits ) throw ; if ( earlyBackerList . length == numOfBackers && backers [ _backer ] . length == 0 ) throw ; if ( backers [ _backer ] . length == 0 ) { earlyBackerList . push ( _backer ) ; backersAddresses . push ( _backer ) ; } backers [ _backer ] . push ( backerData ( _tokenPrice , _tokenAmount , sha3 ( _privatePhrase , _backer ) , true , false , _backerRank ) ) ; prepaidUnits += _tokenAmount ; lastPrice = _tokenPrice ; AddedPrepaidTokensEvent ( _backer , backers [ _backer ] . length - 1 , _tokenPrice , _tokenAmount ) ; return backers [ _backer ] . length - 1 ; }",Adding ` _backer.address ( ) ` as an early backer,"
function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string _privatePhrase, uint _backerRank) external founderCall returns (uint) {
    require(_tokenPrice > 0 && _tokenAmount > 0);
    require(claimedPrepaidUnits == 0);
    require(_tokenAmount + prepaidUnits + claimedUnits <= promissoryUnits);
    if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
        earlyBackerList.push(_backer);
        backersAddresses.push(_backer);
    }
    backers[_backer].push(backerData(_tokenPrice, _tokenAmount, sha3(_privatePhrase, _backer), true, false, _backerRank));
    prepaidUnits += _tokenAmount;
    lastPrice = _tokenPrice;
    AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
    return backers[_backer].length - 1;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}",True,"[{'function': 'setPrepaid', 'complexity': 6}]",14.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrepaid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_backer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_privatePhrase"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_backerRank"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""claimedUnits""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""prepaidUnits""}], ""names"": []}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""claimedUnits""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""promissoryUnits""}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""earlyBackerList""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""numOfBackers""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""earlyBackerList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""backersAddresses""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""backerData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_privatePhrase""}, {""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}], ""names"": []}, {""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""Identifier"", ""name"": ""_backerRank""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prepaidUnits""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""prepaidUnits""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddedPrepaidTokensEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""founderCall"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrepaid', 'complexity': 6}]",7.0,setPrepaid,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        prepaidUnits = 1; // Set to 1 (never 0)
        claimedUnits = 1; // Set to 1 (never 0)
        promissoryUnits = 1; // Set to 1 (never 0)
        lastPrice = 1; // Set to 1 (never 0)
        numOfBackers = 0; // Set to 0
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 1); // Ensure initialized and not zero
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}"
517,function configure ( uint256 _maxHolderPercentage ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; },Used to intialize the variables of the contract,"function configure(uint256 _maxHolderPercentage) public onlyFactory {
    maxHolderPercentage = _maxHolderPercentage;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}",True,"[{'function': 'configure', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""configure"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxHolderPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxHolderPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxHolderPercentage""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyFactory"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'configure', 'complexity': 0}]",1.0,configure,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        maxHolderPercentage = 1;
        factory = address(0x111);
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}"
3727,"function decreaseApprovalWithSender ( address _sender , address _spender , uint256 _subtractedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance - _subtractedValue ; require ( newAllowance <= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }",Core logic of the ` decreaseApproval ` function .,"
function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyProxy {
    require(_spender != address(0));
    uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
    uint256 newAllowance = currentAllowance - _subtractedValue;
    require(newAllowance <= currentAllowance);
    erc20Store.setAllowance(_sender, _spender, newAllowance);
    erc20Proxy.emitApproval(_sender, _spender, newAllowance);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}",True,"[{'function': 'setAllowance', 'complexity': 0}, {'function': 'emitApproval', 'complexity': 0}, {'function': 'decreaseApprovalWithSender', 'complexity': 2}]",9.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseApprovalWithSender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""memberName"": ""allowed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subtractedValue""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""memberName"": ""setAllowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Proxy""}, ""memberName"": ""emitApproval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAllowance', 'complexity': 0}, {'function': 'emitApproval', 'complexity': 0}, {'function': 'decreaseApprovalWithSender', 'complexity': 2}]",3.0,decreaseApprovalWithSender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) Ownable(msg.sender) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}"
5953,function setFallback ( address _fallback ) public onlyOwner returns ( bool ) { fallback = _fallback ; return true ; },"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","function setFallback(address _fallback) public onlyOwner returns (bool) {
    fallback = _fallback;
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}",False,"[{'function': 'setFallback', 'complexity': 0}]",4.0,1.0,{},"[{'function': 'setFallback', 'complexity': 0}]",1.0,setFallback,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    address public fallback = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}"
6776,function collectForREQBurning ( uint256 _amount ) internal { requestBurnerContract . transfer ( _amount ) ; },Sends fees to the request burning address .,"function collectForREQBurning(uint256 _amount) internal {
    requestBurnerContract.transfer(_amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}",True,"[{'function': 'collectForREQBurning', 'complexity': 2}]",5.0,3.0,{},"[{'function': 'collectForREQBurning', 'complexity': 2}]",3.0,collectForREQBurning,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) Ownable(msg.sender) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}"
1286,"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external view returns ( bool ) { bytes memory data = abi . encodePacked ( ""Republic Protocol: open: "" , _trader , _orderID ) ; address signer = Utils . addr ( data , _signature ) ; return ( brokers [ signer ] == true ) ; }",Verifies a broker 's signature for an order opening .,"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external view returns ( bool ) {
    bytes memory data = abi . encodePacked ( ""Republic Protocol: open: "" , _trader , _orderID ) ;
    address signer = Utils . addr ( data , _signature ) ;
    return ( brokers [ signer ] == true ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}",False,"[{'function': 'verifyOpenSignature', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyOpenSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Republic Protocol: open: ""}, {""type"": ""Identifier"", ""name"": ""_trader""}, {""type"": ""Identifier"", ""name"": ""_orderID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Utils""}, ""memberName"": ""addr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""brokers""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'verifyOpenSignature', 'complexity': 0}]",2.0,verifyOpenSignature,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}"
5432,function setMinStandingBalance ( uint balance ) external onlyOwner { minStandingBalance = balance ; },Set the minimum required havven balance to have standing to bring a motion .,"function setMinStandingBalance(uint balance) external onlyOwner {
    minStandingBalance = balance;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}",True,"[{'function': 'setMinStandingBalance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinStandingBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minStandingBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,setMinStandingBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    constructor() Ownable(msg.sender) {
        minStandingBalance = 1; // Set to a non-zero, safe value
    }

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}"
6260,"function tokenFallback ( address _sender_address , uint256 _deposit , bytes _data ) external { require ( msg . sender == address ( token ) ) ; uint192 deposit = uint192 ( _deposit ) ; require ( deposit == _deposit ) ; uint length = _data . length ; require ( length == 40 || length == 44 ) ; address channel_sender_address = address ( addressFromBytes ( _data , 0x20 ) ) ; require ( _sender_address == channel_sender_address || trusted_contracts [ _sender_address ] ) ; address channel_receiver_address = address ( addressFromBytes ( _data , 0x34 ) ) ; if ( length == 40 ) { createChannelPrivate ( channel_sender_address , channel_receiver_address , deposit ) ; } else { uint32 open_block_number = uint32 ( blockNumberFromBytes ( _data , 0x48 ) ) ; updateInternalBalanceStructs ( channel_sender_address , channel_receiver_address , open_block_number , deposit ) ; } }","Opens a new channel or tops up an existing one , compatibility with ERC 223 .","function tokenFallback (address _sender_address, uint256 _deposit, bytes _data) external {
    require(msg.sender == address(token));
    uint192 deposit = uint192(_deposit);
    require(deposit == _deposit);
    uint length = _data.length;
    require(length == 40 || length == 44);

    address channel_sender_address = address(addressFromBytes(_data, 0x20));
    require(_sender_address == channel_sender_address || trusted_contracts[_sender_address]);

    address channel_receiver_address = address(addressFromBytes(_data, 0x34));
    if (length == 40) {
        createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
    } else {
        uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
        updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
    }
}

function addressFromBytes(bytes _data, uint offset) internal pure returns (address addr) {
    assembly {
        addr := mload(add(_data, add(0x20, offset)))
    }
}

function blockNumberFromBytes(bytes _data, uint offset) internal pure returns (uint32 block_number) {
    assembly {
        block_number := mload(add(_data, add(0x48, offset)))
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}",False,"[{'function': 'createChannelPrivate', 'complexity': 0}, {'function': 'updateInternalBalanceStructs', 'complexity': 0}, {'function': 'tokenFallback', 'complexity': 8}, {'function': 'addressFromBytes', 'complexity': 0}, {'function': 'blockNumberFromBytes', 'complexity': 0}]",20.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenFallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""token""}}, {""type"": ""stringLiteral"", ""value"": ""Sender must be the token contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_deposit""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint192""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Deposit exceeds uint192 limit""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deposit"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deposit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""right"": {""type"": ""Identifier"", ""name"": ""_deposit""}}, {""type"": ""stringLiteral"", ""value"": ""Deposit conversion overflow""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""44"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid data length""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""channel_sender_address"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressFromBytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""NumberLiteral"", ""number"": ""0x20"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_sender_address""}, ""right"": {""type"": ""Identifier"", ""name"": ""channel_sender_address""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trusted_contracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender_address""}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized sender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""channel_receiver_address"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressFromBytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""NumberLiteral"", ""number"": ""0x34"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""createChannelPrivate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""channel_sender_address""}, {""type"": ""Identifier"", ""name"": ""channel_receiver_address""}, {""type"": ""Identifier"", ""name"": ""deposit""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""open_block_number"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""blockNumberFromBytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""NumberLiteral"", ""number"": ""0x48"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateInternalBalanceStructs""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""channel_sender_address""}, {""type"": ""Identifier"", ""name"": ""channel_receiver_address""}, {""type"": ""Identifier"", ""name"": ""open_block_number""}, {""type"": ""Identifier"", ""name"": ""deposit""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createChannelPrivate', 'complexity': 0}, {'function': 'updateInternalBalanceStructs', 'complexity': 0}, {'function': 'tokenFallback', 'complexity': 8}, {'function': 'addressFromBytes', 'complexity': 0}, {'function': 'blockNumberFromBytes', 'complexity': 0}]",9.0,tokenFallback,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor() Ownable(msg.sender) {
        require(token != address(0), ""Invalid token address"");
        token = msg.sender; // Set to the contract creator
        for (uint i = 0; i < 1; i++) { // Only one trusted contract for simplicity
            trusted_contracts[msg.sender] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(channel_sender_address == msg.sender || trusted_contracts[msg.sender], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}"
3890,"function doConfirmPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Paid ; liquidPledging . confirmPayment ( uint64 ( p . ref ) , p . amount ) ; p . dest . transfer ( p . amount ) ; ConfirmPayment ( _idPayment , p . ref ) ; }",Transfers ETH according to the data held within the specified payment id ( internal function ),"function doConfirmPayment (uint _idPayment) internal {
    require (_idPayment < payments.length);
    Payment storage p = payments[_idPayment];
    require(p.state == PaymentStatus.Pending);
    p.state = PaymentStatus.Paid;
    liquidPledging.confirmPayment(uint64(p.ref), p.amount);
    p.dest.transfer(p.amount);
    ConfirmPayment(_idPayment, p.ref);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}",False,"[{'function': 'confirmPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 2}]",9.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""doConfirmPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payments""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Pending""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Paid""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""liquidPledging""}, ""memberName"": ""confirmPayment""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""ref""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""dest""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConfirmPayment""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""ref""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'confirmPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 2}]",4.0,doConfirmPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging = LiquidPledging(0x1111111111111111111111111111111111111111);
    Payment[] public payments = new Payment[](1);

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}"
3719,"function changeAdmin ( address newAdmin ) public validate_address ( newAdmin ) onlyAdmin { if ( admin == newAdmin ) revert ( ) ; AdminOwnershipTransferred ( admin , newAdmin ) ; admin = newAdmin ; }",only the admin is allowed to change the admin .,"function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyAdmin {
    if (admin == newAdmin) revert();
    AdminOwnershipTransferred(admin, newAdmin);
    admin = newAdmin;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}",True,"[{'function': 'changeAdmin', 'complexity': 0}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminOwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""admin""}, {""type"": ""Identifier"", ""name"": ""newAdmin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validate_address"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAdmin""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeAdmin', 'complexity': 0}]",2.0,changeAdmin,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    constructor() Ownable(msg.sender) {
        admin = msg.sender; // Use the deployer's address as the initial admin
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}"
4898,"function announceWithdraw ( address _token , uint256 _amount ) external { require ( _amount <= balances [ msg . sender ] [ _token ] , ""Amount too high"" ) ; AnnouncedWithdrawal storage announcement = announcedWithdrawals [ msg . sender ] [ _token ] ; uint256 canWithdrawAt = now + withdrawAnnounceDelay ; announcement . canWithdrawAt = canWithdrawAt ; announcement . amount = _amount ; emit WithdrawAnnounce ( msg . sender , _token , _amount , canWithdrawAt ) ; }",Announces intent to withdraw tokens using ` slowWithdraw `,"function announceWithdraw (address _token, uint256 _amount) external {
    require(_amount <= balances[msg.sender][_token], ""Amount too high"");
    AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
    uint256 canWithdrawAt = now + withdrawAnnounceDelay;
    announcement.canWithdrawAt = canWithdrawAt;
    announcement.amount = _amount;
    emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}",False,"[{'function': 'announceWithdraw', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}}, {""type"": ""stringLiteral"", ""value"": ""Amount too high""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AnnouncedWithdrawal""}, ""name"": ""announcement"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedWithdrawals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canWithdrawAt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""withdrawAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""announcement""}, ""memberName"": ""canWithdrawAt""}, ""right"": {""type"": ""Identifier"", ""name"": ""canWithdrawAt""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""announcement""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""canWithdrawAt""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceWithdraw', 'complexity': 1}]",2.0,announceWithdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor() Ownable(msg.sender) {
        withdrawAnnounceDelay = 1; // Set to a safe, non-zero value for uint256
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}"
2359,function countAttributeTypes ( ) external view returns ( uint256 ) ;,Count the number of attribute types defined by the registry .,"function countAttributeTypes() external view returns (uint256) {
    return _attributeTypes.length;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}",True,"[{'function': 'countAttributeTypes', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""countAttributeTypes"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'countAttributeTypes', 'complexity': 0}]",1.0,countAttributeTypes,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeTypeCounter is Ownable {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _attributeTypes = [1]; // Set to a non-zero, safe value
    }

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}"
239,function addForkedUniverse ( ) onlyInitialized external { IUniverse child_universe = IUniverse ( latest_universe ) . getWinningChildUniverse ( ) ; latest_universe = child_universe ; },Register a new child universe after a fork,"function addForkedUniverse() onlyInitialized external { IUniverse child_universe = IUniverse(latest_universe).getWinningChildUniverse(); latest_universe = child_universe; }


function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",True,"[{'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
4301,"function callPlugins ( bool before , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { allowedAmount = amount ; allowedAmount = callPluginsPledge ( before , fromPledge , fromPledge , toPledge , allowedAmount ) ; allowedAmount = callPluginsPledge ( before , toPledge , fromPledge , toPledge , allowedAmount ) ; }",` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"function callPlugins (bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
    allowedAmount = amount;
    allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
    allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'callPlugins', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'callPlugins', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
2476,"function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly,"function burn(uint256 _value) returns (bool success) {
    require(balanceOf[msg.sender] >= _value);
    balanceOf[msg.sender] -= _value;
    totalSupply -= _value;
    Burn(msg.sender, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}",True,"[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}"
2621,"function unregister ( bytes32 _key , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external returns ( uint ) ;",Only registrations in future can be removed .,"function unregister (bytes32 _key , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice) external returns (uint) ;

// Formatted version of the function
function unregister(
    bytes32 _key,
    address _address,
    uint _timestamp,
    uint _gasLimit,
    uint _gasPrice
) external returns (uint) {
    // Function body here
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}",True,"[{'function': 'unregister', 'complexity': 0}]",9.0,1.0,{},"[{'function': 'unregister', 'complexity': 0}]",1.0,unregister,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
2632,function amountRaised ( ) public constant returns ( uint256 amount ) { },the goal the campaign must reach in order for it to succeed,"function amountRaised() public constant returns (uint256 amount) { }


function amountRaised() public constant returns (uint256 amount) { }

The above formatting style is consistent with the recommended guidelines for formatting Solidity code. The `public` access modifier is used to indicate that the function can be called by anyone, while the `constant` keyword is used to indicate that the function does not modify any state variables. The `returns` keyword is used to specify the return type of the function, which in this case is a uint256 value.

It's important to note that the formatting style used in the example provided is just one way to format Solidity code, and there are many other ways to do it. The most important thing is to make sure that the code is readable and easy to understand for anyone who needs to read or maintain it.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}",True,"[{'function': 'amountRaised', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""amountRaised"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalAmountRaised""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'amountRaised', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Crowdfunding is Ownable {
    using SafeMath for uint256;

    uint256 public totalAmountRaised = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}"
827,"function transferFromMarketplace ( address _from , address _to , uint256 _imageId ) public onlyMarketplaceContract { require ( isApprovedOrOwner ( _from , _imageId ) ) ; clearApproval ( _from , _imageId ) ; removeTokenFrom ( _from , _imageId ) ; addTokenTo ( _to , _imageId ) ; emit Transfer ( _from , _to , _imageId ) ; }",approving image to be taken from specific address,"
function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyMarketplaceContract {
    require(isApprovedOrOwner(_from, _imageId));
    clearApproval(_from, _imageId);
    removeTokenFrom(_from, _imageId);
    addTokenTo(_to, _imageId);
    emit Transfer(_from, _to, _imageId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}",False,"[{'function': 'transferFromMarketplace', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromMarketplace"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_imageId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""marketplaceContract""}}, {""type"": ""stringLiteral"", ""value"": ""Only the marketplace contract can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedOrOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""The token is not approved or owned by the sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""clearApproval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeTokenFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addTokenTo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFromMarketplace', 'complexity': 2}]",3.0,transferFromMarketplace,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) Ownable(msg.sender) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}"
3458,function ( ) public payable atState ( State . Sale ) { byTokens ( ) ; },"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","
function ( ) public payable atState ( State . Sale ) {
    byTokens ( ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}",False,"[{'function': 'byTokens', 'complexity': 0}, {'function': '', 'complexity': 0}]",3.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""function()externalpayableatState(State.Sale){byTokens();}"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""byTokens""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""atState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Sale""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'byTokens', 'complexity': 0}, {'function': '', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }

    constructor() Ownable(msg.sender) {
        currentState = State.Sale;
    }
}"
5648,"function createCheckpoint ( ) public onlyModule ( CHECKPOINT_KEY , true ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; emit LogCheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }",Creates a checkpoint that can be used to query historical balances / totalSuppy,"
function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
    require(currentCheckpointId < 2**256 - 1);
    currentCheckpointId = currentCheckpointId + 1;
    emit LogCheckpointCreated(currentCheckpointId, now);
    return currentCheckpointId;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}",False,"[{'function': 'createCheckpoint', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogCheckpointCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyModule"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CHECKPOINT_KEY""}, {""type"": ""BooleanLiteral"", ""value"": True}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,createCheckpoint,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 1; // Set to 1 (never 0)
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    } // Properly invoke Ownable uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}"
5200,"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_from != address(0), ""Invalid sender address"");
    require(_to != address(0), ""Invalid recipient address"");
    require(_value > 0, ""Invalid value"");
    require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

    // Transfer the tokens
    uint256 fromBalance = balanceOf[_from];
    require(_value <= fromBalance, ""Insufficient funds"");
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    // Emit a transfer event
    emit Transfer(_from, _to, _value);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}",True,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 6}]",15.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the sender or recipient can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromBalance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fromBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 6}]",7.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}"
5602,"function destroy ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; selfdestruct ( owner ) ; }",Allows the owner to destroy the contract and return the tokens to the owner .,"function destroy() public onlyOwner {
    token.transfer(owner, token.balanceOf(this));
    selfdestruct(owner);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}",False,"[{'function': 'destroy', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'destroy', 'complexity': 1}]",2.0,destroy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/token/IERC20.sol"";

contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}"
1932,"function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) { uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; Member storage thisMember = members [ memberAddress ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; loyaltyReward += rewardForEachPeriod * numWholePeriods ; } }",Called to obtain the loyalty reward balance of any given member,"function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) {
    uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
    Member storage thisMember = members [ memberAddress ];
    uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility;
    loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance;
    if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) {
        uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds );
        uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100;
        loyaltyReward += rewardForEachPeriod * numWholePeriods;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}",True,"[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",12.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoyaltyRewardBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""memberAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loyaltyReward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""memberAddress""}}, ""memberName"": ""startOfLoyaltyRewardEligibility""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Member not eligible for loyalty rewards""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loyaltyPeriodSeconds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodDays""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Member""}, ""name"": ""thisMember"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""memberAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTimeSinceEligible"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""thisMember""}, ""memberName"": ""startOfLoyaltyRewardEligibility""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyReward""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""thisMember""}, ""memberName"": ""previouslyAppliedLoyaltyBalance""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTimeSinceEligible""}, ""right"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodSeconds""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numWholePeriods"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTimeSinceEligible""}, ""right"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodSeconds""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rewardForEachPeriod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""thisMember""}, ""memberName"": ""stakeBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""loyaltyRewardAmount""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyReward""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""rewardForEachPeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""numWholePeriods""}}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,getLoyaltyRewardBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loyaltyPeriodDays = 30 days; // Example value for a month
        loyaltyRewardAmount = 10; // 10% of stake balance as reward
    }

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}"
4568,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"
function transfer(address _to, uint256 _amount) returns (bool success) {
    require(transfersEnabled);
    doTransfer(msg.sender, _to, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}",True,"[{'function': 'doTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",6.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfersEnabled""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""doTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'doTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",5.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}"
5799,function setRentAuctionContractAddress ( address _address ) external onlyOwner { RentAuction _contract = RentAuction ( _address ) ; require ( _contract . isRentAuction ( ) ) ; rentAuctionContract = _contract ; },Set the contract address of the rent auction .,"function setRentAuctionContractAddress(address _address) external onlyOwner {
    RentAuction _contract = RentAuction(_address);
    require(_contract.isRentAuction());
    rentAuctionContract = _contract;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}",False,"[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionContractAddress', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRentAuctionContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RentAuction""}, ""name"": ""_contract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RentAuction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contract""}, ""memberName"": ""isRentAuction""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rentAuctionContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contract""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionContractAddress', 'complexity': 1}]",2.0,setRentAuctionContractAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    constructor(address _rentAuctionAddress) {
        require(_rentAuctionAddress != address(0), ""Invalid RentAuction contract address"");
        rentAuctionContract = RentAuction(_rentAuctionAddress);
        Ownable.__Ownable_init();
        Ownable.transferOwnership(msg.sender);
    }

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}"
694,function withdraw ( address addr ) onlyOwner public { addr . transfer ( address ( this ) . balance ) ; },Withdraw any accumulated fees to the specified address,"function withdraw(address addr) public onlyOwner {
    addr.transfer(address(this).balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}",True,"[{'function': 'withdraw', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addr""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdraw', 'complexity': 0}]",1.0,withdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for address;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}"
6751,"function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }",Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}",True,"[{'function': 'allowance ', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""remaining"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance ', 'complexity': 0}]",1.0,allowance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
}"
2680,"function assignBonus ( address _investor , uint256 _bonus ) internal { if ( _bonus == 0 ) { return ; } bonusProvided = bonusProvided . add ( _bonus ) ; bonusHolders [ _investor ] = bonusHolders [ _investor ] . add ( _bonus ) ; emit BonusAssigned ( _investor , _bonus ) ; }",Assigns bonus tokens to the specific contributor .,"function assignBonus ( address _investor , uint256 _bonus ) internal {
    if ( _bonus == 0 ) {
        return ;
    }
    bonusProvided = bonusProvided . add ( _bonus ) ;
    bonusHolders [ _investor ] = bonusHolders [ _investor ] . add ( _bonus ) ;
    emit BonusAssigned ( _investor , _bonus ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}",True,"[{'function': 'assignBonus', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_bonus"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_bonus""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bonusProvided""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bonusProvided""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_bonus""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonusHolders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonusHolders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_bonus""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BonusAssigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""Identifier"", ""name"": ""_bonus""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'assignBonus', 'complexity': 1}]",2.0,assignBonus,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract BonusAssignment is Ownable {
    using SafeMath for uint256;

    uint256 public bonusProvided = 1;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    constructor() Ownable(msg.sender) {
        // No additional initialization needed for state variables as they are already set to safe non-zero values.
    }

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}"
3939,function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; },"Change the address of the registryAdmin , who has the privilege to create new accounts","function setRegistryAdmin (address _newRegistryAdmin) public onlyOwner {
    address _oldRegistryAdmin = registryAdmin;
    registryAdmin = _newRegistryAdmin;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}",True,"[{'function': 'setRegistryAdmin', 'complexity': 0}]",4.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newRegistryAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldRegistryAdmin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newRegistryAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setRegistryAdmin', 'complexity': 0}]",7.0,setRegistryAdmin,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}"
3322,"function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { if ( ! honourWhitelist ( ) ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; preSaleCap = preSaleCap . sub ( allowedContribution ) ; PresaleCapUpdated ( preSaleCap ) ; return ( allowedContribution , refundAmount ) ; } var ( whiteListedAllowedContribution , whiteListedRefundAmount ) = getAllowedContribution ( ) ; if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( whiteListedAllowedContribution , whiteListedRefundAmount ) ; } revert ( ) ; }","Returns the contribution to be used as part of the transaction , and any refund value if expected .","function processContribution() private isValidContribution returns (uint256, uint256) {
    if (!honourWhitelist()) {
        var (allowedContribution, refundAmount) = getAllowedContribution();
        AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
        preSaleCap = preSaleCap.sub(allowedContribution);
        PresaleCapUpdated(preSaleCap);
        return (allowedContribution, refundAmount);
    }

    var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
    if (whitelist[msg.sender] > 0) {
        return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
    }

    revert();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}",False,"[{'function': 'processContribution', 'complexity': 3}, {'function': 'isValidContribution', 'complexity': 0}, {'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}]",16.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""processContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""honourWhitelist""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""allowedContribution"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x11307da90>}, {""type"": ""VariableDeclaration"", ""name"": ""refundAmount"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x11307c6e0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getAllowedContribution""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AllowedContributionCheck""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AllowedContributionState""}, ""memberName"": ""WhitelistClosed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preSaleCap""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preSaleCap""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PresaleCapUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""preSaleCap""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}, {""type"": ""Identifier"", ""name"": ""refundAmount""}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""whiteListedAllowedContribution"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x1131ba6d0>}, {""type"": ""VariableDeclaration"", ""name"": ""whiteListedRefundAmount"", ""isStateVar"": False, ""isIndexed"": False, ""iden"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.IdentifierContext object at 0x1131bbaf0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getAllowedContribution""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processWhitelistedContribution""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""whiteListedAllowedContribution""}, {""type"": ""Identifier"", ""name"": ""whiteListedRefundAmount""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isValidContribution"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'processContribution', 'complexity': 3}, {'function': 'isValidContribution', 'complexity': 0}, {'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}]",3.0,processContribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}

contract YourContractImpl is YourContract {
    constructor() Ownable(msg.sender) {
        preSaleCap = 1; // Set to a safe non-zero value
        contributions[address(0x111)] = Contribution({amount: 1, processed: true});
        contributions[address(0x222)] = Contribution({amount: 1, processed: false});
    }
}"
3650,"function setRegisteredAuthority ( Data storage self , string issuerFirm , address authorityAddress , bool approved ) internal returns ( bool success ) { require ( isRegisteredFirm ( self , issuerFirm ) , ""Error: `issuerFirm` must be registered."" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , authorityAddress ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , authorityAddress ) ) ; require ( self . Storage . setBool ( id_a , approved ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setString ( id_b , issuerFirm ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }",Method for setting a registered issuer firm authority,"function setRegisteredAuthority(Data storage self, string issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
    require(isRegisteredFirm(self, issuerFirm), ""Error: `issuerFirm` must be registered."");
    bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
    bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
    require(self.Storage.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
    require(self.Storage.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}",True,"[{'function': 'setString', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}, {'function': 'isRegisteredFirm', 'complexity': 0}]",8.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegisteredAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""issuerFirm"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""authorityAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegisteredFirm""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: `issuerFirm` must be registered.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_a"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_b"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority.firm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""storageContract""}, ""memberName"": ""setBool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_a""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""storageContract""}, ""memberName"": ""setString""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_b""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setString', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}, {'function': 'isRegisteredFirm', 'complexity': 0}]",4.0,setRegisteredAuthority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

contract Data is Ownable {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) Ownable(msg.sender) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}"
4267,"function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; require ( holderIndex [ _externalHolderId ] == 0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }","Returns holder id for the specified address , creates it if needed .","
function registerHolder (bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
    require (_holderAddress != 0x0);
    require (holderIndex[_externalHolderId] == 0);
    uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
    require (_holderIndex == 0);
    _createCountryId(_countryCode);
    _holderIndex = holdersCount.add(1);
    holdersCount = _holderIndex;
    HoldersData storage _holderData = holders[_holderIndex];
    _holderData.countryCode = _countryCode;
    _holderData.operational = true;
    _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
    _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
    uint _firstAddressIndex = 1;
    _holderData.holderAddressCount = _firstAddressIndex;
    _holderData.address2Index[_holderAddress] = _firstAddressIndex;
    _holderData.index2Address[_firstAddressIndex] = _holderAddress;
    holderIndex[_externalHolderId] = _holderIndex;
    holderAddress2Id[_holderAddress] = _externalHolderId;
    _emitHolderRegistered(_externalHolderId, _holderIndex, _countryCode);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}",False,"[{'function': 'registerHolder', 'complexity': 3}, {'function': '_createCountryId', 'complexity': 0}]",22.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_countryCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_holderIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createCountryId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_countryCode""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holdersCount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""holdersCount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""HoldersData""}, ""name"": ""_holderData"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""countryCode""}, ""right"": {""type"": ""Identifier"", ""name"": ""_countryCode""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""operational""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""sendLimPerDay""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKEN_HOLDER_NUMBER""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""sendLimPerMonth""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKEN_HOLDER_NUMBER""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_firstAddressIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""holderAddressCount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_firstAddressIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_firstAddressIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""index2Address""}, ""index"": {""type"": ""Identifier"", ""name"": ""_firstAddressIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_holderIndex""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HolderRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""_holderIndex""}, {""type"": ""Identifier"", ""name"": ""_countryCode""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracleOrOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'registerHolder', 'complexity': 3}, {'function': '_createCountryId', 'complexity': 0}]",10.0,registerHolder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HolderRegistration is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}"
5707,function multiCancel ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doCancelPayment ( _idPayments [ i ] ) ; } },` onlyOwner ` An efficient way to cancel multiple payments,"function multiCancel (uint256[] _idPayments) public onlyOwner {
    for(uint i = 0; i < _idPayments.length; i++) {
        doCancelPayment(_idPayments[i]);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}",False,"[{'function': 'multiCancel', 'complexity': 1}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_idPayments"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doCancelPayment""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multiCancel', 'complexity': 1}]",3.0,multiCancel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        someUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someAddress = address(0x111);

        // bool: Set to true
        someBool = true;

        // string: Set to 'initialized'
        someString = 'initialized';

        // bytes32: Set to bytes32('init')
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}"
32,function setCurrentPrice ( uint256 newPrice ) public onlyOwner { currentPrice = newPrice ; },Allows the owner of this contract to set the currentPrice for each token,"function setCurrentPrice (uint256 newPrice) public onlyOwner {
    currentPrice = newPrice;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}",True,"[{'function': 'setCurrentPrice', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,setCurrentPrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    constructor() Ownable(msg.sender) {
        currentPrice = 1;
    }

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}"
2463,"function getContractAddress ( string _name ) public view returns ( address _contractAddress ) { bytes4 _signature = bytes4 ( keccak256 ( ""getContractAddress32(bytes32)"" ) ) ; bytes32 _name32 = keccak256 ( abi . encodePacked ( _name ) ) ; assembly { let _registry := sload ( registry_slot ) let _pointer := mload ( 0x40 ) mstore ( _pointer , _signature ) mstore ( add ( _pointer , 0x04 ) , _name32 ) let result := staticcall ( gas , _registry , _pointer , 0x24 , _pointer , 0x20 ) if iszero ( result ) { revert ( 0 , 0 ) } _contractAddress := mload ( _pointer ) mstore ( 0x40 , add ( _pointer , 0x24 ) ) } }",Gets a given contract address by bytes32 in order to save gas,"function getContractAddress(string _name) public view returns (address _contractAddress) {
    bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
    bytes32 _name32 = keccak256(abi.encodePacked(_name));
    assembly {
        let _registry := sload(registry_slot);
        let _pointer := mload(0x40);
        mstore(_pointer, _signature);
        mstore(add(_pointer, 0x04), _name32);
        let result := staticcall(gas, _registry, _pointer, 0x24, _pointer, 0x20);
        if iszero(result) {
            revert(0, 0);
        }
        _contractAddress := mload(_pointer);
        mstore(0x40, add(_pointer, 0x24));
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}",True,"[{'function': 'getContractAddress', 'complexity': 2}]",16.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""_signature"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""getContractAddress32(bytes32)""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name32"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}], ""names"": []}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""_registry""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""sload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""REGISTRY_SLOT"", ""arguments"": []}]}}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""_pointer""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_signature"", ""arguments"": []}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x04""}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""_name32"", ""arguments"": []}]}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""result""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""staticcall"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""gas"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_registry"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x20""}]}}, {""type"": ""AssemblyIf"", ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""iszero"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""result"", ""arguments"": []}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyExpression"", ""functionName"": ""revert"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""DecimalNumber"", ""value"": ""0""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""_contractAddress""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}]}]}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getContractAddress', 'complexity': 2}]",4.0,getContractAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) Ownable(msg.sender) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}"
1777,"function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external { require ( isAttributeType ( ID ) , ""unable to set minimum stake, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . minimumStake = minimumRequiredStake ; }","Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","
function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external {
    require(isAttributeType(ID), ""unable to set minimum stake, no attribute type with the provided ID"");
    _attributeTypes[ID].minimumStake = minimumRequiredStake;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}",True,"[{'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAttributeTypeMinimumRequiredStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minimumRequiredStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""unable to set minimum stake, no attribute type with the provided ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""memberName"": ""minimumStake""}, ""right"": {""type"": ""Identifier"", ""name"": ""minimumRequiredStake""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,setAttributeTypeMinimumRequiredStake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            _attributeTypes[i] = AttributeType({exists: true, minimumStake: uint256(1)});
        }
    }

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}"
2431,function ( ) public payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","function ( ) public payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }

function ( ) public payable {
    require(isContract(controller));
    require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}",False,"[{'function': '', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""account"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': '', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;
    bool public initialized = true;
    bytes32 public initBytes32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        controller = 0x1111111111111111111111111111111111111111; // Replace with your desired controller address
        initialized = true;
    }

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}"
1613,"function getMinerHashRateCurrentHalving ( ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , currentHalving ( ) ) ; }",Calculate the halving hash rate of a miner,"function getMinerHashRateCurrentHalving() public constant returns (bool, uint256) {
    return getHashRateOf(msg.sender, currentHalving());
}

// Example:

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",True,"[{'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
2278,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .,"function increaseApprovalPreSigned(bytes _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
    require(_spender != address(0));
    require(!nonces[_signature]);

    bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
    address from = recover(hashedTx, _signature);
    require(from != address(0));

    nonces[_signature] = true;
    allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
    balances[from] = balances[from].sub(_fee);
    balances[msg.sender] = balances[msg.sender].add(_fee);

    emit Approval(from, _spender, allowed[from][_spender]);
    emit Transfer(from, msg.sender, _fee);
    emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}",False,"[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 4}]",19.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseApprovalPreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""_signature""}}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hashedTx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""increaseApprovalPreSignedHashing""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hashedTx""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""_signature""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addedValue""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPreSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 4}]",4.0,increaseApprovalPreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000;
        allowed[msg.sender][address(0)] = 10000000000; // placeholder value
        nonces[keccak256(abi.encodePacked(address(this), address(0), 0, 0, 0))] = true;
    }

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}"
4847,"function transferToContract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ContractReceiver receiver = ContractReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }",Function that is called when transaction target is contract,"function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    ContractReceiver receiver = ContractReceiver(_to);
    receiver.tokenFallback(msg.sender, _value, _data);
    emit Transfer(msg.sender, _to, _value);
    emit Transfer(msg.sender, _to, _value, _data);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}",True,"[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transferToContract', 'complexity': 1}]",10.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ContractReceiver""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""tokenFallback""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transferToContract', 'complexity': 1}]",2.0,transferToContract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // uint256: Set to 1 (never 0)
    }

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}"
1565,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { doMint ( _tokenHolder , _amount , _operatorData ) ; }",Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner {
    doMint( _tokenHolder, _amount, _operatorData );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}",False,"[{'function': 'mint', 'complexity': 0}]",3.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doMint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mint', 'complexity': 0}]",2.0,mint,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MintWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}"
5534,function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . finalize_ts ; },Returns the timestamp at which the question will be/was finalized,"function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
    return questions[question_id].finalize_ts;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}",False,"[{'function': 'getFinalizeTS', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalizeTS"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""finalize_ts""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,getFinalizeTS,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
    
    Question[] public questionsArray;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}"
2081,function takeOwnership ( uint256 _deedId ) external payable ;,Become owner of a deed for which you are currently approved,"function takeOwnership(uint256 _deedId) external payable {
    require(_deedId > 0, ""Invalid deed ID"");
    require(msg.value >= DEED_PRICE, ""Insufficient payment"");
    require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
    _deeds[_deedId].owner = msg.sender;
    _deeds[_deedId].isOwner = true;
    emit DeedOwnershipTransferred(_deedId, msg.sender);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}",False,"[{'function': 'takeOwnership', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 4}]",8.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_deedId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid deed ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""DEED_PRICE""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient payment""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""memberName"": ""isOwner""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Deed is already owned""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""memberName"": ""isOwner""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DeedOwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deedId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'takeOwnership', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 4}]",4.0,takeOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

contract Deed is Ownable {;
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            _deeds[i + 1] = DeedInfo({owner: address(uint160(uint256(keccak256(abi.encodePacked(""address"", i))))), isOwner: false});
        }
    }

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}"
790,"function updateBrokerVerifierContract ( RenExBrokerVerifier _newBrokerVerifierContract ) external onlyOwner { emit LogBrokerVerifierContractUpdated ( brokerVerifierContract , _newBrokerVerifierContract ) ; brokerVerifierContract = _newBrokerVerifierContract ; }",Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
    emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
    brokerVerifierContract = _newBrokerVerifierContract;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}",False,"[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",4.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBrokerVerifierContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RenExBrokerVerifier""}, ""name"": ""_newBrokerVerifierContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogBrokerVerifierContractUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",9.0,updateBrokerVerifierContract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RenExBrokerVerifier is Ownable {
    using SafeMath for uint256;

    address public brokerVerifierContract;
    bool public initialized = true;
    bytes32 public initBytes32 = bytes32('init');

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    constructor() Ownable(msg.sender) {
        brokerVerifierContract = 0x1111111111111111111111111111111111111111; // Replace with actual value
        initialized = true;
        initBytes32 = bytes32('init');
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}"
1335,"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit_ ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }",Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"function withdrawExcessToken ( address token ) external onlyOwner {
    ERC20 erc20 = ERC20 ( token );
    uint256 withdrawAmount;
    uint256 amountOwned = erc20 . balanceOf ( address ( this ) );
    uint256 quantity;
    bool ok;
    ( quantity , ok ) = getQuantity ( token );
    if ( ok ) {
        withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit_ ) . mul ( quantity ) );
    } else {
        withdrawAmount = amountOwned;
    }
    require ( erc20 . transfer ( owner , withdrawAmount ) );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 2}]",14.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""erc20"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountOwned"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""ok"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""ok""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getQuantity""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""withdrawAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""ok""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawAmount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amountOwned""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creationUnit_""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}], ""names"": []}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountOwned""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""withdrawAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 2}]",3.0,withdrawExcessToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        totalSupply_ = 1; // Set to 1 (never 0)
        creationUnit_ = 1; // Set to 1 (never 0)
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}"
3433,"function setNeuroChainAddress ( string neurochainAddress ) public { neuroChainAddresses [ msg . sender ] = neurochainAddress ; NeuroChainAddressSet ( msg . sender , neurochainAddress , block . timestamp , false ) ; }",Permit ` msg.sender ` to set its NeuroChain Address,"function setNeuroChainAddress(string neurochainAddress) public {
    neuroChainAddresses[msg.sender] = neurochainAddress;
    NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}",True,"[{'function': 'setNeuroChainAddress', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""neurochainAddress"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""neurochainAddress""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""neuroChainAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""neurochainAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NeuroChainAddressSet""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""neurochainAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,setNeuroChainAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract NeuroChainWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        neuroChainAddresses[msg.sender] = ""0x1111111111111111111111111111111111111111""; // Placeholder for actual address initialization
    }

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}"
465,"function getTokenBalance ( Data storage self , string currency , address account ) internal view returns ( uint balance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }",Get the token balance for a given account,"
function getTokenBalance(Data storage self, string currency, address account) internal view returns (uint balance) {
    bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
    return self.Storage.getUint(id);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}",False,"[{'function': 'getUint', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.balance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getForwardedAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""Storage""}, ""memberName"": ""getUint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getUint', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",1.0,getTokenBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

contract Data is Ownable {;
    Storage public immutable Storage;

    constructor() 
        Ownable(msg.sender)
        SafeMath()
    {
        Storage = Storage(0x1111111111111111111111111111111111111111); // Replace with actual address
    }
}

contract TokenBalanceWrapper is Ownable {;
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    constructor() 
        Ownable(msg.sender)
        SafeMath()
    {
        Storage = Storage(0x2222222222222222222222222222222222222222); // Replace with actual address
    }

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}"
5228,"function getDelegateIdx ( Pledge p , uint64 idDelegate ) internal returns ( uint64 ) { for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { if ( p . delegationChain [ i ] == idDelegate ) return uint64 ( i ) ; } return NOTFOUND ; }",A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns (uint64) {
    for (uint i = 0; i < p.delegationChain.length; i++) {
        if (p.delegationChain[i] == idDelegate) return uint64(i);
    }
    return NOTFOUND;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}",False,"[{'function': 'getDelegateIdx', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDelegateIdx"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""p"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idDelegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""idDelegate""}}, ""TrueBody"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""NOTFOUND""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getDelegateIdx', 'complexity': 2}]",3.0,getDelegateIdx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}

contract ModifiedWrapper is Wrapper {
    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        delegationChain = [1, 2, 3]; // Example values for uint64[]
    }
}"
3288,"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Countdown not finished yet"" ) ; }",Distirbutes a different quantity of tokens to all the specified addresses,"function distributeVariable (uint index, address[] _addrs, uint[] _vals) public onlyOwner {
    if (timeGone(index) == true) {
        Airdrop memory airdrop = airdrops[index];
        for (uint i = 0; i < _addrs.length; ++i) {
            airdrop.tokenSC.transfer(_addrs[i], _vals[i]);
        }
    } else {
        revert(""Distribution Failed: Countdown not finished yet"");
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}",False,"[{'function': 'distributeVariable', 'complexity': 4}, {'function': 'timeGone', 'complexity': 0}]",11.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeVariable"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""_vals"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""timeGone""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Airdrop""}, ""name"": ""airdrop"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""airdrops""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": True}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vals""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""tokenSC""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""tokenSC""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transfer(address,uint256)""}], ""names"": []}], ""names"": []}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vals""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}], ""names"": []}}]}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Distribution Failed: Countdown not finished yet""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'distributeVariable', 'complexity': 4}, {'function': 'timeGone', 'complexity': 0}]",5.0,distributeVariable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}"
110,"function initialize ( address _snt , address _sntController , uint256 _startBlock , uint256 _endBlock , address _dynamicCeiling , address _destEthDevs , address _destTokensReserve , address _destTokensSgt , address _destTokensDevs , address _sgt , uint256 _maxSGTSupply ) public onlyOwner { require ( address ( SNT ) == 0x0 ) ; SNT = MiniMeToken ( _snt ) ; require ( SNT . totalSupply ( ) == 0 ) ; require ( SNT . controller ( ) == address ( this ) ) ; require ( SNT . decimals ( ) == 18 ) ; require ( _sntController != 0x0 ) ; sntController = _sntController ; require ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _dynamicCeiling != 0x0 ) ; dynamicCeiling = DynamicCeiling ( _dynamicCeiling ) ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensSgt != 0x0 ) ; destTokensSgt = _destTokensSgt ; require ( _destTokensDevs != 0x0 ) ; destTokensDevs = _destTokensDevs ; require ( _sgt != 0x0 ) ; SGT = MiniMeToken ( _sgt ) ; require ( _maxSGTSupply >= MiniMeToken ( SGT ) . totalSupply ( ) ) ; maxSGTSupply = _maxSGTSupply ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters,"function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}",False,"[{'function': 'decimals', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}]",27.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_snt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sntController"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dynamicCeiling"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destEthDevs"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensReserve"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensSgt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensDevs"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sgt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxSGTSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SNT""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_snt""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""controller""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_sntController""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sntController""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sntController""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_startBlock""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_startBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endBlock""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startBlock""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endBlock""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_dynamicCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dynamicCeiling""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DynamicCeiling""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_dynamicCeiling""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destEthDevs""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destEthDevs""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destEthDevs""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensReserve""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensReserve""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensReserve""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensSgt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensSgt""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensSgt""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensDevs""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensDevs""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensDevs""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_sgt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""SGT""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sgt""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_maxSGTSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SGT""}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSGTSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxSGTSupply""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'decimals', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'initialize', 'complexity': 14}]",15.0,initialize,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    uint256 public totalSupply;

 constructor(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) {
        require(address(SNT) == 0x0);
        SNT = MiniMeToken(_snt);
        require(SNT.totalSupply() == 0);
        require(SNT.controller() == address(this));
        require(SNT.decimals() == 18);
        require(_sntController != 0x0);
        sntController = _sntController;
        require(_startBlock >= getBlockNumber());
        require(_startBlock < _endBlock);
        startBlock = _startBlock;
        endBlock = _endBlock;
        require(_dynamicCeiling != 0x0);
        dynamicCeiling = DynamicCeiling(_dynamicCeiling);
        require(_destEthDevs != 0x0);
        destEthDevs = _destEthDevs;
        require(_destTokensReserve != 0x0);
        destTokensReserve = _destTokensReserve;
        require(_destTokensSgt != 0x0);
        destTokensSgt = _destTokensSgt;
        require(_destTokensDevs != 0x0);
        destTokensDevs = _destTokensDevs;
        require(_sgt != 0x0);
        SGT = MiniMeToken(_sgt);
        require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
        maxSGTSupply = _maxSGTSupply;
    }
}"
2093,"function getTokenDataByIndex ( uint64 _tokenIndex ) public view returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { require ( _tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ _tokenIndex ] ; TokenLookup storage lookupData = tokenLookup [ pixelcon . tokenId ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }",Get all details of PixelCon # ` ( _tokenIndex ) `,"function getTokenDataByIndex (uint64 _tokenIndex) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require (_tokenIndex < totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}",False,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'getTokenDataByIndex', 'complexity': 1}]",6.0,2.0,{},"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'getTokenDataByIndex', 'complexity': 1}]",2.0,getTokenDataByIndex,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

contract PixelConContract is Ownable {
    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint256 tokenId = 1; // Set to a non-zero value
        uint64 collectionIndex = 0x1111111111111111111111111111111111111111; // Use a fixed address value
        uint32 dateCreated = block.timestamp; // Use the current timestamp

        pixelcons[1] = PixelCon(tokenId, collectionIndex, dateCreated);
    }

    function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
        require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
        PixelCon storage pixelcon = pixelcons[_tokenIndex];
        TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
        return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
    }
}"
2971,function getApproved ( uint256 _tokenId ) external view canBeStoredIn40Bits ( _tokenId ) returns ( address ) { require ( _tokenId <= _totalSupply ( ) ) ; if ( cutieIndexToApproved [ uint40 ( _tokenId ) ] != address ( 0 ) ) { return cutieIndexToApproved [ uint40 ( _tokenId ) ] ; } address owner = cutieIndexToOwner [ uint40 ( _tokenId ) ] ; return addressToApprovedAll [ owner ] ; },Get the approved address for a single NFT,"function getApproved (uint256 _tokenId) external view canBeStoredIn40Bits (_tokenId) returns (address) {
    require(_tokenId <= _totalSupply());

    if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
        return cutieIndexToApproved[uint40(_tokenId)];
    }

    address owner = cutieIndexToOwner[uint40(_tokenId)];
    return addressToApprovedAll[owner];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}",False,"[{'function': 'getApproved', 'complexity': 2}, {'function': '_totalSupply', 'complexity': 0}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""arguments"": [], ""names"": []}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToApproved""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint40""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToApproved""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint40""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToOwner""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint40""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addressToApprovedAll""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getApproved', 'complexity': 2}, {'function': '_totalSupply', 'complexity': 0}]",3.0,getApproved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply = 1000000000000000000;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // No need to initialize _totalSupply as it is already initialized to 1 in the declaration
    }

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}"
2241,function tokenHardcapIssued ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapIssuedValue ; },Gets absolute issued hardcap volume which means it will be greater than softcap value .,"function tokenHardcapIssued() public view returns (uint) {
    return tokenSoftcap + tokenHardcapIssuedValue;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}",True,"[{'function': 'tokenHardcapIssued', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenHardcapIssued"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenSoftcap""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenHardcapIssuedValue""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,tokenHardcapIssued,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap = 1;
    uint public tokenHardcapIssuedValue = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}"
4491,"function exchangeEtherForSynthetixAtRate ( uint guaranteedEtherRate , uint guaranteedSynthetixRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice , ""Guaranteed ether rate would not be received"" ) ; require ( guaranteedSynthetixRate == usdToSnxPrice , ""Guaranteed synthetix rate would not be received"" ) ; return exchangeEtherForSynthetix ( ) ; }",Exchange ETH to SNX while insisting on a particular set of rates .,"function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable pricesNotStale notPaused returns (uint) {
    require(guaranteedEtherRate == usdToEthPrice, ""Guaranteed ether rate would not be received"");
    require(guaranteedSynthetixRate == usdToSnxPrice, ""Guaranteed synthetix rate would not be received"");
    return exchangeEtherForSynthetix();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}",False,"[{'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 4}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",6.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""exchangeEtherForSynthetixAtRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""guaranteedEtherRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""guaranteedSynthetixRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""paused""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract is paused""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""guaranteedEtherRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pricing""}, ""memberName"": ""usdToEthPrice""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Guaranteed ether rate would not be received""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""guaranteedSynthetixRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pricing""}, ""memberName"": ""usdToSnxPrice""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Guaranteed synthetix rate would not be received""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeEtherForSynthetix""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 4}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",4.0,exchangeEtherForSynthetixAtRate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) Ownable(msg.sender) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}"
4173,"function calculateAccountValues ( address userAddress ) public view returns ( uint , uint , uint ) { ( Error err , uint supplyValue , uint borrowValue ) = calculateAccountValuesInternal ( userAddress ) ; if ( err != Error . NO_ERROR ) { return ( uint ( err ) , 0 , 0 ) ; } return ( 0 , supplyValue , borrowValue ) ; }","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","function calculateAccountValues ( address userAddress ) public view returns ( uint , uint , uint ) {
( Error err , uint supplyValue , uint borrowValue ) = calculateAccountValuesInternal ( userAddress );
if ( err != Error . NO_ERROR ) {
return ( uint ( err ) , 0 , 0 );
}
return ( 0 , supplyValue , borrowValue );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}",True,"[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAccountValues"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""err"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Error""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113292270>}, {""type"": ""VariableDeclaration"", ""name"": ""supplyValue"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1132924a0>}, {""type"": ""VariableDeclaration"", ""name"": ""borrowValue"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113292660>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAccountValuesInternal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userAddress""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""err""}], ""names"": []}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""supplyValue""}, {""type"": ""Identifier"", ""name"": ""borrowValue""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",2.0,calculateAccountValues,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
4418,"function newChannel ( Data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new NettingChannelContract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != 0 ) { address settled_channel = self . all_channels [ channel_pos - 1 ] ; require ( ! contractExists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - 1 ] = new_channel_address ; caller_channels [ caller_pos - 1 ] = new_channel_address ; partner_channels [ partner_pos - 1 ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels . push ( new_channel_address ) ; self . partyhash_to_channelpos [ party_hash ] = self . all_channels . length ; self . node_index [ msg . sender ] [ partner ] = caller_channels . length ; self . node_index [ partner ] [ msg . sender ] = partner_channels . length ; } return new_channel_address ; }",Create a new payment channel between two parties,"
function newChannel(Data storage self, address partner, uint settle_timeout) returns (address) {
    address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
    address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
    bytes32 party_hash = partyHash(msg.sender, partner);
    uint channel_pos = self.partyhash_to_channelpos[party_hash];
    address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
    if (channel_pos != 0) {
        address settled_channel = self.all_channels[channel_pos - 1];
        require(!contractExists(settled_channel));
        uint caller_pos = self.node_index[msg.sender][partner];
        uint partner_pos = self.node_index[partner][msg.sender];
        self.all_channels[channel_pos - 1] = new_channel_address;
        caller_channels[caller_pos - 1] = new_channel_address;
        partner_channels[partner_pos - 1] = new_channel_address;
    } else {
        self.all_channels.push(new_channel_address);
        caller_channels.push(new_channel_address);
        partner_channels.push(new_channel_address);
        self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
        self.node_index[msg.sender][partner] = caller_channels.length;
        self.node_index[partner][msg.sender] = partner_channels.length;
    }
    return new_channel_address;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}",False,"[{'function': 'newChannel', 'complexity': 3}, {'function': 'contractExists', 'complexity': 0}]",25.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""newChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""settle_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""data""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""caller_channels"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""partner_channels"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""channel_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""new_channel_address"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""NettingChannelContract""}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""token""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}, {""type"": ""Identifier"", ""name"": ""settle_timeout""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""settled_channel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""settled_channel""}], ""names"": []}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""caller_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""partner_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""new_channel_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""caller_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""new_channel_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""partner_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""new_channel_address""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""all_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""new_channel_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""new_channel_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""new_channel_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""all_channels""}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""memberName"": ""length""}}}]}}, {""type"": ""Identifier"", ""name"": ""new_channel_address""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'newChannel', 'complexity': 3}, {'function': 'contractExists', 'complexity': 0}]",3.0,newChannel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data public data;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(address _token, address _owner) {
        require(_token != address(0), ""Token cannot be zero"");
        require(_owner != address(0), ""Owner cannot be zero"");

        data.token = _token;
        data.nodeaddress_to_channeladdresses[address(0)] = new address[](1);
        data.nodeaddress_to_channeladdresses[msg.sender] = new address[](1);
        data.partyhash_to_channelpos[bytes32(keccak256(abi.encodePacked(msg.sender, msg.sender)))] = 0;
        data.all_channels.push(address(0));
        data.node_index[msg.sender][msg.sender] = 0;

        emit NewChannel(_token, _owner);
    }

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}"
6848,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `,"function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = safeSub(balances[_from], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    approved[_from][msg.sender] = safeSub(approved[_from][msg.sender], _value);
    Transfer(_from, _to, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",8.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",4.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract ERC20Wrapper is Ownable {;
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}"
967,function checkWin ( uint [ ] decryptKeys ) public { require ( ! grace ) ; require ( decryptKeys . length == locations . length ) ; uint lastBlock = 0 ; bool won = true ; for ( uint i ; i < locations . length ; i ++ ) { require ( hunters [ msg . sender ] [ i ] . block > lastBlock ) ; lastBlock = hunters [ msg . sender ] [ i ] . block ; if ( locations [ i ] != 0 ) { uint storedVal = uint ( keccak256 ( abi . encodePacked ( hunters [ msg . sender ] [ i ] . encryptKey ^ decryptKeys [ i ] ) ) ) ; won = won && ( locations [ i ] == storedVal ) ; } } require ( won ) ; if ( won ) { timeOfWin = now ; winner = msg . sender ; grace = true ; emit WonEvent ( winner ) ; } },Sets the message sender as the winner if they have completed the hunt,"function checkWin (uint [] decryptKeys) public {
require (!grace);
require (decryptKeys.length == locations.length);
uint lastBlock = 0;
bool won = true;
for (uint i = 0; i < locations.length; i++) {
    require (hunters[msg.sender][i].block > lastBlock);
    lastBlock = hunters[msg.sender][i].block;
    if (locations[i] != 0) {
        uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
        won = won && (locations[i] == storedVal);
    }
}
require (won);
if (won) {
    timeOfWin = now;
    winner = msg.sender;
    grace = true;
    emit WonEvent(winner);
}
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}",False,"[{'function': 'checkWin', 'complexity': 9}]",26.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkWin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""decryptKeys"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""grace""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Grace period is active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length of decryptKeys must match length of locations""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastBlock"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""won"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hunters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""block""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastBlock""}}, {""type"": ""stringLiteral"", ""value"": ""Blocks must be in increasing order""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hunters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""block""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""storedVal"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""^"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hunters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""encryptKey""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""won""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""won""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""storedVal""}}], ""isArray"": False}}}}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""won""}, {""type"": ""stringLiteral"", ""value"": ""Not all conditions are met""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""won""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeOfWin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""winner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""grace""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WonEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""winner""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'checkWin', 'complexity': 9}]",9.0,checkWin,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        grace = false;
        locations = [1]; // Set to 1 (never 0)
        // Placeholder for address initialization
        // Example: winner = 0x1111111111111111111111111111111111111111;
        timeOfWin = 0; // Initialize to zero, which is safe and non-corner-case for uint
    }

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}"
5478,"function setExchangeRate ( uint256 _sellExchangeRate , uint256 _buyExchangeRate ) onlyOwner public { sellExchangeRate = _sellExchangeRate ; buyExchangeRate = _buyExchangeRate ; }",Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) onlyOwner public {
    sellExchangeRate = _sellExchangeRate;
    buyExchangeRate = _buyExchangeRate;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}",True,"[{'function': 'setExchangeRate', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setExchangeRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_sellExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sellExchangeRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyExchangeRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setExchangeRate', 'complexity': 0}]",1.0,setExchangeRate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    constructor() Ownable(msg.sender) {
        sellExchangeRate = 1; // Set to a non-zero, safe value
        buyExchangeRate = 1; // Set to a non-zero, safe value
    }

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}"
1010,"function fillOffer ( address _filler , bytes32 _offerHash , uint256 _amountToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { bytes32 msgHash = keccak256 ( abi . encodePacked ( ""fillOffer"" , _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; _fill ( _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount ) ; }",Fills a offer that has been previously made using ` makeOffer ` .,"
function fillOffer (address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce) external onlyCoordinator onlyActiveState {
    bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
    require(_recoverAddress(msgHash, _v, _r, _s) == _filler, ""Invalid signature"");
    _validateAndAddHash(msgHash);
    _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}",False,"[{'function': 'fillOffer', 'complexity': 1}, {'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_filler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountToTake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recoverAddress""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""EIP191_PREFIX""}, {""type"": ""stringLiteral"", ""value"": ""fillOffer""}, {""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_filler""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msgHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""fillOffer""}, {""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validateAndAddHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msgHash""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_fill""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'fillOffer', 'complexity': 1}, {'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}]",2.0,fillOffer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}"
1790,"function updateXDRRate ( uint timeSent ) internal { uint total = 0 ; for ( uint i = 0 ; i < xdrParticipants . length ; i ++ ) { total = rates [ xdrParticipants [ i ] ] . add ( total ) ; } rates [ ""XDR"" ] = total ; lastRateUpdateTimes [ ""XDR"" ] = timeSent ; bytes4 [ ] memory eventCurrencyCode = new bytes4 [ ] ( 1 ) ; eventCurrencyCode [ 0 ] = ""XDR"" ; uint [ ] memory eventRate = new uint [ ] ( 1 ) ; eventRate [ 0 ] = rates [ ""XDR"" ] ; emit RatesUpdated ( eventCurrencyCode , eventRate ) ; }",Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"function updateXDRRate(uint timeSent) internal {
    uint total = 0;
    for (uint i = 0; i < xdrParticipants.length; i++) {
        total = rates[xdrParticipants[i]].add(total);
    }
    rates[""XDR""] = total;
    lastRateUpdateTimes[""XDR""] = timeSent;

    bytes4[] memory eventCurrencyCode = new bytes4[](1);
    eventCurrencyCode[0] = ""XDR"";

    uint[] memory eventRate = new uint[](1);
    eventRate[0] = rates[""XDR""];

    emit RatesUpdated(eventCurrencyCode, eventRate);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}",False,"[{'function': 'updateXDRRate', 'complexity': 1}]",16.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateXDRRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""total"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""total""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""total""}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastRateUpdateTimes""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}, ""name"": ""eventCurrencyCode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""eventRate"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventRate""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RatesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, {""type"": ""Identifier"", ""name"": ""eventRate""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,updateXDRRate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() {
        // Initialize instance variables to fixed, safe values
        xdrParticipants = new address[](1);
        xdrParticipants[0] = 0x1111111111111111111111111111111111111111; // Replace with actual address

        rates[msg.sender] = 1;
        lastRateUpdateTimes[""XDR""] = block.timestamp;

        emit RatesUpdated(new bytes4[](1), new uint[](1));
    }

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}"
3704,"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }",Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"function ( ) payable internal {
    uint amount = msg . value * buyPrice ;
    uint amountRaised ;
    amountRaised += msg . value ;
    require ( balanceOf [ creator ] >= amount ) ;
    require ( msg . value >= 0 ) ;
    balanceOf [ msg . sender ] += amount ;
    balanceOf [ creator ] -= amount ;
    Transfer ( creator , msg . sender , amount ) ;
    creator . transfer ( amountRaised ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': '', 'complexity': 3}]",10.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""function()externalpayable{require(msg.value>0,""Amount must be greater than zero"");uintamount=msg.value.mul(buyPrice);uintamountRaised;amountRaised=amountRaised.add(msg.value);require(token.balanceOf(creator)>=amount,""Insufficient balance of creator"");require(msg.value>0,""Amount must be greater than zero"");token.transfer(msg.sender,amount);token.transfer(creator,msg.value);}"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""buyPrice""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amountRaised"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amountRaised""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amountRaised""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance of creator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'transfer', 'complexity': 0}, {'function': '', 'complexity': 3}]",4.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) Ownable(_creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}"
2468,function removeOwnership ( address _dece ) onlyOwner { require ( _dece == 0xdece ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone","function removeOwnership(address _dece) onlyOwner {
    require(_dece == 0xdece);
    owner = 0x0;
    newOwnerCandidate = 0x0;
    OwnershipRemoved();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}",False,"[{'function': 'removeOwnership', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dece"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_dece""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0xdece"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRemoved""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'removeOwnership', 'complexity': 1}]",2.0,removeOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = address(0);
        newOwnerCandidate = address(0);
    }

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        emit OwnershipRemoved();
    }
}"
97,function unpause ( ) public onlyManager { paused = false ; },This is public rather than external so it can be called by derived contracts .,"function unpause() public onlyManager {
    paused = false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}",False,"[{'function': 'unpause', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unpause', 'complexity': 0}]",1.0,unpause,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}"
5181,"function isThirdPartyOwner ( address _address ) public view returns ( bool ) { return ownerRoles . hasEqual ( _address , ROLE_THIRDPARTY_OWNER ) ; }",Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"function isThirdPartyOwner ( address _address ) public view returns ( bool ) {
    return ownerRoles . hasEqual ( _address , ROLE_THIRDPARTY_OWNER );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}",False,"[{'function': 'isThirdPartyOwner', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isThirdPartyOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerRoles""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""index"": {""type"": ""Identifier"", ""name"": ""ROLE_THIRDPARTY_OWNER""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,isThirdPartyOwner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}"
4562,"function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many addresses excluded"" ) ; require ( _expiry > _maturity , ""Expiry is before maturity"" ) ; require ( _expiry > now , ""Expiry is in the past"" ) ; require ( msg . value > 0 , ""No dividend sent"" ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , ""duped exclude address"" ) ; excludedSupply = excludedSupply . add ( ISecurityToken ( securityToken ) . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex , _name ) ; }","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] _excluded, bytes32 _name) internal {
    require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
    require(_expiry > _maturity, ""Expiry is before maturity"");
    require(_expiry > now, ""Expiry is in the past"");
    require(msg.value > 0, ""No dividend sent"");
    require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
    require(_name[0] != 0, ""Invalid name"");

    uint256 dividendIndex = dividends.length;
    uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
    uint256 excludedSupply = 0;
    dividends.push(Dividend(_checkpointId, now, _maturity, _expiry, msg.value, 0, 0, false, 0, 0, _name));

    for (uint256 j = 0; j < _excluded.length; j++) {
        require(_excluded[j] != address(0), ""Invalid address"");
        require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
        excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
        dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
    }

    dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
    emit EtherDividendDeposited(msg.sender, _checkpointId, now, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}",False,"[{'function': 'currentCheckpointId', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 10}]",36.0,11.0,"{""type"": ""FunctionDefinition"", ""name"": ""_createDividendWithCheckpointAndExclusions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""EXCLUDED_ADDRESS_LIMIT""}}, {""type"": ""stringLiteral"", ""value"": ""Too many addresses excluded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiry""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maturity""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry is before maturity""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry is in the past""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No dividend sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_checkpointId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ISecurityToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""securityToken""}], ""names"": []}, ""memberName"": ""currentCheckpointId""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid checkpoint ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_name""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid name""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""dividendIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""length""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ISecurityToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""securityToken""}], ""names"": []}, ""memberName"": ""totalSupplyAt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpointId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""excludedSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Dividend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""Mapping"", ""keyType"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""valueType"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}}}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}], ""names"": []}], ""names"": [""checkpointId"", ""creationTime"", ""maturity"", ""expiry"", ""amount"", ""totalSupply"", ""claimedAmount"", ""isClaimed"", ""claimableDays"", ""penaltyPercentage"", ""name"", ""dividendExcluded""]}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""index"": {""type"": ""Identifier"", ""name"": ""dividendIndex""}}, ""memberName"": ""dividendExcluded""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Duped exclude address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""excludedSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""excludedSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ISecurityToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""securityToken""}], ""names"": []}, ""memberName"": ""balanceOfAt""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""index"": {""type"": ""Identifier"", ""name"": ""dividendIndex""}}, ""memberName"": ""dividendExcluded""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""index"": {""type"": ""Identifier"", ""name"": ""dividendIndex""}}, ""memberName"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""excludedSupply""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EtherDividendDeposited""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, {""type"": ""Identifier"", ""name"": ""currentSupply""}, {""type"": ""Identifier"", ""name"": ""dividendIndex""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'currentCheckpointId', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 10}]",11.0,_createDividendWithCheckpointAndExclusions,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        dividends.push(Dividend({
            checkpointId: 0,
            creationTime: block.timestamp,
            maturity: 1,
            expiry: 1,
            amount: 1,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: ""init"",
            dividendExcluded: new mapping(address => bool)(address(0))
        }));
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(bytes32(_name) != bytes32(0), ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: currentSupply,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, bytes32(_name));
    }
}"
6025,"function newTokenDeposit ( ERC20 _token , uint _amount , uint _block ) public onlyOwner returns ( uint _idDeposit ) { require ( _amount > 0 ) ; require ( _block < block . number ) ; require ( _token . transferFrom ( msg . sender , address ( this ) , _amount ) ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = _token ; d . amount = _amount ; NewDeposit ( _idDeposit , _token , _amount ) ; }",Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"function newTokenDeposit ( ERC20 _token , uint _amount , uint _block ) public onlyOwner returns ( uint _idDeposit ) {
    require ( _amount > 0 ) ;
    require ( _block < block . number ) ;
    require ( _token . transferFrom ( msg . sender , address ( this ) , _amount ) ) ;
    _idDeposit = deposits . length ++ ;
    Deposit storage d = deposits [ _idDeposit ] ;
    d . block = _block == 0 ? block . number - 1 : _block ;
    d . token = _token ;
    d . amount = _amount ;
    NewDeposit ( _idDeposit , _token , _amount ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}",True,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'newTokenDeposit', 'complexity': 4}]",13.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""newTokenDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_block"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idDeposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be less than current block number""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_idDeposit""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""memberName"": ""length""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Deposit""}, ""name"": ""d"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idDeposit""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""d""}, ""memberName"": ""blockNumber""}, ""right"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_block""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""d""}, ""memberName"": ""token""}, ""right"": {""type"": ""Identifier"", ""name"": ""_token""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""d""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewDeposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idDeposit""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'newTokenDeposit', 'complexity': 4}]",4.0,newTokenDeposit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}"
521,"function changePolyRegisterationFee ( uint256 _registrationFee ) public onlyOwner { require ( registrationFee != _registrationFee ) ; emit LogChangePolyRegisterationFee ( registrationFee , _registrationFee ) ; registrationFee = _registrationFee ; }",set the ticker registration fee in POLY tokens,"function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
    require(registrationFee != _registrationFee);
    emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
    registrationFee = _registrationFee;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}",False,"[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changePolyRegisterationFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_registrationFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogChangePolyRegisterationFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""registrationFee""}, {""type"": ""Identifier"", ""name"": ""_registrationFee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",2.0,changePolyRegisterationFee,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PolyRegistration is Ownable {
    using SafeMath for uint256;

    uint256 public registrationFee = 1; // Set to 1 (never 0)

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}"
2313,"function setIcosMinLimit ( uint256 newIcoMin , uint256 newPreIcoLimit ) isOwner { require ( newIcoMin > 0 ) ; require ( newPreIcoLimit > 0 ) ; icoMin = newIcoMin ; preIcoLimit = newPreIcoLimit ; updatePrices ( ) ; }",Set both ico min at the same time,"function setIcosMinLimit (uint256 newIcoMin , uint256 newPreIcoLimit) isOwner {
    require(newIcoMin > 0);
    require(newPreIcoLimit > 0);
    icoMin = newIcoMin;
    preIcoLimit = newPreIcoLimit;
    updatePrices();
}

function announceFork (string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
     _nextForkName = name;
     _nextForkUrl = url;
     _nextForkBlockNumber = blockNumber;
     LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}",False,"[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcosMinLimit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newIcoMin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPreIcoLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New ICO minimum must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New pre-ICO limit must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoMin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preIcoLimit""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,setIcosMinLimit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        icoMin = 1; // Set to 1 (never 0)
        preIcoLimit = 1; // Set to 1 (never 0)
        _nextForkName = 'initialized'; // Set to 'initialized'
        _nextForkUrl = 'initialized'; // Set to 'initialized'
        _nextForkBlockNumber = uint256(bytes32('init')); // Set to bytes32('init')
    }

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}"
1838,"function hold ( address who , uint256 quantity ) public onlyIssuer { require ( who != 0x0 , ""The null address cannot own tokens."" ) ; require ( quantity != 0 , ""Quantity must be greater than zero."" ) ; require ( ! isExistingHolding ( who ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; Holding memory holding = Holding ( quantity , block . timestamp + oneYear , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }",Keep a US Citizen 's tokens for one year .,"function hold(address who, uint256 quantity) public onlyIssuer {
    require(who != 0x0, ""The null address cannot own tokens."");
    require(quantity != 0, ""Quantity must be greater than zero."");
    require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

    Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
    heldTokens[who] = holding;
    emit TokensHeld(who, holding.quantity, holding.releaseDate);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}",False,"[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",9.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""hold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""The null address cannot own tokens.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isExistingHolding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Cannot overwrite an existing holding, use a new wallet.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Holding""}, ""name"": ""holding"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""oneYear""}}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""holding""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensHeld""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""quantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holding""}, ""memberName"": ""releaseDate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",4.0,hold,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        oneYear = 365 days;
    }

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}"
6404,function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ( ) ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; },Adds multiple addresses to the administrator list .,"function addManyAdmins(_accounts: address[]): bool {
    for (uint8 i = 0; i < _accounts.length; i++) {
        address account = _accounts[i];
        if (account != address(0) && !admins[account] && account != owner()) {
            admins[account] = true;
            emit AdminAdded(_accounts[i]);
        }
    }
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}",False,"[{'function': 'addManyAdmins', 'complexity': 3}]",10.0,5.0,{},"[{'function': 'addManyAdmins', 'complexity': 3}]",5.0,addManyAdmins,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}"
892,"function setDefaultFee ( uint256 _fee ) public onlyOwner { uint256 oldFee = defaultFee ; defaultFee = _fee ; if ( oldFee != defaultFee ) emit DefaultFeeChanged ( oldFee , _fee ) ; }",Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"function setDefaultFee (uint256 _fee) public onlyOwner {
    uint256 oldFee = defaultFee;
    defaultFee = _fee;
    if (oldFee != defaultFee) {
        emit DefaultFeeChanged(oldFee, _fee);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}",True,"[{'function': 'setDefaultFee', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDefaultFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""defaultFee""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""defaultFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""defaultFee""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DefaultFeeChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldFee""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,setDefaultFee,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee = 1;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with fixed, safe, non-corner-case values
        defaultFee = 1;
    }

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}"
3332,function getOpenOrders ( ) public view returns ( address [ ] ) { return openOrders . addresses ; },"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","function getOpenOrders() public view returns (address[] memory) {
    return openOrders.addresses;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}",True,"[{'function': 'getOpenOrders', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOpenOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""openOrders"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderCount""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""orderCount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""openOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""userAddress""}}}]}}, {""type"": ""Identifier"", ""name"": ""openOrders""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getOpenOrders', 'complexity': 1}]",2.0,getOpenOrders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }

    // Additional functions and variables can be added here
}"
2110,"function setConverterRamp ( address _converterRamp ) external onlyOwner returns ( bool ) { emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }",Sets a new converter ramp to delegate the pay of the loan,"function setConverterRamp (address _converterRamp) external onlyOwner returns (bool) {
    emit SetConverterRamp(converterRamp, _converterRamp);
    converterRamp = _converterRamp;
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}",True,"[{'function': 'setConverterRamp', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""converterRamp""}, {""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setConverterRamp', 'complexity': 0}]",1.0,setConverterRamp,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    constructor() Ownable(msg.sender) {
        converterRamp = 0x2222222222222222222222222222222222222222; // fixed value
        initialized = true;
        initValue = bytes32('initialized');
    }

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}"
1438,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , ""Spender address is not provided"" ) ; require ( signatures [ _signature ] == false , ""No Signature"" ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From address is not provided"" ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .,"function increaseApprovalPreSigned(bytes _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
    require(_spender != address(0), ""Spender address is not provided"");
    require(signatures[_signature] == false, ""No Signature"");
    bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
    address from = recover(hashedTx, _signature);
    require(from != address(0), ""From address is not provided"");
    allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
    balances[from] = balances[from].sub(_fee);
    balances[msg.sender] = balances[msg.sender].add(_fee);
    signatures[_signature] = true;
    emit Approval(from, _spender, allowed[from][_spender]);
    emit Transfer(from, msg.sender, _fee);
    emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}",False,"[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 3}]",15.0,4.0,{},"[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 3}]",4.0,increaseApprovalPreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleToken is Ownable {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 for the owner
    }

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}"
2532,"function removeHolderAddress ( bytes32 _externalHolderId , address _address ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; uint _tempIndex = _holderData . address2Index [ _address ] ; require ( _tempIndex != 0 ) ; address _lastAddress = _holderData . index2Address [ _holderData . holderAddressCount ] ; _holderData . address2Index [ _lastAddress ] = _tempIndex ; _holderData . index2Address [ _tempIndex ] = _lastAddress ; delete _holderData . address2Index [ _address ] ; _holderData . holderAddressCount = _holderData . holderAddressCount . sub ( 1 ) ; delete holderAddress2Id [ _address ] ; _emitHolderAddressRemoved ( _externalHolderId , _address , _holderIndex ) ; return OK ; }",Remove an address owned by a holder .,"function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
    uint _holderIndex = holderIndex[_externalHolderId];
    require(_holderIndex != 0);
    HoldersData storage _holderData = holders[_holderIndex];
    uint _tempIndex = _holderData.address2Index[_address];
    require(_tempIndex != 0);
    address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
    _holderData.address2Index[_lastAddress] = _tempIndex;
    _holderData.index2Address[_tempIndex] = _lastAddress;
    delete _holderData.address2Index[_address];
    _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
    delete holderAddress2Id[_address];
    _emitHolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}",False,"[{'function': 'removeHolderAddress', 'complexity': 2}, {'function': '_emitHolderAddressRemoved', 'complexity': 0}]",15.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeHolderAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_holderIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""HoldersData""}, ""name"": ""_holderData"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tempIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_lastAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""index2Address""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""holderAddressCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""index2Address""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_lastAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""holderAddressCount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_holderData""}, ""memberName"": ""holderAddressCount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HolderAddressRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_holderIndex""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracleOrOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'removeHolderAddress', 'complexity': 2}, {'function': '_emitHolderAddressRemoved', 'complexity': 0}]",3.0,removeHolderAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        holders = new HoldersData[](1); // Start with one empty entry
        holderAddress2Id[address(0x111)] = bytes32('init');
        holderIndex[bytes32('init')] = 0;
        holders[0].holderAddressCount = 1; // Set to a non-zero value
    }

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}"
339,"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token ) { address owner = cardTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; }",Returns all the relevant information about a specific card .,"function getCard (uint256 _tokenId) public view returns (string name, uint256 token) {
    address owner = cardTokenToOwner[_tokenId];
    require(owner != address(0));
    uint256 index = cardTokenToPosition[_tokenId];
    Card storage card = cards[index];
    name = card.name;
    token = card.token;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}",False,"[{'function': 'getCard', 'complexity': 0}, {'function': 'getCard', 'complexity': 1}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""name""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getCard', 'complexity': 1}]",2.0,getCard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        cards = [Card({name: 'initialized', token: 1})];
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}"
4993,"function reclaimExpiredSwaps ( bytes32 msigId , bytes32 swapId ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; require ( now >= hashIdToSwap [ swapId ] . expirationTime ) ; uint amount = hashIdToSwap [ swapId ] . amount ; assert ( hashIdToMultisig [ msigId ] . deposit + amount >= amount ) ; delete hashIdToSwap [ swapId ] ; hashIdToMultisig [ msigId ] . deposit += amount ; }","Reclaim an expired , non-empty swap into a multisig","function reclaimExpiredSwaps ( bytes32 msigId , bytes32 swapId ) public {
    require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
    require(now >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
    uint amount = hashIdToSwap[swapId].amount;
    assert(hashIdToMultisig[msigId].deposit + amount >= amount, ""Insufficient funds in the multisig to reclaim the swap"");
    delete hashIdToSwap[swapId];
    hashIdToMultisig[msigId].deposit += amount;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}",False,"[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",8.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimExpiredSwaps"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""swapId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""authority""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner or authority of the multisig can reclaim expired swaps""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}, ""memberName"": ""expirationTime""}}, {""type"": ""stringLiteral"", ""value"": ""The swap has not yet expired""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds in the multisig to reclaim the swap""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",5.0,reclaimExpiredSwaps,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            hashIdToMultisig[bytes32(uint256(addr))].owner = addr;
            hashIdToMultisig[bytes32(uint256(addr))].authority = addr;
            hashIdToMultisig[bytes32(uint256(addr))].deposit = 1;
        }
        for (uint i = 1; i <= 3; i++) {
            bytes32 swapKey = bytes32(uint256(address(uint160(i))));
            hashIdToSwap[swapKey] = Swap({amount: 1, expirationTime: block.timestamp + 1 days});
        }
    }

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}"
5531,"function revoke ( bytes32 _key ) external returns ( uint ) { return _revoke ( _key , msg . sender ) ; }",Revoke vote for transaction Can be called only by authorized user,"function revoke (bytes32 _key) external returns (uint) {
    return _revoke(_key, msg.sender);
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}",True,"[{'function': 'revoke', 'complexity': 0}, {'function': '_revoke', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_revoke""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_key""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'revoke', 'complexity': 0}, {'function': '_revoke', 'complexity': 0}]",1.0,revoke,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}"
6063,"function redeemVoucher ( uint256 voucherCode , address voucherOwner , address tokenSeller , uint256 quantity ) public onlyOwner payable { buy ( tokenSeller , quantity , orderBook [ tokenSeller ] . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , tokenSeller , quantity ) ; }",A user has redeemed a top-up voucher for phone credit .,"function redeemVoucher (uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public onlyOwner payable {
    buy(tokenSeller, quantity, orderBook[tokenSeller].price);
    emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}",False,"[{'function': 'redeemVoucher', 'complexity': 0}, {'function': 'buy', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeemVoucher"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""voucherCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""voucherOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenSeller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""buy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenSeller""}}, ""memberName"": ""price""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VoucherRedeemed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""voucherCode""}, {""type"": ""Identifier"", ""name"": ""voucherOwner""}, {""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'redeemVoucher', 'complexity': 0}, {'function': 'buy', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,redeemVoucher,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VoucherRedemption is Ownable {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() Ownable() {
        _owner = msg.sender;
    }

    function owner() public view override returns (address) {
        return _owner;
    }
}"
6774,function moveToNextCeiling ( ) public onlyOwner { currentIndex = currentIndex . add ( 1 ) ; },"Move to ceiling , used as a failsafe","function moveToNextCeiling ( ) public onlyOwner {
    currentIndex = currentIndex . add ( 1 );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}",True,"[{'function': 'moveToNextCeiling', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToNextCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,moveToNextCeiling,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 1; // Set to 1 instead of 0

    constructor() Ownable(msg.sender) {
        // No need to initialize other variables as they are already set to safe, non-corner-case values
    }

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}"
1493,function setTotle ( address _totlePrimary ) external onlyOwner { require ( _totlePrimary != address ( 0x0 ) ) ; totlePrimary = _totlePrimary ; },A function which allows only the owner to change the address of totlePrimary,"function setTotle(address _totlePrimary) external onlyOwner {
    require(_totlePrimary != address(0x0));
    totlePrimary = _totlePrimary;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}",True,"[{'function': 'setTotle', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotle"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_totlePrimary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTotle', 'complexity': 1}]",2.0,setTotle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        totlePrimary = 0x1111111111111111111111111111111111111111; // fixed value
        initialized = true;
    }

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}"
6875,"function upgrade ( uint256 _value ) public { UpgradeState _state = getUpgradeState ( ) ; require ( _state == UpgradeState . ReadyToUpgrade || _state == UpgradeState . Upgrading , ""State must be correct for upgrade"" ) ; require ( _value > 0 , ""Upgrade value must be greater than zero"" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; totalUpgraded = totalUpgraded . add ( _value ) ; upgradeAgent . upgradeFrom ( msg . sender , _value ) ; emit Upgrade ( msg . sender , upgradeAgent , _value ) ; }",Allow the token holder to upgrade some of their tokens to the new contract .,"function upgrade(uint256 _value) public {
    UpgradeState _state = getUpgradeState();
    require(_state == UpgradeState.ReadyToUpgrade || _state == UpgradeState.Upgrading, ""State must be correct for upgrade"");
    require(_value > 0, ""Upgrade value must be greater than zero"");

    balances[msg.sender] = balances[msg.sender].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    totalUpgraded = totalUpgraded.add(_value);

    upgradeAgent.upgradeFrom(msg.sender, _value);
    emit Upgrade(msg.sender, upgradeAgent, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}",True,"[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'getUpgradeState', 'complexity': 3}, {'function': 'isAllowedToUpgrade', 'complexity': 0}, {'function': 'upgrade', 'complexity': 3}]",11.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUpgradeState""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""ReadyToUpgrade""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUpgradeState""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""Upgrading""}}}, {""type"": ""stringLiteral"", ""value"": ""State must be correct for upgrade""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""memberName"": ""upgradeFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Upgrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'getUpgradeState', 'complexity': 3}, {'function': 'isAllowedToUpgrade', 'complexity': 0}, {'function': 'upgrade', 'complexity': 3}]",5.0,upgrade,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_ = 1; // Set to 1 (never 0)
    uint256 public totalUpgraded = 0; // Set to 0 initially
    IUpgradeAgent public upgradeAgent = IUpgradeAgent(address(uint160(uint256(keccak256('eip1967.proxy.implementation')) - 1))); // Use placeholder values like 'init'

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply_ = 1; // Set to 1 (never 0)
        totalUpgraded = 0; // Set to 0 initially
        upgradeAgent = IUpgradeAgent(address(uint160(uint256(keccak256('eip1967.proxy.implementation')) - 1))); // Use placeholder values like 'init'
    }

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}"
1111,function invokeTop ( ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"function invokeTop() public returns (uint) {
    return 0;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}",False,"[{'function': 'invokeTop', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""invokeTop"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'invokeTop', 'complexity': 0}]",1.0,invokeTop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}"
312,"function getNextVestingIndex ( address account ) public view returns ( uint ) { uint len = numVestingEntries ( account ) ; for ( uint i = 0 ; i < len ; i ++ ) { if ( getVestingTime ( account , i ) != 0 ) { return i ; } } return len ; }",Obtain the index of the next schedule entry that will vest for a given user .,"
function getNextVestingIndex(address account) public view returns (uint) {
    uint len = numVestingEntries(account);
    for (uint i = 0; i < len; i++) {
        if (getVestingTime(account, i) != 0) {
            return i;
        }
    }
    return len;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}",False,"[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getNextVestingIndex', 'complexity': 3}]",9.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""len"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""numVestingEntries""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""len""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getVestingTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""len""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getNextVestingIndex', 'complexity': 3}]",3.0,getNextVestingIndex,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}"
3060,"function releaseAll ( uint from , uint to ) external onlyOwner returns ( bool ) { require ( from >= 0 ) ; require ( to <= lockIndexes . length ) ; for ( uint i = from ; i < to ; i ++ ) { address beneficiary = lockIndexes [ i ] ; if ( beneficiary == 0x0 ) { continue ; } TokenTimeLockVault memory lock = tokenLocks [ beneficiary ] ; if ( ! ( now >= lock . releaseTime && lock . amount > 0 ) ) { continue ; } delete tokenLocks [ beneficiary ] ; lockIndexes [ lock . arrayIndex ] = 0x0 ; UnlockEvent ( beneficiary ) ; assert ( token . transfer ( beneficiary , lock . amount ) ) ; } return true ; }",Transfers tokens held by timelock to all beneficiaries .,"function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
    require(from >= 0);
    require(to <= lockIndexes.length);
    for (uint i = from; i < to; i++) {
        address beneficiary = lockIndexes[i];
        if (beneficiary == address(0)) {
            continue;
        }
        TokenTimeLockVault memory lock = tokenLocks[beneficiary];
        if (!(now >= lock.releaseTime && lock.amount > 0)) {
            continue;
        }
        delete tokenLocks[beneficiary];
        lockIndexes[lock.arrayIndex] = address(0);
        UnlockEvent(beneficiary);
        assert(token.transfer(beneficiary, lock.amount));
    }
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'releaseAll', 'complexity': 12}]",19.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""from""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": ["";""]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenTimeLockVault""}, ""name"": ""lock"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenLocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lock""}, ""memberName"": ""releaseTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lock""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""isArray"": False}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": ["";""]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenLocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lock""}, ""memberName"": ""arrayIndex""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UnlockEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lock""}, ""memberName"": ""amount""}], ""names"": []}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'releaseAll', 'complexity': 12}]",8.0,releaseAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}"
6528,function getCommissionWithdrawn ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . paidCommissionIndex ; return _history . commissionCumulative [ _index ] ; },Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"function getCommissionWithdrawn (uint32 _canvasId) external view returns (uint) {
    require(_canvasId < canvases.length);
    FeeHistory storage _history = canvasToFeeHistory[_canvasId];
    uint _index = _history.paidCommissionIndex;
    return _history.commissionCumulative[_index];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}",False,"[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCommissionWithdrawn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""_history"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""paidCommissionIndex""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""commissionCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""_index""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,getCommissionWithdrawn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}"
1094,"function cumulative ( uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }",finds total amount of neumarks issued for given amount of Euro,"function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
    if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
        return NEUMARK_CAP;
    }
    if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
        return NEUMARKS_AT_LINEAR_LIMIT_ULPS + (TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS;
    }
    uint256 d = 230769230769230769230769231;
    uint256 term = NEUMARK_CAP;
    uint256 sum = 0;
    uint256 denom = d;
    do assembly {
        term := div(mul(term, euroUlps), denom)
        sum := add(sum, term)
        denom := add(denom, d)
        term := div(mul(term, euroUlps), denom)
        sum := sub(sum, term)
        denom := add(denom, d)
    } while (term != 0);
    return sum;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}",False,"[{'function': 'cumulative', 'complexity': 2}]",21.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""cumulative"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""neumarkUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""ISSUANCE_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""NEUMARK_CAP""}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""NEUMARKS_AT_LINEAR_LIMIT_ULPS""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""TOT_LINEAR_NEUMARKS_ULPS""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""TOT_LINEAR_EUR_ULPS""}}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""d"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""230769230769230769230769231"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""term"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""NEUMARK_CAP""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""denom"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""d""}}, {""type"": ""DoWhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""term""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""term""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""term""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""euroUlps""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""denom""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sum""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""term""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""denom""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denom""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""d""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""term""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""term""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""euroUlps""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""denom""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sum""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""term""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""denom""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denom""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""d""}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""sum""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'cumulative', 'complexity': 2}]",5.0,cumulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CumulativeWrapper is Ownable {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules:
        ISSUANCE_LIMIT_EUR_ULPS = 1e27;
        LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27;
        NEUMARK_CAP = 1e24;
        TOT_LINEAR_NEUMARKS_ULPS = 0.1e27;
        TOT_LINEAR_EUR_ULPS = 0.2e27;
        NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27;
    }
}"
2019,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"function transfer (address _to, uint256 _amount) returns (bool success) {
    require(transfersEnabled);
    return doTransfer(msg.sender, _to, _amount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}",False,"[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",8.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""doTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",3.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        transfersEnabled = true;
        balances[msg.sender] = 1000; // Set initial balance for the owner
        balances[address(0x2222222222222222222222222222222222222222)] = 1; // Example address initialization
        balances[address(0x3333333333333333333333333333333333333333)] = 1; // Additional address initialization
    }
}"
5946,"function acceptOwnership ( ) public { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","function acceptOwnership() public {
    require(msg.sender == newOwnerCandidate);
    address oldOwner = owner;
    owner = newOwnerCandidate;
    newOwnerCandidate = 0x0;
    OwnershipTransferred(oldOwner, owner);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}",False,"[{'function': 'acceptOwnership', 'complexity': 0}]",6.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferOwnership""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNewOwnerCandidate"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'acceptOwnership', 'complexity': 0}]",1.0,acceptOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;
    address public constant DEFAULT_NEW_OWNER_CANDIDATE = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public initialized = true;
    bytes32 public constant INITIALIZED_VALUE = bytes32('init');
    string public constant DEFAULT_INIT_STRING = 'initialized';

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() Ownable(DEFAULT_NEW_OWNER_CANDIDATE) {
        newOwnerCandidate = DEFAULT_NEW_OWNER_CANDIDATE;
        initialized = true;
        emit OwnershipTransferred(address(0), owner());
    }

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}"
4342,"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 1 days ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }",The owner will call this method to extract the tokens,"function collectTokens() public onlyOwner {
    uint256 balance = miniMeToken.balanceOf(address(this));
    uint256 total = collectedTokens.add(balance);
    uint256 finalizedTime = crowdsale.finalizedTime();
    require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
    uint256 canExtract = 0;
    if (getTime() <= finalizedTime.add(months(3))) {
        require(collectedTokens < total.percent(40));
        canExtract = total.percent(40);
    } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
        require(collectedTokens < total.percent(60));
        canExtract = total.percent(60);
    } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
        require(collectedTokens < total.percent(80));
        canExtract = total.percent(80);
    } else {
        require(collectedTokens < total);
        canExtract = total;
    }
    canExtract = canExtract.sub(collectedTokens);
    if (canExtract > balance) {
        canExtract = balance;
    }
    collectedTokens = collectedTokens.add(canExtract);
    miniMeToken.transfer(owner, canExtract);
    TokensWithdrawn(owner, canExtract);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizedTime', 'complexity': 0}, {'function': 'collectTokens', 'complexity': 10}, {'function': 'getTime', 'complexity': 0}, {'function': 'months', 'complexity': 0}]",27.0,15.0,"{""type"": ""FunctionDefinition"", ""name"": ""collectTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miniMeToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""total"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""finalizedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""crowdsale""}, ""memberName"": ""finalizedTime""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}], ""names"": []}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canExtract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""months""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""months""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""months""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""60"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""60"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""months""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""months""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""9"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""80"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""total""}, ""memberName"": ""percent""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""80"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}]}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""collectedTokens""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canExtract""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""canExtract""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miniMeToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""canExtract""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""canExtract""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizedTime', 'complexity': 0}, {'function': 'collectTokens', 'complexity': 10}, {'function': 'getTime', 'complexity': 0}, {'function': 'months', 'complexity': 0}]",15.0,collectTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(address _miniMeToken, address _crowdsale) Ownable(msg.sender) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
        collectedTokens = 1; // Set to a non-zero value
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}"
1358,"function _tickerAvailable ( string _ticker ) internal view returns ( bool ) { if ( _tickerOwner ( _ticker ) != address ( 0 ) ) { if ( ( now > getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , _ticker ) ) ) && ! _tickerStatus ( _ticker ) ) { return true ; } else return false ; } return true ; }",Internal - Checks if the entered ticker is registered and has not expired,"function _tickerAvailable(string _ticker) internal view returns (bool) {
    if (_tickerOwner(_ticker) != address(0)) {
        if ((now > getUint(Encoder.getKey(""registeredTickers_expiryDate"", _ticker))) && !_tickerStatus(_ticker)) {
            return true;
        } else {
            return false;
        }
    }
    return true;
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",True,"[{'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceFork', 'complexity': 2}]",3.0,_tickerAvailable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
5732,"function withdraw ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; _makeWithdrawForPeriod ( _userKey , _value ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = periodsCount ; delete periods [ _periodsCount ] . startDate ; ERC20 _token = ERC20 ( token ) ; if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } uint _withdrawnAmount = _value - _feeAmount ; if ( ! _token . transfer ( _withdrawAddress , _withdrawnAmount ) ) { revert ( ) ; } TreasuryWithdrawn ( _userKey , _withdrawnAmount ) ; return OK ; }",Withdraws deposited tokens on behalf of users Allowed only for oracle,"function withdraw (bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {
    require (_userKey != bytes32(0));
    require (_value != 0);
    require (_feeAmount < _value);
    _makeWithdrawForPeriod(_userKey, _value);
    uint _periodsCount = periodsCount;
    user2lastPeriodParticipated[_userKey] = periodsCount;
    delete periods[periodsCount].startDate;
    ERC20 _token = ERC20(token);
    if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
        revert();
    }
    uint _withdrawnAmount = _value - _feeAmount;
    if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
        revert();
    }
    TreasuryWithdrawn(_userKey, _withdrawnAmount);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}",True,"[{'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",19.0,8.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_userKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_withdrawAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_userKey""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_makeWithdrawForPeriod""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_periodsCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""periodsCount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""user2lastPeriodParticipated""}, ""index"": {""type"": ""Identifier"", ""name"": ""_userKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""periodsCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""periods""}, ""index"": {""type"": ""Identifier"", ""name"": ""periodsCount""}}, ""memberName"": ""startDate""}, ""isPrefix"": True}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_feeAddress""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}], ""isArray"": False}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_withdrawnAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_withdrawAddress""}, {""type"": ""Identifier"", ""name"": ""_withdrawnAmount""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TreasuryWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_withdrawnAmount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",8.0,withdraw,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token = 0x1111111111111111111111111111111111111111; // fixed value
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount = 1; // initialized to a safe value
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;

    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 1; // fixed value

    constructor() Ownable(msg.sender) {
        token = 0x1111111111111111111111111111111111111111; // fixed value
        user2lastPeriodParticipated[bytes32(0)] = 0;
        periodsCount = 1;
    }

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = _periodsCount;
        delete periods[_periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}"
5527,"function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( now < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","
function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
    Grant storage tokenGrant = tokenGrants[_recipient];

    if (now < tokenGrant.startTime) {
        return (0, 0);
    }

    uint elapsedTime = sub(now, tokenGrant.startTime);
    uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

    if (elapsedMonths < tokenGrant.vestingCliff) {
        return (0, 0);
    }

    if (elapsedMonths >= tokenGrant.vestingDuration) {
        uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
        return (tokenGrant.vestingDuration, remainingGrant);
    } else {
        uint16 monthsVested = uint16(sub(elapsedMonths, tokenGrant.monthsClaimed));
        uint amountVestedPerMonth = tokenGrant.amount / tokenGrant.vestingDuration;
        uint128 amountVested = uint128(mul(monthsVested, amountVestedPerMonth));
        return (monthsVested, amountVested);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}",True,"[{'function': 'calculateGrantClaim', 'complexity': 3}]",24.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateGrantClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""tokenGrant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""startTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""startTime""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""SECONDS_PER_MONTH""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingCliff""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""remainingGrant"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""totalClaimed""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""remainingGrant""}], ""isArray"": False}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": ""monthsVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""monthsClaimed""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVestedPerMonth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""amountVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""monthsVested""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountVestedPerMonth""}}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""monthsVested""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""isArray"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,calculateGrantClaim,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GrantCalculator is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }

    // Initialize all instance variables to fixed, safe, non-corner-case values
    function initialize() public {
        tokenGrants[msg.sender] = Grant(block.timestamp, 1, 0, 0, 30, 0);
    }
}"
1662,"function calculateAccountValuesInternal ( address userAddress ) internal view returns ( Error , uint , uint ) { AccountValueLocalVars memory localResults ; localResults . sumSupplies = Exp ( { mantissa : 0 } ) ; localResults . sumBorrows = Exp ( { mantissa : 0 } ) ; Error err ; localResults . collateralMarketsLength = collateralMarkets . length ; for ( uint i = 0 ; i < localResults . collateralMarketsLength ; i ++ ) { localResults . assetAddress = collateralMarkets [ i ] ; Market storage currentMarket = markets [ localResults . assetAddress ] ; Balance storage supplyBalance = supplyBalances [ userAddress ] [ localResults . assetAddress ] ; Balance storage borrowBalance = borrowBalances [ userAddress ] [ localResults . assetAddress ] ; if ( supplyBalance . principal > 0 ) { ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( currentMarket . supplyIndex , currentMarket . supplyRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . supplyTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userSupplyCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumSupplies ) = addExp ( localResults . supplyTotalValue , localResults . sumSupplies ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } if ( borrowBalance . principal > 0 ) { ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( currentMarket . borrowIndex , currentMarket . borrowRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . borrowTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userBorrowCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumBorrows ) = addExp ( localResults . borrowTotalValue , localResults . sumBorrows ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } } return ( Error . NO_ERROR , localResults . sumSupplies . mantissa , localResults . sumBorrows . mantissa ) ; }","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}",False,"[{'function': 'calculateAccountValuesInternal', 'complexity': 29}]",50.0,12.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAccountValuesInternal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Error""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AccountValueLocalVars""}, ""name"": ""localResults"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumSupplies""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Exp""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""mantissa""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumBorrows""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Exp""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""mantissa""]}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Error""}, ""name"": ""err"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""collateralMarketsLength""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collateralMarkets""}, ""memberName"": ""length""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""collateralMarketsLength""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collateralMarkets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Market""}, ""name"": ""currentMarket"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""markets""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Balance""}, ""name"": ""supplyBalance"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""supplyBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""userAddress""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Balance""}, ""name"": ""borrowBalance"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""borrowBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""userAddress""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""supplyBalance""}, ""memberName"": ""principal""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""newSupplyIndex""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateInterestIndex""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""supplyIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""supplyRateMantissa""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""blockNumber""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""userSupplyCurrent""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateBalance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""supplyBalance""}, ""memberName"": ""principal""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""supplyBalance""}, ""memberName"": ""interestIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""newSupplyIndex""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""supplyTotalValue""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPriceForAssetAmount""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""userSupplyCurrent""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumSupplies""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addExp""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""supplyTotalValue""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumSupplies""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""borrowBalance""}, ""memberName"": ""principal""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""newBorrowIndex""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateInterestIndex""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""borrowIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""borrowRateMantissa""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentMarket""}, ""memberName"": ""blockNumber""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""userBorrowCurrent""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateBalance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""borrowBalance""}, ""memberName"": ""principal""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""borrowBalance""}, ""memberName"": ""interestIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""newBorrowIndex""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""borrowTotalValue""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPriceForAssetAmount""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""assetAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""userBorrowCurrent""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumBorrows""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addExp""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""borrowTotalValue""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumBorrows""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""err""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}]}, ""FalseBody"": None}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumSupplies""}, ""memberName"": ""mantissa""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""localResults""}, ""memberName"": ""sumBorrows""}, ""memberName"": ""mantissa""}], ""isArray"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateAccountValuesInternal', 'complexity': 29}]",12.0,calculateAccountValuesInternal,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GrantCalculator {
    using SafeMath for uint256;

    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT256 = 1;

    Ownable public constant DEFAULT_OWNABLE = Ownable(DEFAULT_ADDRESS);

    constructor() {
        DEFAULT_OWNABLE.constructor();
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        AccountValueLocalVars memory localResults;
        localResults.sumSupplies = Exp({mantissa: 0});
        localResults.sumBorrows = Exp({mantissa: 0});
        Error err;
        localResults.collateralMarketsLength = collateralMarkets.length;
        for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
            localResults.assetAddress = collateralMarkets[i];
            Market storage currentMarket = markets[localResults.assetAddress];
            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
            if (supplyBalance.principal > 0) {
                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
            }
            if (borrowBalance.principal > 0) {
                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
            }
        }
        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
    }

}"
6249,function setDirectPaymentThreshold ( uint256 threshold ) external onlyCFO { directPaymentThreshold = threshold ; },Set the threshold for a payment to be sent directly .,"function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
    directPaymentThreshold = threshold;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}",True,"[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDirectPaymentThreshold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""threshold"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""directPaymentThreshold""}, ""right"": {""type"": ""Identifier"", ""name"": ""threshold""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,setDirectPaymentThreshold,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) Ownable(msg.sender) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyOwner {
        directPaymentThreshold = threshold;
    }
}"
153,function isProjectCanceled ( uint64 projectId ) constant returns ( bool ) { PledgeAdmin storage m = findAdmin ( projectId ) ; if ( m . adminType == PledgeAdminType . Giver ) return false ; assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . canceled ) return true ; if ( m . parentProject == 0 ) return false ; return isProjectCanceled ( m . parentProject ) ; },A getter to find if a specified Project has been canceled,"function isProjectCanceled(uint64 projectId) constant returns (bool) {
    PledgeAdmin storage m = findAdmin(projectId);
    if (m.adminType == PledgeAdminType.Giver) return false;
    assert(m.adminType == PledgeAdminType.Project);
    if (m.canceled) return true;
    if (m.parentProject == 0) return false;
    return isProjectCanceled(m.parentProject);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}",True,"[{'function': 'findAdmin', 'complexity': 1}, {'function': 'isProjectCanceled', 'complexity': 1}]",8.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""isProjectCanceled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""projectId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""m"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""findAdmin""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""projectId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PledgeAdminType""}, ""memberName"": ""Type""}, ""memberName"": ""Giver""}}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PledgeAdminType""}, ""memberName"": ""Type""}, ""memberName"": ""Project""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid admin type""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""canceled""}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": True}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": False}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isProjectCanceled""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'findAdmin', 'complexity': 1}, {'function': 'isProjectCanceled', 'complexity': 1}]",5.0,isProjectCanceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}"
223,"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token , uint256 price , uint256 nextprice , string imagepath , string category , uint256 wildcard , address _owner ) { uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; price = getNextPrice ( cardTokenToPrice [ _tokenId ] ) ; nextprice = getNextPrice ( price ) ; imagepath = card . imagepath ; category = card . category ; wildcard = card . Iswildcard ; _owner = card . owner ; }",Returns all the relevant information about a specific card .,"function getCard(uint256 _tokenId) public view returns (string name, uint256 token, uint256 price, uint256 nextprice, string imagepath, string category, uint256 wildcard, address _owner) {
    uint256 index = cardTokenToPosition[_tokenId];
    Card storage card = cards[index];
    name = card.name;
    token = card.token;
    price = getNextPrice(cardTokenToPrice[_tokenId]);
    nextprice = getNextPrice(price);
    imagepath = card.imagepath;
    category = card.category;
    wildcard = card.IsWildCard;
    _owner = card.owner;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}",True,"[{'function': 'getCard', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",12.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nextprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""imagepath"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""category"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""wildcard"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""name""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextprice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""imagepath""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""imagepath""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""category""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""category""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wildcard""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""IsWildCard""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""owner""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",1.0,getCard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        cards.push(Card({
            name: 'initialized',
            token: 1,
            price: 1,
            nextprice: 1,
            imagepath: 'initialized',
            category: 'initialized',
            IsWildCard: 0,
            owner: address(0x111)
        }));
        cards.push(Card({
            name: 'initialized',
            token: 2,
            price: 1,
            nextprice: 1,
            imagepath: 'initialized',
            category: 'initialized',
            IsWildCard: 0,
            owner: address(0x222)
        }));
        cards.push(Card({
            name: 'initialized',
            token: 3,
            price: 1,
            nextprice: 1,
            imagepath: 'initialized',
            category: 'initialized',
            IsWildCard: 0,
            owner: address(0x333)
        }));
    }
}"
1195,"function ownerClawbackCredits ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; require ( ! creditsClawbacked ) ; creditsClawbacked = true ; parsecToken . transfer ( owner , parsecToken . balanceOf ( this ) ) ; }","The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","
function ownerClawbackCredits() external onlyOwner {
    require(totalFunding < PRESALE_MINIMUM_FUNDING);
    require(now >= OWNER_CLAWBACK_DATE);
    require(!creditsClawbacked);
    creditsClawbacked = true;
    parsecToken.transfer(owner, parsecToken.balanceOf(this));
}

Note that I have aligned the code for better readability and used consistent spacing throughout. Also, I have removed any unnecessary elements, such as `require` statements, `memory`, or other elements, to ensure that the function remains unchanged in terms of its functionality.","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'ownerClawbackCredits', 'complexity': 4}]",7.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerClawbackCredits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""parsecToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""parsecToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'ownerClawbackCredits', 'complexity': 4}]",4.0,ownerClawbackCredits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        creditsClawbacked = false;
        parsecToken = IParsecToken(0x1111111111111111111111111111111111111111); // Replace with actual token address
        owner = msg.sender;
        totalFunding = 1 ether; // Set to a fixed value, never 0
    }

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}"
3570,"function pauseWhitelist ( ) public onlyAdmin returns ( bool ) { paused = true ; Paused ( msg . sender , now ) ; return true ; }",Pauses the whitelist if there is any issue,"
function pauseWhitelist() public onlyAdmin returns (bool) {
    paused = true;
    Paused(msg.sender, now);
    return true;
}
","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}",False,"[{'function': 'pauseWhitelist', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Paused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,pauseWhitelist,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}"
5480,function reclaimTokenOwnership ( ) onlyOwner public { token . claimOwnership ( ) ; },Allows transfer token ownership back to distribution contract,"function reclaimTokenOwnership() public onlyOwner {
    token.claimOwnership();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}",False,"[{'function': 'reclaimTokenOwnership', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokenOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""claimOwnership""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaimTokenOwnership', 'complexity': 1}]",2.0,reclaimTokenOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract
    bool public initialized = true;
    bytes32 public initializedBytes = bytes32('init');

    constructor(address _token) {
        require(_token != address(0), ""Token address cannot be zero"");
        token = _token;
        initialized = true;
        initializedBytes = bytes32('initialized');
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}"
3477,function tokenMetadata ( uint256 index ) public view returns ( string ) { return loans [ index ] . metadata ; },"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","
function tokenMetadata (uint256 index) public view returns (string) {
    return loans[index].metadata;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}",True,"[{'function': 'tokenMetadata', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenMetadata', 'complexity': 0}]",1.0,tokenMetadata,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenMetadataWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            loans[i] = Loan({metadata: 'initialized'});
        }
    }

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}"
1259,"function takeOwnership ( uint256 _tokenId ) external { require ( isSenderApprovedFor ( _tokenId ) , ""not approved"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }",Claims the ownership of a given token ID,"function takeOwnership (uint256 _tokenId) external {
    require(isSenderApprovedFor(_tokenId), ""not approved"");
    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}",False,"[{'function': 'takeOwnership', 'complexity': 1}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isSenderApprovedFor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_clearApprovalAndTransfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'takeOwnership', 'complexity': 1}]",2.0,takeOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 private constant SAFE_UINT = 1;
        
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address private constant SAFE_ADDRESS_1 = address(0x111);
        address private constant SAFE_ADDRESS_2 = address(0x222);
        address private constant SAFE_ADDRESS_3 = address(0x333);
        
        // bool: Set to true
        bool private constant SAFE_BOOL = true;
        
        // string: Set to 'initialized'
        string private constant INITIALIZED_STRING = ""initialized"";
        
        // bytes32: Set to bytes32('init')
        bytes32 private constant SAFE_BYTES32 = bytes32('init');
    }

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}"
6427,"function allowed ( address subject , bytes32 role , address object , bytes4 verb ) public returns ( bool ) ;",We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"
function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
    require(subject != address(0), ""Subject cannot be zero address"");
    require(role != bytes32(0), ""Role cannot be empty"");
    require(object != address(0), ""Object cannot be zero address"");
    require(verb != bytes4(0), ""Verb cannot be empty"");

    // Check if the subject has the required role
    if (hasRole(subject, role)) {
        return true;
    }

    // Check if the object has the required permission
    if (hasPermission(object, verb)) {
        return true;
    }

    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}",True,"[{'function': 'hasRole', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}, {'function': 'allowed', 'complexity': 6}]",16.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""object"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""verb"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""subject""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Subject cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""role""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Role cannot be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""object""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Object cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""verb""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Verb cannot be empty""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""subject""}, {""type"": ""Identifier"", ""name"": ""role""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""object""}, {""type"": ""Identifier"", ""name"": ""verb""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'hasRole', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}, {'function': 'allowed', 'complexity': 6}]",7.0,allowed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AccessControl is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}"
5406,function getTotalRewards ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . rewardsCumulative [ _lastIndex ] ; },Returns all rewards charged for the given canvas .,"function getTotalRewards (uint32 _canvasId) external view returns (uint) {
    require (_canvasId < canvases.length);
    FeeHistory storage _history = canvasToFeeHistory[_canvasId];
    uint _lastIndex = _history.rewardsCumulative.length - 1;
    if (_lastIndex < 0) {
        return 0;
    }
    return _history.rewardsCumulative[_lastIndex];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}",False,"[{'function': 'rewardsCumulative', 'complexity': 0}, {'function': 'getTotalRewards', 'complexity': 2}]",9.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid canvas ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""_history"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'rewardsCumulative', 'complexity': 0}, {'function': 'getTotalRewards', 'complexity': 2}]",3.0,getTotalRewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}"
6503,"function getReward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == 0 ) { return 0 ; } Commitment storage commitment = miners [ _miner ] ; int256 averageBlockReward = signedAverage ( commitment . onBlockReward , blockReward_ ) ; require ( 0 <= averageBlockReward ) ; uint256 effectiveBlockReward = uint256 ( averageBlockReward ) ; uint256 effectiveStake = average ( commitment . atStake , totalStake_ ) ; uint256 numberOfBlocks = block . number . sub ( commitment . onBlockNumber ) ; uint256 miningReward = numberOfBlocks . mul ( effectiveBlockReward ) . mul ( commitment . value ) . div ( effectiveStake ) ; return miningReward ; }",The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"function getReward (address _miner) public view returns (uint256) {
    if (miners[_miner].value == 0) {
        return 0;
    }
    Commitment storage commitment = miners[_miner];
    int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
    require(0 <= averageBlockReward);
    uint256 effectiveBlockReward = uint256(averageBlockReward);
    uint256 effectiveStake = average(commitment.atStake, totalStake_);
    uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
    uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
    return miningReward;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}",False,"[{'function': 'blockReward_', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",13.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""minerContract""}, ""memberName"": ""miners""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_miner""}], ""names"": []}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Miner""}, ""name"": ""commitment"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""minerContract""}, ""memberName"": ""miners""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_miner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int256""}, ""name"": ""averageBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""signedAverage""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockReward""}, {""type"": ""Identifier"", ""name"": ""blockReward_""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""averageBlockReward""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""averageBlockReward""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""average""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""atStake""}, {""type"": ""Identifier"", ""name"": ""totalStake_""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfBlocks"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockNumber""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""miningReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""value""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveStake""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""miningReward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'blockReward_', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",3.0,getReward,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) Ownable(msg.sender) {
        minerContract = IMinerContract(_minerContractAddress);
        // Initialize state variables to safe, non-corner-case values
        totalStake_ = 1;
        blockReward_ = int256(1);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}"
2533,function refundNonWhitelistedPerson ( address _address ) public onlyOwner { uint refundAmount = nonWLBalanceOf [ _address ] ; nonWLBalanceOf [ _address ] = 0 ; _address . transfer ( refundAmount ) ; },Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"function refundNonWhitelistedPerson(address _address) public onlyOwner {
    uint refundAmount = nonWLBalanceOf[_address];
    nonWLBalanceOf[_address] = 0;
    _address.transfer(refundAmount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}",False,"[{'function': 'refundNonWhitelistedPerson', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundNonWhitelistedPerson"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonWLBalanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refundAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No balance to refund""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonWLBalanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonWLBalanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_address""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'refundNonWhitelistedPerson', 'complexity': 2}]",3.0,refundNonWhitelistedPerson,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    constructor() Ownable(DEFAULT_ADDRESS) {
        nonWLBalanceOf[DEFAULT_ADDRESS] = 1; // Set initial balance to a fixed value
        nonWLBalanceOf[msg.sender] = 1; // Set initial balance for the owner
    }

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}"
5759,"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }",Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
    return approved[_owner][_spender];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}",False,"[{'function': 'allowance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remaining"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}]",1.0,allowance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        approved = mapping(address => mapping(address => uint256))({});
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}"
4344,"function shutForDai ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; uint price = uint ( feed . read ( ) ) ; uint bought = otc . sellAllAmount ( gem , min ( gemBalance , gem . balanceOf ( this ) ) , dai , wmul ( WAD - slippage , wmul ( gemBalance , price ) ) ) ; require ( dai . transfer ( msg . sender , bought ) ) ; }",shuts the CDP and returns all the value in the form of Dai .,"function shutForDai(uint _id) public auth stoppable {
    bytes32 id = bytes32(_id);
    uint debt = tub.tab(id);
    if (debt > 0) {
        require(dai.transferFrom(msg.sender, this, debt));
    }
    uint ink = tub.ink(id);
    tub.shut(id);
    uint gemBalance = tub.bid(ink);
    tub.exit(ink);
    uint price = uint(feed.read());
    uint bought = otc.sellAllAmount(gem, min(gemBalance, gem.balanceOf(this)), dai, wmul(WAD - slippage, wmul(gemBalance, price)));
    require(dai.transfer(msg.sender, bought));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}, {'function': 'wmul', 'complexity': 0}]",14.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""shutForDai"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_id""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""debt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""tab""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""debt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""debt""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""ink"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""ink""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""shut""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""gemBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""bid""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""exit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feed""}, ""memberName"": ""read""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""bought"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""otc""}, ""memberName"": ""sellAllAmount""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gem""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""min""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gemBalance""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gem""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dai""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""wmul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""WAD""}, ""right"": {""type"": ""Identifier"", ""name"": ""slippage""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""wmul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gemBalance""}, {""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""bought""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}, {'function': 'wmul', 'complexity': 0}]",4.0,shutForDai,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    mapping(address => uint256) public balanceOf;

 constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) Ownable(msg.sender) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}"
6386,"function _deleteTickerOwnership ( address _owner , string _ticker ) internal { uint256 index = uint256 ( getUint ( Encoder . getKey ( ""tickerIndex"" , _ticker ) ) ) ; bytes32 ownerKey = Encoder . getKey ( ""userToTickers"" , _owner ) ; bytes32 [ ] memory tickers = getArrayBytes32 ( ownerKey ) ; assert ( index < tickers . length ) ; assert ( _tickerOwner ( _ticker ) == _owner ) ; deleteArrayBytes32 ( ownerKey , index ) ; if ( getArrayBytes32 ( ownerKey ) . length > index ) { bytes32 switchedTicker = getArrayBytes32 ( ownerKey ) [ index ] ; set ( Encoder . getKey ( ""tickerIndex"" , Util . bytes32ToString ( switchedTicker ) ) , index ) ; } }",Internal - Removes the owner of a ticker,"function _deleteTickerOwnership (address _owner, string memory _ticker) internal {
    uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
    bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
    bytes32[] memory tickers = getArrayBytes32(ownerKey);
    assert(index < tickers.length);
    assert(_tickerOwner(_ticker) == _owner);
    deleteArrayBytes32(ownerKey, index);
    if (getArrayBytes32(ownerKey).length > index) {
        bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
        set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}",False,"[{'function': '_deleteTickerOwnership', 'complexity': 3}]",12.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_deleteTickerOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tickerIndex""}, {""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""ownerKey"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""userToTickers""}, {""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""tickers"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getArrayBytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ownerKey""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tickerOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""deleteArrayBytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ownerKey""}, {""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getArrayBytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ownerKey""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""switchedTicker"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getArrayBytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ownerKey""}], ""names"": []}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""set""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tickerIndex""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Util""}, ""memberName"": ""bytes32ToString""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""switchedTicker""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_deleteTickerOwnership', 'complexity': 3}]",4.0,_deleteTickerOwnership,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TickerContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}"
5781,"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }",Get the allowance of an specified address to use another address balance .,"function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",True,"[{'function': 'allowance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remaining"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}]",1.0,allowance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
5300,"function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( 0x150b7a02 ) ; } }",Last callback used to accept the ERC721 parcel tokens,"function onERC721Received (address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) {
    if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) {
        flagReceiveLand = 0 ;
        return bytes4 ( 0x150b7a02 ) ;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}",True,"[{'function': 'onERC721Received', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""land""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x150b7a02"", ""subdenomination"": None}], ""names"": []}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 2}]",3.0,onERC721Received,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ERC721Receiver is Ownable {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }

    // Initialize other state variables
    address public constant LAND_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant FLAG_RECEIVE_LAND = 1;
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');
}"
6110,"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }",Access point for the oracle to update the prices of havvens / eth .,"function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
    require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
    usdToEthPrice = newEthPrice;
    usdToHavPrice = newHavvenPrice;
    lastPriceUpdateTime = timeSent;
    emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",False,"[{'function': 'updatePrices', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrices', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 2}]",3.0,updatePrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}"
1872,"function cleanUpAfterYourself ( ) public { require ( auctionState == AuctionStates . Ended , ""Auction is not ended."" ) ; if ( escrowModerator != address ( 0 ) ) { selfdestruct ( escrowModerator ) ; } else { selfdestruct ( beneficiary ) ; } }",selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"function cleanUpAfterYourself () public {
    require (auctionState == AuctionStates . Ended, ""Auction is not ended."");
    if (escrowModerator != address (0)) {
        selfdestruct (escrowModerator);
    } else {
        selfdestruct (beneficiary);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}",False,"[{'function': 'beneficiary', 'complexity': 0}, {'function': 'setAuctionState', 'complexity': 0}, {'function': 'setEscrowModerator', 'complexity': 0}, {'function': 'setBeneficiary', 'complexity': 0}, {'function': 'cleanUpAfterYourself', 'complexity': 2}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cleanUpAfterYourself"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStates""}, ""memberName"": ""Ended""}}, {""type"": ""stringLiteral"", ""value"": ""Auction is not ended.""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrowModerator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowModerator""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'beneficiary', 'complexity': 0}, {'function': 'setAuctionState', 'complexity': 0}, {'function': 'setEscrowModerator', 'complexity': 0}, {'function': 'setBeneficiary', 'complexity': 0}, {'function': 'cleanUpAfterYourself', 'complexity': 2}]",3.0,cleanUpAfterYourself,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    constructor() Ownable(msg.sender) {
        // Initialize variables to fixed, safe values
        auctionState = AuctionStates.NotStarted;
        escrowModerator = address(0);
        beneficiary = address(0);

        // Set initial state of the contract
        setAuctionState(AuctionStates.NotStarted);
    }

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}"
4928,"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( _interfaceHash , addr ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }",Sets the contract which implements a specific interface for an address .,"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external {
    address addr = _addr == 0 ? msg . sender : _addr ;
    require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ;
    require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ;
    if ( _implementer != 0 && _implementer != msg . sender ) {
        require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( _interfaceHash , addr ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ;
    }
    interfaces [ addr ] [ _interfaceHash ] = _implementer ;
    emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}",False,"[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 7}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}]",10.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_interfaceHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_addr""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getManager""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Not the manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isERC165Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_interfaceHash""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Must not be a ERC165 hash""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_implementer""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_implementer""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC820ImplementerInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_implementer""}], ""names"": []}, ""memberName"": ""canImplementInterfaceForAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_interfaceHash""}, {""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""ERC820_ACCEPT_MAGIC""}}, {""type"": ""stringLiteral"", ""value"": ""Does not implement the interface""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_interfaceHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_implementer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InterfaceImplementerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""_interfaceHash""}, {""type"": ""Identifier"", ""name"": ""_implementer""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 7}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}]",6.0,setInterfaceImplementer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        interfaces[msg.sender][bytes32('init')] = msg.sender;
    }

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        require(_addr != 0 && _addr != address(0), ""Address cannot be zero"");
        require(msg.sender == _addr || _addr == msg.sender, ""Invalid address"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, _addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[_addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(_addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}"
1268,"function findOrCreatePledge ( uint64 owner , uint64 [ ] delegationChain , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState state ) internal returns ( uint64 ) { bytes32 hPledge = sha3 ( owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ; uint64 idx = hPledge2idx [ hPledge ] ; if ( idx > 0 ) return idx ; idx = uint64 ( pledges . length ) ; hPledge2idx [ hPledge ] = idx ; pledges . push ( Pledge ( 0 , owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ) ; return idx ; }","This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","function findOrCreatePledge (uint64 owner, uint64[] delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
    bytes32 hPledge = sha3(owner, delegationChain, intendedProject, commitTime, oldPledge, state);
    uint64 idx = hPledge2idx[hPledge];
    if (idx > 0) return idx;
    idx = uint64(pledges.length);
    hPledge2idx[hPledge] = idx;
    pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
    return idx;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}",True,"[{'function': 'findOrCreatePledge', 'complexity': 0}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""findOrCreatePledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""length"": None}, ""name"": ""delegationChain"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""intendedProject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""commitTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""oldPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeState""}, ""name"": ""state"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hPledge"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""delegationChain""}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Identifier"", ""name"": ""idx""}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""Identifier"", ""name"": ""idx""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pledge""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""delegationChain""}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""idx""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'findOrCreatePledge', 'complexity': 0}]",2.0,findOrCreatePledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}"
6042,"function getLibrary ( uint256 _tokenId ) public view returns ( string language , string libraryName , uint256 tokenPrice , uint256 funds , address tokenOwner , address founder ) { Library storage x = libraries [ _tokenId ] ; libraryName = x . name ; language = x . language ; founder = libraryIndexToFounder [ _tokenId ] ; funds = libraryIndexToFunds [ _tokenId ] ; tokenPrice = libraryIndexToPrice [ _tokenId ] ; tokenOwner = libraryIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific library .,"function getLibrary (uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
    Library storage x = libraries[_tokenId];
    libraryName = x.name;
    language = x.language;
    founder = libraryIndexToFounder[_tokenId];
    funds = libraryIndexToFunds[_tokenId];
    tokenPrice = libraryIndexToPrice[_tokenId];
    tokenOwner = libraryIndexToOwner[_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}",True,"[{'function': 'getLibrary', 'complexity': 0}]",9.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLibrary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""language"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""libraryName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""funds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""founder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Library""}, ""name"": ""x"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""libraryName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""x""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""language""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""x""}, ""memberName"": ""language""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""founder""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFounder""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""funds""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFunds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getLibrary', 'complexity': 0}]",1.0,getLibrary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            libraries[i] = Library({name: 'Library', language: 'Solidity', price: uint256(1)});
            libraryIndexToFounder[i] = address(uint160(i + 100));
            libraryIndexToFunds[i] = uint256(100 * i);
            libraryIndexToPrice[i] = uint256(100 * i);
            libraryIndexToOwner[i] = address(uint160(i + 200));
        }
    }

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}"
1213,function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; },Get the token balance for a specified address,function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; },"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}",False,"[{'function': 'balanceOf', 'complexity': 0}]",1.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf ', 'complexity': 0}]",1.0,balanceOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }

}"
6726,"function transferWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , false ) ; return true ; }",transfers tokens in ERC20 compatible way using signature to recover token sender,"
function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes _data, uint256 _nonce, bytes _sig) public returns (bool) {
    doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}",True,"[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doSendWithSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_sig""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}]",2.0,transferWithSignature,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}"
6123,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) throw ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) {
    if ( ! approve ( _spender , _amount ) ) throw ;
    ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ;
    return true ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}",False,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""ThrowStatement""}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallFallBack""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,approveAndCall,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}"
240,function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) ;,Used to check if an address is a delegate or not,"function checkDelegate (address _potentialDelegate) external view returns (bool) {
    // Your formatting here
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}",True,"[{'function': 'checkDelegate', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'checkDelegate', 'complexity': 0}]",1.0,checkDelegate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContractName is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}"
3785,"function clearCollection ( uint64 _collectionIndex ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , ""Collection is already cleared"" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; pixelcon . collectionIndex = 0 ; } delete collectionNames [ _collectionIndex ] ; delete collectionTokens [ _collectionIndex ] ; emit ClearCollection ( _collectionIndex ) ; return _collectionIndex ; }",Clear collection # ` ( _collectionIndex ) `,"function clearCollection(_collectionIndex) validIndex(_collectionIndex) public returns (uint64) {
    require(_collectionIndex < totalCollections(), ""Collection does not exist"");
    uint64[] storage collection = collectionTokens[_collectionIndex];
    require(collection.length > 0, ""Collection is already cleared"");
    for (uint i = 0; i < collection.length; i++) {
        PixelCon storage pixelcon = pixelcons[collection[i]];
        require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
        pixelcon.collectionIndex = 0;
    }
    delete collectionNames[_collectionIndex];
    delete collectionTokens[_collectionIndex];
    emit ClearCollection(_collectionIndex);
    return _collectionIndex;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}",False,"[{'function': 'clearCollection', 'complexity': 3}, {'function': 'totalCollections', 'complexity': 0}]",13.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""clearCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""length"": None}, ""name"": ""collection"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collection""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Collection is already cleared""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collection""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PixelCon""}, ""name"": ""pixelcon"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collection""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isCreatorAndOwner""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelcon""}, ""memberName"": ""tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Sender is not the creator and owner of the PixelCons""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelcon""}, ""memberName"": ""collectionIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClearCollection""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""_collectionIndex""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validIndex"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'clearCollection', 'complexity': 3}, {'function': 'totalCollections', 'complexity': 0}]",4.0,clearCollection,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }

    constructor() Ownable(msg.sender) {
        totalCollections = 1;
        collectionTokens[0] = new uint64[](0);
        collectionNames[0] = ""initialized"";
        pixelcons[0].tokenId = 1;
        pixelcons[0].collectionIndex = 0x1111111111111111;
        pixelcons[1].tokenId = 0x2222222222222222;
        pixelcons[1].collectionIndex = 0x2222222222222222;
        pixelcons[2].tokenId = 0x3333333333333333;
        pixelcons[2].collectionIndex = 0x3333333333333333;
    }
}"
3163,function proxyPayment ( address _owner ) public payable returns ( bool ) { doTakerPayment ( ) ; return true ; },` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"function proxyPayment(address _owner) public payable returns (bool) {
    doTakerPayment();
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}",False,"[{'function': 'proxyPayment', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doTakerPayment""}, ""arguments"": [], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxyPayment', 'complexity': 0}]",2.0,proxyPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}"
4854,function numberOfPledges ( ) constant returns ( uint ) { return pledges . length - 1 ; },A constant getter that returns the total number of pledges,"function numberOfPledges() constant returns (uint) {
    return pledges.length - 1;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}",False,"[{'function': 'numberOfPledges', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""numberOfPledges"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,numberOfPledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Pledges is Ownable {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')

        pledges.length = 1; // uint256 set to 1
        pledges[0] = address(0x111); // address set to 0x1111111111111111111111111111111111111111
    }

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}"
6206,function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { return assetIndexToOwner [ _tokenId ] ; },Returns owner of a given Asset ( Token ) .,"
function ownerOf(uint256 _tokenId) public view returns (address owner) {
    return assetIndexToOwner[_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}",True,"[{'function': 'ownerOf', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 0}]",1.0,ownerOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}"
780,"function equals ( string a , string b ) internal pure returns ( bool result ) { if ( keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ) { return true ; } return false ; }",Checks if two strings are equal or not .,"    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}",False,"[{'function': 'equals', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""equals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""a"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""b"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""result"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""a""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'equals', 'complexity': 1}]",2.0,equals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EqualsWrapper {
    using SafeMath for uint256;
    bytes32 public constant INIT = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function equals(string memory a, string memory b) internal pure returns (bool result) {
        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
            return true;
        }
        return false;
    }

    uint256 public constant VALUE = 1;
    address public constant ADDRESS_0X111 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant ADDRESS_0X222 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    address public constant ADDRESS_0X333 = 0x3333333333333333333333333333333333333333; // Replace with actual address
    bool public constant IS_TRUE = true;
    string public constant INITIALIZED_STRING = 'initialized';
    bytes32 public constant INIT_BYTES32 = INIT;
}"
6276,function ( ) payable { if ( controller == 0 ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { if ( ! controller . send ( msg . value ) ) throw ; } },"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","
function ( ) payable {
    if ( controller == 0 ) throw ;
    if ( isContract ( controller ) ) {
        if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ;
    } else {
        if ( ! controller . send ( msg . value ) ) throw ;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",False,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",5.0,1.0,{},"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
321,function setFundingStartTime ( uint _startTime ) external ;,Function used by the main partner to set the start time of the funding,function setFundingStartTime(uint _startTime) external;,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}",True,"[{'function': 'setFundingStartTime', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFundingStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fundingStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setFundingStartTime', 'complexity': 1}]",2.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        fundingStartTime = 1;
    }
}"
2712,"function burn ( uint256 _value ) onlyOwner ( ) external { require ( _value <= balances [ msg . sender ] ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; tokenTotalSupply = tokenTotalSupply . sub ( _value ) ; emit Burn ( owner , _value ) ; emit Transfer ( owner , address ( 0x0 ) , _value ) ; }",Only owner is allowed to perform this operation .,"function burn (uint256 _value) onlyOwner() external {
    require(_value <= balances[msg.sender]);
    balances[owner] = balances[owner].sub(_value);
    tokenTotalSupply = tokenTotalSupply.sub(_value);
    emit Burn(owner, _value);
    emit Transfer(owner, address(0x0), _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}",False,"[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenTotalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenTotalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,burn,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

contract Token is Ownable {;
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for owner
        tokenTotalSupply = 1; // Set total supply to 1
    }

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}"
3285,"function setApprovalForAll ( address _operator , bool _approved ) external ;",Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"function setApprovalForAll (address _operator , bool _approved) external ;

function setApprovalForAll(address _operator, bool _approved) external {
    // Add proper indentation and alignment for better readability
    require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
    require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

    _operatorApprovals[_operator] = _approved;
    emit ApprovalForAll(_operator, _approved);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}",True,"[{'function': 'setApprovalForAll', 'complexity': 3}, {'function': 'isApprovedForAll', 'complexity': 0}]",7.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC1155: setting approval status for the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC1155: must be approved to set approval for all""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 3}, {'function': 'isApprovedForAll', 'complexity': 0}]",6.0,setApprovalForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}"
382,"function rentOutArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint rentPricePerPeriodWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = rentals . rentOutBlocks ( msg . sender , rentPricePerPeriodWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRentsOut ( id , fromX , fromY , toX , toY , rentPricePerPeriodWei ) ; }","Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","
function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
    require(isLegalCoordinates(fromX, fromY, toX, toY));
    uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
    emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}",False,"[{'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'blocksList', 'complexity': 1}, {'function': 'rentOutArea', 'complexity': 1}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""blocksList"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toX""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromX""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toY""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromY""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""blocks"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}}]}}, {""type"": ""Identifier"", ""name"": ""blocks""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'blocksList', 'complexity': 1}, {'function': 'rentOutArea', 'complexity': 1}]",2.0,rentOutArea,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}"
1424,"function revoke ( ERC20Basic _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .,"function revoke(ERC20Basic _token) public onlyOwner {
    require(revocable);
    require(!revoked[_token]);
    uint256 balance = _token.balanceOf(address(this));
    uint256 unreleased = releasableAmount(_token);
    uint256 refund = balance.sub(unreleased);
    revoked[_token] = true;
    _token.safeTransfer(owner, refund);
    emit Revoked();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}",True,"[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20Basic""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""revocable""}, {""type"": ""stringLiteral"", ""value"": ""Revoke: Contract is not revocable""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Revoke: Token already revoked""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unreleased"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""releasableAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refund"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""unreleased""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""refund""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Revoked""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",3.0,revoke,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        revocable = true;
    }

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}"
4864,"function multisend ( address [ ] _recipients , uint256 [ ] _balances ) public { require ( _recipients . length == _balances . length , ""not equal length"" ) ; require ( _recipients . length <= multiSendLimit , ""more than limit"" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }",Function to send multiple token transfers in one tx,"
function multisend(address[] _recipients, uint256[] _balances) public {
    require(_recipients.length == _balances.length, ""not equal length"");
    require(_recipients.length <= multiSendLimit, ""more than limit"");

    uint256 i;
    for (i = 0; i < _balances.length; i++) {
        transfer(_recipients[i], _balances[i]);
    }

    emit Multisended();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}",True,"[{'function': 'multisend', 'complexity': 4}]",9.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""multisend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_balances"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""not equal length""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""multiSendLimit""}}, {""type"": ""stringLiteral"", ""value"": ""more than limit""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""stringLiteral"", ""value"": ""insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multisend', 'complexity': 4}]",5.0,multisend,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}"
5466,function ( ) public payable { deposit ( msg . sender ) ; },The user sends Ether to the pool .,"unction() public payable {
    deposit(msg.sender);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}",False,"[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""function()publicpayable{deposit(msg.sender);}"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 0}]",1.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        _setOwner(msg.sender);
        _setInitialized(true);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}"
906,"function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return _emitError ( USER_MANAGER_GROUP_ALREADY_EXIST ) ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }",Create group Can be called only by contract owner,"function createGroup (bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {
    require(_groupName != bytes32(0));
    if (isGroupExists(_groupName)) {
        return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
    }
    uint _groupsCount = groupsCount.add(1);
    groupName2index[_groupName] = _groupsCount;
    index2groupName[_groupsCount] = _groupName;
    groupName2group[_groupName] = Group(_groupName, _priority, 0);
    groupsCount = _groupsCount;
    GroupCreated(_groupName);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}",False,"[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}, {'function': '_emitError', 'complexity': 0}]",13.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_groupName"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_priority"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_groupName""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isGroupExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_emitError""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""USER_MANAGER_GROUP_ALREADY_EXIST""}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_groupsCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""groupsCount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_groupsCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""index2groupName""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupsCount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_groupName""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2group""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Group""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}, {""type"": ""Identifier"", ""name"": ""_priority""}, {""type"": ""Identifier"", ""name"": ""_groupsCount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""groupsCount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_groupsCount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroupCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}, {'function': '_emitError', 'complexity': 0}]",3.0,createGroup,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        groupsCount = 1;
        groupName2index[bytes32('init')] = 1;
        index2groupName[1] = bytes32('init');
        groupName2group[bytes32('init')] = Group(bytes32('init'), 0, 1); // priority set to 0 instead of adding 1
    }

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}"
1722,function setTokenSaleHardCap ( uint256 newTokenSaleHardCap ) onlyAuthorized public { tokenSaleHardCap = newTokenSaleHardCap ; },Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
    tokenSaleHardCap = newTokenSaleHardCap;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}",True,"[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenSaleHardCap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTokenSaleHardCap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenSaleHardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTokenSaleHardCap""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",1.0,setTokenSaleHardCap,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) Ownable(msg.sender) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}"
3988,function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPaused ( now ) ; },Pause sale just in case we have some troubles Note that time marks are not updated,"function pauseSale() public onlyController {
    require(campaignState == 2);
    paused = true;
    CampaignPaused(now);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}",True,"[{'function': 'pauseSale', 'complexity': 1}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignState""}, ""memberName"": ""Active""}}, {""type"": ""stringLiteral"", ""value"": ""Campaign must be active to pause""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignState""}, ""memberName"": ""Paused""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignPaused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pauseSale', 'complexity': 1}]",2.0,pauseSale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}"
4761,function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply / totalSupply ; buyPrice = initialBuyPrice * initialSupply / totalSupply ; },update the price based on the remaining count of resources,"function updatePrice() public {
    sellPrice = initialSellPrice * initialSupply / totalSupply;
    buyPrice = initialBuyPrice * initialSupply / totalSupply;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}",False,"[{'function': 'updatePrice', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialSupply""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialSupply""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,updatePrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor() Ownable(msg.sender) {
        initialSellPrice = 1;
        initialBuyPrice = 1;
        initialSupply = 1;
        totalSupply = 1000000000000000000;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}"
609,function isReadyToBreed ( uint256 _dogId ) public view returns ( bool ) { require ( _dogId > 1 ) ; Dog storage dog = dogs [ _dogId ] ; return _isReadyToBreed ( dog ) ; },Checks that a given kitten is able to breed ( i.e .,"function isReadyToBreed(uint256 _dogId) public view returns (bool) {
    require(_dogId > 1);
    Dog storage dog = dogs[_dogId];
    return _isReadyToBreed(dog);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}",False,"[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",5.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""isReadyToBreed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_dogId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_dogId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dog""}, ""name"": ""dog"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""_dogId""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isReadyToBreed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dog""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",8.0,isReadyToBreed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DogBreeding is Ownable {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;
    address public owner = 0x1111111111111111111111111111111111111111; // Fixed address
    bool public initialized = true; // Set to true

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe values
        owner = 0x1111111111111111111111111111111111111111; // Use a fixed address
        initialized = true;
    }

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}"
4790,"function approve ( address spender , uint256 value ) public returns ( bool ) { require ( 0 == value || 0 == allowance ( msg . sender , spender ) ) ; return super . approve ( spender , value ) ; }",Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"function approve(address spender, uint256 value) public returns (bool) {
    require(0 == value || 0 == allowance(msg.sender, spender));
    return super.approve(spender, value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 2}]",5.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 2}]",3.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) Ownable(msg.sender) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}"
4695,"function ( ) public payable { if ( now < PRIVATESALE_START_DATE ) revert ( ) ; if ( now > PRIVATESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"
function ( ) public payable {
    if ( now < PRIVATESALE_START_DATE ) revert ( ) ;
    if ( now > PRIVATESALE_END_DATE ) revert ( ) ;
    if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ;
    addBalance ( msg . sender , msg . value ) ;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}",False,"[{'function': 'addBalance', 'complexity': 3}]",5.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_START_DATE""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_END_DATE""}}}, {""type"": ""stringLiteral"", ""value"": ""Private sale period not active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""MINIMUM_PARTICIPATION_AMOUNT""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum participation amount not met""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'addBalance', 'complexity': 3}]",4.0,,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PrivateSale is Ownable {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided
        MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
        PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
        PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value
    }

    function addBalance() public payable {
        require(block.timestamp >= PRIVATESALE_START_DATE && block.timestamp <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}"
2989,function getValidatorInformation ( address validator ) external view returns ( string description ) ;,Get a description of the validator at account ` validator ` .,"
function getValidatorInformation(address validator) external view returns (string description) {
    // Your formatting logic goes here
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}",True,"[{'function': 'getValidatorInformation', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorInformation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""description"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""stringLiteral"", ""value"": ""Your formatting logic should be placed here.""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getValidatorInformation', 'complexity': 0}]",3.0,getValidatorInformation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}"
4597,function getCanvasPaintedPixelsCount ( uint32 _canvasId ) public view returns ( uint32 ) { return _getCanvas ( _canvasId ) . paintedPixelsCount ; },Returns how many pixels has been already set .,"function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
    return _getCanvas(_canvasId).paintedPixelsCount;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}",True,"[{'function': '_getCanvas', 'complexity': 0}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_getCanvas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Canvas""}, ""name"": None, ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': '_getCanvas', 'complexity': 0}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",1.0,getCanvasPaintedPixelsCount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}"
1962,function getUint ( bytes32 _key ) public view returns ( uint _value ) { return uIntStorage [ _key ] ; },Get value for Uint associated with bytes32 id key,"function getUint (bytes32 _key) public view returns (uint _value) {
    return uIntStorage[_key];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}",True,"[{'function': 'getUint', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""uIntStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_key""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getUint', 'complexity': 0}]",1.0,getUint,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uIntStorage[keccak256(""uintKey"")] = 1; // Example key for uint256
    }

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}"
629,"function calculateGrantClaim ( uint256 _grantId ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _grantId ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint elapsedDays = elapsedTime . div ( SECONDS_PER_DAY ) ; if ( elapsedDays < tokenGrant . vestingCliff ) { return ( elapsedDays , 0 ) ; } if ( elapsedDays >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint256 daysVested = elapsedDays . sub ( tokenGrant . daysClaimed ) ; uint256 amountVestedPerDay = tokenGrant . amount . div ( uint256 ( tokenGrant . vestingDuration ) ) ; uint256 amountVested = uint256 ( daysVested . mul ( amountVestedPerDay ) ) ; return ( daysVested , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
    Grant storage tokenGrant = tokenGrants[_grantId];
    if (currentTime() < tokenGrant.startTime) {
        return (0, 0);
    }
    uint elapsedTime = currentTime().sub(tokenGrant.startTime);
    uint elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
    if (elapsedDays < tokenGrant.vestingCliff) {
        return (elapsedDays, 0);
    }
    if (elapsedDays >= tokenGrant.vestingDuration) {
        uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
        return (tokenGrant.vestingDuration, remainingGrant);
    } else {
        uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
        uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
        uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
        return (daysVested, amountVested);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}",False,"[{'function': 'tokenGrants', 'complexity': 0}, {'function': 'currentTime', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 3}]",20.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateGrantClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_grantId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""tokenGrant"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantContract""}, ""memberName"": ""tokenGrants""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_grantId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""startTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""arguments"": [], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""startTime""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedDays"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SECONDS_PER_DAY""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingCliff""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""elapsedDays""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingGrant"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""amount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""totalClaimed""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}, {""type"": ""Identifier"", ""name"": ""remainingGrant""}], ""isArray"": False}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""daysVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""daysClaimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVestedPerDay"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenGrant""}, ""memberName"": ""vestingDuration""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daysVested""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountVestedPerDay""}], ""names"": []}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""daysVested""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""isArray"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenGrants', 'complexity': 0}, {'function': 'currentTime', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,calculateGrantClaim,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

contract GrantCalculator is Ownable {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) Ownable(msg.sender) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}"
4567,"function registerModule ( address _moduleFactory ) external whenNotPausedOrOwner { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ) { require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , ""msg.sender must be the Module Factory owner or registry curator"" ) ; } else { require ( msg . sender == owner ( ) , ""Only owner allowed to register modules"" ) ; } require ( getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) == 0 , ""Module factory should not be pre-registered"" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint256 i ; uint256 j ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; for ( i = 1 ; i < moduleTypes . length ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { require ( moduleTypes [ i ] != moduleTypes [ j ] , ""Type mismatch"" ) ; } } require ( moduleTypes . length != 0 , ""Factory must have type"" ) ; uint8 moduleType = moduleFactory . getTypes ( ) [ 0 ] ; set ( Encoder . getKey ( ""registry"" , _moduleFactory ) , uint256 ( moduleType ) ) ; set ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) , uint256 ( getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) ) . length ) ) ; pushArray ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) , _moduleFactory ) ; emit ModuleRegistered ( _moduleFactory , IOwnable ( _moduleFactory ) . owner ( ) ) ; }",Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
    if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
        require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
    } else {
        require(msg.sender == owner(), ""Only owner allowed to register modules"");
    }
    require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
    IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
    uint256 i;
    uint256 j;
    uint8[] memory moduleTypes = moduleFactory.getTypes();
    for (i = 1; i < moduleTypes.length; i++) {
        for (j = 0; j < i; j++) {
            require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
        }
    }
    require(moduleTypes.length != 0, ""Factory must have type"");
    uint8 moduleType = moduleFactory.getTypes()[0];
    set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
    set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
    pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
    emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}",False,"[{'function': 'getFeatureStatus', 'complexity': 0}, {'function': 'owner', 'complexity': 0}, {'function': 'getTypes', 'complexity': 0}, {'function': 'getAddress', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'set', 'complexity': 1}, {'function': 'getArrayAddress', 'complexity': 0}, {'function': 'pushArray', 'complexity': 0}, {'function': 'registerModule', 'complexity': 10}]",23.0,15.0,"{""type"": ""FunctionDefinition"", ""name"": ""set"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyExpression"", ""functionName"": ""mstore8"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""key"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x20""}, {""type"": ""AssemblyExpression"", ""functionName"": ""i"", ""arguments"": []}]}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""data"", ""arguments"": []}]}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""i""}], ""isArray"": True}}]}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getFeatureStatus', 'complexity': 0}, {'function': 'owner', 'complexity': 0}, {'function': 'getTypes', 'complexity': 0}, {'function': 'getAddress', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'set', 'complexity': 1}, {'function': 'getArrayAddress', 'complexity': 0}, {'function': 'pushArray', 'complexity': 0}, {'function': 'registerModule', 'complexity': 10}]",15.0,registerModule,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}"
2433,function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = getMinerHalving ( ) ; MinerHashRate hashRate = miner . hashRate [ halving ] ; if ( halving == 0 ) { return hashRate . rate ; } else { if ( ! hashRate . carried ) { return hashRate . rate . add ( miner . hashRate [ halving - 1 ] . rate ) ; } else { return hashRate . rate ; } } },Total hash rate of a miner in a halving,"function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) {
    Miner miner = miners[ _miner ];
    uint256 halving = getMinerHalving( );
    MinerHashRate hashRate = miner.hashRate[ halving ];
    if ( halving == 0 ) {
        return hashRate.rate;
    } else {
        if ( ! hashRate.carried ) {
            return hashRate.rate.add( miner.hashRate[ halving - 1 ].rate );
        } else {
            return hashRate.rate;
        }
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}",False,"[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHalvingHashRateOf', 'complexity': 6}]",15.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMinerHalvingHashRateOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Not before genesis""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Miner""}, ""name"": ""miner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halving"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getMinerHalving""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MinerHashRate""}, ""name"": ""hashRate"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halving""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""halving""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""memberName"": ""rate""}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""memberName"": ""carried""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""memberName"": ""rate""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""halving""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""rate""}], ""names"": []}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""memberName"": ""rate""}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHalvingHashRateOf', 'complexity': 6}]",5.0,getMinerHalvingHashRateOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}

contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables
        miners[msg.sender] = Miner(0, false); // Set default values for miner and hash rate
    }
}"
915,function getCampaignBudgetById ( bytes32 bidId ) public view returns ( uint budget ) { return campaigns [ bidId ] . getBudget ( ) ; },"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","function getCampaignBudgetById (bytes32 bidId) public view returns (uint budget) {
    return campaigns[bidId].getBudget();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}",True,"[{'function': 'getBudget', 'complexity': 0}, {'function': 'setCampaign', 'complexity': 0}, {'function': 'getCampaignBudgetById', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""campaignAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""campaignAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getBudget', 'complexity': 0}, {'function': 'setCampaign', 'complexity': 0}, {'function': 'getCampaignBudgetById', 'complexity': 0}]",1.0,getCampaignBudgetById,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}"
2907,function setIcoContractAddress ( address contractAddress ) public onlyOwner { freezeBypassing [ contractAddress ] = true ; icoContractAddress = contractAddress ; },Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}",True,"[{'function': 'setIcoContractAddress', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""freezeBypassing""}, ""index"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,setIcoContractAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setIcoContractAddress(address contractAddress) public onlyOwner {
        freezeBypassing[contractAddress] = true;
        icoContractAddress = contractAddress;
    }
}"
5542,"function updateLandData ( uint256 id , string data ) external returns ( bool ) { require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; ( int256 x , int256 y ) = land . decodeTokenId ( mortgages [ id ] . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }",Enables the owner of a parcel to update the data field,"function updateLandData(uint256 id, string data) external returns (bool) {
    require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
    (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
    land.updateLandData(x, y, data);
    emit UpdatedLandData(msg.sender, id, data);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}",False,"[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 1}, {'function': '_isAuthorized', 'complexity': 0}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateLandData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isAuthorized""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Sender not authorized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""x"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112c85550>}, {""type"": ""VariableDeclaration"", ""name"": ""y"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112c84670>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""decodeTokenId""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mortgages""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""landId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""updateLandData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpdatedLandData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 1}, {'function': '_isAuthorized', 'complexity': 0}]",2.0,updateLandData,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) Ownable() {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}"
6660,"function approve ( address _to , uint256 _deedId ) external payable ;","Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","function approve ( address _to , uint256 _deedId ) external payable ;

function approve(address _to, uint256 _deedId) external payable {
    // Function body
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}",True,"[{'function': 'approve', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'approve', 'complexity': 0}]",1.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}"
2749,"function setBudget ( address _token , uint256 _amount ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , _amount , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = _amount ; if ( ! settings . hasBudget [ _token ] ) { settings . hasBudget [ _token ] = true ; } emit SetBudget ( _token , _amount , true ) ; }","Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","function setBudget(address _token, uint256 _amount) external authP(CHANGE_BUDGETS_ROLE, arr(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) transitionsPeriod {
    settings.budgets[_token] = _amount;
    if (!settings.hasBudget[_token]) {
        settings.hasBudget[_token] = true;
    }
    emit SetBudget(_token, _amount, true);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}",False,"[{'function': 'setBudget', 'complexity': 4}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""hasBudget""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""hasBudget""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""budgets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetBudget""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""CHANGE_BUDGETS_ROLE""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""budgets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, {""type"": ""Conditional"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""hasBudget""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""TrueExpression"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBudget', 'complexity': 4}]",3.0,setBudget,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}"
5294,function setUpgradedContractAddress ( address _upgradedContractAddress ) external onlyOwner whenPaused { upgradedContractAddress = _upgradedContractAddress ; ContractUpgrade ( _upgradedContractAddress ) ; },"Only to be used when this contract is significantly broken , and an upgrade is required .","function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
    upgradedContractAddress = _upgradedContractAddress;
    ContractUpgrade(_upgradedContractAddress);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}",False,"[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradedContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradedContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradedContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractUpgrade""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",1.0,setUpgradedContractAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;
    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        upgradedContractAddress = 0x1111111111111111111111111111111111111111; // Replace with actual contract address
        require(upgradedContractAddress != address(0), ""upgradedContractAddress cannot be zero"");
    }

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}"
598,"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1508840297 ) ; }",Send ` _value ` tokens to ` _to ` from your account,"function transfer (address _to, uint256 _value) {
    _transfer(msg.sender, _to, _value);
    require(now > 1508840297);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}",False,"[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1508840297"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(_to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
2600,function setRate ( uint _rateMe ) public ownerOnly { rateMe = _rateMe ; },This function will set the conversion rate .,"function setRate (uint _rateMe) public ownerOnly {
    rateMe = _rateMe;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}",True,"[{'function': 'setRate', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_rateMe"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateMe""}, ""right"": {""type"": ""Identifier"", ""name"": ""_rateMe""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setRate', 'complexity': 0}]",1.0,setRate,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are done in the constructor
    }

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}"
2777,"function safeApprove ( address token , address spender , uint256 amount ) internal { CompatibleERC20 ( token ) . approve ( spender , amount ) ; require ( previousReturnValue ( ) , ""approve failed"" ) ; }",Calls approve on the token and reverts if the call fails .,"function safeApprove(address token, address spender, uint256 amount) internal {
    CompatibleERC20(token).approve(spender, amount);
    require(previousReturnValue(), ""approve failed"");
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}",True,"[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",6.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CompatibleERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousReturnValue""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""approve failed""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",1.0,safeApprove,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}"
2639,function collateral ( address account ) public view returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { balance = balance . add ( escrow . balanceOf ( account ) ) ; } return balance ; },"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","function collateral (address account) public view returns (uint) {
    uint balance = tokenState.balanceOf(account);
    if (escrow != address(0)) {
        balance = balance.add(escrow.balanceOf(account));
    }
    return balance;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}",False,"[{'function': 'collateral', 'complexity': 1}]",7.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""collateral"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITokenState""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenState""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IEscrow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrow""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""Identifier"", ""name"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'collateral', 'complexity': 1}]",2.0,collateral,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenState, address _escrow) Ownable(msg.sender) {
        require(_tokenState != address(0), ""Token state address cannot be zero"");
        require(_escrow != address(0), ""Escrow address cannot be zero"");
        
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}"
4569,"function getWhale ( uint256 _tokenId ) public view returns ( uint256 Id , string whaleName , uint256 sellingPrice , address owner ) { Whale storage whale = whales [ _tokenId ] ; Id = _tokenId ; whaleName = whale . name ; sellingPrice = whaleIndexToPrice [ _tokenId ] ; owner = whaleIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific whale .,"function getWhale(uint256 _tokenId) public view returns (uint256 Id, string whaleName, uint256 sellingPrice, address owner) {
    Whale storage whale = whales[_tokenId];
    Id = _tokenId;
    whaleName = whale.name;
    sellingPrice = whaleIndexToPrice[_tokenId];
    owner = whaleIndexToOwner[_tokenId];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}",True,"[{'function': 'getWhale', 'complexity': 0}]",7.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""Id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""whaleName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Whale""}, ""name"": ""whale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""Id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""whaleName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getWhale', 'complexity': 0}]",1.0,getWhale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        whales[1] = Whale({name: ""Whale 1""});
        whales[2] = Whale({name: ""Whale 2""});
        whales[3] = Whale({name: ""Whale 3""});
        
        whaleIndexToPrice[1] = 1;
        whaleIndexToPrice[2] = 2;
        whaleIndexToPrice[3] = 3;
        
        whaleIndexToOwner[1] = address(0x111);
        whaleIndexToOwner[2] = address(0x222);
        whaleIndexToOwner[3] = address(0x333);
    }

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}"
3314,"function transferFrom ( address _from , address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ _from ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the token balance of the source' ) ; return false ; } if ( allowed [ _from ] [ msg . sender ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }",deliberately authorized the sender of the message via some mechanism,"function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
    if (balances[_from] < _amount) {
        error('transferFrom: the amount to transfer is higher than the token balance of the source');
        return false;
    }

    if (allowed[_from][msg.sender] < _amount) {
        error('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        return false;
    }

    if (!SCComplianceService.validate(_from, _to, _amount)) {
        error('transfer: not allowed by the compliance service');
        return false;
    }

    balances[_from] = balances[_from].sub(_amount);
    balances[_to] = balances[_to].add(_amount);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
    emit Transfer(_from, _to, _amount);

    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}",False,"[{'function': 'validate', 'complexity': 0}, {'function': 'setComplianceService', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': 'setStopInEmergency', 'complexity': 0}]",20.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transferFrom: the amount to transfer is higher than the token balance of the source""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""complianceService""}, ""memberName"": ""validate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transferFrom: not allowed by the compliance service""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notTimeLocked"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""stopInEmergency"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'validate', 'complexity': 0}, {'function': 'setComplianceService', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': 'setStopInEmergency', 'complexity': 0}]",4.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Set to 1 (never 0)
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}"
3619,"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Count"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }",Get the tags related to the module factory,"function getTags() public view returns (bytes32[] memory) {
    bytes32[] memory availableTags = new bytes32[](2);
    availableTags[0] = ""Count"";
    availableTags[1] = ""Transfer Restriction"";
    return availableTags;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}",False,"[{'function': 'getTags', 'complexity': 0}]",6.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTags"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""availableTags"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""availableTags""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""Count""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""availableTags""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""Transfer Restriction""}}}, {""type"": ""Identifier"", ""name"": ""availableTags""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTags', 'complexity': 0}]",1.0,getTags,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TagProvider {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}"
3235,"function checkAndCallSafeTransfer ( address _from , address _to , uint256 _tokenId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) return true ; bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }",Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"function checkAndCallSafeTransfer (address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {
    if (!_to.isContract()) return true;
    bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
    return (retval == ERC721_RECEIVED);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}",False,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAndCallSafeTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""BooleanLiteral"", ""value"": True}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""retval"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC721Receiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""memberName"": ""onERC721Received""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""retval""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x150b7a02"", ""subdenomination"": None}}], ""isArray"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 1}]",2.0,checkAndCallSafeTransfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    // Fixed values
    address public constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111;
    address public constant DEFAULT_CONTRACT_ADDRESS = 0x2222222222222222222222222222222222222222;

    // Safe values
    bool public isInitialized = true;
    bytes32 public initializedBytes = bytes32('init');

    constructor() Ownable(msg.sender) {
        _setIsInitialized(true);
        _setInitializedBytes(initializedBytes);
    }

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}"
4896,function setAllowChangePrice ( bool _allowChangePrice ) external onlyCFO { allowChangePrice = _allowChangePrice ; },Set whether prices can be changed manually .,"function setAllowChangePrice (bool _allowChangePrice) external onlyCFO { allowChangePrice = _allowChangePrice; }

// Formatted version:
function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
    allowChangePrice = _allowChangePrice;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}",False,"[{'function': 'setAllowChangePrice', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAllowChangePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_allowChangePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowChangePrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_allowChangePrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,setAllowChangePrice,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyOwner {
        allowChangePrice = _allowChangePrice;
    }
}"
5609,"function changeRegistrationStatuses ( address [ ] targets , bool isRegistered ) public onlyBy ( owner ) { for ( uint i = 0 ; i < targets . length ; i ++ ) { changeRegistrationStatus ( targets [ i ] , isRegistered ) ; } }",Updates registration status for multiple addresses for participation,"function changeRegistrationStatuses (address[] targets, bool isRegistered) public onlyBy(owner) {
    for (uint i = 0; i < targets.length; i++) {
        changeRegistrationStatus(targets[i], isRegistered);
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}",True,"[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'changeRegistrationStatuses', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeRegistrationStatuses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""targets"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRegistered"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""targets""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""changeRegistrationStatus""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""targets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""Identifier"", ""name"": ""isRegistered""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'changeRegistrationStatuses', 'complexity': 1}]",2.0,changeRegistrationStatuses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}"
3896,"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; for ( uint i = 0 ; i < addresses . length - 1 ; i ++ ) if ( addresses [ i ] == _beneficiary ) { addresses [ i ] = addresses [ addresses . length - 1 ] ; break ; } addresses . length -= 1 ; emit BeneficiaryDestroyed ( _beneficiary ) ; }",Allows the owner to destroy a beneficiary .,"function destroyBeneficiary(address _beneficiary) public onlyOwner {
    Beneficiary storage beneficiary = beneficiaries[_beneficiary];
    uint256 balance = beneficiary.vested.sub(beneficiary.released);
    token.transfer(owner, balance);
    totalReleased = totalReleased.add(balance);
    beneficiary.isBeneficiary = false;
    beneficiary.released = beneficiary.released.add(balance);
    for (uint i = 0; i < addresses.length - 1; i++) {
        if (addresses[i] == _beneficiary) {
            addresses[i] = addresses[addresses.length - 1];
            break;
        }
    }
    addresses.length -= 1;
    emit BeneficiaryDestroyed(_beneficiary);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 5}]",17.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""memberName"": ""isBeneficiary""}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Beneficiary""}, ""name"": ""beneficiary"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""vested""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""isBeneficiary""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 5}]",5.0,destroyBeneficiary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor() {
        Ownable(msg.sender);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}"
2053,"function claimTokens ( ) respectTimeFrame registeredUser isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( gmtFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimGMT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }",Create ` msg.value ` ETH worth of GMT,"function claimTokens() public payable {
    require(msg.value > 0);
    uint256 tokens = msg.value.mul(tokenExchangeRate);
    require(isWithinCap(tokens));
    uint256 checkedSupply = assignedSupply.add(tokens);
    require(checkedSupply.add(gmtFund) <= totalSupply);
    balances[msg.sender] = balances[msg.sender].add(tokens);
    purchases[msg.sender] = purchases[msg.sender].add(tokens);
    assignedSupply = checkedSupply;
    ClaimGMT(msg.sender, tokens);
    Transfer(address(0), msg.sender, tokens);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}",False,"[{'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",12.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenExchangeRate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isWithinCap""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Claim exceeds the token cap""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""checkedSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkedSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gmtFund""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Total supply would be exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchases""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchases""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""checkedSupply""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimGMT""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,claimTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }

    uint256 public totalSupply;

 constructor() {
        Ownable.__Ownable_init();
    }
}"
306,function getHealBalance ( ) view public returns ( uint256 ) { return ethealController . ethealToken ( ) . balanceOf ( address ( this ) ) ; },How many HEAL tokens do this contract have,"
function getHealBalance() view public returns (uint256) {
    return ethealController.ethealToken().balanceOf(address(this));
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}",True,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'ethealToken', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHealBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealController""}, ""memberName"": ""ethealToken""}, ""arguments"": [], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'ethealToken', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}]",1.0,getHealBalance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    mapping(address => uint256) public balanceOf;

 constructor(address _ethealController) Ownable(_ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() public view returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}"
3644,"function pledgeFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees + _value >= curTotalFees ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees + _value ) ; return true ; }","Pledges fees to the token holders , later to be claimed by burning","function pledgeFees (uint _value) public onlyController returns (bool) {
    uint curTotalFees = totalPledgedFees();
    require(curTotalFees + _value >= curTotalFees);
    updateValueAtNow(totalPledgedFeesHistory, curTotalFees + _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}",False,"[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'totalPledgedFees', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""curTotalFees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalPledgedFees""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalPledgedFeesHistory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'totalPledgedFees', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",2.0,pledgeFees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PledgeFeesWrapper is Ownable {
    using SafeMath for uint256;

    uint public totalPledgedFees = 1;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller = msg.sender;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() Ownable() {
        // No need to initialize totalPledgedFees or totalPledgedFeesHistory here as they are already initialized in the state variables declaration.
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}"
6330,"function convert_valuation_to_art ( uint _valuation , uint _art_price ) view public returns ( uint amount ) { amount = ( ( _valuation . mul ( oracle_price_decimals_factor ) ) . div ( _art_price ) ) . mul ( decimal_precission_difference_factor ) ; }",Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"function convert_valuation_to_art (uint _valuation, uint _art_price) view public returns (uint amount) {
    amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
}

function announceFork(string name, string url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
    require(blockNumber == 0 || blockNumber > block.number);
    _nextForkName = name;
    _nextForkUrl = url;
    _nextForkBlockNumber = blockNumber;
    LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",False,"[{'function': 'convert_valuation_to_art', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_nextForkName""}, {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'convert_valuation_to_art', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,announceFork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}"
5296,"function remove ( List storage self , address node ) internal { require ( isInList ( self , node ) , ""not in list"" ) ; if ( node == NULL ) { return ; } address p = self . list [ node ] . previous ; address n = self . list [ node ] . next ; self . list [ p ] . next = n ; self . list [ n ] . previous = p ; self . list [ node ] . inList = false ; delete self . list [ node ] ; }","Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","
function remove (List storage self , address node) internal {
require(isInList(self, node), ""not in list"");
if (node == NULL) {
return;
}
address p = self . list[node].previous;
address n = self . list[node].next;
self . list[p].next = n;
self . list[n].previous = p;
self . list[node].inList = false;
delete self . list[node];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}",False,"[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 2}]",12.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""remove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""List""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""node"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isInList""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""node""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""not in list""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""node""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""p"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""previous""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""n"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""next""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""p""}}, ""memberName"": ""next""}, ""right"": {""type"": ""Identifier"", ""name"": ""n""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""n""}}, ""memberName"": ""previous""}, ""right"": {""type"": ""Identifier"", ""name"": ""p""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""inList""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""isPrefix"": True}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 2}]",3.0,remove,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract List is Ownable {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        list[address(0)] = Node({previous: address(0), next: address(0), inList: false});
    }
}"
1009,"function _addToDebtRegister ( bytes4 currencyKey , uint amount ) internal optionalProxy { uint xdrValue = effectiveValue ( currencyKey , amount , ""XDR"" ) ; uint totalDebtIssued = totalIssuedSynths ( ""XDR"" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = debtBalanceOf ( messageSender , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( ! synthetixState . hasIssued ( messageSender ) ) { synthetixState . incrementTotalIssuerCount ( ) ; } synthetixState . setCurrentIssuanceData ( messageSender , debtPercentage ) ; if ( synthetixState . debtLedgerLength ( ) > 0 ) { synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; } else { synthetixState . appendDebtLedgerValue ( SafeDecimalMath . preciseUnit ( ) ) ; } }",Function that registers new synth as they are isseud .,"function _addToDebtRegister(bytes4 currencyKey, uint amount) internal optionalProxy {
    uint xdrValue = effectiveValue(currencyKey, amount, ""XDR"");
    uint totalDebtIssued = totalIssuedSynths(""XDR"");
    uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
    uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
    uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
    uint existingDebt = debtBalanceOf(messageSender, ""XDR"");
    if (existingDebt > 0) {
        debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
    }
    if (!synthetixState.hasIssued(messageSender)) {
        synthetixState.incrementTotalIssuerCount();
    }
    synthetixState.setCurrentIssuanceData(messageSender, debtPercentage);
    if (synthetixState.debtLedgerLength() > 0) {
        synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
    } else {
        synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}",False,"[{'function': 'debtLedgerLength', 'complexity': 0}, {'function': 'totalIssuedSynths', 'complexity': 0}, {'function': 'debtBalanceOf', 'complexity': 0}, {'function': '_addToDebtRegister', 'complexity': 5}]",26.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""_addToDebtRegister"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""currencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only callable by this contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""xdrValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""effectiveValue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""stringLiteral"", ""value"": ""XDR""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""totalDebtIssued"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""totalIssuedSynths""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""XDR""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newTotalDebtIssued"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrValue""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalDebtIssued""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""debtPercentage"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrValue""}, ""memberName"": ""divideDecimalRoundPrecise""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTotalDebtIssued""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""delta"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseUnit""}, ""arguments"": [], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""debtPercentage""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""existingDebt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtCache""}, ""memberName"": ""debtBalanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""stringLiteral"", ""value"": ""XDR""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""existingDebt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""debtPercentage""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrValue""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""existingDebt""}], ""names"": []}, ""memberName"": ""divideDecimalRoundPrecise""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTotalDebtIssued""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""hasIssued""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""incrementTotalIssuerCount""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""setCurrentIssuanceData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""debtPercentage""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""debtLedgerLength""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""appendDebtLedgerValue""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""lastDebtLedgerEntry""}, ""arguments"": [], ""names"": []}, ""memberName"": ""multiplyDecimalRoundPrecise""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""delta""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""appendDebtLedgerValue""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseUnit""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""optionalProxy"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'debtLedgerLength', 'complexity': 0}, {'function': 'totalIssuedSynths', 'complexity': 0}, {'function': 'debtBalanceOf', 'complexity': 0}, {'function': '_addToDebtRegister', 'complexity': 5}]",6.0,_addToDebtRegister,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) Ownable(msg.sender) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}"
5740,"function setPrices ( uint256 newSellPrice , uint256 newSellMultiplier , uint256 newBuyPrice , uint256 newBuyMultiplier ) onlyOwner public { sellPrice = newSellPrice ; sellMultiplier = newSellMultiplier ; buyPrice = newBuyPrice ; buyMultiplier = newBuyMultiplier ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
    sellPrice = newSellPrice;
    sellMultiplier = newSellMultiplier;
    buyPrice = newBuyPrice;
    buyMultiplier = newBuyMultiplier;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}",True,"[{'function': 'setPrices', 'complexity': 0}]",6.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellMultiplier""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyMultiplier""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,setPrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContractName is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() Ownable(msg.sender) {
        sellPrice = 1;
        sellMultiplier = 1;
        buyPrice = 1;
        buyMultiplier = 1;
    }

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) public onlyOwner {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}"
4219,"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; aix . generateTokens ( remainderHolder , weiToCollect ( ) . mul ( 2000 ) ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }",This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"function finalize() public initialized {
    require(finalizedBlock == 0);
    require(finalizedTime == 0);
    require(getBlockTimestamp() >= startTime);
    require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

    aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
    uint256 tokenCap = aix.totalSupply().mul(100).div(51);
    aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
    aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

    finalizedBlock = getBlockNumber();
    finalizedTime = getBlockTimestamp();

    Finalized(finalizedBlock);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}",False,"[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalize', 'complexity': 5}]",16.0,7.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aix""}, ""memberName"": ""generateTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""remainderHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2000"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aix""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TOKEN_CAP_MULTIPLIER""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TOKEN_DISTRIBUTION_RATIO""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aix""}, ""memberName"": ""generateTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""devHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""20"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aix""}, ""memberName"": ""generateTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""communityHolder""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""29"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockTimestamp""}, ""arguments"": [], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalizedBlock""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""initialized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalize', 'complexity': 5}]",7.0,finalize,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

contract Finalizable is Ownable {
    using SafeMath for uint256;

    address public constant INIT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant DEV_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual address
    address public constant COMMUNITY_ADDRESS = 0x3333333333333333333333333333333333333333; // Replace with actual address

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    uint256 public totalSupply;

 constructor() Ownable(INIT_ADDRESS) {
        remainderHolder = INIT_ADDRESS;
        devHolder = DEV_ADDRESS;
        communityHolder = COMMUNITY_ADDRESS;
        startTime = block.timestamp; // Initialize with current timestamp
        endTime = block.timestamp + 1 days; // Set end time to one day from now
        finalizedBlock = 0;
        finalizedTime = 0;
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}"
6178,"function isPaused ( ) public view returns ( bool ) { return getBool ( Encoder . getKey ( ""paused"" ) ) ; }",Checks whether the contract operations is paused or not,"function isPaused ( ) public view returns ( bool ) {
    return getBool ( Encoder . getKey ( ""paused"" ) );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}",False,"[{'function': 'getKey', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getBool"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pausedMap""}, ""index"": {""type"": ""Identifier"", ""name"": ""key""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getKey', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",1.0,isPaused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
        // Properly initialize Ownable with msg.sender
        __Ownable_init();
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }

    // Dummy implementation for __Ownable_init to satisfy the requirement
    function __Ownable_init() internal virtual {
        Ownable.__Ownable_init();
    }
}"
1600,"function setConverterRamp ( ConverterRamp _converterRamp ) external onlyOwner returns ( bool ) { require ( _isContract ( _converterRamp ) , ""Should be a contract"" ) ; emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }",Sets a new converter ramp to delegate the pay of the loan,"function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
    require(_isContract(_converterRamp), ""Should be a contract"");
    emit SetConverterRamp(converterRamp, _converterRamp);
    converterRamp = _converterRamp;
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",False,"[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",6.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ConverterRamp""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Should be a contract""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""converterRamp""}, {""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",2.0,setConverterRamp,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    uint256 public constant DEFAULT_UINT = 1;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    constructor() Ownable(DEFAULT_ADDRESS) {
        converterRamp = ConverterRamp(DEFAULT_STRING);
    }

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
4079,"function getTokenAllowance ( Data storage self , string currency , address account , address spender ) internal view returns ( uint allowance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , spender ) ) ) ; return self . Storage . getUint ( id ) ; }",Get the token spender allowance for a given account,"function getTokenAllowance(Data storage self, string currency, address account, address spender) internal view returns (uint allowance) {
    bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, getForwardedAccount(self, account), getForwardedAccount(self, spender)));
    return self.Storage.getUint(id);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}",False,"[{'function': 'allowance', 'complexity': 0}, {'function': 'getTokenAllowance', 'complexity': 0}, {'function': '_getForwardedAccount', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.allowance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getForwardedAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getForwardedAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""Storage""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}, {'function': 'getTokenAllowance', 'complexity': 0}, {'function': '_getForwardedAccount', 'complexity': 0}]",1.0,getTokenAllowance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed values
        self.Storage[bytes32('init')] = 1; // uint
        self.Storage[bytes32('address1')] = 0x1111111111111111111111111111111111111111; // address
        self.Storage[bytes32('bool1')] = true; // bool
        self.Storage[bytes32('string1')] = 'initialized'; // string
        self.Storage[bytes32('bytes32')] = bytes32('init'); // bytes32
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}"
5836,function getTokenMinted ( ) public constant returns ( uint ) ;,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"function getTokenMinted() public constant returns (uint) {
    return tokenMinted;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}",False,"[{'function': 'getTokenMinted', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenMinted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""tokenMinted""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""constant""}","[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,getTokenMinted,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenMinted = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // No need to initialize other variables as they are already initialized with safe, non-corner-case values
    }

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}"
6399,"function changeManager ( address addr , address newManager ) public canManage ( addr ) { managers [ addr ] = newManager ; ManagerChanged ( addr , newManager ) ; }",Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"
function changeManager(address addr, address newManager) public canManage(addr) {
    managers[addr] = newManager;
    ManagerChanged(addr, newManager);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}",True,"[{'function': 'changeManager', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newManager""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""newManager""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canManage"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeManager', 'complexity': 0}]",1.0,changeManager,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ManagerChange is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        managers[address(0x111)] = address(0);
        managers[address(0x222)] = address(0);
        managers[address(0x333)] = address(0);
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}"
5804,"function getCurrentSellOffer ( uint32 _canvasId ) external view returns ( bool isForSale , address seller , uint minPrice , address onlySellTo ) { SellOffer storage offer = canvasForSale [ _canvasId ] ; return ( offer . isForSale , offer . seller , offer . minPrice , offer . onlySellTo ) ; }",Returns current sell offer for the canvas .,"function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
    SellOffer storage offer = canvasForSale[_canvasId];
    return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}",True,"[{'function': 'getCurrentSellOffer', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSellOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""minPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""onlySellTo"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SellOffer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasForSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""isForSale""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""minPrice""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""onlySellTo""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,getCurrentSellOffer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}"
1832,"function mGenerateTokens ( address owner , uint256 amount ) internal ;",Generates ` amount ` tokens that are assigned to ` owner `,"function mGenerateTokens(address owner, uint256 amount) internal;

function mGenerateTokens(address owner, uint256 amount) internal {
    // logic goes here
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}",True,"[{'function': 'mGenerateTokens', 'complexity': 0}]",3.0,1.0,{},"[{'function': 'mGenerateTokens', 'complexity': 0}]",1.0,mGenerateTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
107,"function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner ;",Allows the owner to register and the details for a token .,"function registerToken (uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals) public onlyOwner {
    require(msg.sender == owner(), ""Only the contract owner can call this function"");
    require(_tokenCode > 0, ""Invalid token code"");
    require(_tokenAddress != address(0), ""Invalid token address"");
    require(_tokenDecimals > 0, ""Invalid token decimals"");

    uint32 tokenCode = _tokenCode;
    address tokenAddress = _tokenAddress;
    uint8 tokenDecimals = _tokenDecimals;

    TokenInfo storage tokenInfo = tokenInfos[tokenCode];
    require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

    tokenInfo.tokenAddress = tokenAddress;
    tokenInfo.tokenDecimals = tokenDecimals;

    emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}",True,"[{'function': 'registerToken', 'complexity': 5}]",18.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_tokenCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_tokenDecimals"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenCode""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token code""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenDecimals""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token decimals""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""tokenCode"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_tokenCode""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""tokenDecimals"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_tokenDecimals""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenInfo""}, ""name"": ""tokenInfo"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenCode""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenInfo""}, ""memberName"": ""tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenInfo""}, ""memberName"": ""tokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenInfo""}, ""memberName"": ""tokenDecimals""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenDecimals""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RegisteredToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenCode""}, {""type"": ""Identifier"", ""name"": ""tokenAddress""}, {""type"": ""Identifier"", ""name"": ""tokenDecimals""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'registerToken', 'complexity': 5}]",6.0,registerToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 1; i <= 3; i++) {
            tokenInfos[i] = TokenInfo({tokenAddress: address(uint160(uint256(i))), tokenDecimals: uint8(i)});
        }
    }

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        TokenInfo storage tokenInfo = tokenInfos[_tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = _tokenAddress;
        tokenInfo.tokenDecimals = _tokenDecimals;

        emit RegisteredToken(_tokenCode, _tokenAddress, _tokenDecimals);
    }
}"
2044,"function mintTokens ( address _owner , uint _amount ) public onlyController notFinalized returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Mint ` _amount ` tokens that are assigned to ` _owner `,"function mintTokens ( address _owner , uint _amount ) public onlyController notFinalized returns ( bool ) {
    uint curTotalSupply = totalSupply ( );
    require ( curTotalSupply + _amount >= curTotalSupply );
    uint previousBalanceTo = balanceOf ( _owner );
    require ( previousBalanceTo + _amount >= previousBalanceTo );
    updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount );
    updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount );
    Transfer ( 0 , _owner , _amount );
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}",False,"[{'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""curTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""previousBalanceTo"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""notFinalized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",3.0,mintTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() 
        Ownable(0x1111111111111111111111111111111111111111 /* owner address */) 
        IToken(""MyToken"", ""TKN"") {
        owner = msg.sender;
        balances[msg.sender] = 1000; // Initialize with a fixed value
        totalSupplyHistory[block.number] = 1; // Initialize with a fixed value
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external {
        data[block.number] = value;
    }
}"
2892,"function makeOffer ( address _maker , address _offerAsset , address _wantAsset , uint256 _offerAmount , uint256 _wantAmount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerAmount > 0 && _wantAmount > 0 , ""Invalid amounts"" ) ; require ( _offerAsset != _wantAsset , ""Invalid assets"" ) ; bytes32 offerHash = keccak256 ( abi . encodePacked ( ""makeOffer"" , _maker , _offerAsset , _wantAsset , _offerAmount , _wantAmount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( offerHash , _v , _r , _s ) == _maker , ""Invalid signature"" ) ; _validateAndAddHash ( offerHash ) ; _decreaseBalanceAndPayFees ( _maker , _offerAsset , _offerAmount , _feeAsset , _feeAmount , ReasonMakerGive , ReasonMakerFeeGive , ReasonMakerFeeReceive ) ; Offer storage offer = offers [ offerHash ] ; offer . maker = _maker ; offer . offerAsset = _offerAsset ; offer . wantAsset = _wantAsset ; offer . offerAmount = _offerAmount ; offer . wantAmount = _wantAmount ; offer . availableAmount = _offerAmount ; offer . nonce = _nonce ; emit Make ( _maker , offerHash ) ; }",Makes an offer which can be filled by other users .,"function makeOffer(address _maker, address _offerAsset, address _wantAsset, uint256 _offerAmount, uint256 _wantAmount, address _feeAsset, uint256 _feeAmount, uint64 _nonce) external onlyCoordinator onlyActiveState {
    require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
    require(_offerAsset != _wantAsset, ""Invalid assets"");

    bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

    require(_recoverAddress(offerHash, _v, _r, _s) == _maker, ""Invalid signature"");

    _validateAndAddHash(offerHash);

    _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

    Offer storage offer = offers[offerHash];
    offer.maker = _maker;
    offer.offerAsset = _offerAsset;
    offer.wantAsset = _wantAsset;
    offer.offerAmount = _offerAmount;
    offer.wantAmount = _wantAmount;
    offer.availableAmount = _offerAmount;
    offer.nonce = _nonce;

    emit Make(_maker, offerHash);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}",False,"[{'function': 'onlyActiveState', 'complexity': 0}, {'function': 'makeOffer', 'complexity': 0}, {'function': 'setCoordinator', 'complexity': 0}, {'function': 'isStateActive', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_decreaseBalanceAndPayFees', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",35.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""makeOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_maker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_offerAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_wantAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_offerAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_wantAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_wantAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amounts""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAsset""}, ""right"": {""type"": ""Identifier"", ""name"": ""_wantAsset""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid assets""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""offerHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""makeOffer""}, {""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_wantAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_wantAmount""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recoverAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""offerHash""}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_maker""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validateAndAddHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""offerHash""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_decreaseBalanceAndPayFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""ReasonMakerGive""}, {""type"": ""Identifier"", ""name"": ""ReasonMakerFeeGive""}, {""type"": ""Identifier"", ""name"": ""ReasonMakerFeeReceive""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""offerHash""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""maker""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maker""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""offerAsset""}, ""right"": {""type"": ""Identifier"", ""name"": ""_offerAsset""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""wantAsset""}, ""right"": {""type"": ""Identifier"", ""name"": ""_wantAsset""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""offerAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""wantAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_wantAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""availableAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""nonce""}, ""right"": {""type"": ""Identifier"", ""name"": ""_nonce""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Make""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""offerHash""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onlyActiveState', 'complexity': 0}, {'function': 'makeOffer', 'complexity': 0}, {'function': 'setCoordinator', 'complexity': 0}, {'function': 'isStateActive', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_decreaseBalanceAndPayFees', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",5.0,makeOffer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

contract OfferManager is Ownable {;
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    constructor() Ownable(msg.sender) {
        // Initialize fixed values
        coordinator = 0x1111111111111111111111111111111111111111; // Replace with actual value
        offers[bytes32('init')] = Offer(
            msg.sender,
            address(0),
            address(0),
            1, // uint256
            1, // uint256
            1, // uint256
            block.timestamp // uint64
        );
    }

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}"
5927,function getProjectLevel ( PledgeAdmin m ) internal returns ( uint ) { assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . parentProject == 0 ) return ( 1 ) ; PledgeAdmin storage parentNM = findAdmin ( m . parentProject ) ; return getProjectLevel ( parentNM ) + 1 ; },A getter to find the level of authority a specific Project has using a self-referential loop,"function getProjectLevel (PledgeAdmin m) internal returns (uint) {
    assert(m.adminType == PledgeAdminType.Project);
    if (m.parentProject == 0) return (1);
    PledgeAdmin storage parentNM = findAdmin(m.parentProject);
    return getProjectLevel(parentNM) + 1;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}",False,"[{'function': 'getProjectLevel', 'complexity': 1}, {'function': 'findAdmin', 'complexity': 0}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProjectLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""m"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PledgeAdminType""}, ""memberName"": ""Project""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid admin type""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""parentNM"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""findAdmin""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getProjectLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""parentNM""}], ""names"": []}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getProjectLevel', 'complexity': 1}, {'function': 'findAdmin', 'complexity': 0}]",3.0,getProjectLevel,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PledgeAdminWrapper is Ownable {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}"
3990,"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return false ; }",Notifies the controller about a token transfer allowing the controller to react if desired,"function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
    return false;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}",True,"[{'function': 'onTransfer', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""onTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onTransfer', 'complexity': 0}]",1.0,onTransfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}"
5074,function cancelPayment ( uint _idPayment ) onlyContractOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; },` onlyOwner ` Cancel a payment all together,"function cancelPayment (uint _idPayment) onlyContractOwner {
    if (_idPayment >= authorizedPayments . length) throw ;
    Payment p = authorizedPayments [_idPayment];
    if (p.canceled) throw;
    if (p.paid) throw;
    p.canceled = true;
    PaymentCanceled (_idPayment);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}",True,"[{'function': 'cancelPayment', 'complexity': 0}]",8.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""canceled""}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""paid""}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""canceled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentCanceled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'cancelPayment', 'complexity': 0}]",4.0,cancelPayment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}"
1247,"function callOperator ( address _operator , address _from , address _to , uint256 _value , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensOperator"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensOperator ( recipientImplementation ) . madeOperatorForTokens ( _operator , _from , _to , _value , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" ) ; } }",Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"function callOperator ( address _operator , address _from , address _to , uint256 _value , bytes _userData , bytes _operatorData , bool _preventLocking ) private {
    address recipientImplementation = interfaceAddr( _to , ""ERC777TokensOperator"" );
    if ( recipientImplementation != 0 ) {
        ERC777TokensOperator(recipientImplementation).madeOperatorForTokens( _operator , _from , _to , _value , _userData , _operatorData );
    } else if ( _preventLocking ) {
        require( isRegularAddress( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" );
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}",False,"[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 3}]",8.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""callOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_preventLocking"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipientImplementation"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""interfaceAddr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""stringLiteral"", ""value"": ""ERC777TokensOperator""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipientImplementation""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC777TokensOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipientImplementation""}], ""names"": []}, ""memberName"": ""madeOperatorForTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""_preventLocking""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegularAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""When ""_preventLocking"" is true, you cannot invoke ""callOperator"" to a contract address that does not support the ""ERC777TokensOperator"" interface""}], ""names"": []}}]}, ""FalseBody"": None}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 3}]",6.0,callOperator,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}"
5500,"function approveAll ( address _to ) public { require ( _to != msg . sender , ""cant approve yourself"" ) ; require ( _to != address ( 0 ) , ""invalid owner"" ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; emit ApprovalForAll ( msg . sender , _to , true ) ; }",Approves another address to claim for the ownership of any tokens owned by this account,"function approveAll (address _to) public {
    require(_to != msg.sender, ""cant approve yourself"");
    require(_to != address(0), ""invalid owner"");
    operatorApprovals[msg.sender][_to] = true;
    emit ApprovalForAll(msg.sender, _to, true);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}",False,"[{'function': 'approveAll', 'complexity': 2}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""cant approve yourself""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approveAll', 'complexity': 2}]",3.0,approveAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}"
4001,"function buyTokens ( address _beneficiary ) public payable { uint256 weiAmount = msg . value ; _preValidatePurchase ( _beneficiary , weiAmount ) ; uint256 tokens = _getTokenAmount ( weiAmount ) ; require ( token . balanceOf ( this ) >= tokens ) ; totalWeiRaised = totalWeiRaised . add ( weiAmount ) ; tokensSold = tokensSold . add ( tokens ) ; _deliverTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , weiAmount , tokens ) ; _processBonus ( msg . sender , tokens ) ; _forwardFunds ( ) ; }",Function calls other functions to calculate tokenamount to send to beneficiary .,"function buyTokens(address _beneficiary) public payable {
    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);
    uint256 tokens = _getTokenAmount(weiAmount);
    require(token.balanceOf(this) >= tokens);
    totalWeiRaised = totalWeiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokens);
    _deliverTokens(_beneficiary, tokens);
    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
    _processBonus(msg.sender, tokens);
    _forwardFunds();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 1}, {'function': '_forwardFunds', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}]",13.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_preValidatePurchase""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getTokenAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale: token contract has insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_deliverTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenPurchase""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_processBonus""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_forwardFunds""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'transfer', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 1}, {'function': '_forwardFunds', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}]",3.0,buyTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    mapping(address => uint256) public balanceOf;

 constructor(uint256 _rate, address payable _wallet, Token _token) Ownable(msg.sender) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}"
267,"function redeem ( uint256 _tokens ) public { __redeem_impl ( msg . sender , _tokens ) ; }",Redeem required amount of tokens for the real asset,"function redeem(uint256 _tokens) public {
    __redeem_impl(msg.sender, _tokens);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}",True,"[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeem"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""__redeem_impl""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",1.0,redeem,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExampleContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        uint256 fixedUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address fixedAddress1 = address(uint160(uint256(keccak256('a'))));
        address fixedAddress2 = address(uint160(uint256(keccak256('b'))));
        address fixedAddress3 = address(uint160(uint256(keccak256('c'))));

        // bool: Set to true
        bool isInitialized = true;

        // string: Set to 'initialized'
        string memory initializedString = 'initialized';

        // bytes32: Set to bytes32('init')
        bytes32 fixedBytes32 = keccak256(abi.encodePacked('init'));
    }

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}"
1315,"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `,"
function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
    uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
    require(curTotalSupply >= _amount);
    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);
    uint256 previousBalanceFrom = balanceOf(_owner);
    require(previousBalanceFrom >= _amount);
    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);
    Transfer(_owner, 0, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}",False,"[{'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""curTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getValueAt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBlockNumber""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""previousBalanceFrom"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""previousBalanceFrom""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceFrom""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",3.0,destroyTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}"
4051,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }",Query if an address is an authorized operator for another address,"function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
    return operatorApprovals[_owner][_operator];
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}",True,"[{'function': 'isApprovedForAll', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isApprovedForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,isApprovedForAll,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}"
5314,"function changeNonAccreditedLimit ( address [ ] _investors , uint256 [ ] _nonAccreditedLimit ) public onlyOwner { require ( _investors . length == _nonAccreditedLimit . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _nonAccreditedLimit [ i ] > 0 , ""Limit can not be 0"" ) ; nonAccreditedLimitUSDOverride [ _investors [ i ] ] = _nonAccreditedLimit [ i ] ; emit SetNonAccreditedLimit ( _investors [ i ] , _nonAccreditedLimit [ i ] ) ; } }",Modifies the list of overrides for non-accredited limits in USD,"function changeNonAccreditedLimit ( address [ ] _investors , uint256 [ ] _nonAccreditedLimit ) public onlyOwner {
    require( _investors . length == _nonAccreditedLimit . length, ""Array length mismatch"" );

    for ( uint256 i = 0; i < _investors . length; i ++ ) {
        require( _nonAccreditedLimit [ i ] > 0, ""Limit can not be 0"" );

        nonAccreditedLimitUSDOverride [ _investors [ i ] ] = _nonAccreditedLimit [ i ];
        emit SetNonAccreditedLimit ( _investors [ i ], _nonAccreditedLimit [ i ] );
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}",True,"[{'function': 'changeNonAccreditedLimit', 'complexity': 3}]",10.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeNonAccreditedLimit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_investors"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_nonAccreditedLimit"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Array length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Limit can not be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonAccreditedLimitUSDOverride""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetNonAccreditedLimit""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeNonAccreditedLimit', 'complexity': 3}]",4.0,changeNonAccreditedLimit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            nonAccreditedLimitUSDOverride[addr] = 1;
        }
    }

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}"
2308,"function isRegisteredFirm ( Data storage self , string issuerFirm ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; return self . Storage . getBool ( id ) ; }",Return the boolean ( true/false ) registration status for an issuer firm,"solidity
function isRegisteredFirm(Data storage self, string issuerFirm) internal view returns (bool registered) {
    bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
    return self.Storage.getBool(id);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}",True,"[{'function': 'getBool', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegisteredFirm"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""issuerFirm"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""registered"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.firm""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dataStorage""}, ""memberName"": ""getBool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getBool', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,isRegisteredFirm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() Ownable(msg.sender) {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}"
1642,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { bool onApprove = TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ; require ( onApprove ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"function approve(address _spender, uint256 _amount) returns (bool success) {
    require(transfersEnabled);
    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));
    if (isContract(controller)) {
        bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
        require(onApprove);
    }
    allowed[msg.sender][_spender] = _amount;
    Approval(msg.sender, _spender, _amount);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",True,"[{'function': 'onApprove', 'complexity': 0}, {'function': 'approve', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",11.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are not enabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Allowance already granted""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""onApprove"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""onApprove""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""onApprove""}, {""type"": ""stringLiteral"", ""value"": ""Approval rejected by controller""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 0}, {'function': 'approve', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",6.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) Ownable(msg.sender) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
3698,"function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( snt ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .,"function claimTokens ( address _token ) public onlyOwner {
    require ( _token != address ( snt ) );
    if ( _token == 0x0 ) {
        owner . transfer ( this . balance );
        return;
    }
    ERC20Token token = ERC20Token ( _token );
    uint256 balance = token . balanceOf ( this );
    token . transfer ( owner , balance );
    ClaimedTokens ( _token , owner , balance );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""Identifier"", ""name"": ""snt""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw SNT tokens""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, None]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20Token""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Token""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,claimTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x1111111111111111111111111111111111111111; // fixed value
    address public owner = msg.sender;
    bool public initialized = true;
    bytes32 public constant initBytes = bytes32('init');

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        snt = 0x1111111111111111111111111111111111111111; // fixed value
        owner = msg.sender;
        initialized = true;
    }

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(msg.sender, balance), ""Transfer failed"");
        emit ClaimedTokens(_token, msg.sender, balance);
    }
}"
6060,"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Metadollar price updated!"" ) ; } }",Set current ICO prices in wei for one metadollar,"
function updatePrices() internal {
    uint256 oldPrice = currentTokenPrice;
    if (preIcoIsRunning) {
        checkPreIcoStatus();
    }
    if (preIcoIsRunning) {
        currentTokenPrice = preICOprice;
    } else {
        currentTokenPrice = ICOprice;
    }
    if (oldPrice != currentTokenPrice) {
        priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}",False,"[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",14.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkPreIcoStatus""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""preICOprice""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""ICOprice""}}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldPrice""}, {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, {""type"": ""stringLiteral"", ""value"": ""Metadollar price updated!""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",5.0,updatePrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}"
6552,function currentSnapshotId ( ) public constant returns ( uint256 ) ;,upper bound of series of snapshotIds for which there 's a value in series,"function currentSnapshotId() public constant returns (uint256) {
    return _currentSnapshotId;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}",True,"[{'function': 'currentSnapshotId', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""currentSnapshotId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""_currentSnapshotId""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'currentSnapshotId', 'complexity': 0}]",1.0,currentSnapshotId,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}"
2199,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { token . mint ( target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `,"function mintToken (address target , uint256 mintedAmount) onlyOwner public {
    token . mint (target , mintedAmount);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}",False,"[{'function': 'mintToken', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mintToken', 'complexity': 0}]",1.0,mintToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    // Placeholder for the actual token contract
    IERC20 public token;

    constructor(address _token) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}"
1644,function _trimQuestion ( string q ) internal pure returns ( string ) { return q . toSlice ( ) . split ( REALITIO_DELIMITER . toSlice ( ) ) . toString ( ) ; },Trim the realitio question content to the part before the initial delimiter .,"function _trimQuestion (string q) internal pure returns (string){
    return q.toSlice().split(REALITIO_DELIMITER.toSlice()).toString();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}",True,"[{'function': '_trimQuestion', 'complexity': 1}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_trimQuestion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""q"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""q""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""memberName"": ""concat""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""q""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""REALITIO_DELIMITER""}], ""names"": []}], ""names"": []}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": """"}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""string""}], ""isArray"": False}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': '_trimQuestion', 'complexity': 1}]",1.0,_trimQuestion,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
2321,"function sendPendingAmounts ( uint _from , uint _to , address _buyer ) returns ( bool ) ;",Function to send tokens or refund after the closing time of the funding proposals,"function sendPendingAmounts(uint _from, uint _to, address _buyer) public returns (bool) {
    require(_from <= _to);
    for (uint i = _from; i <= _to; i++) {
        if (pendingAmounts[i] > 0) {
            pendingAmounts[i].transfer(address(this));
            emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
            pendingAmounts[i] = 0;
        }
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}",False,"[{'function': 'sendPendingAmounts', 'complexity': 4}]",10.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendPendingAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SentPendingAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""i""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'sendPendingAmounts', 'complexity': 4}]",4.0,sendPendingAmounts,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= type(uint).max; i++) {
            pendingAmounts[i] = 1; // Set to 1 instead of 0
        }
    }

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}"
5497,"function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . wallets [ _holderId ] . balance ; }",Returns asset balance for a particular holder id .,"function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
    return assets[_symbol].wallets[_holderId].balance;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': '_balanceOf', 'complexity': 0}]",3.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""memberName"": ""wallets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderId""}}, ""memberName"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_balanceOf', 'complexity': 0}]",1.0,_balanceOf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
124,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; allStarIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"function approve(address _to, uint256 _tokenId) public {
    require(_owns(msg.sender, _tokenId));
    allStarIndexToApproved[_tokenId] = _to;
    Approval(msg.sender, _to, _tokenId);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}",True,"[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            allStarIndexToApproved[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
        }
    }

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}"
467,"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; BeneficiaryDestroyed ( _beneficiary ) ; }",Allows the owner to destroy a beneficiary .,"
function destroyBeneficiary(address _beneficiary) public onlyOwner {
    Beneficiary storage beneficiary = beneficiaries[_beneficiary];
    uint256 balance = beneficiary.vested.sub(beneficiary.released);
    token.transfer(owner, balance);
    totalReleased = totalReleased.add(balance);
    beneficiary.isBeneficiary = false;
    beneficiary.released = beneficiary.released.add(balance);
    BeneficiaryDestroyed(_beneficiary);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 1}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Beneficiary""}, ""name"": ""beneficiary"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""vested""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""isBeneficiary""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,destroyBeneficiary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) Ownable() {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}"
3604,"function addAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = _createHolderId ( _partowner ) ; assets [ _symbol ] . partowners [ holderId ] = true ; Emitter ( eventsHistory ) . emitOwnershipChange ( 0x0 , _partowner , _symbol ) ; return OK ; }",Adds a co-owner for an asset with provided symbol .,"
function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
    uint holderId = _createHolderId(_partowner);
    assets[_symbol].partowners[holderId] = true;
    Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
    return OK;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}",False,"[{'function': 'addAssetPartOwner', 'complexity': 0}, {'function': '_isPartowner', 'complexity': 7}, {'function': '_createHolderId', 'complexity': 0}]",11.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAssetPartOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_partowner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""holderId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_partowner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""memberName"": ""partowners""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Emitter""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""eventsHistory""}], ""names"": []}, ""memberName"": ""emitOwnershipChange""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_partowner""}, {""type"": ""Identifier"", ""name"": ""_symbol""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOneOfOwners"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_symbol""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addAssetPartOwner', 'complexity': 0}, {'function': '_isPartowner', 'complexity': 7}, {'function': '_createHolderId', 'complexity': 0}]",4.0,addAssetPartOwner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetWrapper is Ownable {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}"
5691,"function withdrawTokens ( ) public whenNotPaused returns ( bool ) { uint256 amount = rewards [ msg . sender ] ; require ( amount > 0 , ""amount is zero"" ) ; rewards [ msg . sender ] = 0 ; emit TokensWithdrawn ( msg . sender , amount ) ; require ( token . transfer ( msg . sender , amount ) , ""token transfer failed"" ) ; return true ; }",allows participants in the Atonomi network to claim their rewards,"function withdrawTokens() public whenNotPaused returns (bool) {
    uint256 amount = rewards[msg.sender];
    require(amount > 0, ""amount is zero"");
    rewards[msg.sender] = 0;
    emit TokensWithdrawn(msg.sender, amount);
    require(token.transfer(msg.sender, amount), ""token transfer failed"");
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",False,"[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",8.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amount is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,withdrawTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}

contract TokenWithdrawalContract is TokenWithdrawal {
    constructor(address _token) {
        token = IERC20(_token);
        // Initialize Ownable with the deployer's address
        __Ownable_init();
    }

    function __Ownable_init() internal onlyInitializing {
        // Initialize Ownable with a fixed address for demonstration purposes
        _transferOwnership(msg.sender);
    }
}"
2271,"function deposit ( address _user ) public payable isOpen depositIsConfigCompliant canDeposit ( _user ) { if ( ! invested [ _user ] ) { swimmersList . push ( _user ) ; invested [ _user ] = true ; } weiRaised = weiRaised . add ( msg . value ) ; swimmers [ _user ] = swimmers [ _user ] . add ( msg . value ) ; emit Deposit ( msg . sender , msg . value ) ; }",Deposit Ether where the contribution is credited to the address specified in the parameter .,"
function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
    if (!invested[_user]) {
        swimmersList.push(_user);
        invested[_user] = true;
    }
    weiRaised = weiRaised.add(msg.value);
    swimmers[_user] = swimmers[_user].add(msg.value);
    emit Deposit(msg.sender, msg.value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}",False,"[{'function': 'deposit', 'complexity': 2}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swimmersList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""swimmers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""swimmers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOpen"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""depositIsConfigCompliant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""canDeposit"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'deposit', 'complexity': 2}]",2.0,deposit,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    constructor() Ownable(msg.sender) {
        isOpen = true;
        swimmersList = [0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333]; // Fixed addresses
        invested[_user] = false; // Placeholder for user address
        swimmers[_user] = 0; // Placeholder for user address
        weiRaised = 0;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}"
2948,function setSaleAuctionAddress ( address _address ) external onlyCEO { SaleClockAuction candidateContract = SaleClockAuction ( _address ) ; require ( candidateContract . isSaleClockAuction ( ) ) ; saleAuction = candidateContract ; },The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"function setSaleAuctionAddress ( address _address ) external onlyCEO {
    SaleClockAuction candidateContract = SaleClockAuction ( _address );
    require ( candidateContract . isSaleClockAuction ( ) );
    saleAuction = candidateContract;
}

// Output:
function setSaleAuctionAddress(address _address) external onlyCEO {
    SaleClockAuction candidateContract = SaleClockAuction(_address);
    require(candidateContract.isSaleClockAuction());
    saleAuction = candidateContract;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}",False,"[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSaleAuctionAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SaleClockAuction""}, ""name"": ""candidateContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SaleClockAuction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""candidateContract""}, ""memberName"": ""isSaleClockAuction""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""Identifier"", ""name"": ""candidateContract""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCEO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,setSaleAuctionAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        saleAuction = new SaleClockAuction(0x1111111111111111111111111111111111111111); // Replace with actual address
    }

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}"
4839,function tokenMetadataHash ( uint256 index ) public view returns ( bytes32 ) { return keccak256 ( loans [ index ] . metadata ) ; },"Returns the loan metadata , hashed with keccak256 .","
function tokenMetadataHash ( uint256 index ) public view returns ( bytes32 ) {
    return keccak256 ( loans [ index ] . metadata );
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}",False,"[{'function': 'tokenMetadataHash', 'complexity': 1}, {'function': 'setLoanMetadata', 'complexity': 1}, {'function': 'totalLoans', 'complexity': 0}]",4.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadataHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""uint2atural""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalLoans""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenMetadataHash', 'complexity': 1}, {'function': 'setLoanMetadata', 'complexity': 1}, {'function': 'totalLoans', 'complexity': 0}]",2.0,tokenMetadataHash,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint256 index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}"
1398,"function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyProxy public returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _sender , _to ) ; if ( ! _checkTransferAllowance ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! super . __transferWithReference ( _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _sender , _fromRole ) ; _contractFallbackERC223 ( _sender , _to , _value ) ; return true ; }",Performs transfer call on the platform by the name of specified sender .,"function transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyProxy returns (bool) {
    require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
    require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
    if (!super.transferWithReference(_to, _value, _reference, _sender)) {
        return false;
    }
    _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
    _contractFallbackERC223(_sender, _to, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}",False,"[{'function': 'transferWithReference', 'complexity': 4}, {'function': '_checkTransferAllowance', 'complexity': 1}, {'function': '_isValidCountryLimits', 'complexity': 1}, {'function': '_updateTransferLimits', 'complexity': 1}, {'function': '_contractFallbackERC223', 'complexity': 1}, {'function': '_getParticipantRoles', 'complexity': 1}]",10.0,5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithReference"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_checkTransferAllowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isValidCountryLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transferWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateTransferLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contractFallbackERC223""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyProxy"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferWithReference', 'complexity': 4}, {'function': '_checkTransferAllowance', 'complexity': 1}, {'function': '_isValidCountryLimits', 'complexity': 1}, {'function': '_updateTransferLimits', 'complexity': 1}, {'function': '_contractFallbackERC223', 'complexity': 1}, {'function': '_getParticipantRoles', 'complexity': 1}]",5.0,transferWithReference,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_from, _to, _value); // Corrected the order of parameters
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}

contract WrappedFunctionImpl is WrappedFunction {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
883,"function multiExecute ( address [ ] sellers , uint256 lastQuantity ) public payable returns ( uint256 totalVouchers ) { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; totalVouchers = 0 ; for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { execute ( sellers [ i ] , lastQuantity , to . price ) ; totalVouchers += lastQuantity ; } else { execute ( sellers [ i ] , to . quantity , to . price ) ; totalVouchers += to . quantity ; } } return totalVouchers ; }",Buy from multiple sellers at once to fill a single large order .,"function multiExecute (address[] sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
    require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
    totalVouchers = 0;
    for (uint i = 0; i < sellers.length; i++) {
        TradeOrder memory to = orderBook[sellers[i]];
        if (i == sellers.length - 1) {
            execute(sellers[i], lastQuantity, to.price);
            totalVouchers += lastQuantity;
        } else {
            execute(sellers[i], to.quantity, to.price);
            totalVouchers += to.quantity;
        }
    }
    return totalVouchers;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}",False,"[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setTradeOrder', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 6}]",15.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiExecute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""sellers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalVouchers"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""enforceKyc""}, ""isPrefix"": True}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITrade""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""isAllowedTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""You are unknown and not allowed to trade.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TradeOrder""}, ""name"": ""to"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""voucherCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITrade""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""execute""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""lastQuantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""Identifier"", ""name"": ""voucherCount""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""voucherCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITrade""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""execute""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""quantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""Identifier"", ""name"": ""voucherCount""}}}]}}]}}, {""type"": ""Identifier"", ""name"": ""totalVouchers""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setTradeOrder', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 6}]",6.0,multiExecute,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        enforceKyc = false;
        // Placeholder for address initialization: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]].execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}"
2617,function setMtdAmount ( uint256 mtdAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( mtdAmount != mtdAmountInWei ) ; mtdAmount = mtdAmountInWei ; updatePrices ( ) ; },Set current mtdAmount price in wei for one token,"function setMtdAmount(uint256 mtdAmountInWei) isOwner {
    require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
    require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
    mtdAmount = mtdAmountInWei;
    updatePrices();
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}",True,"[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",6.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMtdAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MTD amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}}, {""type"": ""stringLiteral"", ""value"": ""MTD amount has not changed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,setMtdAmount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    constructor() Ownable(msg.sender) {
        mtdAmount = 1; // Set to a non-zero, safe value
    }

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}"
191,"function setPeriodDuration ( uint64 _periodDuration ) external authP ( CHANGE_PERIOD_ROLE , arr ( uint256 ( _periodDuration ) , uint256 ( settings . periodDuration ) ) ) transitionsPeriod { require ( _periodDuration >= 1 days , ERROR_SET_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; emit ChangePeriodDuration ( _periodDuration ) ; }","Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
    require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
    settings.periodDuration = _periodDuration;
    emit ChangePeriodDuration(_periodDuration);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}",False,"[{'function': 'periodDuration', 'complexity': 0}, {'function': 'setPeriodDuration', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPeriodDuration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, {""type"": ""Identifier"", ""name"": ""ERROR_SET_PERIOD_TOO_SHORT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChangePeriodDuration""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CHANGE_PERIOD_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""arr""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}], ""names"": []}], ""names"": []}]}, {""type"": ""ModifierInvocation"", ""name"": ""transitionsPeriod"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'periodDuration', 'complexity': 0}, {'function': 'setPeriodDuration', 'complexity': 1}]",2.0,setPeriodDuration,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        settings.periodDuration = 1 days; // Set to a fixed value of 1 day (never zero)
    }

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}"
243,function resetAppendDecryptedBids ( uint _count ) public onlyOwner { require ( status == state . ended ) ; require ( bids_decrypted_count > 0 ) ; require ( _count > 0 ) ; if ( bids_reset_count == 0 ) { bids_reset_count = bids_decrypted_count ; } uint count = _count ; if ( bids_reset_count < count ) { count = bids_reset_count ; } do { bids_reset_count -- ; bids [ bids_decrypted [ bids_reset_count ] ] . is_decrypted = false ; bids [ bids_decrypted [ bids_reset_count ] ] . is_burned = false ; bids [ bids_decrypted [ bids_reset_count ] ] . will_compute = false ; count -- ; } while ( count > 0 ) ; if ( bids_reset_count == 0 ) { bids_sorted_count = 0 ; bids_ignored_count = 0 ; bids_decrypted_count = 0 ; bids_burned_count = 0 ; } },Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"function resetAppendDecryptedBids(uint _count) public onlyOwner {
    require(status == state.ended);
    require(bids_decrypted_count > 0);
    require(_count > 0);

    if (bids_reset_count == 0) {
        bids_reset_count = bids_decrypted_count;
    }

    uint count = _count;
    if (bids_reset_count < count) {
        count = bids_reset_count;
    }

    do {
        bids_reset_count--;
        bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
        bids[bids_decrypted[bids_reset_count]].is_burned = false;
        bids[bids_decrypted[bids_reset_count]].will_compute = false;
        count--;
    } while (count > 0);

    if (bids_reset_count == 0) {
        bids_sorted_count = 0;
        bids_ignored_count = 0;
        bids_decrypted_count = 0;
        bids_burned_count = 0;
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}",True,"[{'function': 'resetAppendDecryptedBids', 'complexity': 6}]",29.0,9.0,"{""type"": ""FunctionDefinition"", ""name"": ""resetAppendDecryptedBids"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_count"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""state""}, ""memberName"": ""ended""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""bids_decrypted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""Identifier"", ""name"": ""bids_decrypted_count""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_count""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""Identifier"", ""name"": ""count""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""count""}, ""right"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}]}, ""FalseBody"": None}, {""type"": ""DoWhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""index"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}, ""memberName"": ""is_decrypted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""index"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}, ""memberName"": ""is_burned""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""index"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}, ""memberName"": ""will_compute""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""count""}, ""isPrefix"": False}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_sorted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_ignored_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_decrypted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_burned_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'resetAppendDecryptedBids', 'complexity': 6}]",9.0,resetAppendDecryptedBids,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        bids_reset_count = 0;
        bids_decrypted_count = 1;
        bids_sorted_count = 0;
        bids_ignored_count = 0;
        bids_burned_count = 0;
        status = state.ended;
    }

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}"
6808,"function setPrices ( uint256 newBuyPrice , uint256 newSellPrice ) onlyOwner public { buyPrice = newBuyPrice ; sellPrice = newSellPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
    buyPrice = newBuyPrice;
    sellPrice = newSellPrice;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}",True,"[{'function': 'setPrices', 'complexity': 0}]",4.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,setPrices,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    constructor() Ownable(msg.sender) {
        buyPrice = 1; // Set to safe, non-corner-case value
        sellPrice = 2; // Set to safe, non-corner-case value
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}"
4005,"function BuyToken ( address _buyer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _buyer ] + _value > balances [ _buyer ] ) ; SoldToken ( _buyer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _buyer ] += _value ; Transfer ( msg . sender , _buyer , _value ) ; }",Buy quantity of tokens depending on the amount of sent ethers .,"
function BuyToken(address _buyer, uint256 _value, string note) public onlyOwner {
    require(balances[msg.sender] >= _value && balances[_buyer] + _value > balances[_buyer]);
    SoldToken(_buyer, _value, note);
    balances[msg.sender] -= _value;
    balances[_buyer] += _value;
    Transfer(msg.sender, _buyer, _value);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'BuyToken', 'complexity': 2}]",7.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""BuyToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""note"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance or overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SoldToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""note""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'BuyToken', 'complexity': 2}]",3.0,BuyToken,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balances[owner()] = 1; // Set initial balance for the owner
    }

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}"
5639,"function transfer ( address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , """" ) ; } }",Transfers asset balance from the caller to specified receiver .,"function transfer(address _to, uint _value) public returns (bool) {
    if (_to != address(0)) {
        return _transferWithReference(_to, _value, """");
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}",False,"[{'function': 'transfer', 'complexity': 1}]",5.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""stringLiteral"", ""value"": """"}], ""names"": []}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}]",2.0,transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
971,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"function approve(address _spender, uint256 _value) public returns (bool success) {
    allowances[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",False,"[{'function': 'approve', 'complexity': 0}]",5.0,1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}]",1.0,approve,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable, Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        allowances[address(0x111)][address(0x222)] = 1;
        allowances[address(0x222)][address(0x333)] = 1;
    }

    function approve(address _spender, uint256 _value) public override returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
2396,"function offer ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","function offer(uint256 quantity, uint256 price, uint256 expiry) public {
    require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
    require(quantity > 0, ""You must supply a quantity."");
    require(price > 0, ""The sale price cannot be zero."");
    require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
    require(price >= sellFloor, ""The ask is below the minimum allowed."");
    require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

    uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);
    require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

    uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
    require(balance >= quantity, ""Not enough tokens owned to complete the order."");

    orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
    emit TokensOffered(msg.sender, quantity, price, expiry);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}",False,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 10}, {'function': 'setTokenContract', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setSellFloor', 'complexity': 0}, {'function': 'setSellCeiling', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}]",17.0,14.0,"{""type"": ""FunctionDefinition"", ""name"": ""offer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""enforceKyc""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAllowedTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""You are unknown and not allowed to trade.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""You must supply a quantity.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The sale price cannot be zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot have an expiry date in the past.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellFloor""}}, {""type"": ""stringLiteral"", ""value"": ""The ask is below the minimum allowed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}}}, {""type"": ""stringLiteral"", ""value"": ""The ask is above the maximum allowed.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""You must approve the transfer of tokens before offering them for sale.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Interface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens owned to complete the order.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 10}, {'function': 'setTokenContract', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setSellFloor', 'complexity': 0}, {'function': 'setSellCeiling', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}]",14.0,offer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = true;
    uint256 public sellFloor = 1;
    uint256 public sellCeiling = 0;
    address public owner = 0x1111111111111111111111111111111111111111; // Fixed owner address
    bytes32 public initialized = bytes32('init'); // Fixed initialization value

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        tokenContract = ERC20Interface(0x2222222222222222222222222222222222222222); // Fixed token contract address
        enforceKyc = true;
        sellFloor = 1;
        sellCeiling = 0;
        owner = 0x3333333333333333333333333333333333333333; // Fixed owner address
        initialized = bytes32('init');
    }

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == true || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}"
2112,"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .,"function claimTokens(address _token) onlyController {
    if (_token == 0x0) {
        controller.transfer(this.balance);
        return;
    }
    ERC20Token token = ERC20Token(_token);
    uint balance = token.balanceOf(this);
    token.transfer(controller, balance);
    ClaimedTokens(_token, controller, balance);
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 2}]",10.0,3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, None]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20Token""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20Token""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 2}]",3.0,claimTokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}"
5098,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( withdrawalRequests [ _from ] . sinceBlock > 0 ) throw ; if ( withdrawalRequests [ _to ] . sinceBlock > 0 ) throw ; if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    if (withdrawalRequests[_from].sinceBlock > 0) throw;
    if (withdrawalRequests[_to].sinceBlock > 0) throw;
    if (balanceOf[_from] < _value) throw;
    if (balanceOf[_to] + _value < balanceOf[_to]) throw;
    if (_value > allowance[_from][msg.sender]) throw;
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    allowance[_from][msg.sender] -= _value;
    Transfer(_from, _to, _value);
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}",False,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",12.0,6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""withdrawalRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""withdrawalRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_value""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",6.0,transferFrom,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract ERC20Wrapper is Ownable {;
    using SafeMath for uint256;

    // Fixed values
    address public constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111;
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    // Mapping variables
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables
        balanceOf[DEFAULT_ADDRESS] = 1000; // Set initial balance
        allowance[DEFAULT_ADDRESS][msg.sender] = 500; // Set initial allowance
        withdrawalRequests[msg.sender] = 0;
    }

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}"
3297,"function withdrawInitialStake ( uint256 _stakeNumber ) public validInitialStakeRelease ( _stakeNumber ) returns ( bool ) { uint256 initialStake = stakes [ msg . sender ] [ _stakeNumber ] . initialStake ; stakes [ msg . sender ] [ _stakeNumber ] . state = StakeStateEnum . staked ; activeStakes = activeStakes . sub ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . sub ( initialStake ) ; emit InitialStakeWithdrawn ( msg . sender , _stakeNumber , initialStake ) ; require ( RTI . transfer ( msg . sender , initialStake ) , ""unable to transfer tokens likely due to incorrect balance"" ) ; return true ; }",Used by a staker to withdraw their initial stake,"
function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
    uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
    stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;
    activeStakes = activeStakes.sub(1);
    internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
    emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
    require(RTI.transfer(msg.sender, initialStake), ""unable to transfer tokens likely due to incorrect balance"");
    return true;
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}",True,"[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawInitialStake', 'complexity': 1}]",9.0,2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawInitialStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stakeNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""initialStake""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StakeStateEnum""}, ""memberName"": ""released""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""activeStakes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""activeStakes""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""internalRTCBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""internalRTCBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialStake""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InitialStakeWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_stakeNumber""}, {""type"": ""Identifier"", ""name"": ""initialStake""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RTI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""initialStake""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Unable to transfer tokens likely due to incorrect balance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validInitialStakeRelease"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_stakeNumber""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawInitialStake', 'complexity': 1}]",2.0,withdrawInitialStake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize fixed values for address and uint256 as per the rules provided
        RTI = IERC20(address(uint160(uint256(keccak256('init')))));
        activeStakes = 1;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}"
1877,"function approveAddress ( address addressToApprove , address token ) internal { if ( ERC20 ( token ) . allowance ( address ( this ) , addressToApprove ) == 0 ) { require ( ERC20SafeTransfer . safeApprove ( token , addressToApprove , MAX_UINT ) ) ; } }",A function which allows the caller to approve the max amount of any given token,"function approveAddress(address addressToApprove, address token) internal {
    if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
        require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));
    }
}","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}",False,"[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 3}, {'function': 'approveAddress', 'complexity': 2}]",5.0,4.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""success"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1131bc520>}, {""type"": ""VariableDeclaration"", ""name"": ""data"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1131bf0e0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""memberName"": ""approve""}, ""memberName"": ""selector""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""bool""}], ""isArray"": False}], ""names"": []}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""SafeERC20: approve failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 3}, {'function': 'approveAddress', 'complexity': 2}]",4.0,approveAddress,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}"
