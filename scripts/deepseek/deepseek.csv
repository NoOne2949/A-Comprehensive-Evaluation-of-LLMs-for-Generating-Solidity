ID,Comment,Contract,DeepSeekGenerated,Time,target_function,DeepseekCognitiveComplexity,DeepseekCyclomaticComplexity,ast,TED,SemanticSimilarity,BLEU,contract_with_constructor
3024,Announce that a particular future Ethereum fork will the one taken by the contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FutureForkAnnouncer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ANNOUNCER_ROLE = keccak256(""ANNOUNCER_ROLE"");

    event FutureForkAnnounced(uint256 indexed forkBlock);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ANNOUNCER_ROLE, msg.sender);
    }

    function announceFutureFork(uint256 targetBlock) public onlyRole(ANNOUNCER_ROLE) {
        emit FutureForkAnnounced(targetBlock);
    }
}",1.869822263717652,announceFutureFork,"[{'function': 'announceFutureFork', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFutureFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""targetBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""FutureForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""targetBlock""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ANNOUNCER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.7579054393392587,0.0160475502932606,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract FutureForkAnnouncer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ANNOUNCER_ROLE = keccak256(""ANNOUNCER_ROLE"");

    event FutureForkAnnounced(uint256 indexed forkBlock);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ANNOUNCER_ROLE, msg.sender);
    }

    function announceFutureFork(uint256 targetBlock) public onlyRole(ANNOUNCER_ROLE) {
        emit FutureForkAnnounced(targetBlock);
    }
}"
2295,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenSale is ReentrancyGuard {
    IERC20 public token;
    uint256 public pricePerToken;
    address payable public owner;

    event TokensPurchased(address indexed buyer, uint256 amount);

    constructor(address _tokenAddress, uint256 _pricePerToken) {
        token = IERC20(_tokenAddress);
        pricePerToken = _pricePerToken;
        owner = payable(msg.sender);
    }

    function buyTokens(uint256 amount) nonReentrant external payable {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 totalCost = amount * pricePerToken;
        require(msg.value >= totalCost, ""Insufficient funds sent"");

        // Transfer tokens to the buyer
        bool success = token.transfer(msg.sender, amount);
        require(success, ""Token transfer failed"");

        // Refund any excess ether
        if (msg.value > totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }

        emit TokensPurchased(msg.sender, amount);
    }
}",2.921517372131348,buyTokens,"[{'function': 'buyTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalCost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""pricePerToken""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCost""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds sent""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCost""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCost""}}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensPurchased""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",61.0,0.6377204384267978,0.0458065260968984,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is ReentrancyGuard, Ownable {
    IERC20 public token;
    uint256 public pricePerToken;

    event TokensPurchased(address indexed buyer, uint256 amount);

    constructor(address _tokenAddress, uint256 _pricePerToken) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        pricePerToken = _pricePerToken;
    }

    function buyTokens(uint256 amount) nonReentrant external payable {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 totalCost = amount * pricePerToken;
        require(msg.value >= totalCost, ""Insufficient funds sent"");

        // Transfer tokens to the buyer
        bool success = token.transfer(msg.sender, amount);
        require(success, ""Token transfer failed"");

        // Refund any excess ether
        if (msg.value > totalCost) {
            payable(msg.sender).transfer(msg.value - totalCost);
        }

        emit TokensPurchased(msg.sender, amount);
    }
}"
1386,Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FIFOSystem {
    using SafeMath for uint256;

    uint256 public minimumDeposit = 1 ether; // Example minimum deposit amount in wei (1 sUSD)

    function setMinimumDeposit(uint256 _minimumDeposit) external onlyOwner {
        require(_minimumDeposit > 0, ""Minimum deposit must be greater than zero"");
        minimumDeposit = _minimumDeposit;
    }

    function depositSUSD() external payable {
        require(msg.value >= minimumDeposit, ""Insufficient funds sent"");
        // Additional logic for depositing sUSD into the FIFO queue can be added here
    }
}",1.653611421585083,setMinimumDeposit,"[{'function': 'setMinimumDeposit', 'complexity': 1}, {'function': 'depositSUSD', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minimumDeposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minimumDeposit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum deposit must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minimumDeposit""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minimumDeposit""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8716268738187419,0.2426284563218242,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FIFOSystem is Ownable {
    using SafeMath for uint256;

    uint256 public minimumDeposit = 1 ether; // Example minimum deposit amount in wei (1 sUSD)

    constructor() Ownable(msg.sender) {
        minimumDeposit = 1 ether;
    }

    function setMinimumDeposit(uint256 _minimumDeposit) external onlyOwner {
        require(_minimumDeposit > 0, ""Minimum deposit must be greater than zero"");
        minimumDeposit = _minimumDeposit;
    }

    function depositSUSD() external payable {
        require(msg.value >= minimumDeposit, ""Insufficient funds sent"");
        // Additional logic for depositing sUSD into the FIFO queue can be added here
    }
}"
6236,Helper function that checks for ERC777TokensSender on the sender and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is IERC777Recipient {
    using SafeMath for uint256;

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        require(msg.sender == address(this), ""Only this contract can call this function"");
        // Additional logic can be added here
    }
}",1.515958547592163,tokensReceived,"[{'function': 'tokensReceived', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokensReceived"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only this contract can call this function""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7490390156369793,0.0177133116803431,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is IERC777Recipient {
    using SafeMath for uint256;

    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(DEFAULT_BOOL) {
        super(DEFAULT_ADDRESS, DEFAULT_STRING);
        // Initialize other state variables here if needed
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        require(msg.sender == address(this), ""Only this contract can call this function"");
        // Additional logic can be added here
    }
}"
1700,This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CONTROLLER_ROLE = keccak256(""CONTROLLER_ROLE"");
    uint256 public endTime;

    constructor(uint256 _endTime) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(CONTROLLER_ROLE, DEFAULT_ADMIN_ROLE);
        endTime = _endTime;
    }

    function withdrawTokens() public onlyRole(CONTROLLER_ROLE) {
        require(block.timestamp >= endTime, ""Contribution period has not ended yet."");
        // Additional logic can be added here
    }
}",1.924188137054444,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, {""type"": ""stringLiteral"", ""value"": ""Contribution period has not ended yet.""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CONTROLLER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.4134773344520981,0.0360582304680996,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant CONTROLLER_ROLE = keccak256(""CONTROLLER_ROLE"");
    uint256 public endTime;

    constructor(uint256 _endTime) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(CONTROLLER_ROLE, DEFAULT_ADMIN_ROLE);
        endTime = _endTime;
    }

    function withdrawTokens() public onlyRole(CONTROLLER_ROLE) {
        require(block.timestamp >= endTime, ""Contribution period has not ended yet."");
        // Additional logic can be added here
    }
}"
250,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TimeLockManager is Ownable {
    uint256 public immutable absoluteMinTimeLock;
    uint256 public timeLock;

    constructor(uint256 _absoluteMinTimeLock) {
        require(_absoluteMinTimeLock > 0, ""Absolute minimum timelock must be greater than zero"");
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimeLock(uint256 newTimeLock) external onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New timelock cannot be lower than the absolute minimum timelock"");
        timeLock = newTimeLock;
    }
}",1.628507375717163,setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timelock cannot be lower than the absolute minimum timelock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8938768213295168,0.2559331300463092,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLockManager is Ownable {
    uint256 public immutable absoluteMinTimeLock;
    uint256 public timeLock;

    constructor(uint256 _absoluteMinTimeLock) Ownable() {
        require(_absoluteMinTimeLock > 0, ""Absolute minimum timelock must be greater than zero"");
        absoluteMinTimeLock = _absoluteMinTimeLock;
        // Initialize timeLock to a safe non-zero value
        if (_absoluteMinTimeLock == 1) {
            timeLock = 2; // Ensure it's always above the minimum
        } else {
            timeLock = _absoluteMinTimeLock + 1; // Safe initialization
        }
    }

    function setTimeLock(uint256 newTimeLock) external onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New timelock cannot be lower than the absolute minimum timelock"");
        timeLock = newTimeLock;
    }
}"
5791,Give melon tokens to receive shares of this fund,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MelonFundDistribution is Ownable {
    using SafeMath for uint256;

    IERC20 public melonToken;
    mapping(address => uint256) public shares;

    constructor(address _melonTokenAddress) {
        melonToken = IERC20(_melonTokenAddress);
    }

    function distributeTokens() external onlyOwner {
        uint256 totalSupply = melonToken.totalSupply();
        for (uint256 i = 0; i < ownerCount; i++) {
            address recipient = owners[i];
            uint256 share = shares[recipient];
            if (share > 0) {
                uint256 amount = totalSupply.mul(share).div(100);
                require(melonToken.transfer(recipient, amount), ""Transfer failed"");
            }
        }
    }
}",2.4471242427825928,distributeTokens,"[{'function': 'distributeTokens', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""melonToken""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""ownerCount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""share"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""shares""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""share""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""share""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""melonToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.4076467168757715,0.0239178822962141,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MelonFundDistribution is Ownable {
    using SafeMath for uint256;

    IERC20 public melonToken;
    mapping(address => uint256) public shares;

    uint256 public totalSupply;

 constructor(address _melonTokenAddress) Ownable(msg.sender) {
        melonToken = IERC20(_melonTokenAddress);
        // Initialize state variables with safe, non-corner-case values
        melonToken = IERC20(_melonTokenAddress);
        shares[address(0x111)] = 50; // Example share initialization
        shares[address(0x222)] = 30; // Example share initialization
        shares[address(0x333)] = 20; // Example share initialization
    }

    function distributeTokens() external onlyOwner {
        uint256 totalSupply = melonToken.totalSupply();
        for (uint256 i = 0; i < ownerCount; i++) {
            address recipient = owners[i];
            uint256 share = shares[recipient];
            if (share > 0) {
                uint256 amount = totalSupply.mul(share).div(100);
                require(melonToken.transfer(recipient, amount), ""Transfer failed"");
            }
        }
    }
}"
1160,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor(address _tokenAddress, uint256 _newBuyPrice, uint256 _newSellPrice) {
        token = IToken(_tokenAddress);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() public payable {
        require(msg.value == newBuyPrice, ""Incorrect amount of ETH sent"");
        uint256 tokensToSend = msg.value.div(newBuyPrice);
        require(token.transfer(msg.sender, tokensToSend), ""Token transfer failed"");
    }

    function sellTokens(uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 ethToReceive = _amount.mul(newSellPrice);
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance to sell tokens"");
        require(token.transfer(owner(), _amount), ""Token transfer failed"");
        payable(msg.sender).transfer(ethToReceive);
    }
}",3.430776834487915,sellTokens,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 2}, {'function': 'sellTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethToReceive"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newSellPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to sell tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethToReceive""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.4612952704748286,0.00797747599484,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress, uint256 _newBuyPrice, uint256 _newSellPrice) Ownable(msg.sender) {
        token = IToken(_tokenAddress);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() public payable {
        require(msg.value == newBuyPrice, ""Incorrect amount of ETH sent"");
        uint256 tokensToSend = msg.value.div(newBuyPrice);
        require(token.transfer(msg.sender, tokensToSend), ""Token transfer failed"");
    }

    function sellTokens(uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 ethToReceive = _amount.mul(newSellPrice);
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance to sell tokens"");
        require(token.transfer(owner(), _amount), ""Token transfer failed"");
        payable(msg.sender).transfer(ethToReceive);
    }
}"
3416,Returns all the relevant information about a specific property .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PropertyRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => Property) public properties;
    uint256 public propertyCount;

    struct Property {
        uint256 id;
        string name;
        address owner;
        uint256 price;
        bool forSale;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addProperty(string memory name, uint256 price) public onlyRole(ADMIN_ROLE) returns (uint256) {
        propertyCount++;
        properties[propertyCount] = Property({
            id: propertyCount,
            name: name,
            owner: msg.sender,
            price: price,
            forSale: true
        });
        return propertyCount;
    }

    function getProperty(uint256 id) public view returns (uint256, string memory, address, uint256, bool) {
        require(_exists(id), ""Property does not exist"");
        Property storage property = properties[id];
        return (property.id, property.name, property.owner, property.price, property.forSale);
    }

    function _exists(uint256 id) internal view returns (bool) {
        return id <= propertyCount && id > 0;
    }
}",3.595589399337769,addProperty,"[{'function': 'addProperty', 'complexity': 1}, {'function': 'getProperty', 'complexity': 1}, {'function': '_exists', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addProperty"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""propertyCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyCount""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Property""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""propertyCount""}, {""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""id"", ""name"", ""owner"", ""price"", ""forSale""]}}}, {""type"": ""Identifier"", ""name"": ""propertyCount""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",76.0,0.4716728912642321,0.0052564785146732,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PropertyRegistry is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => Property) public properties;
    uint256 public propertyCount;

    struct Property {
        uint256 id;
        string name;
        address owner;
        uint256 price;
        bool forSale;
    }

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        propertyCount = 1; // Initialize to a non-zero value
    }

    function addProperty(string memory name, uint256 price) public onlyRole(ADMIN_ROLE) returns (uint256) {
        require(price > 0, ""Price must be greater than zero""); // Ensure price is valid
        propertyCount++;
        properties[propertyCount] = Property({
            id: propertyCount,
            name: name,
            owner: msg.sender,
            price: price,
            forSale: true
        });
        return propertyCount;
    }

    function getProperty(uint256 id) public view returns (uint256, string memory, address, uint256, bool) {
        require(_exists(id), ""Property does not exist"");
        Property storage property = properties[id];
        return (property.id, property.name, property.owner, property.price, property.forSale);
    }

    function _exists(uint256 id) internal view returns (bool) {
        return id <= propertyCount && id > 0;
    }
}"
4560,Get the current total number of market listings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}","pragma solidity ^0.8.0;

interface IMarketplace {
    function getTotalListings() external view returns (uint256);
}

contract Marketplace is IMarketplace {
    using SafeMath for uint256;

    mapping(address => bool) private authorizedUsers;

    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender], ""Not Authorized"");
        _;
    }

    function addAuthorizedUser(address user) external {
        authorizedUsers[user] = true;
    }

    uint256 private totalListings;

    function getTotalListings() external view override onlyAuthorized returns (uint256) {
        return totalListings;
    }

    function addListing(uint256 listingId) external onlyAuthorized {
        totalListings = totalListings.add(listingId);
    }
}",1.8775203227996824,addAuthorizedUser,"[{'function': 'getTotalListings', 'complexity': 0}, {'function': 'addAuthorizedUser', 'complexity': 0}, {'function': 'getTotalListings', 'complexity': 0}, {'function': 'addListing', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAuthorizedUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.183801092467841,0.0215603584683474,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IMarketplace {
    function getTotalListings() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Marketplace is IMarketplace, Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private authorizedUsers;

    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender], ""Not Authorized"");
        _;
    }

    uint256 private totalListings;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        authorizedUsers[_msgSender()] = true; // msg.sender is the deployer
        totalListings = 1; // Set to 1 (never 0)
    }

    function getTotalListings() external view override onlyAuthorized returns (uint256) {
        return totalListings;
    }

    function addListing(uint256 listingId) external onlyAuthorized {
        totalListings = totalListings.add(listingId);
    }
}"
2354,Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface ITokenReceiver {
    function onTransferReceived(address sender, uint256 amount) external returns (bool);
}

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    function transferTokens(IERC20 token, address from, address to, uint256 amount) public onlyOwner returns (bool) {
        require(token.balanceOf(from) >= amount, ""Insufficient balance"");
        bool success = token.transferFrom(from, to, amount);
        if (success && to.code.length > 0 && ITokenReceiver(to).onTransferReceived(from, amount)) {
            return true;
        } else {
            revert(""Transfer or callback failed"");
        }
    }
}",2.002382516860962,transferTokens,"[{'function': 'onTransferReceived', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""code""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITokenReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""onTransferReceived""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Transfer or callback failed""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",55.0,0.6166635301595891,0.0632540490300168,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ITokenReceiver {
    function onTransferReceived(address sender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(IERC20 token, address from, address to, uint256 amount) public onlyOwner returns (bool) {
        require(token.balanceOf(from) >= amount, ""Insufficient balance"");
        bool success = token.transferFrom(from, to, amount);
        if (success && to.code.length > 0 && ITokenReceiver(to).onTransferReceived(from, amount)) {
            return true;
        } else {
            revert(""Transfer or callback failed"");
        }
    }
}"
3881,Check if specified holder trusts an address with recovery procedure .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TrustRecovery is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant TRUST_ROLE = keccak256(""TRUST_ROLE"");

    mapping(address => bool) private trusts;

    event TrustSet(address indexed holder, address indexed trustedAddress);
    event TrustRemoved(address indexed holder, address indexed trustedAddress);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRUST_ROLE, msg.sender);
    }

    function setTrust(address holder, address trustedAddress) public onlyRole(TRUST_ROLE) {
        trusts[trustedAddress] = true;
        emit TrustSet(holder, trustedAddress);
    }

    function removeTrust(address holder, address trustedAddress) public onlyRole(TRUST_ROLE) {
        trusts[trustedAddress] = false;
        emit TrustRemoved(holder, trustedAddress);
    }

    function isTrusted(address holder, address trustedAddress) public view returns (bool) {
        return trusts[trustedAddress];
    }
}",2.6678237915039062,setTrust,"[{'function': 'setTrust', 'complexity': 0}, {'function': 'removeTrust', 'complexity': 0}, {'function': 'isTrusted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTrust"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""trustedAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trusts""}, ""index"": {""type"": ""Identifier"", ""name"": ""trustedAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TrustSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""holder""}, {""type"": ""Identifier"", ""name"": ""trustedAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""TRUST_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.6133613421162069,0.0319698853264512,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TrustRecovery is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant TRUST_ROLE = keccak256(""TRUST_ROLE"");

    mapping(address => bool) private trusts;

    event TrustSet(address indexed holder, address indexed trustedAddress);
    event TrustRemoved(address indexed holder, address indexed trustedAddress);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRUST_ROLE, msg.sender);
    }

    function setTrust(address holder, address trustedAddress) public onlyRole(TRUST_ROLE) {
        trusts[trustedAddress] = true;
        emit TrustSet(holder, trustedAddress);
    }

    function removeTrust(address holder, address trustedAddress) public onlyRole(TRUST_ROLE) {
        trusts[trustedAddress] = false;
        emit TrustRemoved(holder, trustedAddress);
    }

    function isTrusted(address holder, address trustedAddress) public view returns (bool) {
        return trusts[trustedAddress];
    }
}"
2976,Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenBlacklistRemover is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    address public blacklistedAccount;

    constructor(address _token, address _blacklistedAccount) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        blacklistedAccount = _blacklistedAccount;
    }

    function removeBlacklistPermission(address user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(user != address(0), ""Invalid address"");
        require(blacklistedAccount != address(0), ""Blacklisted account not set"");
        token.transferFrom(msg.sender, blacklistedAccount, token.balanceOf(user));
    }
}",2.216273784637451,removeBlacklistPermission,"[{'function': 'removeBlacklistPermission', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeBlacklistPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""blacklistedAccount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Blacklisted account not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""blacklistedAccount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.765208165205762,0.0467605887845406,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is used here for proper mapping(address => uint256) public balanceOf;

 constructor invocation

contract TokenBlacklistRemover is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public blacklistedAccount;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _blacklistedAccount) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        blacklistedAccount = _blacklistedAccount;
    }

    function removeBlacklistPermission(address user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(user != address(0), ""Invalid address"");
        require(blacklistedAccount != address(0), ""Blacklisted account not set"");
        token.transferFrom(msg.sender, blacklistedAccount, token.balanceOf(user));
    }
}"
6370,This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    IERC20 public token;
    bool public transferEnabled = false;
    uint256 public endICO;

    constructor(address _token, uint256 _endICO) {
        token = IERC20(_token);
        endICO = _endICO;
    }

    function enableTransfers() external onlyOwner {
        require(block.timestamp > endICO, ""Token transfers are not enabled yet."");
        transferEnabled = true;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are not enabled."");
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance."");
        token.transferFrom(msg.sender, to, amount);
    }
}",2.1534841060638428,transferTokens,"[{'function': 'enableTransfers', 'complexity': 1}, {'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are not enabled.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.5476143819635236,0.0446937986662945,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    IERC20 public token;
    bool public transferEnabled = false;
    uint256 public endICO;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, uint256 _endICO) Ownable(msg.sender) {
        token = IERC20(_token);
        endICO = _endICO;
    }

    function enableTransfers() external onlyOwner {
        require(block.timestamp > endICO, ""Token transfers are not enabled yet."");
        transferEnabled = true;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are not enabled."");
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance."");
        token.transferFrom(msg.sender, to, amount);
    }
}"
3576,adds or removes addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Whitelist is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    mapping(address => bool) private whitelist;

    event AddedToWhitelist(address indexed user);
    event RemovedFromWhitelist(address indexed user);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WHITELIST_ROLE, msg.sender);
    }

    function addToWhitelist(address[] memory users) public onlyRole(WHITELIST_ROLE) {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = true;
            emit AddedToWhitelist(users[i]);
        }
    }

    function removeFromWhitelist(address[] memory users) public onlyRole(WHITELIST_ROLE) {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = false;
            emit RemovedFromWhitelist(users[i]);
        }
    }

    function isWhitelisted(address user) public view returns (bool) {
        return whitelist[user];
    }
}",3.19732928276062,addToWhitelist,"[{'function': 'addToWhitelist', 'complexity': 1}, {'function': 'removeFromWhitelist', 'complexity': 1}, {'function': 'isWhitelisted', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""users"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""users""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddedToWhitelist""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELIST_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.5802830887312606,0.0390874766182258,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Whitelist is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    mapping(address => bool) private whitelist;

    event AddedToWhitelist(address indexed user);
    event RemovedFromWhitelist(address indexed user);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WHITELIST_ROLE, msg.sender);
    }

    function addToWhitelist(address[] memory users) public onlyRole(WHITELIST_ROLE) {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = true;
            emit AddedToWhitelist(users[i]);
        }
    }

    function removeFromWhitelist(address[] memory users) public onlyRole(WHITELIST_ROLE) {
        for (uint256 i = 0; i < users.length; i++) {
            whitelist[users[i]] = false;
            emit RemovedFromWhitelist(users[i]);
        }
    }

    function isWhitelisted(address user) public view returns (bool) {
        return whitelist[user];
    }
}"
1319,Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Token is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    string public name = ""TokenName"";
    string public symbol = ""TKN"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10**uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);

        emit Transfer(sender, recipient, amount);
        return true;
    }
}",5.643429279327393,transferFrom,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.5407123206906506,0.0832724096908118,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    string public name = ""TokenName"";
    string public symbol = ""TKN"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) Ownable(msg.sender) {
        _totalSupply = initialSupply * 10**uint256(decimals);
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);

        emit Transfer(sender, recipient, amount);
        return true;
    }
}"
4806,Returns the ether in escrow to the seller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}","pragma solidity ^0.8.0;

interface IEscrow {
    function release(address payable seller) external;
}

contract Escrow is IEscrow {
    address public buyer;
    uint256 public amount;

    constructor(address _buyer, uint256 _amount) {
        require(_buyer != address(0), ""Invalid buyer address"");
        buyer = _buyer;
        amount = _amount;
    }

    function release(address payable seller) external override {
        require(msg.sender == buyer, ""Only the buyer can release funds"");
        (bool success, ) = seller.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",1.5480678081512451,release,"[{'function': 'release', 'complexity': 0}, {'function': 'release', 'complexity': 2}]",3.0,{},81.0,0.5510594467999593,0.0105225624244965,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IEscrow {
    function release(address payable seller) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable, IEscrow {
    address public buyer;
    uint256 public amount;

    constructor(address _buyer, uint256 _amount) Ownable(_buyer) {
        require(_buyer != address(0), ""Invalid buyer address"");
        buyer = _buyer;
        amount = _amount;
    }

    function release(address payable seller) external override {
        require(msg.sender == buyer, ""Only the buyer can release funds"");
        (bool success, ) = seller.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}"
3857,Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Campaign is Ownable {
    enum State {Inactive, Active}
    State public state;
    address public controller;
    mapping(address => uint256) public contributions;
    uint256 public minimumContribution;
    uint256 public teamTokenVault;

    event CampaignActivated();

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can activate the campaign."");
        _;
    }

    constructor(address _controller, uint256 _minimumContribution) {
        controller = _controller;
        minimumContribution = _minimumContribution;
        state = State.Inactive;
    }

    function setTeamTokenVault(uint256 amount) external onlyOwner {
        teamTokenVault = amount;
    }

    function activateCampaign() external onlyController {
        require(teamTokenVault > 0, ""Team token vault must be set up to activate the campaign."");
        state = State.Active;
        emit CampaignActivated();
    }
}",2.396855115890503,activateCampaign,"[{'function': 'setTeamTokenVault', 'complexity': 0}, {'function': 'activateCampaign', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""activateCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""teamTokenVault""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Team token vault must be set up to activate the campaign.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Active""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignActivated""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.6526069273266484,0.0712504554802864,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    enum State {Inactive, Active}
    State public state;
    address public controller;
    mapping(address => uint256) public contributions;
    uint256 public minimumContribution;
    uint256 public teamTokenVault;

    event CampaignActivated();

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can activate the campaign."");
        _;
    }

    constructor(address _controller, uint256 _minimumContribution) Ownable(msg.sender) {
        controller = _controller;
        minimumContribution = _minimumContribution;
        state = State.Inactive;
    }

    function setTeamTokenVault(uint256 amount) external onlyOwner {
        teamTokenVault = amount;
    }

    function activateCampaign() external onlyController {
        require(teamTokenVault > 0, ""Team token vault must be set up to activate the campaign."");
        state = State.Active;
        emit CampaignActivated();
    }
}"
497,Add an associated Synth contract to the Synthetix system,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISynth {
    function mint(address to, uint256 amount) external;
}

contract Synthetix is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    ISynth public synthContract;

    constructor(address _synthAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
        synthContract = ISynth(_synthAddress);
    }

    function addMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MINTER_ROLE, minter);
    }

    function removeMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MINTER_ROLE, minter);
    }

    function mintSynth(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        synthContract.mint(to, amount);
    }
}",2.91755747795105,addMinter,"[{'function': 'mint', 'complexity': 0}, {'function': 'addMinter', 'complexity': 0}, {'function': 'removeMinter', 'complexity': 0}, {'function': 'mintSynth', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addMinter"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""minter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""Identifier"", ""name"": ""minter""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.3510331674130091,0.0170974705310289,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function mint(address to, uint256 amount) external;
}

contract Synthetix is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    ISynth public synthContract;

    constructor(address _synthAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
        synthContract = ISynth(_synthAddress);
    }

    function addMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MINTER_ROLE, minter);
    }

    function removeMinter(address minter) public onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MINTER_ROLE, minter);
    }

    function mintSynth(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        synthContract.mint(to, amount);
    }
}"
5313,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public basePrice;
    uint256 public remainingResources;
    uint256 public priceDecreaseRate;

    constructor(uint256 _basePrice, uint256 _remainingResources, uint256 _priceDecreaseRate) {
        require(_remainingResources > 0, ""Remaining resources must be greater than zero"");
        basePrice = _basePrice;
        remainingResources = _remainingResources;
        priceDecreaseRate = _priceDecreaseRate;
    }

    function updatePrice(uint256 usedResources) public onlyOwner {
        require(usedResources <= remainingResources, ""Not enough resources left"");
        uint256 newRemainingResources = remainingResources.sub(usedResources);
        if (newRemainingResources > 0) {
            basePrice = basePrice.mul(100).div(newRemainingResources);
            remainingResources = newRemainingResources;
        } else {
            basePrice = 0;
        }
    }
}",2.689719915390014,updatePrice,"[{'function': 'updatePrice', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""usedResources"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""usedResources""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingResources""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough resources left""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRemainingResources"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""remainingResources""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usedResources""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newRemainingResources""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""basePrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""basePrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRemainingResources""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""remainingResources""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRemainingResources""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""basePrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.7270121091323533,0.0426207833826948,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public basePrice;
    uint256 public remainingResources;
    uint256 public priceDecreaseRate;

    constructor() {
        basePrice = 1;
        remainingResources = 100; // Set to a value greater than zero
        priceDecreaseRate = 10; // Example rate, adjust as needed
        Ownable.init(msg.sender);
    }

    function updatePrice(uint256 usedResources) public onlyOwner {
        require(usedResources <= remainingResources, ""Not enough resources left"");
        uint256 newRemainingResources = remainingResources.sub(usedResources);
        if (newRemainingResources > 0) {
            basePrice = basePrice.mul(100).div(newRemainingResources);
            remainingResources = newRemainingResources;
        } else {
            basePrice = 0;
        }
    }
}"
565,Removes a list of addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract WhitelistRemover is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant WHITELIST_REMOVER_ROLE = keccak256(""WHITELIST_REMOVER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WHITELIST_REMOVER_ROLE, msg.sender);
    }

    function removeAddressesFromWhitelist(address[] memory addresses) public onlyRole(WHITELIST_REMOVER_ROLE) {
        for (uint256 i = 0; i < addresses.length; i++) {
            // Additional logic can be added here to handle the removal of each address from the whitelist
            // For example, you might want to emit an event or update a state variable indicating that the address has been removed
        }
    }
}",2.303053617477417,removeAddressesFromWhitelist,"[{'function': 'removeAddressesFromWhitelist', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAddressesFromWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELIST_REMOVER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.8490237321530487,0.1879024600783667,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract WhitelistRemover is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant WHITELIST_REMOVER_ROLE = keccak256(""WHITELIST_REMOVER_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(WHITELIST_REMOVER_ROLE, admin);
        transferOwnership(admin);
    }

    function removeAddressesFromWhitelist(address[] memory addresses) public onlyRole(WHITELIST_REMOVER_ROLE) {
        for (uint256 i = 0; i < addresses.length; i++) {
            // Additional logic can be added here to handle the removal of each address from the whitelist
            // For example, you might want to emit an event or update a state variable indicating that the address has been removed
        }
    }
}"
3142,Get the token balance of ` tokenOwner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenBalanceGetter {
    function getTokenBalance(address tokenAddress, address tokenOwner) public view returns (uint256) {
        require(tokenAddress != address(0), ""Invalid token address"");
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(tokenOwner);
    }
}",1.1131694316864014,getTokenBalance,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenOwner""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",19.0,0.8539576336725231,0.1803130733976817,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenBalanceGetter is Ownable {
    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenBalance(address tokenAddress, address tokenOwner) public view returns (uint256) {
        require(tokenAddress != address(0), ""Invalid token address"");
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(tokenOwner);
    }
}"
3096,This method can be used by the owner to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenRecovery is Ownable {
    function recoverTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(owner(), amount), ""Token transfer failed"");
    }
}",1.116382360458374,recoverTokens,"[{'function': 'recoverTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.661213701640828,0.1072010329170778,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRecovery is Ownable {
    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized by the parent contract (Ownable)
    }

    function recoverTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(owner(), amount), ""Token transfer failed"");
    }
}"
6593,returns the trader of the given orderID .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract OrderBook is AccessControl {
    struct Order {
        address trader;
        // other order details...
    }

    mapping(uint256 => Order) public orders;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function getTrader(uint256 orderID) external view returns (address) {
        require(_exists(orderID), ""Order does not exist"");
        return orders[orderID].trader;
    }

    function _exists(uint256 orderID) internal view returns (bool) {
        return orders[orderID].trader != address(0);
    }
}",1.7133903503417969,getTrader,"[{'function': 'getTrader', 'complexity': 1}, {'function': '_exists', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTrader"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderID""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Order does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderID""}}, ""memberName"": ""trader""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.8853175341214763,0.2578557675410513,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderBook is AccessControl, Ownable {
    struct Order {
        address trader;
        // other order details...
    }

    mapping(uint256 => Order) public orders;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        for (uint256 i = 1; i <= 3; i++) {
            orders[i] = Order({trader: address(uint160(uint256(keccak256(abi.encodePacked(""trader"", i))))});
        }
    }

    function getTrader(uint256 orderID) external view returns (address) {
        require(_exists(orderID), ""Order does not exist"");
        return orders[orderID].trader;
    }

    function _exists(uint256 orderID) internal view returns (bool) {
        return orders[orderID].trader != address(0);
    }
}"
2524,Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    function transferTokens(address _from, address _to, uint256 _amount) public onlyOwner returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        IERC20 token = IERC20(0xYourTokenAddress); // Replace with actual token address
        require(token.allowance(_from, address(this)) >= _amount, ""Contract allowance not sufficient"");
        require(token.balanceOf(_from) >= _amount, ""Insufficient balance to transfer"");

        bool success = token.transferFrom(_from, _to, _amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}",2.256875276565552,transferTokens,"[{'function': 'transferTokens', 'complexity': 4}]",5.0,{},34.0,0.8483664588799964,0.2569464185948587,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(address _from, address _to, uint256 _amount) public onlyOwner returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        IERC20 token = IERC20(0xYourTokenAddress); // Replace with actual token address
        require(token.allowance(_from, address(this)) >= _amount, ""Contract allowance not sufficient"");
        require(token.balanceOf(_from) >= _amount, ""Insufficient balance to transfer"");

        bool success = token.transferFrom(_from, _to, _amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}"
4577,Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApproval is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function approveToken(address _who, uint256 _value) external onlyOwner returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        return token.approve(_who, _value);
    }
}",1.4496393203735352,approveToken,"[{'function': 'approveToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.8326446657577559,0.2753048866934419,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function approveToken(address _who, uint256 _value) external onlyOwner returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        return token.approve(_who, _value);
    }
}"
6152,Whether price of asset has been updated less than VALIDITY seconds ago,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetPriceUpdater {
    using SafeMath for uint256;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds
    mapping(address => uint256) public lastUpdateTime;

    function hasPriceBeenUpdatedLessThanOneHourAgo() external view returns (bool) {
        require(lastUpdateTime[msg.sender] != 0, ""No update has been made yet."");
        return block.timestamp.sub(lastUpdateTime[msg.sender]) < VALIDITY;
    }
}",1.4811320304870603,hasPriceBeenUpdatedLessThanOneHourAgo,"[{'function': 'hasPriceBeenUpdatedLessThanOneHourAgo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasPriceBeenUpdatedLessThanOneHourAgo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastUpdateTime""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No update has been made yet.""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastUpdateTime""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""VALIDITY""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.6633395751301159,0.1200867879321324,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetPriceUpdater is Ownable {
    using SafeMath for uint256;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds
    mapping(address => uint256) public lastUpdateTime;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        VALIDITY = 3600;
        // Assuming the address array is initialized with specific addresses as per the requirement
        lastUpdateTime[address(0x111)] = block.timestamp;
        lastUpdateTime[address(0x222)] = block.timestamp;
        lastUpdateTime[address(0x333)] = block.timestamp;
    }

    function hasPriceBeenUpdatedLessThanOneHourAgo() external view returns (bool) {
        require(lastUpdateTime[msg.sender] != 0, ""No update has been made yet."");
        return block.timestamp.sub(lastUpdateTime[msg.sender]) < VALIDITY;
    }
}"
4397,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        token = IERC20(_token);
        transferEnabled = true;
    }

    function setTransferEnabled(bool enabled) external onlyAdmin {
        transferEnabled = enabled;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are currently disabled."");
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin."");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer."");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed."");
    }
}",2.7066352367401123,transferTokens,"[{'function': 'setTransferEnabled', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are currently disabled.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed.""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.541833079787232,0.0037326563418176,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) { // Initialize Ownable with admin address
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        token = IERC20(_token);
        transferEnabled = true;
    }

    function setTransferEnabled(bool enabled) external onlyOwner { // Only owner can enable transfers
        transferEnabled = enabled;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are currently disabled."");
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin."");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer."");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed."");
    }
}"
6310,Set address of migration target contract and enable migration process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MigrationContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MIGRATOR_ROLE = keccak256(""MIGRATOR_ROLE"");
    address private _targetContract;
    bool private _migrationEnabled;

    constructor(address target) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setTargetContract(target);
    }

    function setMigrationTarget(address target) public onlyRole(MIGRATOR_ROLE) {
        _setTargetContract(target);
    }

    function enableMigration() public onlyRole(DEFAULT_ADMIN_ROLE) {
        _migrationEnabled = true;
    }

    function migrate() public onlyRole(MIGRATOR_ROLE) {
        require(_migrationEnabled, ""Migration is not enabled"");
        // Additional migration logic can be added here
    }

    function getTargetContract() public view returns (address) {
        return _targetContract;
    }

    function isMigrationEnabled() public view returns (bool) {
        return _migrationEnabled;
    }

    function grantMigratorRole(address user) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MIGRATOR_ROLE, user);
    }

    function revokeMigratorRole(address user) public onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MIGRATOR_ROLE, user);
    }

    function renounceRole() public {
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function _setTargetContract(address target) internal {
        require(target != address(0), ""Invalid target contract address"");
        _targetContract = target;
    }
}",4.025704145431519,migrate,"[{'function': 'setMigrationTarget', 'complexity': 0}, {'function': 'enableMigration', 'complexity': 0}, {'function': 'migrate', 'complexity': 1}, {'function': 'getTargetContract', 'complexity': 0}, {'function': 'isMigrationEnabled', 'complexity': 0}, {'function': 'grantMigratorRole', 'complexity': 0}, {'function': 'revokeMigratorRole', 'complexity': 0}, {'function': 'renounceRole', 'complexity': 0}, {'function': '_setTargetContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_setTargetContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid target contract address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_targetContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""target""}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.5353481779562413,0.0490518283258345,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MigrationContract is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MIGRATOR_ROLE = keccak256(""MIGRATOR_ROLE"");
    address private _targetContract;
    bool private _migrationEnabled;

    constructor(address target) Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setTargetContract(target);
    }

    function setMigrationTarget(address target) public onlyRole(MIGRATOR_ROLE) {
        _setTargetContract(target);
    }

    function enableMigration() public onlyRole(DEFAULT_ADMIN_ROLE) {
        _migrationEnabled = true;
    }

    function migrate() public onlyRole(MIGRATOR_ROLE) {
        require(_migrationEnabled, ""Migration is not enabled"");
        // Additional migration logic can be added here
    }

    function getTargetContract() public view returns (address) {
        return _targetContract;
    }

    function isMigrationEnabled() public view returns (bool) {
        return _migrationEnabled;
    }

    function grantMigratorRole(address user) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MIGRATOR_ROLE, user);
    }

    function revokeMigratorRole(address user) public onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MIGRATOR_ROLE, user);
    }

    function renounceRole() public {
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function _setTargetContract(address target) internal {
        require(target != address(0), ""Invalid target contract address"");
        _targetContract = target;
    }
}"
4553,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Mintable is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Minting not allowed for this user"");
        // Additional logic can be added here
    }
}",1.7783536911010742,mint,"[{'function': 'mint', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Minting not allowed for this user""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.7543186326153615,0.0967270243060629,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Mintable is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Minting not allowed for this user"");
        // Additional logic can be added here
    }
}"
4912,Used only if there are some leftover funds ( because of topUpBalance ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public balances;

    event TopUpBalance(address indexed user, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function topUpBalance(address user, uint256 amount) public onlyRole(ADMIN_ROLE) {
        balances[user] = balances[user].add(amount);
        emit TopUpBalance(user, amount);
    }
}",1.9749727249145508,topUpBalance,"[{'function': 'topUpBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""topUpBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TopUpBalance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.5287694301319862,0.0551778488981649,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public balances;

    event TopUpBalance(address indexed user, uint256 amount);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        balances[msg.sender] = 1000; // Initialize the balance of the owner to 1
    }

    function topUpBalance(address user, uint256 amount) public onlyRole(ADMIN_ROLE) {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        balances[user] = balances[user].add(amount);
        emit TopUpBalance(user, amount);
    }
}"
4727,This method MUST NEVER be called by smart contract code .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 a, uint256 b) public view onlyAdmin returns (uint256) {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        return a.add(b);
    }
}",1.7859513759613037,myFunction,"[{'function': 'myFunction', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.3355546774243957,0.051820224450817,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 a, uint256 b) public view onlyAdmin returns (uint256) {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        return a.add(b);
    }
}"
5921,Hash ( keccak256 ) of the payload used by approvePreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract ApprovePreSigned is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => bool) public approvedHashes;

    IERC20 public token;

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, admin);
        token = IERC20(_token);
    }

    function approvePreSigned(bytes32 payloadHash, uint256 amount) external {
        require(!approvedHashes[payloadHash], ""Payload already approved"");
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");

        // Approve the token transfer
        bool success = token.approve(msg.sender, amount);
        require(success, ""Token approval failed"");

        // Mark the payload hash as approved
        approvedHashes[payloadHash] = true;
    }
}",3.0124828815460205,approvePreSigned,"[{'function': 'approve', 'complexity': 0}, {'function': 'approvePreSigned', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approvePreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""payloadHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedHashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""payloadHash""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payload already approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token approval failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedHashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""payloadHash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.7308131375330946,0.013609554174654,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract ApprovePreSigned is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => bool) public approvedHashes;

    IERC20 public token;

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, admin);
        token = IERC20(_token);
    }

    function approvePreSigned(bytes32 payloadHash, uint256 amount) external {
        require(!approvedHashes[payloadHash], ""Payload already approved"");
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");

        // Approve the token transfer
        bool success = token.approve(msg.sender, amount);
        require(success, ""Token approval failed"");

        // Mark the payload hash as approved
        approvedHashes[payloadHash] = true;
    }
}"
5070,Withdraw ether and delete the htlc swap .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IHTLC {
    function withdraw() external;
}

contract HTLC is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    address public htlcAddress;

    constructor(address _htlcAddress) {
        require(_htlcAddress != address(0), ""HTLC contract address cannot be zero"");
        htlcAddress = _htlcAddress;
    }

    function withdrawAndDelete() external nonReentrant {
        IHTLC(htlcAddress).withdraw();
        delete htlcAddress;
    }
}",1.851912021636963,withdrawAndDelete,"[{'function': 'withdraw', 'complexity': 0}, {'function': 'withdrawAndDelete', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawAndDelete"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IHTLC""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""htlcAddress""}], ""names"": []}, ""memberName"": ""withdraw""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""htlcAddress""}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.36117668036102,0.007210205434267,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IHTLC {
    function withdraw() external;
}

contract HTLC is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    address public htlcAddress;

    constructor(address _htlcAddress) Ownable(msg.sender) {
        require(_htlcAddress != address(0), ""HTLC contract address cannot be zero"");
        htlcAddress = _htlcAddress;
    }

    function withdrawAndDelete() external nonReentrant {
        IHTLC(htlcAddress).withdraw();
        delete htlcAddress;
    }
}"
4823,Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MultiTokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccounts;

    constructor() {}

    function freezeAccount(address account) external onlyOwner {
        require(account != address(0), ""Invalid account"");
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(account != address(0), ""Invalid account"");
        delete frozenAccounts[account];
    }

    function transferTokens(
        IERC20 token,
        address[] memory recipients,
        uint256[] memory amounts
    ) public {
        require(recipients.length == amounts.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(!frozenAccounts[recipients[i]], ""Recipient is frozen"");
            uint256 amount = amounts[i];
            token.transferFrom(msg.sender, recipients[i], amount);
        }
    }
}",2.8482916355133057,transferTokens,"[{'function': 'freezeAccount', 'complexity': 1}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'transferTokens', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""freezeAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""frozenAccounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",56.0,0.5657602540578556,0.1672196254461072,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MultiTokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccounts;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function freezeAccount(address account) external onlyOwner {
        require(account != address(0), ""Invalid account"");
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(account != address(0), ""Invalid account"");
        delete frozenAccounts[account];
    }

    function transferTokens(
        IERC20 token,
        address[] memory recipients,
        uint256[] memory amounts
    ) public {
        require(recipients.length == amounts.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(!frozenAccounts[recipients[i]], ""Recipient is frozen"");
            uint256 amount = amounts[i];
            token.transferFrom(msg.sender, recipients[i], amount);
        }
    }
}"
4675,Used to launch the Module with the help of factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ModuleLauncher is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant LAUNCHER_ROLE = keccak256(""LAUNCHER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(LAUNCHER_ROLE, msg.sender);
    }

    function launchModule(address moduleAddress) public onlyRole(LAUNCHER_ROLE) {
        // Additional logic can be added here
    }
}",1.5646324157714844,launchModule,"[{'function': 'launchModule', 'complexity': 0}]",1.0,{},0.0,0.4863828691414274,0.0008054701171019,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ModuleLauncher is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant LAUNCHER_ROLE = keccak256(""LAUNCHER_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(LAUNCHER_ROLE, msg.sender);
        transferOwnership(admin); // Transfer ownership to the provided address
    }

    function launchModule(address moduleAddress) public onlyRole(LAUNCHER_ROLE) {
        // Additional logic can be added here
    }
}"
772,This should be public rather than external .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 a, uint256 b) public onlyRole(ADMIN_ROLE) returns (uint256) {
        return a.add(b);
    }
}",1.618591547012329,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.284459003810865,0.0211231440755999,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 a, uint256 b) public onlyRole(ADMIN_ROLE) returns (uint256) {
        return a.add(b);
    }
}"
6429,Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PoaTokenUpgrader is Ownable {
    address public poaTokenMaster;

    function updatePoaTokenMaster(address newPoaTokenMaster) external onlyOwner {
        require(newPoaTokenMaster != address(0), ""Invalid address"");
        poaTokenMaster = newPoaTokenMaster;
    }
}",1.023906707763672,updatePoaTokenMaster,"[{'function': 'updatePoaTokenMaster', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePoaTokenMaster"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newPoaTokenMaster"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newPoaTokenMaster""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPoaTokenMaster""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.7018252069669164,0.0088690421624942,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PoaTokenUpgrader is Ownable {
    address public poaTokenMaster;

    constructor(address _poaTokenMaster) Ownable(msg.sender) {
        require(_poaTokenMaster != address(0), ""Invalid address"");
        poaTokenMaster = _poaTokenMaster;
    }

    function updatePoaTokenMaster(address newPoaTokenMaster) external onlyOwner {
        require(newPoaTokenMaster != address(0), ""Invalid address"");
        poaTokenMaster = newPoaTokenMaster;
    }
}"
4411,Trust an address to perform recovery procedure for the caller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RecoveryProcedure {
    using SafeMath for uint256;
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");
    mapping(address => bool) private authorizedRecoverers;

    event Recovered(address indexed recoveredBy, address indexed to);

    modifier onlyAuthorizedRecoverer() {
        require(authorizedRecoverers[msg.sender], ""Not an authorized recoverer"");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addAuthorizedRecoverer(address recoverer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        authorizedRecoverers[recoverer] = true;
    }

    function removeAuthorizedRecoverer(address recoverer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(authorizedRecoverers[recoverer], ""Recoverer not authorized"");
        delete authorizedRecoverers[recoverer];
    }

    function trustAddressToRecover(address to) internal virtual {
        addAuthorizedRecoverer(to);
    }

    function recover(address to, uint256 amount) public onlyAuthorizedRecoverer {
        require(amount > 0, ""Amount must be greater than zero"");
        // Perform the recovery procedure logic here
        (bool success, ) = payable(to).call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Recovered(msg.sender, to);
    }
}",3.4628729820251465,recover,"[{'function': 'addAuthorizedRecoverer', 'complexity': 0}, {'function': 'removeAuthorizedRecoverer', 'complexity': 1}, {'function': 'trustAddressToRecover', 'complexity': 0}, {'function': 'recover', 'complexity': 2}]",3.0,{},48.0,0.4783419033032947,0.0355637047945461,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RecoveryProcedure is Ownable, AccessControl {
    using SafeMath for uint256;
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");
    mapping(address => bool) private authorizedRecoverers;

    event Recovered(address indexed recoveredBy, address indexed to);

    modifier onlyAuthorizedRecoverer() {
        require(authorizedRecoverers[msg.sender], ""Not an authorized recoverer"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(RECOVERY_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function addAuthorizedRecoverer(address recoverer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        authorizedRecoverers[recoverer] = true;
    }

    function removeAuthorizedRecoverer(address recoverer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(authorizedRecoverers[recoverer], ""Recoverer not authorized"");
        delete authorizedRecoverers[recoverer];
    }

    function trustAddressToRecover(address to) internal virtual {
        addAuthorizedRecoverer(to);
    }

    function recover(address to, uint256 amount) public onlyAuthorizedRecoverer {
        require(amount > 0, ""Amount must be greater than zero"");
        // Perform the recovery procedure logic here
        (bool success, ) = payable(to).call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Recovered(msg.sender, to);
    }
}"
2481,Destroy the vesting information associated with an account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingDestroyer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant DESTROYER_ROLE = keccak256(""DESTROYER_ROLE"");

    struct VestingInfo {
        uint256 amount;
        uint256 start;
        uint256 duration;
        bool initialized;
    }

    mapping(address => VestingInfo) public vestingInfos;

    event VestingDestroyed(address indexed account, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(DESTROYER_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(DESTROYER_ROLE, msg.sender);
    }

    function destroyVestingInfo(address account) external onlyRole(DESTROYER_ROLE) {
        require(vestingInfos[account].initialized, ""Vesting info not initialized"");
        uint256 amount = vestingInfos[account].amount;
        delete vestingInfos[account];
        emit VestingDestroyed(account, amount);
    }
}",2.817089796066284,destroyVestingInfo,"[{'function': 'destroyVestingInfo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyVestingInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""initialized""}, {""type"": ""stringLiteral"", ""value"": ""Vesting info not initialized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VestingDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DESTROYER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.7112841684481045,0.12524296922554,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract VestingDestroyer is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant DESTROYER_ROLE = keccak256(""DESTROYER_ROLE"");

    struct VestingInfo {
        uint256 amount;
        uint256 start;
        uint256 duration;
        bool initialized;
    }

    mapping(address => VestingInfo) public vestingInfos;

    event VestingDestroyed(address indexed account, uint256 amount);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(DESTROYER_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(DESTROYER_ROLE, msg.sender);

        // Initialization of state variables
        vestingInfos[msg.sender] = VestingInfo({
            amount: 1,
            start: block.timestamp,
            duration: 365 days,
            initialized: true
        });
    }

    function destroyVestingInfo(address account) external onlyRole(DESTROYER_ROLE) {
        require(vestingInfos[account].initialized, ""Vesting info not initialized"");
        uint256 amount = vestingInfos[account].amount;
        delete vestingInfos[account];
        emit VestingDestroyed(account, amount);
    }
}"
4726,` finalizeSale ( ) ` ends the TokenSale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public totalTokensSold;
    mapping(address => uint256) public tokensBought;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        // Assuming token price is set in wei per token
        uint256 tokensBought = msg.value.div(tokenPrice);
        totalTokensSold += tokensBought;
        tokensBought[msg.sender] += tokensBought;
    }

    function finalizeSale() external {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        selfdestruct(payable(owner()));
    }
}",2.5945870876312256,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'finalizeSale', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensBought"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensBought""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensBought""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",49.0,0.529493043068053,0.0119444691952618,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public totalTokensSold;
    mapping(address => uint256) public tokensBought;
    uint256 private tokenPrice = 10**18; // Placeholder for token price in wei

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint256 tokensBought = msg.value.div(tokenPrice);
        totalTokensSold += tokensBought;
        tokensBought[msg.sender] += tokensBought;
    }

    function finalizeSale() external {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        selfdestruct(payable(owner()));
    }
}"
475,Release some of an affiliate 's tokens to a broker/trading wallet .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AffiliateTokenRelease is Ownable {
    IERC20 private token;
    mapping(address => bool) public brokers;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function addBroker(address broker) external onlyOwner {
        brokers[broker] = true;
    }

    function releaseTokens(address affiliate, uint256 amount) external onlyOwner {
        require(brokers[_msgSender()], ""Only authorized brokers can call this function"");
        token.transferFrom(owner(), affiliate, amount);
    }
}",1.7272710800170898,releaseTokens,"[{'function': 'addBroker', 'complexity': 0}, {'function': 'releaseTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""affiliate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""brokers""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only authorized brokers can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""affiliate""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.6984518306930102,0.0127861405521437,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AffiliateTokenRelease is Ownable {
    IERC20 private token;
    mapping(address => bool) public brokers;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        brokers[_msgSender()] = true; // Assuming the owner is a broker by default for this example
    }

    function addBroker(address broker) external onlyOwner {
        brokers[broker] = true;
    }

    function releaseTokens(address affiliate, uint256 amount) external onlyOwner {
        require(brokers[_msgSender()], ""Only authorized brokers can call this function"");
        token.transferFrom(owner(), affiliate, amount);
    }
}"
1443,the method caller will have to claim ownership of regulators since regulators are claimable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RegulatorClaim is Ownable {
    address public owner;
    mapping(address => bool) public regulators;

    modifier onlyRegulator() {
        require(regulators[msg.sender], ""Only regulators can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function claimRegulator(address regulator) public onlyOwner {
        require(!regulators[regulator], ""Regulator already claimed"");
        regulators[regulator] = true;
    }
}",1.4163384437561035,claimRegulator,"[{'function': 'claimRegulator', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimRegulator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""regulator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""index"": {""type"": ""Identifier"", ""name"": ""regulator""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Regulator already claimed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""index"": {""type"": ""Identifier"", ""name"": ""regulator""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.6886807427908204,0.0204897782283366,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RegulatorClaim is Ownable {
    address public owner;
    mapping(address => bool) public regulators;

    modifier onlyRegulator() {
        require(regulators[msg.sender], ""Only regulators can call this function"");
        _;
    }

    constructor(address initialOwner) Ownable(initialOwner) {
        owner = initialOwner;
    }

    function claimRegulator(address regulator) public onlyOwner {
        require(!regulators[regulator], ""Regulator already claimed"");
        regulators[regulator] = true;
    }
}"
6667,Compute the new IssuanceData on the old balance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract IssuanceCalculator {
    using SafeMath for uint256;

    function computeNewIssuanceData(uint256 oldBalance, uint256 newBalance) public pure returns (uint256) {
        require(oldBalance <= type(uint256).max && newBalance <= type(uint256).max, ""Overflow detected"");
        return newBalance.sub(oldBalance);
    }
}",1.234978437423706,computeNewIssuanceData,"[{'function': 'computeNewIssuanceData', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNewIssuanceData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""oldBalance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newBalance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldBalance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",38.0,0.6875437353289942,0.0056022518268688,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract IssuanceCalculator is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function computeNewIssuanceData(uint256 oldBalance, uint256 newBalance) public pure returns (uint256) {
        require(oldBalance <= type(uint256).max && newBalance <= type(uint256).max, ""Overflow detected"");
        return newBalance.sub(oldBalance);
    }
}"
1283,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract TokenApproval {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function approveToken(address tokenAddress, address spender, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.approve(spender, amount), ""Approval failed"");
    }
}",1.588987112045288,approveToken,"[{'function': 'approve', 'complexity': 0}, {'function': 'approveToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.314741860843524,0.0345261446549558,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveToken(address tokenAddress, address spender, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.approve(spender, amount), ""Approval failed"");
    }
}"
6724,Adds a pair of addresses to manual blockings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ManualBlocking {
    address[] public blockedAddresses;
    mapping(address => bool) public isBlocked;
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
    address private manager;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);
        manager = msg.sender;
    }

    modifier onlyManager() {
        require(hasRole(MANAGER_ROLE, msg.sender), ""Caller is not the manager"");
        _;
    }

    function addBlockedAddresses(address[] memory newAddresses) public onlyManager {
        for (uint256 i = 0; i < newAddresses.length; i++) {
            if (!isBlocked[newAddresses[i]]) {
                isBlocked[newAddresses[i]] = true;
                blockedAddresses.push(newAddresses[i]);
            }
        }
    }
}",2.366659641265869,addBlockedAddresses,"[{'function': 'addBlockedAddresses', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBlockedAddresses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""newAddresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newAddresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBlocked""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""newAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBlocked""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""newAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""blockedAddresses""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""newAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.5698342969794784,0.0115893868760385,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManualBlocking is AccessControl, Ownable {
    address[] public blockedAddresses;
    mapping(address => bool) public isBlocked;
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);
        manager = msg.sender;
    }

    function addBlockedAddresses(address[] memory newAddresses) public onlyManager {
        for (uint256 i = 0; i < newAddresses.length; i++) {
            if (!isBlocked[newAddresses[i]]) {
                isBlocked[newAddresses[i]] = true;
                blockedAddresses.push(newAddresses[i]);
            }
        }
    }
}"
2869,this function lets arbitrator withdraw DAI to the provided address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract ArbitratorWithdrawal {
    IERC20 public daiToken;
    address public arbitrator;

    constructor(address _daiToken, address _arbitrator) {
        daiToken = IERC20(_daiToken);
        arbitrator = _arbitrator;
    }

    function withdrawDAI(address recipient, uint256 amount) external {
        require(msg.sender == arbitrator, ""Only arbitrator can withdraw DAI"");
        daiToken.transfer(recipient, amount);
    }
}",1.4803636074066162,withdrawDAI,"[{'function': 'withdrawDAI', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDAI"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""arbitrator""}}, {""type"": ""stringLiteral"", ""value"": ""Only arbitrator can withdraw DAI""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.8705891889060116,0.0537408743649463,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ArbitratorWithdrawal is Ownable {
    IERC20 public daiToken;
    address public arbitrator;

    constructor(address _daiToken, address _arbitrator) Ownable(msg.sender) {
        daiToken = IERC20(_daiToken);
        arbitrator = _arbitrator;
    }

    function withdrawDAI(address recipient, uint256 amount) external onlyOwner {
        require(msg.sender == owner(), ""Only the owner can withdraw DAI"");
        daiToken.transfer(recipient, amount);
    }
}"
3748,Get the node at the end of a double linked list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}","pragma solidity ^0.8.0;

contract DoubleLinkedList {
    struct Node {
        uint256 value;
        Node next;
        Node prev;
    }

    mapping(uint256 => Node) private nodes;
    uint256 public headId;
    uint256 public tailId;

    function getNodeAtEnd() external view returns (uint256 value, Node memory next, Node memory prev) {
        require(headId != 0, ""List is empty"");
        Node storage current = nodes[tailId];
        return (current.value, current.next, current.prev);
    }
}",1.4107599258422852,getNodeAtEnd,"[{'function': 'getNodeAtEnd', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNodeAtEnd"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""next"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""prev"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""headId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""List is empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""current"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""tailId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""value""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""prev""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.6130674023659801,0.0302974177809353,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DoubleLinkedList is Ownable {
    struct Node {
        uint256 value;
        Node next;
        Node prev;
    }

    mapping(uint256 => Node) private nodes;
    uint256 public headId = 1; // Set to 1 (never 0)
    uint256 public tailId = 2; // Set to 2

    constructor() Ownable(msg.sender) {
        // Initialize the first node with a placeholder value and fixed address
        nodes[headId] = Node({value: 1, next: headId + 1, prev: 0});

        // Initialize the second node with another placeholder value and fixed address
        nodes[tailId] = Node({value: 2, next: 0, prev: headId});
    }

    function getNodeAtEnd() external view returns (uint256 value, Node memory next, Node memory prev) {
        require(headId != 0, ""List is empty"");
        Node storage current = nodes[tailId];
        return (current.value, current.next, current.prev);
    }
}"
1053,Updates the board status according to the players score .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GameBoard {
    using SafeMath for uint256;

    enum Status {Pending, Active, Finished}
    struct Player {
        uint256 score;
        bool isActive;
    }

    mapping(address => Player) public players;
    address[] public playerList;
    Status public gameStatus;

    modifier onlyActivePlayer() {
        require(players[msg.sender].isActive, ""Only active players can call this function"");
        _;
    }

    function updateBoard(uint256 score) external onlyActivePlayer {
        Player storage player = players[msg.sender];
        player.score = player.score.add(score);
        if (player.score >= 100) {
            gameStatus = Status.Finished;
        }
    }
}",1.975019216537476,updateBoard,"[{'function': 'updateBoard', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBoard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""score"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Player""}, ""name"": ""player"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""players""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""player""}, ""memberName"": ""score""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""player""}, ""memberName"": ""score""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""score""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""player""}, ""memberName"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""gameStatus""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""Finished""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyActivePlayer"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.6628742831093082,0.0119794749844175,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GameBoard is Ownable {
    using SafeMath for uint256;

    enum Status {Pending, Active, Finished}
    struct Player {
        uint256 score;
        bool isActive;
    }

    mapping(address => Player) public players;
    address[] public playerList;
    Status public gameStatus;

    modifier onlyActivePlayer() {
        require(players[msg.sender].isActive, ""Only active players can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        gameStatus = Status.Pending;
        for (uint256 i = 0; i < 3; i++) {
            players[address(uint160(i + 1))] = Player({score: 1, isActive: true});
        }
    }

    function updateBoard(uint256 score) external onlyActivePlayer {
        Player storage player = players[msg.sender];
        player.score = player.score.add(score);
        if (player.score >= 100) {
            gameStatus = Status.Finished;
        }
    }
}"
963,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract AuthorizedOperatorQuery is AccessControl {
    using SafeMath for uint256;

    IERC721 public nftContract;
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor(address _nftContractAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
        nftContract = IERC721(_nftContractAddress);
    }

    function isAuthorizedOperator(address owner, address operator) public view returns (bool) {
        return nftContract.isApprovedForAll(owner, operator);
    }
}",2.8900723457336426,sub,"[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'isAuthorizedOperator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sub"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: subtraction overflow""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",13.0,0.2413644274492931,0.0186964259949365,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract AuthorizedOperatorQuery is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC721 public nftContract;
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor(address _nftContractAddress) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
        nftContract = IERC721(_nftContractAddress);
    }

    function isAuthorizedOperator(address owner, address operator) public view returns (bool) {
        return nftContract.isApprovedForAll(owner, operator);
    }
}"
3793,Create an invite using the signing model described in the contract description,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}","pragma solidity ^0.8.0;

interface ISignatureVerifier {
    function verify(bytes32 message, bytes memory signature) external pure returns (bool);
}

contract InviteSigningModel {
    address private owner;
    ISignatureVerifier public signerVerifier;

    event InviteCreated(address indexed invitedAddress, uint256 inviteId);

    mapping(uint256 => bool) usedInvites;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _signerVerifier) {
        owner = msg.sender;
        signerVerifier = ISignatureVerifier(_signerVerifier);
    }

    function createInvite(address invitedAddress, uint256 inviteId, bytes32 message, bytes memory signature) public onlyOwner {
        require(!usedInvites[inviteId], ""Invite ID already used"");
        require(signerVerifier.verify(message, signature), ""Signature verification failed"");
        usedInvites[inviteId] = true;
        emit InviteCreated(invitedAddress, inviteId);
    }
}",2.45949649810791,createInvite,"[{'function': 'verify', 'complexity': -1}, {'function': 'createInvite', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvite"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""invitedAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""inviteId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""message"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""usedInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Invite ID already used""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signerVerifier""}, ""memberName"": ""verify""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""message""}, {""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Signature verification failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""usedInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InviteCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""invitedAddress""}, {""type"": ""Identifier"", ""name"": ""inviteId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.8772215318847721,0.1654727904316817,"pragma solidity ^0.8.0;

interface ISignatureVerifier {
    function verify(bytes32 message, bytes memory signature) external pure returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract InviteSigningModel is Ownable {
    address private owner;
    ISignatureVerifier public signerVerifier;

    mapping(uint256 => bool) usedInvites;

    event InviteCreated(address indexed invitedAddress, uint256 inviteId);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _signerVerifier) Ownable(_signerVerifier) {
        signerVerifier = ISignatureVerifier(_signerVerifier);
    }

    function createInvite(address invitedAddress, uint256 inviteId, bytes32 message, bytes memory signature) public onlyOwner {
        require(!usedInvites[inviteId], ""Invite ID already used"");
        require(signerVerifier.verify(message, signature), ""Signature verification failed"");
        usedInvites[inviteId] = true;
        emit InviteCreated(invitedAddress, inviteId);
    }
}"
3662,Allow pre-approved user to take ownership of a token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenOwnerTransfer is Ownable {
    IERC20 private token;
    mapping(address => bool) public preApprovedUsers;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function addPreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = true;
    }

    function removePreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = false;
    }

    function transferTokenToUser(address to, uint256 amount) external {
        require(preApprovedUsers[msg.sender], ""You are not pre-approved"");
        token.transfer(to, amount);
    }
}",2.059011459350586,transferTokenToUser,"[{'function': 'addPreApprovedUser', 'complexity': 0}, {'function': 'removePreApprovedUser', 'complexity': 0}, {'function': 'transferTokenToUser', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokenToUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preApprovedUsers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You are not pre-approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.5802616099746922,0.0219313495481737,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnerTransfer is Ownable {
    IERC20 private token;
    mapping(address => bool) public preApprovedUsers;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables to safe, non-corner-case values
        preApprovedUsers[address(0x111)] = true;
        preApprovedUsers[address(0x222)] = false;
    }

    function addPreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = true;
    }

    function removePreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = false;
    }

    function transferTokenToUser(address to, uint256 amount) external {
        require(preApprovedUsers[msg.sender], ""You are not pre-approved"");
        token.transfer(to, amount);
    }
}"
4592,Function use to change the lower and upper bound of the compatible version st,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VersionSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private lowerBound;
    uint256 private upperBound;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function setBounds(uint256 newLowerBound, uint256 newUpperBound) public onlyRole(ADMIN_ROLE) {
        require(newLowerBound <= newUpperBound, ""Lower bound must be less than or equal to upper bound"");
        lowerBound = newLowerBound;
        upperBound = newUpperBound;
    }
}",2.202624797821045,setBounds,"[{'function': 'setBounds', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBounds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newLowerBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newUpperBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newLowerBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""newUpperBound""}}, {""type"": ""stringLiteral"", ""value"": ""Lower bound must be less than or equal to upper bound""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lowerBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""newLowerBound""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upperBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""newUpperBound""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.4698177003668718,0.0070487936934743,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract VersionSetter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private lowerBound;
    uint256 private upperBound;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
        lowerBound = 1;
        upperBound = 1;
    }

    function setBounds(uint256 newLowerBound, uint256 newUpperBound) public onlyRole(ADMIN_ROLE) {
        require(newLowerBound <= newUpperBound, ""Lower bound must be less than or equal to upper bound"");
        lowerBound = newLowerBound;
        upperBound = newUpperBound;
    }
}"
6054,Only the owner of a locked wallet can unlock the tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LockedWallet is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function unlockTokens() external onlyOwner {
        require(token.transfer(owner(), token.balanceOf(address(this))), ""Transfer failed"");
    }
}",1.514275312423706,unlockTokens,"[{'function': 'unlockTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""unlockTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",66.0,0.740369632218079,0.0736457144808268,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LockedWallet is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function unlockTokens() external onlyOwner {
        require(token.transfer(owner(), token.balanceOf(address(this))), ""Transfer failed"");
    }
}"
6003,Proxy function which allows sending of transactions in behalf of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ProxyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant PROXY_ROLE = keccak256(""PROXY_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PROXY_ROLE, msg.sender);
    }

    function sendTransaction(address payable recipient, uint256 amount) public onlyRole(PROXY_ROLE) {
        require(recipient != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transaction failed"");
    }
}",1.9904029369354248,sendTransaction,"[{'function': 'sendTransaction', 'complexity': 3}]",4.0,{},0.0,0.5662472927624319,0.0387540662940813,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ProxyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant PROXY_ROLE = keccak256(""PROXY_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(PROXY_ROLE, admin);
        transferOwnership(admin);
    }

    function sendTransaction(address payable recipient, uint256 amount) public onlyRole(PROXY_ROLE) {
        require(recipient != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transaction failed"");
    }
}"
1262,Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSender is Ownable {
    function sendTokens(address token, address from, address to, uint256 amount) public onlyOwner returns (bool) {
        IERC20 tokenContract = IERC20(token);
        require(tokenContract.balanceOf(from) >= amount, ""Insufficient balance"");
        bool success = tokenContract.transferFrom(from, to, amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}",1.4994757175445557,sendTokens,"[{'function': 'sendTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.600192490785279,0.0170648758230654,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSender is Ownable {
    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendTokens(address token, address from, address to, uint256 amount) public onlyOwner returns (bool) {
        IERC20 tokenContract = IERC20(token);
        require(tokenContract.balanceOf(from) >= amount, ""Insufficient balance"");
        bool success = tokenContract.transferFrom(from, to, amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}"
4646,Returns the bond of a given darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DarkNodeBond {
    using SafeMath for uint256;

    mapping(address => uint256) private darknodeBonds;

    function getBond(address darknode) public view returns (uint256) {
        return darknodeBonds[darknode];
    }
}",0.981107234954834,getBond,"[{'function': 'getBond', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknode""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",20.0,0.7750027551126857,0.0575116231191684,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract DarkNodeBond is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private darknodeBonds;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        darknodeBonds[msg.sender] = 1;
    }

    function getBond(address darknode) public view returns (uint256) {
        return darknodeBonds[darknode];
    }
}"
476,Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        IERC20 token = IERC20(msg.sender);
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= _value, ""Insufficient balance"");
        bool transferSuccess = token.transfer(_to, _value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}",1.7702486515045166,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.8259770915828338,0.3098081804762422,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are not defined in this contract
    }

    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        IERC20 token = IERC20(msg.sender);
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= _value, ""Insufficient balance"");
        bool transferSuccess = token.transfer(_to, _value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}"
2119,Returns the order amount for trader ` _trader ` at '_price ',"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IExchange {
    function getOrderAmount(address trader, uint256 price) external view returns (uint256);
}

contract Exchange is AccessControl, IExchange {
    using SafeMath for uint256;

    bytes32 public constant TRADER_ROLE = keccak256(""TRADER_ROLE"");
    mapping(address => uint256) private balances;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRADER_ROLE, msg.sender);
    }

    function getOrderAmount(address trader, uint256 price) external view override returns (uint256) {
        require(hasRole(TRADER_ROLE, trader), ""Caller is not a trader"");
        return balances[trader].mul(price);
    }
}",2.215458631515503,getOrderAmount,"[{'function': 'getOrderAmount', 'complexity': 0}, {'function': 'getOrderAmount', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOrderAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TRADER_ROLE""}, {""type"": ""Identifier"", ""name"": ""trader""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a trader""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""trader""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",13.0,0.7487848299633498,0.0177962373953712,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IExchange {
    function getOrderAmount(address trader, uint256 price) external view returns (uint256);
}

contract Exchange is AccessControl, Ownable, IExchange {
    using SafeMath for uint256;

    bytes32 public constant TRADER_ROLE = keccak256(""TRADER_ROLE"");
    mapping(address => uint256) private balances;

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRADER_ROLE, msg.sender);
    }

    function getOrderAmount(address trader, uint256 price) external view override returns (uint256) {
        require(hasRole(TRADER_ROLE, trader), ""Caller is not a trader"");
        return balances[trader].mul(price);
    }
}"
3447,Set the Synth contract that the issuance controller uses to issue Synths .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}","pragma solidity ^0.8.0;

interface ISynth {
    function setIssuanceData(address synth, address issuer) external;
}

contract IssuanceController {
    address public owner;
    mapping(address => bool) public authorizedIssuers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedIssuers[msg.sender], ""Caller is not authorized"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addAuthorizedIssuer(address issuer) public onlyOwner {
        authorizedIssuers[issuer] = true;
    }

    function removeAuthorizedIssuer(address issuer) public onlyOwner {
        require(authorizedIssuers[issuer], ""Issuer is not authorized"");
        authorizedIssuers[issuer] = false;
    }

    function setSynthContract(address synth, address issuer) public onlyAuthorized {
        ISynth(synth).setIssuanceData(msg.sender, issuer);
    }
}",2.464679718017578,removeAuthorizedIssuer,"[{'function': 'setIssuanceData', 'complexity': 0}, {'function': 'addAuthorizedIssuer', 'complexity': 0}, {'function': 'removeAuthorizedIssuer', 'complexity': 1}, {'function': 'setSynthContract', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAuthorizedIssuer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedIssuers""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, {""type"": ""stringLiteral"", ""value"": ""Issuer is not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedIssuers""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.2833170256295652,0.031146377792658,"pragma solidity ^0.8.0;

interface ISynth {
    function setIssuanceData(address synth, address issuer) external;
}
import ""openzeppelin/SafeMath.sol"";
contract IssuanceController is Ownable {
    mapping(address => bool) public authorizedIssuers;

    modifier onlyAuthorized() {
        require(authorizedIssuers[msg.sender], ""Caller is not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender;
        authorizedIssuers[owner] = true;
    }

    function addAuthorizedIssuer(address issuer) public onlyOwner {
        authorizedIssuers[issuer] = true;
    }

    function removeAuthorizedIssuer(address issuer) public onlyOwner {
        require(authorizedIssuers[issuer], ""Issuer is not authorized"");
        authorizedIssuers[issuer] = false;
    }

    function setSynthContract(address synth, address issuer) public onlyAuthorized {
        ISynth(synth).setIssuanceData(msg.sender, issuer);
    }
}"
2394,Migrate tokens to the new token contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenMigration is ReentrancyGuard {
    IERC20 public oldToken;
    address public newTokenAddress;

    constructor(address _oldToken, address _newToken) {
        require(_oldToken != address(0), ""Invalid old token address"");
        require(_newToken != address(0), ""Invalid new token address"");
        oldToken = IERC20(_oldToken);
        newTokenAddress = _newToken;
    }

    function migrateTokens() external nonReentrant {
        uint256 balance = oldToken.balanceOf(msg.sender);
        require(balance > 0, ""No tokens to transfer"");

        bool success = oldToken.transferFrom(msg.sender, address(this), balance);
        require(success, ""Transfer failed"");

        IERC20 newToken = IERC20(newTokenAddress);
        require(newToken.balanceOf(address(this)) >= balance, ""Insufficient new token balance"");

        bool transferred = newToken.transfer(msg.sender, balance);
        require(transferred, ""Transfer to user failed"");
    }
}",2.7795863151550293,migrateTokens,"[{'function': 'migrateTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient new token balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferred"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferred""}, {""type"": ""stringLiteral"", ""value"": ""Transfer to user failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.6484711047131644,0.0414218266504227,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenMigration is Ownable, ReentrancyGuard {
    IERC20 public oldToken;
    address public newTokenAddress;

    mapping(address => uint256) public balanceOf;

 constructor(address _oldToken, address _newToken) Ownable(msg.sender) {
        require(_oldToken != address(0), ""Invalid old token address"");
        require(_newToken != address(0), ""Invalid new token address"");
        oldToken = IERC20(_oldToken);
        newTokenAddress = _newToken;
    }

    function migrateTokens() external nonReentrant {
        uint256 balance = oldToken.balanceOf(msg.sender);
        require(balance > 0, ""No tokens to transfer"");

        bool success = oldToken.transferFrom(msg.sender, address(this), balance);
        require(success, ""Transfer failed"");

        IERC20 newToken = IERC20(newTokenAddress);
        require(newToken.balanceOf(address(this)) >= balance, ""Insufficient new token balance"");

        bool transferred = newToken.transfer(msg.sender, balance);
        require(transferred, ""Transfer to user failed"");
    }
}"
6317,This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenPurchase {
    using SafeMath for uint256;

    address public thirdPartyAddress;
    mapping(address => uint256) public contributions;

    event ContributionReceived(address indexed contributor, uint256 amount);

    constructor(address _thirdPartyAddress) {
        thirdPartyAddress = _thirdPartyAddress;
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        contributions[msg.sender] += msg.value;
        (bool success, ) = thirdPartyAddress.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
        emit ContributionReceived(msg.sender, msg.value);
    }
}",1.8831145763397217,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",3.0,{},17.0,0.5230817576219792,0.0742409104067352,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenPurchase is Ownable {
    using SafeMath for uint256;

    address public thirdPartyAddress;
    mapping(address => uint256) public contributions;

    event ContributionReceived(address indexed contributor, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialize variables to fixed, safe values
        thirdPartyAddress = 0x1111111111111111111111111111111111111111; // Replace with actual address
        contributions[msg.sender] = 1; // Set initial contribution value to 1 (never 0)
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        contributions[msg.sender] += msg.value;
        (bool success, ) = thirdPartyAddress.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
        emit ContributionReceived(msg.sender, msg.value);
    }
}"
5800,` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}","pragma solidity ^0.8.0;

interface CampaignToken {
    function seal() external;
}

contract Campaign {
    address public owner;
    CampaignToken public token;

    constructor(address _token) {
        require(_token != address(0), ""Invalid token address"");
        owner = msg.sender;
        token = CampaignToken(_token);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function sealCampaign() external onlyOwner {
        token.seal();
    }
}",1.3541319370269775,sealCampaign,"[{'function': 'seal', 'complexity': 0}, {'function': 'sealCampaign', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""sealCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""seal""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7271963645845824,0.0069251276486822,"pragma solidity ^0.8.0;

interface CampaignToken {
    function seal() external;
}
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    CampaignToken public token;

    constructor(address _token) Ownable(msg.sender) {
        require(_token != address(0), ""Invalid token address"");
        token = CampaignToken(_token);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function sealCampaign() external onlyOwner {
        token.seal();
    }
}"
5101,Returns asset balance for a particular holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract AssetBalanceChecker {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public authorizedUsers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender] || msg.sender == owner, ""Only authorized users can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addAuthorizedUser(address user) public onlyOwner {
        authorizedUsers[user] = true;
    }

    function removeAuthorizedUser(address user) public onlyOwner {
        require(user != owner, ""Cannot remove the owner"");
        delete authorizedUsers[user];
    }

    function getBalance(address tokenAddress, address holder) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(holder);
    }
}",2.760658264160156,removeAuthorizedUser,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'addAuthorizedUser', 'complexity': 0}, {'function': 'removeAuthorizedUser', 'complexity': 1}, {'function': 'getBalance', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAuthorizedUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot remove the owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.3707993093078545,0.0337274278293383,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract AssetBalanceChecker is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public authorizedUsers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender] || msg.sender == owner, ""Only authorized users can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent mapping(address => uint256) public balanceOf;

 constructor
    }

    function addAuthorizedUser(address user) public onlyOwner {
        authorizedUsers[user] = true;
    }

    function removeAuthorizedUser(address user) public onlyOwner {
        require(user != owner, ""Cannot remove the owner"");
        delete authorizedUsers[user];
    }

    function getBalance(address tokenAddress, address holder) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(holder);
    }
}"
752,"Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RenExSettlement is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SETTLER_ROLE = keccak256(""SETTLER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SETTLER_ROLE, msg.sender);
    }

    function settle(address payable recipient, uint256 amount) external onlyRole(SETTLER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        recipient.transfer(amount);
    }
}",1.7853217124938965,settle,"[{'function': 'settle', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""settle"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""SETTLER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",46.0,0.4405105552548213,0.0216811638387444,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract RenExSettlement is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SETTLER_ROLE = keccak256(""SETTLER_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(SETTLER_ROLE, admin);
        transferOwnership(admin); // Transfer ownership to the admin
    }

    function settle(address payable recipient, uint256 amount) external onlyRole(SETTLER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        recipient.transfer(amount);
    }
}"
1142,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApproval is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function approveSpender(address _spender, uint256 _amount) public onlyOwner returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.approve(_spender, _amount);
    }
}",1.4844887256622314,approveSpender,"[{'function': 'approveSpender', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.8802282049620673,0.3458360632300567,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function approveSpender(address _spender, uint256 _amount) public onlyOwner returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.approve(_spender, _amount);
    }
}"
3633,` _value ` tokens will be sended to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSender is AccessControl {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function sendTokens(address _to, uint256 _value) external onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Amount must be greater than zero"");
        return token.transfer(_to, _value);
    }
}",2.0019662380218506,sendTokens,"[{'function': 'sendTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.6900226431609049,0.2942727942851444,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenSender is AccessControl, Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender), AccessControl() {
        token = IERC20(_tokenAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function sendTokens(address _to, uint256 _value) external onlyRole(DEFAULT_ADMIN_ROLE) returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Amount must be greater than zero"");
        return token.transfer(_to, _value);
    }
}"
4852,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Mintable is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller is not a minter"");
        // SafeMath usage for addition and subtraction can be added here if necessary
        // _mint(to, amount); // Uncomment and implement the actual minting logic if needed
    }
}",2.0243170261383057,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a minter""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.5165096687405634,0.0113828098061268,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract Mintable is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller is not a minter"");
        // SafeMath usage for addition and subtraction can be added here if necessary
        // _mint(to, amount); // Uncomment and implement the actual minting logic if needed
    }
}"
2521,Returns the address currently assigned ownership of a given Warrior .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract WarriorOwner is Ownable {
    struct Warrior {
        uint256 id;
        address owner;
    }

    mapping(uint256 => Warrior) public warriors;

    function getWarriorOwner(uint256 warriorId) public view returns (address) {
        require(warriors[warriorId].id == warriorId, ""Warrior does not exist"");
        return warriors[warriorId].owner;
    }
}",1.2614383697509766,getWarriorOwner,"[{'function': 'getWarriorOwner', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWarriorOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""warriorId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""index"": {""type"": ""Identifier"", ""name"": ""warriorId""}}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""warriorId""}}, {""type"": ""stringLiteral"", ""value"": ""Warrior does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""index"": {""type"": ""Identifier"", ""name"": ""warriorId""}}, ""memberName"": ""owner""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.7234513506888255,0.1998573974138023,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WarriorOwner is Ownable {
    struct Warrior {
        uint256 id;
        address owner;
    }

    mapping(uint256 => Warrior) public warriors;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            warriors[i] = Warrior({id: i, owner: address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))))});
        }
    }

    function getWarriorOwner(uint256 warriorId) public view returns (address) {
        require(warriors[warriorId].id == warriorId, ""Warrior does not exist"");
        return warriors[warriorId].owner;
    }
}"
402,Contract owner or Multisig can clawback ether after refund period is finished,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Clawback is Ownable {
    uint256 public refundPeriod;
    mapping(address => bool) public canClawback;

    event ClawbackExecuted(address indexed user, uint256 amount);

    constructor(uint256 _refundPeriod, address[] memory multisigAddresses) {
        require(_refundPeriod > 0, ""Refund period must be greater than zero"");
        refundPeriod = _refundPeriod;
        for (uint256 i = 0; i < multisigAddresses.length; i++) {
            canClawback[multisigAddresses[i]] = true;
        }
    }

    function clawback(address payable user) external onlyOwnerOrMultisig {
        require(block.timestamp >= refundPeriod, ""Refund period has not ended yet"");
        uint256 balance = address(this).balance;
        user.transfer(balance);
        emit ClawbackExecuted(user, balance);
    }

    modifier onlyOwnerOrMultisig() {
        require(owner() == msg.sender || canClawback[msg.sender], ""Only owner or multisig can call this function"");
        _;
    }
}",2.731849670410156,clawback,"[{'function': 'clawback', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""clawback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""refundPeriod""}}, {""type"": ""stringLiteral"", ""value"": ""Refund period has not ended yet""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClawbackExecuted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwnerOrMultisig"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7374383740009944,0.1849893824702657,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Clawback is Ownable {
    uint256 public refundPeriod;
    mapping(address => bool) public canClawback;

    event ClawbackExecuted(address indexed user, uint256 amount);

    constructor(uint256 _refundPeriod, address[] memory multisigAddresses) Ownable(msg.sender) {
        require(_refundPeriod > 0, ""Refund period must be greater than zero"");
        refundPeriod = _refundPeriod;
        for (uint256 i = 0; i < multisigAddresses.length; i++) {
            canClawback[multisigAddresses[i]] = true;
        }
    }

    function clawback(address payable user) external onlyOwnerOrMultisig {
        require(block.timestamp >= refundPeriod, ""Refund period has not ended yet"");
        uint256 balance = address(this).balance;
        user.transfer(balance);
        emit ClawbackExecuted(user, balance);
    }

    modifier onlyOwnerOrMultisig() {
        require(owner() == msg.sender || canClawback[msg.sender], ""Only owner or multisig can call this function"");
        _;
    }
}"
2323,By using this function you accept the terms of DXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}","pragma solidity ^0.8.0;

interface IDXFTerms {
    function acceptedTermsOfService(address user) external view returns (bool);
}

contract DXFSmartContract {
    address public immutable dxfTermsAddress;

    constructor(address _dxfTermsAddress) {
        require(_dxfTermsAddress != address(0), ""Invalid terms contract address"");
        dxfTermsAddress = _dxfTermsAddress;
    }

    function acceptTermsOfService() external {
        IDXFTerms(dxfTermsAddress).acceptedTermsOfService(msg.sender);
    }
}",1.286768913269043,acceptTermsOfService,"[{'function': 'acceptedTermsOfService', 'complexity': 0}, {'function': 'acceptTermsOfService', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptTermsOfService"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IDXFTerms""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dxfTermsAddress""}], ""names"": []}, ""memberName"": ""acceptedTermsOfService""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",135.0,0.6222542077994969,2.523555342179272e-06,"pragma solidity ^0.8.0;

interface IDXFTerms {
    function acceptedTermsOfService(address user) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract DXFSmartContract is Ownable {
    address public immutable dxfTermsAddress;

    constructor(address _dxfTermsAddress) Ownable(_dxfTermsAddress) {
        require(_dxfTermsAddress != address(0), ""Invalid terms contract address"");
        dxfTermsAddress = _dxfTermsAddress;
    }

    function acceptTermsOfService() external {
        IDXFTerms(dxfTermsAddress).acceptedTermsOfService(msg.sender);
    }
}"
36,Function used by the creator to set the contractor manager smart contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IContractorManager {
    function setContractor(address _contractor) external;
}

contract ContractorSetter is Ownable {
    address public contractorManagerAddress;

    constructor(address _contractorManagerAddress) {
        require(_contractorManagerAddress != address(0), ""Invalid address"");
        contractorManagerAddress = _contractorManagerAddress;
    }

    function setContractor(address _contractor) external onlyOwner {
        IContractorManager(contractorManagerAddress).setContractor(_contractor);
    }
}",1.4221086502075195,setContractor,"[{'function': 'setContractor', 'complexity': 0}, {'function': 'setContractor', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IContractorManager""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractorManagerAddress""}], ""names"": []}, ""memberName"": ""setContractor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contractor""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8672419845544879,0.0450682095644612,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IContractorManager {
    function setContractor(address _contractor) external;
}
import ""openzeppelin/SafeMath.sol"";
contract ContractorSetter is Ownable {
    address public contractorManagerAddress;

    constructor(address _contractorManagerAddress) Ownable(_contractorManagerAddress) {
        require(_contractorManagerAddress != address(0), ""Invalid address"");
        contractorManagerAddress = _contractorManagerAddress;
    }

    function setContractor(address _contractor) external onlyOwner {
        IContractorManager(contractorManagerAddress).setContractor(_contractor);
    }
}"
1979,Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}","pragma solidity ^0.8.0;

interface IAttributeType {
    struct AttributeInfo {
        uint256 id;
        string name;
        // Add other necessary fields here
    }

    function getAttributeInfo(uint256 attributeTypeID) external view returns (AttributeInfo memory);
}

contract AttributeQuery {
    IAttributeType public attributeTypeContract;

    constructor(address _attributeTypeAddress) {
        attributeTypeContract = IAttributeType(_attributeTypeAddress);
    }

    function getAttributeInfoById(uint256 attributeTypeID) external view returns (IAttributeType.AttributeInfo memory) {
        return attributeTypeContract.getAttributeInfo(attributeTypeID);
    }
}",1.5086872577667236,getAttributeInfoById,"[{'function': 'getAttributeInfo', 'complexity': 0}, {'function': 'getAttributeInfoById', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeInfoById"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IAttributeType.AttributeInfo""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeTypeContract""}, ""memberName"": ""getAttributeInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""attributeTypeID""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",39.0,0.8353176366381457,0.1597720064620457,"pragma solidity ^0.8.0;

interface IAttributeType {
    struct AttributeInfo {
        uint256 id;
        string name;
        // Add other necessary fields here
    }

    function getAttributeInfo(uint256 attributeTypeID) external view returns (AttributeInfo memory);
}
import ""openzeppelin/SafeMath.sol"";
contract AttributeQuery is Ownable {
    IAttributeType public attributeTypeContract;

    constructor(address _attributeTypeAddress) Ownable(msg.sender) {
        attributeTypeContract = IAttributeType(_attributeTypeAddress);
    }

    function getAttributeInfoById(uint256 attributeTypeID) external view returns (IAttributeType.AttributeInfo memory) {
        return attributeTypeContract.getAttributeInfo(attributeTypeID);
    }
}"
2733,Set the stale period on the updated havven price,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HavvenPriceUpdater is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");
    uint256 public stalePeriod;

    event PriceUpdated(uint256 newPrice, uint256 timestamp);

    constructor(address initialUpdater) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(UPDATER_ROLE, initialUpdater);
    }

    function setStalePeriod(uint256 newStalePeriod) public onlyRole(DEFAULT_ADMIN_ROLE) {
        stalePeriod = newStalePeriod;
    }

    function updatePrice(uint256 newPrice) public onlyRole(UPDATER_ROLE) {
        require(block.timestamp <= newPrice + stalePeriod, ""Price is stale"");
        // Additional logic can be added here
        emit PriceUpdated(newPrice, block.timestamp);
    }
}",2.511382818222046,updatePrice,"[{'function': 'setStalePeriod', 'complexity': 0}, {'function': 'updatePrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""newPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""stalePeriod""}}}, {""type"": ""stringLiteral"", ""value"": ""Price is stale""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPrice""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPDATER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.567272083707872,0.0067347191281656,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenPriceUpdater is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");
    uint256 public stalePeriod;

    event PriceUpdated(uint256 newPrice, uint256 timestamp);

    constructor(address initialUpdater) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(UPDATER_ROLE, initialUpdater);
        stalePeriod = 1; // Set to a non-zero value
    }

    function setStalePeriod(uint256 newStalePeriod) public onlyRole(DEFAULT_ADMIN_ROLE) {
        stalePeriod = newStalePeriod;
    }

    function updatePrice(uint256 newPrice) public onlyRole(UPDATER_ROLE) {
        require(block.timestamp <= newPrice + stalePeriod, ""Price is stale"");
        // Additional logic can be added here
        emit PriceUpdated(newPrice, block.timestamp);
    }
}"
1587,allows EtherToken to reclaim tokens wrongly sent to its address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract EtherTokenReclaim {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function reclaimTokens() external nonReentrant {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to reclaim"");
        require(token.transfer(msg.sender, balance), ""Token transfer failed"");
    }
}",1.5005714893341064,reclaimTokens,"[{'function': 'reclaimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to reclaim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7510049199869466,0.0444822016822598,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EtherTokenReclaim is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function reclaimTokens() external nonReentrant {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to reclaim"");
        require(token.transfer(msg.sender, balance), ""Token transfer failed"");
    }
}"
1004,"Used to reference a loan that is not yet created , and by that does not have an index","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanManager is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant LOAN_ROLE = keccak256(""LOAN_ROLE"");
    mapping(uint256 => bool) private loanIndexes;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(LOAN_ROLE, msg.sender);
    }

    function createLoan(uint256 index) public onlyRole(LOAN_ROLE) {
        require(!loanIndexes[index], ""Loan already exists"");
        loanIndexes[index] = true;
    }
}",1.828662633895874,createLoan,"[{'function': 'createLoan', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createLoan"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loanIndexes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Loan already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loanIndexes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""LOAN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.3938735393165448,0.0043775384246105,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract LoanManager is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant LOAN_ROLE = keccak256(""LOAN_ROLE"");
    mapping(uint256 => bool) private loanIndexes;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(LOAN_ROLE, msg.sender);
    }

    function createLoan(uint256 index) public onlyRole(LOAN_ROLE) {
        require(!loanIndexes[index], ""Loan already exists"");
        loanIndexes[index] = true;
    }
}"
6826,Returns the block number for when the channel was closed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}","pragma solidity ^0.8.0;

interface IChannel {
    function closeBlockNumber() external view returns (uint256);
}

contract ChannelAccessor {
    function getCloseBlockNumber(address channelAddress) public view returns (uint256) {
        require(channelAddress != address(0), ""Invalid channel address"");
        IChannel channel = IChannel(channelAddress);
        return channel.closeBlockNumber();
    }
}",1.0039739608764648,getCloseBlockNumber,"[{'function': 'closeBlockNumber', 'complexity': 0}, {'function': 'getCloseBlockNumber', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCloseBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""channelAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""channelAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid channel address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IChannel""}, ""name"": ""channel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IChannel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""channelAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""channel""}, ""memberName"": ""closeBlockNumber""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.4882306904839122,0.1129797953064189,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IChannel {
    function closeBlockNumber() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract ChannelAccessor is Ownable, ChannelAccessorBase {
    constructor(address channelAddress) {
        require(channelAddress != address(0), ""Invalid channel address"");
        _setChannel(channelAddress);
    }

    function getCloseBlockNumber(address channelAddress) public view returns (uint256) {
        require(channelAddress != address(0), ""Invalid channel address"");
        IChannel channel = IChannel(channelAddress);
        return channel.closeBlockNumber();
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ChannelAccessorBase is Ownable {
    address private _channel;

    function _setChannel(address newChannel) internal {
        require(newChannel != address(0), ""Invalid channel address"");
        _channel = newChannel;
    }

    function getCloseBlockNumber() public view returns (uint256) {
        IChannel channel = IChannel(_channel);
        return channel.closeBlockNumber();
    }
}"
4437,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenApproval {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        return token.approve(_spender, _value);
    }
}",1.2714824676513672,approveSpender,"[{'function': 'approveSpender', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8737123562217735,0.3301521779413357,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        return token.approve(_spender, _value);
    }
}"
2473,Finalize an upgrade process setting new asset implementation contract address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract UpgradeProcess is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPGRADER_ROLE = keccak256(""UPGRADER_ROLE"");
    address private _newAssetImplementation;

    event Upgraded(address indexed newImplementation);

    constructor(address initialAdmin, address newImpl) {
        _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin);
        _setNewAssetImplementation(newImpl);
        _grantRole(UPGRADER_ROLE, msg.sender);
    }

    function finalizeUpgrade() external onlyRole(UPGRADER_ROLE) {
        require(_newAssetImplementation != address(0), ""Invalid new implementation address"");
        emit Upgraded(_newAssetImplementation);
        // Additional logic can be added here
    }

    function setNewAssetImplementation(address newImpl) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setNewAssetImplementation(newImpl);
    }

    function grantUpgraderRole(address upgrader) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(UPGRADER_ROLE, upgrader);
    }

    function revokeUpgraderRole(address upgrader) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(upgrader != msg.sender, ""Cannot revoke role from self"");
        _revokeRole(UPGRADER_ROLE, upgrader);
    }

    function getNewAssetImplementation() external view returns (address) {
        return _newAssetImplementation;
    }

    function renounceUpgraderRole() external {
        require(hasRole(UPGRADER_ROLE, msg.sender), ""Caller is not a upgrader"");
        _revokeRole(UPGRADER_ROLE, msg.sender);
    }

    function _setNewAssetImplementation(address newImpl) internal {
        require(newImpl != address(0), ""Invalid implementation address"");
        _newAssetImplementation = newImpl;
    }
}",4.434842824935913,finalizeUpgrade,"[{'function': 'finalizeUpgrade', 'complexity': 1}, {'function': 'setNewAssetImplementation', 'complexity': 0}, {'function': 'grantUpgraderRole', 'complexity': 0}, {'function': 'revokeUpgraderRole', 'complexity': 1}, {'function': 'getNewAssetImplementation', 'complexity': 0}, {'function': 'renounceUpgraderRole', 'complexity': 1}, {'function': '_setNewAssetImplementation', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newAssetImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid new implementation address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Upgraded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newAssetImplementation""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPGRADER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.5786362295457449,0.0167581645368036,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract UpgradeProcess is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPGRADER_ROLE = keccak256(""UPGRADER_ROLE"");
    address private _newAssetImplementation;

    event Upgraded(address indexed newImplementation);

    constructor(address initialAdmin, address newImpl) {
        _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin);
        _setNewAssetImplementation(newImpl);
        _grantRole(UPGRADER_ROLE, msg.sender);
    }

    function finalizeUpgrade() external onlyRole(UPGRADER_ROLE) {
        require(_newAssetImplementation != address(0), ""Invalid new implementation address"");
        emit Upgraded(_newAssetImplementation);
        // Additional logic can be added here
    }

    function setNewAssetImplementation(address newImpl) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setNewAssetImplementation(newImpl);
    }

    function grantUpgraderRole(address upgrader) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(UPGRADER_ROLE, upgrader);
    }

    function revokeUpgraderRole(address upgrader) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(upgrader != msg.sender, ""Cannot revoke role from self"");
        _revokeRole(UPGRADER_ROLE, upgrader);
    }

    function getNewAssetImplementation() external view returns (address) {
        return _newAssetImplementation;
    }

    function renounceUpgraderRole() external {
        require(hasRole(UPGRADER_ROLE, msg.sender), ""Caller is not a upgrader"");
        _revokeRole(UPGRADER_ROLE, msg.sender);
    }

    function _setNewAssetImplementation(address newImpl) internal {
        require(newImpl != address(0), ""Invalid implementation address"");
        _newAssetImplementation = newImpl;
    }
}"
4258,Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeSub(uint256 a, uint2atural b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract TokenSpender {
    using SafeMath for uint256;

    function spendTokens(address token, address spender, uint256 value) external returns (bool) {
        IERC20 tokenContract = IERC20(token);
        uint256 balance = tokenContract.balanceOf(msg.sender);
        require(value <= balance, ""Insufficient balance"");
        return tokenContract.transferFrom(msg.sender, spender, value);
    }
}",1.9698657989501955,spendTokens,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeSub', 'complexity': 1}, {'function': 'spendTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""spendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.4929773734995382,0.0506803405295763,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSpender {
    using SafeMath for uint256;

    function spendTokens(address token, address spender, uint256 value) external returns (bool) {
        IERC20 tokenContract = IERC20(token);
        uint256 balance = tokenContract.balanceOf(msg.sender);
        require(value <= balance, ""Insufficient balance"");
        return tokenContract.transferFrom(msg.sender, spender, value);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSpenderV2 is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function spendTokens(address token, address spender, uint256 value) external returns (bool) {
        IERC20 tokenContract = IERC20(token);
        uint256 balance = tokenContract.balanceOf(msg.sender);
        require(value <= balance, ""Insufficient balance"");
        return tokenContract.transferFrom(msg.sender, spender, value);
    }
}"
3893,should be called off chain with as much gas as needed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}","pragma solidity ^0.8.0;

interface IAllowlist {
    function isAllowed(address user) external view returns (bool);
}

contract MyContract {
    address public owner;
    IAllowlist public allowlist;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _allowlistAddress) {
        owner = msg.sender;
        allowlist = IAllowlist(_allowlistAddress);
    }

    function setAllowlist(address _allowlistAddress) public onlyOwner {
        allowlist = IAllowlist(_allowlistAddress);
    }

    function performAction(address user) public view returns (bool) {
        require(allowlist.isAllowed(user), ""User not allowed"");
        // Additional logic can be added here
        return true;
    }
}",1.8905980587005613,performAction,"[{'function': 'isAllowed', 'complexity': 0}, {'function': 'setAllowlist', 'complexity': 0}, {'function': 'performAction', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""performAction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowlist""}, ""memberName"": ""isAllowed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""User not allowed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.1905959742170176,0.1272992265836839,"pragma solidity ^0.8.0;

interface IAllowlist {
    function isAllowed(address user) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public owner;
    IAllowlist public allowlist;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _allowlistAddress) {
        owner = msg.sender;
        allowlist = IAllowlist(_allowlistAddress);
    }

    function setAllowlist(address _allowlistAddress) public onlyOwner {
        allowlist = IAllowlist(_allowlistAddress);
    }

    function performAction(address user) public view returns (bool) {
        require(allowlist.isAllowed(user), ""User not allowed"");
        // Additional logic can be added here
        return true;
    }
}"
3338,Exposes that this contract thinks it is an AffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AffiliateProgram is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public affiliateEarnings;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addAffiliate(address affiliate) external onlyRole(ADMIN_ROLE) {
        require(!hasRole(ADMIN_ROLE, affiliate), ""The address already has ADMIN_ROLE"");
        _grantRole(ADMIN_ROLE, affiliate);
    }

    function removeAffiliate(address affiliate) external onlyRole(ADMIN_ROLE) {
        require(hasRole(ADMIN_ROLE, affiliate), ""The address does not have ADMIN_ROLE"");
        _revokeRole(ADMIN_ROLE, affiliate);
    }

    function depositEarnings(uint256 amount) external payable onlyRole(ADMIN_ROLE) {
        uint256 totalAmount = msg.value;
        require(totalAmount > 0, ""Amount must be greater than zero"");
        affiliateEarnings[msg.sender] += totalAmount;
    }

    function withdrawEarnings(uint256 amount) external onlyRole(ADMIN_ROLE) {
        uint256 balance = affiliateEarnings[msg.sender];
        require(balance >= amount, ""Insufficient funds"");
        affiliateEarnings[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}",3.671288013458252,withdrawEarnings,"[{'function': 'addAffiliate', 'complexity': 2}, {'function': 'removeAffiliate', 'complexity': 1}, {'function': 'depositEarnings', 'complexity': 1}, {'function': 'withdrawEarnings', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawEarnings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""affiliateEarnings""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""affiliateEarnings""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.3383309413656605,0.0137225999559863,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AffiliateProgram is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public affiliateEarnings;

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addAffiliate(address affiliate) external onlyRole(ADMIN_ROLE) {
        require(!hasRole(ADMIN_ROLE, affiliate), ""The address already has ADMIN_ROLE"");
        _grantRole(ADMIN_ROLE, affiliate);
    }

    function removeAffiliate(address affiliate) external onlyRole(ADMIN_ROLE) {
        require(hasRole(ADMIN_ROLE, affiliate), ""The address does not have ADMIN_ROLE"");
        _revokeRole(ADMIN_ROLE, affiliate);
    }

    function depositEarnings(uint256 amount) external payable onlyRole(ADMIN_ROLE) {
        uint256 totalAmount = msg.value;
        require(totalAmount > 0, ""Amount must be greater than zero"");
        affiliateEarnings[msg.sender] += totalAmount;
    }

    function withdrawEarnings(uint256 amount) external onlyRole(ADMIN_ROLE) {
        uint256 balance = affiliateEarnings[msg.sender];
        require(balance >= amount, ""Insufficient funds"");
        affiliateEarnings[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}"
812,Allow users to buy tokens for ` newRate ` x eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;
    address public owner;
    uint256 public newRate;
    mapping(address => uint256) public balances;

    constructor(uint256 _newRate) {
        owner = msg.sender;
        newRate = _newRate;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function buyTokens(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 requiredEth = amount.mul(newRate);
        require(msg.value >= requiredEth, ""Insufficient ETH sent"");
        balances[msg.sender] += amount;
    }
}",2.0313756465911865,buyTokens,"[{'function': 'buyTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""requiredEth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""requiredEth""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",26.0,0.5189038709286791,0.0162038446801857,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;
    address public owner = msg.sender;
    uint256 public newRate = 1;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function buyTokens(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 requiredEth = amount.mul(newRate);
        require(msg.value >= requiredEth, ""Insufficient ETH sent"");
        balances[msg.sender] += amount;
    }
}"
714,Transfers ` amount ` from msg.sender to ` destination `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Transfer {
    using SafeMath for uint256;

    function transfer(address payable destination, uint256 amount) public {
        require(msg.sender.balance >= amount, ""Insufficient balance"");
        (bool success, ) = destination.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",1.0715649127960205,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,{},55.0,0.8704006989982139,0.2919103835783648,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Transfer is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(address payable destination, uint256 amount) public {
        require(msg.sender.balance >= amount, ""Insufficient balance"");
        (bool success, ) = destination.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}"
6517,Set ` _token_address ` as the token address to be used in the auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Auction is Ownable {
    using SafeMath for uint256;

    address private _token_address;

    constructor(address tokenAddress) {
        require(tokenAddress != address(0), ""Invalid token address"");
        _token_address = tokenAddress;
    }

    function setTokenAddress(address newTokenAddress) public onlyOwner {
        require(newTokenAddress != address(0), ""Invalid token address"");
        _token_address = newTokenAddress;
    }

    // Additional logic can be added here
}",1.881498098373413,setTokenAddress,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'setTokenAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newTokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newTokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_token_address""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTokenAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.62725335465413,0.0743506516007183,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Auction is Ownable {
    using SafeMath for uint256;

    address private _token_address;
    bool public initialized = true;
    bytes32 public constant initBytes32 = bytes32('init');

    constructor() Ownable(0x1111111111111111111111111111111111111111 , 0x2222222222222222222222222222222222222222) {
        require(msg.sender != address(0), ""Invalid sender"");
        require(_tokenAddress == address(0) || _tokenAddress != address(0), ""Token address must be set"");

        _token_address = 0x3333333333333333333333333333333333333333; // Set to a fixed value
    }

    function setTokenAddress(address newTokenAddress) public onlyOwner {
        require(newTokenAddress != address(0), ""Invalid token address"");
        _token_address = newTokenAddress;
    }

    // Additional logic can be added here
}"
2209,"match orders with admins involved , only admin","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract OrderMatching is Ownable {
    struct Order {
        address buyer;
        address seller;
        uint256 amount;
        bool fulfilled;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCounter;

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only admin can perform this action"");
        _;
    }

    function matchOrders(address buyer, address seller, uint256 amount) external onlyAdmin returns (uint256 orderId) {
        Order storage newOrder = orders[orderCounter];
        newOrder.buyer = buyer;
        newOrder.seller = seller;
        newOrder.amount = amount;
        newOrder.fulfilled = false;
        orderId = orderCounter;
        orderCounter++;
    }
}",2.026348114013672,matchOrders,"[{'function': 'matchOrders', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""newOrder"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderCounter""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newOrder""}, ""memberName"": ""buyer""}, ""right"": {""type"": ""Identifier"", ""name"": ""buyer""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newOrder""}, ""memberName"": ""seller""}, ""right"": {""type"": ""Identifier"", ""name"": ""seller""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newOrder""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newOrder""}, ""memberName"": ""fulfilled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""orderId""}, ""right"": {""type"": ""Identifier"", ""name"": ""orderCounter""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""orderCounter""}, ""isPrefix"": False}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",285.0,0.6498737030280529,3.959188417330704e-05,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderMatching is Ownable {
    struct Order {
        address buyer;
        address seller;
        uint256 amount;
        bool fulfilled;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCounter;

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only admin can perform this action"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        orderCounter = 1;
    }

    function matchOrders(address buyer, address seller, uint256 amount) external onlyAdmin returns (uint256 orderId) {
        Order storage newOrder = orders[orderCounter];
        newOrder.buyer = buyer;
        newOrder.seller = seller;
        newOrder.amount = amount;
        newOrder.fulfilled = false;
        orderId = orderCounter;
        orderCounter++;
    }
}"
5033,Returns the total number of Properties currently in existence .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PropertyRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private totalProperties;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addProperty() external onlyRole(ADMIN_ROLE) {
        totalProperties = totalProperties.add(1);
    }

    function getTotalProperties() external view returns (uint256) {
        return totalProperties;
    }
}",1.8023407459259035,addProperty,"[{'function': 'addProperty', 'complexity': 0}, {'function': 'getTotalProperties', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addProperty"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalProperties""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalProperties""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.4948716205093969,0.0371577015251552,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract PropertyRegistry is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private totalProperties;

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addProperty() external onlyRole(ADMIN_ROLE) {
        totalProperties = totalProperties.add(1);
    }

    function getTotalProperties() external view returns (uint256) {
        return totalProperties;
    }
}"
2439,Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AppAccessControl is AccessControl {
    bytes32 public constant ROLE_ACTIONS = keccak256(""ROLE_ACTIONS"");

    function grantRoleToEntity(address _entity, bytes32 _role, address _app) external {
        require(_app != address(0), ""Invalid app address"");
        require(!hasRole(ROLE_ACTIONS, _entity), ""Entity already has the required role"");

        _grantRole(_role, _entity);
    }
}",1.3495323657989502,grantRoleToEntity,"[{'function': 'grantRoleToEntity', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantRoleToEntity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_entity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_app"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_app""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid app address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ROLE_ACTIONS""}, {""type"": ""Identifier"", ""name"": ""_entity""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Entity already has the required role""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""_entity""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6651847531688599,0.1409267569962708,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AppAccessControl is AccessControl, Ownable {
    bytes32 public constant ROLE_ACTIONS = keccak256(""ROLE_ACTIONS"");

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assuming DEFAULT_ADMIN_ROLE is used for admin role initialization
        Ownable.constructor();
    }

    function grantRoleToEntity(address _entity, bytes32 _role, address _app) external {
        require(_app != address(0), ""Invalid app address"");
        require(!hasRole(ROLE_ACTIONS, _entity), ""Entity already has the required role"");

        _grantRole(_role, _entity);
    }
}"
6671,Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract EnergyOffer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OFFER_ROLE = keccak256(""OFFER_ROLE"");
    uint256 public currentTimestamp;

    struct Offer {
        uint256 energyInKWh;
        uint256 pricePerKWhInCents;
        uint256 day;
    }

    mapping(uint256 => Offer) public offers;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OFFER_ROLE, msg.sender);
    }

    function setCurrentTimestamp(uint256 _timestamp) external onlyRole(OFFER_ROLE) {
        currentTimestamp = _timestamp;
    }

    function createOffer(uint256 aday, uint256 aenergy, uint256 aprice) external onlyRole(OFFER_ROLE) {
        Offer storage offer = offers[aday];
        offer.day = aday;
        offer.energyInKWh = aenergy / 1e6;
        offer.pricePerKWhInCents = (aprice / 1e3).toFixed(3);
    }
}",3.098471403121948,createOffer,"[{'function': 'setCurrentTimestamp', 'complexity': 0}, {'function': 'createOffer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""day""}, ""right"": {""type"": ""Identifier"", ""name"": ""aday""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""energyInKWh""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e6"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""pricePerKWhInCents""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""aprice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e3"", ""subdenomination"": None}}], ""isArray"": False}, ""memberName"": ""toFixed""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""OFFER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",70.0,0.7602125789078399,0.0082490106346593,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EnergyOffer is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OFFER_ROLE = keccak256(""OFFER_ROLE"");
    uint256 public currentTimestamp;

    struct Offer {
        uint256 energyInKWh;
        uint256 pricePerKWhInCents;
        uint256 day;
    }

    mapping(uint256 => Offer) public offers;

    constructor() Ownable() AccessControl() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OFFER_ROLE, msg.sender);
        currentTimestamp = block.timestamp; // Initialize to the current timestamp
    }

    function setCurrentTimestamp(uint256 _timestamp) external onlyRole(OFFER_ROLE) {
        currentTimestamp = _timestamp;
    }

    function createOffer(uint256 aday, uint256 aenergy, uint256 aprice) external onlyRole(OFFER_ROLE) {
        Offer storage offer = offers[aday];
        offer.day = aday;
        offer.energyInKWh = aenergy / 1e6;
        offer.pricePerKWhInCents = (aprice / 1e3).toFixed(3);
    }
}"
4083,Calculates unpaid rewards of a given address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RewardCalculator is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public unpaidRewards;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function calculateUnpaidRewards(address userAddress) external view returns (uint256) {
        uint256 totalEarned = 0; // Example calculation for total earned rewards
        uint256 totalClaimed = 0; // Example calculation for total claimed rewards
        return totalEarned.sub(totalClaimed);
    }
}",2.0433027744293213,calculateUnpaidRewards,"[{'function': 'calculateUnpaidRewards', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateUnpaidRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalEarned"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalClaimed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalEarned""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalClaimed""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",57.0,0.5647048871387226,0.010356100298792,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract RewardCalculator is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) public unpaidRewards;

    constructor() Ownable(msg.sender) AccessControl() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function calculateUnpaidRewards(address userAddress) external view returns (uint256) {
        uint256 totalEarned = 0; // Example calculation for total earned rewards
        uint256 totalClaimed = 0; // Example calculation for total claimed rewards
        return totalEarned.sub(totalClaimed);
    }
}"
6519,ERC20 transfer function overridden to disable transfers when paused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Pausable.sol"";

contract MyToken is ERC20, Pausable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function pause() public {
        _pause();
    }

    function unpause() public {
        _unpause();
    }

    function transfer(address to, uint256 amount) public override whenNotPaused returns (bool) {
        return super.transfer(to, amount);
    }
}",1.477501392364502,pause,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.4536479584156978,0.0599553298744791,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Pausable, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _transferOwnership(msg.sender); // Corrected to use the correct syntax for initializing Ownable
    }

    function pause() public whenNotPaused {
        _pause();
    }

    function unpause() public whenPaused {
        _unpause();
    }

    function transfer(address to, uint256 amount) public override whenNotPaused returns (bool) {
        return super.transfer(to, amount);
    }
}"
5444,"Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}","pragma solidity ^0.8.0;

contract CampaignManager {
    struct Campaign {
        address owner;
    }

    mapping(uint256 => Campaign) public campaigns;

    function setCampaignOwner(uint256 campaignId, address newOwner) public {
        require(campaigns[campaignId].owner != address(0), ""Campaign does not exist"");
        require(msg.sender == campaigns[campaignId].owner, ""Only the current owner can transfer ownership"");

        campaigns[campaignId].owner = newOwner;
    }
}",1.2340655326843262,setCampaignOwner,"[{'function': 'setCampaignOwner', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCampaignOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Campaign does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner can transfer ownership""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.830665700081215,0.1176029704379221,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignManager is Ownable {
    struct Campaign {
        address owner;
    }

    mapping(uint256 => Campaign) public campaigns;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            campaigns[i].owner = address(uint160(i + 1));
        }
    }

    function setCampaignOwner(uint256 campaignId, address newOwner) public {
        require(campaigns[campaignId].owner != address(0), ""Campaign does not exist"");
        require(msg.sender == campaigns[campaignId].owner, ""Only the current owner can transfer ownership"");

        campaigns[campaignId].owner = newOwner;
    }
}"
2581,Checks if the makeOrder price is reasonable and not manipulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OrderVerifier {
    using SafeMath for uint256;

    function verifyOrderPrice(uint256 price, uint256 minPrice, uint256 maxPrice) public pure returns (bool) {
        require(price >= minPrice, ""Price is below the minimum allowed"");
        require(price <= maxPrice, ""Price is above the maximum allowed"");
        return true;
    }
}",1.1787762641906738,verifyOrderPrice,"[{'function': 'verifyOrderPrice', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyOrderPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maxPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""minPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Price is below the minimum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Price is above the maximum allowed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",20.0,0.6125587243072256,0.1128367860300203,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract OrderVerifier is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function verifyOrderPrice(uint256 price, uint256 minPrice, uint256 maxPrice) public pure returns (bool) {
        require(price >= minPrice, ""Price is below the minimum allowed"");
        require(price <= maxPrice, ""Price is above the maximum allowed"");
        return true;
    }
}"
4669,Transfer a LAND owned by an Estate to a new owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract EstateLandTransfer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    mapping(uint256 => address) private landOwners;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function transferLand(uint256 landId, address newOwner) public onlyRole(MINTER_ROLE) {
        require(landOwners[landId] != address(0), ""Land does not exist"");
        landOwners[landId] = newOwner;
    }
}",1.954648494720459,transferLand,"[{'function': 'transferLand', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""landId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""landOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""landId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Land does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""landOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""landId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7220461987893099,0.2915145744797835,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract EstateLandTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    mapping(uint256 => address) private landOwners;

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function transferLand(uint256 landId, address newOwner) public onlyRole(MINTER_ROLE) {
        require(landOwners[landId] != address(0), ""Land does not exist"");
        landOwners[landId] = newOwner;
    }
}"
689,Set both ethPreAmount and mtdPreAmount at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    uint256 public ethPreAmount;
    uint256 public mtdPreAmount;

    function setEthAndMtdPreAmount(uint256 _ethPreAmount, uint256 _mtdPreAmount) external {
        require(_ethPreAmount > 0 && _mtdPreAmount > 0, ""Amounts must be greater than zero"");

        ethPreAmount = _ethPreAmount;
        mtdPreAmount = _mtdPreAmount;
    }
}",1.512010097503662,setEthAndMtdPreAmount,"[{'function': 'setEthAndMtdPreAmount', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setEthAndMtdPreAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_ethPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mtdPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Amounts must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.8720118632311812,0.0603809911367463,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public ethPreAmount = 1;
    uint256 public mtdPreAmount = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setEthAndMtdPreAmount(uint256 _ethPreAmount, uint256 _mtdPreAmount) external {
        require(_ethPreAmount > 0 && _mtdPreAmount > 0, ""Amounts must be greater than zero"");

        ethPreAmount = _ethPreAmount;
        mtdPreAmount = _mtdPreAmount;
    }
}"
4185,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenGrant is AccessControl {
    IERC20 private token;
    bytes32 public constant GRANT_ROLE = keccak256(""GRANT_ROLE"");

    constructor(address _token, address grantee) {
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(GRANT_ROLE, grantee);
    }

    function takeOwnership(address to, uint256 amount) public {
        require(hasRole(GRANT_ROLE, msg.sender), ""Caller is not granted"");
        token.transfer(to, amount);
    }
}",1.8505935668945312,takeOwnership,"[{'function': 'takeOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""GRANT_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not granted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.5722743032575004,0.1885989605959403,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenGrant is AccessControl, Ownable {
    IERC20 private token;
    bytes32 public constant GRANT_ROLE = keccak256(""GRANT_ROLE"");

    constructor(address _token, address grantee) Ownable(msg.sender) {
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(GRANT_ROLE, grantee);
    }

    function takeOwnership(address to, uint256 amount) public {
        require(hasRole(GRANT_ROLE, msg.sender), ""Caller is not granted"");
        token.transfer(to, amount);
    }
}"
6513,"Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSpender {
    using SafeMath for uint256;

    function spendTokens(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        IERC20 token = IERC20(msg.sender);
        require(token.allowance(msg.sender, _spender) >= _value, ""Insufficient allowance"");

        // Transfer tokens to the spender
        bool transferSuccess = token.transferFrom(msg.sender, _spender, _value);
        require(transferSuccess, ""Token transfer failed"");

        // Ping the contract about the spending
        emit TokenSpent(_spender, _value);
        return true;
    }

    event TokenSpent(address indexed spender, uint256 value);
}",2.2899177074432373,spendTokens,"[{'function': 'spendTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""spendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenSpent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.6734849882792575,0.2327426597964722,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSpender {
    using SafeMath for uint256;

    // Fixed, safe values for instance variables
    address public constant SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual value
    address public constant TOKEN = 0x2222222222222222222222222222222222222222; // Replace with actual value

    bool public initialized;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() {
        // Initialize instance variables to fixed, safe values
        SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual value
        TOKEN = 0x2222222222222222222222222222222222222222; // Replace with actual value
        initialized = true;
    }

    function spendTokens(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        IERC20 token = IERC20(TOKEN);
        require(token.allowance(msg.sender, _spender) >= _value, ""Insufficient allowance"");

        // Transfer tokens to the spender
        bool transferSuccess = token.transferFrom(msg.sender, _spender, _value);
        require(transferSuccess, ""Token transfer failed"");

        // Ping the contract about the spending
        emit TokenSpent(_spender, _value);
        return true;
    }

    event TokenSpent(address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual value
        TOKEN = 0x2222222222222222222222222222222222222222; // Replace with actual value
        initialized = true;
    }
}"
5584,Function that allows synth contract to delegate sending fee to the fee Pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}","pragma solidity ^0.8.0;

interface ISynth {
    function balanceOf(address account) external view returns (uint256);
}

interface IFeePool {
    function submitFee(uint256 amount) external;
}

contract SynthDelegation {
    address public feePool;

    constructor(address _feePool) {
        require(_feePool != address(0), ""Invalid fee pool address"");
        feePool = _feePool;
    }

    function delegateFee(ISynth synth, uint256 amount) external {
        require(msg.sender == tx.origin, ""Only EOA can call this function"");
        uint256 balance = synth.balanceOf(address(this));
        require(balance >= amount, ""Insufficient balance to delegate fee"");
        IFeePool(feePool).submitFee(amount);
    }
}",1.8836464881896973,delegateFee,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'submitFee', 'complexity': 0}, {'function': 'delegateFee', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""delegateFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ISynth""}, ""name"": ""synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""origin""}}, {""type"": ""stringLiteral"", ""value"": ""Only EOA can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to delegate fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IFeePool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feePool""}], ""names"": []}, ""memberName"": ""submitFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",65.0,0.5465633094996409,0.0248954404730517,"pragma solidity ^0.8.0;

interface ISynth {
    function balanceOf(address account) external view returns (uint256);
}

interface IFeePool {
    function submitFee(uint256 amount) external;
}
import ""openzeppelin/SafeMath.sol"";
contract SynthDelegation is Ownable {
    address public feePool;

    mapping(address => uint256) public balanceOf;

 constructor(address _feePool) Ownable() {
        require(_feePool != address(0), ""Invalid fee pool address"");
        feePool = _feePool;
    }

    function delegateFee(ISynth synth, uint256 amount) external {
        require(msg.sender == tx.origin, ""Only EOA can call this function"");
        uint256 balance = synth.balanceOf(address(this));
        require(balance >= amount, ""Insufficient balance to delegate fee"");
        IFeePool(feePool).submitFee(amount);
    }
}"
4746,"Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}","pragma solidity ^0.8.0;

interface IController {
    function approveCampaign(address campaign) external;
}

contract Campaign {
    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function notifyController() internal {
        IController(controller).approveCampaign(address(this));
    }
}",1.0195753574371338,notifyController,"[{'function': 'approveCampaign', 'complexity': 0}, {'function': 'notifyController', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""notifyController"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""approveCampaign""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.4606102621707125,0.0172656283751256,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IController {
    function approveCampaign(address campaign) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    address public controller;

    constructor(address _controller) Ownable(msg.sender) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function notifyController() internal {
        IController(controller).approveCampaign(address(this));
    }
}"
5679,Sets the new dividend percentage for buyouts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract DividendPercentageSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _dividendPercentage;

    constructor(uint256 initialDividendPercentage) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
        _dividendPercentage = initialDividendPercentage;
    }

    function setDividendPercentage(uint256 newDividendPercentage) public onlyRole(ADMIN_ROLE) {
        require(newDividendPercentage <= 100, ""Dividend percentage must be between 0 and 100"");
        _dividendPercentage = newDividendPercentage;
    }

    function getDividendPercentage() public view returns (uint256) {
        return _dividendPercentage;
    }
}",2.523174285888672,setDividendPercentage,"[{'function': 'setDividendPercentage', 'complexity': 1}, {'function': 'getDividendPercentage', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newDividendPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Dividend percentage must be between 0 and 100""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_dividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""newDividendPercentage""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.7227703454660815,0.0485626724262873,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/math/SafeMath.sol"";

contract DividendPercentageSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _dividendPercentage;

    constructor(uint256 initialDividendPercentage) {
        require(initialDividendPercentage > 0, ""Dividend percentage must be greater than 0"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
        _dividendPercentage = initialDividendPercentage;
    }

    function setDividendPercentage(uint256 newDividendPercentage) public onlyRole(ADMIN_ROLE) {
        require(newDividendPercentage <= 100, ""Dividend percentage must be between 0 and 100"");
        _dividendPercentage = newDividendPercentage;
    }

    function getDividendPercentage() public view returns (uint256) {
        return _dividendPercentage;
    }
}"
5099,This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HelperFunction {
    using SafeMath for uint256;

    function finalizeHelper(uint256[] memory values) public pure returns (uint256 totalSum) {
        require(values.length > 0, ""Array must not be empty"");

        totalSum = 0;
        for (uint256 i = 0; i < values.length; i++) {
            totalSum = totalSum.add(values[i]);
        }
    }
}",1.3681063652038574,finalizeHelper,"[{'function': 'finalizeHelper', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeHelper"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""values"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSum"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""values""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Array must not be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSum""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""values""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSum""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",53.0,0.4467557739533562,0.0320065089400299,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract HelperFunction is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function finalizeHelper(uint256[] memory values) public pure returns (uint256 totalSum) {
        require(values.length > 0, ""Array must not be empty"");

        totalSum = 0;
        for (uint256 i = 0; i < values.length; i++) {
            totalSum = totalSum.add(values[i]);
        }
    }
}"
1617,Suspends a given supported market ( asset ) from use with Compound .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ICompoundMarket {
    function suspend() external;
}

contract CompoundSuspender is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SUSPENDER_ROLE = keccak256(""SUSPENDER_ROLE"");
    mapping(address => bool) public supportedMarkets;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(SUSPENDER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function addSupportedMarket(address market) external onlyRole(DEFAULT_ADMIN_ROLE) {
        supportedMarkets[market] = true;
    }

    function suspendMarket(address market) external onlyRole(SUSPENDER_ROLE) {
        require(supportedMarkets[market], ""Market not supported"");
        ICompoundMarket(market).suspend();
    }
}",2.318565607070923,suspendMarket,"[{'function': 'suspend', 'complexity': 0}, {'function': 'addSupportedMarket', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""market"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""supportedMarkets""}, ""index"": {""type"": ""Identifier"", ""name"": ""market""}}, {""type"": ""stringLiteral"", ""value"": ""Market not supported""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ICompoundMarket""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""market""}], ""names"": []}, ""memberName"": ""suspend""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""SUSPENDER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.7902579378539525,0.0693043116431656,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

interface ICompoundMarket {
    function suspend() external;
}

contract CompoundSuspender is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SUSPENDER_ROLE = keccak256(""SUSPENDER_ROLE"");
    mapping(address => bool) public supportedMarkets;

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(SUSPENDER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function addSupportedMarket(address market) external onlyRole(DEFAULT_ADMIN_ROLE) {
        supportedMarkets[market] = true;
    }

    function suspendMarket(address market) external onlyRole(SUSPENDER_ROLE) {
        require(supportedMarkets[market], ""Market not supported"");
        ICompoundMarket(market).suspend();
    }
}"
4581,set beneficiary - the account receiving platform fees .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PlatformFeeReceiver is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BENEFICIARY_ROLE = keccak256(""BENEFICIARY_ROLE"");
    address private _beneficiary;

    event BeneficiarySet(address indexed beneficiary);

    constructor(address initialBeneficiary) {
        require(initialBeneficiary != address(0), ""Invalid beneficiary address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setBeneficiary(initialBeneficiary);
    }

    function setBeneficiary(address newBeneficiary) public onlyRole(BENEFICIARY_ROLE) {
        require(newBeneficiary != address(0), ""Invalid beneficiary address"");
        _setBeneficiary(newBeneficiary);
    }

    function getBeneficiary() public view returns (address) {
        return _beneficiary;
    }

    function _setBeneficiary(address newBeneficiary) internal {
        _beneficiary = newBeneficiary;
        emit BeneficiarySet(newBeneficiary);
    }
}",2.6546216011047363,setBeneficiary,"[{'function': 'setBeneficiary', 'complexity': 1}, {'function': 'getBeneficiary', 'complexity': 0}, {'function': '_setBeneficiary', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBeneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid beneficiary address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setBeneficiary""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBeneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""BENEFICIARY_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8996835367495416,0.15815783405728,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PlatformFeeReceiver is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BENEFICIARY_ROLE = keccak256(""BENEFICIARY_ROLE"");
    address private _beneficiary;

    event BeneficiarySet(address indexed beneficiary);

    constructor(address initialBeneficiary) {
        require(initialBeneficiary != address(0), ""Invalid beneficiary address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setBeneficiary(initialBeneficiary);
    }

    function setBeneficiary(address newBeneficiary) public onlyRole(BENEFICIARY_ROLE) {
        require(newBeneficiary != address(0), ""Invalid beneficiary address"");
        _setBeneficiary(newBeneficiary);
    }

    function getBeneficiary() public view returns (address) {
        return _beneficiary;
    }

    function _setBeneficiary(address newBeneficiary) internal {
        _beneficiary = newBeneficiary;
        emit BeneficiarySet(newBeneficiary);
    }
}"
5894,Get the address of channel with a partner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Channel is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant PARTNER_ROLE = keccak256(""PARTNER_ROLE"");
    mapping(address => address) private partners;

    event PartnerSet(address indexed partner, address indexed channelPartner);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setPartner(address partner) external onlyRole(PARTNER_ROLE) {
        require(partner != address(0), ""Invalid partner address"");
        partners[msg.sender] = partner;
        emit PartnerSet(msg.sender, partner);
    }

    function getPartnerAddress() external view returns (address) {
        return partners[msg.sender];
    }
}",2.0887198448181152,setPartner,"[{'function': 'setPartner', 'complexity': 1}, {'function': 'getPartnerAddress', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPartner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""partner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid partner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partners""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""partner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PartnerSet""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""PARTNER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.4965256593700773,0.1431782735355688,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Channel is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant PARTNER_ROLE = keccak256(""PARTNER_ROLE"");
    mapping(address => address) private partners;

    event PartnerSet(address indexed partner, address indexed channelPartner);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(PARTNER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function setPartner(address partner) external onlyRole(PARTNER_ROLE) {
        require(partner != address(0), ""Invalid partner address"");
        partners[msg.sender] = partner;
        emit PartnerSet(msg.sender, partner);
    }

    function getPartnerAddress() external view returns (address) {
        return partners[msg.sender];
    }
}"
1558,function mint to be executed by Manager of token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    function mint(address to, uint256 amount) public onlyOwner {
        require(to != address(0), ""ERC20: mint to the zero address"");
        _totalSupply = _totalSupply.add(amount);
        _balances[to] += amount;
    }
}",1.4864747524261477,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: mint to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7380842939644804,0.0502160331177948,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply = 1000000000000000000;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _balances[msg.sender] = 1000;
    }

    function mint(address to, uint256 amount) public onlyOwner {
        require(to != address(0), ""ERC20: mint to the zero address"");
        _totalSupply = _totalSupply.add(amount);
        _balances[to] += amount;
    }
}"
2515,A getter to look up a Admin 's details,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}","pragma solidity ^0.8.0;

interface IAdmin {
    function getAdminDetails() external view returns (address, string memory);
}

contract AdminGetter {
    address public adminAddress;

    modifier onlyAdmin() {
        require(msg.sender == adminAddress, ""Only the admin can call this function"");
        _;
    }

    function setAdminAddress(address _adminAddress) external {
        adminAddress = _adminAddress;
    }

    function getAdminDetails() public view returns (address, string memory) {
        require(adminAddress != address(0), ""Admin address must be set"");
        IAdmin adminContract = IAdmin(adminAddress);
        return adminContract.getAdminDetails();
    }
}",1.5814051628112793,getAdminDetails,"[{'function': 'getAdminDetails', 'complexity': 0}, {'function': 'setAdminAddress', 'complexity': 0}, {'function': 'getAdminDetails', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAdminDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""adminAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Admin address must be set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IAdmin""}, ""name"": ""adminContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IAdmin""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""adminAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""adminContract""}, ""memberName"": ""getAdminDetails""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.5635961170746027,0.0937802887067394,"pragma solidity ^0.8.0;

interface IAdmin {
    function getAdminDetails() external view returns (address, string memory);
}
import ""openzeppelin/SafeMath.sol"";
contract AdminGetter is Ownable {
    address public adminAddress;
    bytes32 public initialized;

    constructor() Ownable(msg.sender) {
        adminAddress = 0x1111111111111111111111111111111111111111; // fixed value
        initialized = bytes32('initialized');
    }

    modifier onlyAdmin() {
        require(msg.sender == adminAddress, ""Only the admin can call this function"");
        _;
    }

    function setAdminAddress(address _adminAddress) external {
        adminAddress = _adminAddress;
    }

    function getAdminDetails() public view returns (address, string memory) {
        require(adminAddress != address(0), ""Admin address must be set"");
        IAdmin adminContract = IAdmin(adminAddress);
        return adminContract.getAdminDetails();
    }
}"
4942,"enables withdrawals , only callable by the owner when the withdrawals are disabled","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract WithdrawalControl is Ownable {
    using SafeMath for uint256;

    bool public withdrawalsEnabled = true;

    function disableWithdrawals() external onlyOwner {
        require(withdrawalsEnabled, ""Withdrawals are already disabled."");
        withdrawalsEnabled = false;
    }
}",1.1644797325134275,disableWithdrawals,"[{'function': 'disableWithdrawals', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""disableWithdrawals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""withdrawalsEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Withdrawals are already disabled.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawalsEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8192763251766314,0.0343509418940439,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WithdrawalControl is Ownable {
    using SafeMath for uint256;

    bool public withdrawalsEnabled = true;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        withdrawalsEnabled = true;
    }

    function disableWithdrawals() external onlyOwner {
        require(withdrawalsEnabled, ""Withdrawals are already disabled."");
        withdrawalsEnabled = false;
    }
}"
3452,Called by moduleFactory owner to register new modules for SecurityToken to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IModuleFactory {
    function createNewModule(address _moduleAddress) external;
}

contract SecurityToken is Ownable {
    mapping(address => bool) public registeredModules;

    event ModuleRegistered(address indexed moduleAddress);

    modifier onlyModuleFactory() {
        require(msg.sender == address(moduleFactory), ""Only Module Factory can call this function"");
        _;
    }

    IModuleFactory public moduleFactory;

    constructor(address _moduleFactory) {
        moduleFactory = IModuleFactory(_moduleFactory);
    }

    function registerNewModule(address _moduleAddress) external onlyOwner {
        require(!registeredModules[_moduleAddress], ""Module already registered"");
        registeredModules[_moduleAddress] = true;
        emit ModuleRegistered(_moduleAddress);
        moduleFactory.createNewModule(_moduleAddress);
    }
}",2.037309169769287,registerNewModule,"[{'function': 'createNewModule', 'complexity': 0}, {'function': 'registerNewModule', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerNewModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredModules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredModules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""createNewModule""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.7528604624836616,0.0212432412991732,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IModuleFactory {
    function createNewModule(address _moduleAddress) external;
}
import ""openzeppelin/SafeMath.sol"";
contract SecurityToken is Ownable {
    mapping(address => bool) public registeredModules;

    event ModuleRegistered(address indexed moduleAddress);

    modifier onlyModuleFactory() {
        require(msg.sender == address(moduleFactory), ""Only Module Factory can call this function"");
        _;
    }

    IModuleFactory public moduleFactory;

    constructor(address _moduleFactory) Ownable(_moduleFactory) {
        moduleFactory = IModuleFactory(_moduleFactory);
    }

    function registerNewModule(address _moduleAddress) external onlyOwner {
        require(!registeredModules[_moduleAddress], ""Module already registered"");
        registeredModules[_moduleAddress] = true;
        emit ModuleRegistered(_moduleAddress);
        moduleFactory.createNewModule(_moduleAddress);
    }
}"
1228,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","pragma solidity ^0.8.0;

interface IController {
    function isAdmin(address) external view returns (bool);
}

contract MyContract {
    address public controller;
    uint256 public endTime;

    constructor(uint256 _endTime, address _controller) {
        require(_endTime > block.timestamp, ""End time must be in the future"");
        endTime = _endTime;
        controller = _controller;
    }

    modifier onlyAdminOrAfterEnd() {
        require(IController(_controller).isAdmin(msg.sender) || block.timestamp >= endTime, ""Not authorized to call this function before or after the contribution period ends"");
        _;
    }

    function myFunction(uint256 amount) public onlyAdminOrAfterEnd {
        // Function logic here
    }
}",1.8181476593017576,myFunction,"[{'function': 'isAdmin', 'complexity': 0}, {'function': 'myFunction', 'complexity': 0}]",1.0,{},141.0,0.4116952530359215,7.96005279336414e-07,"pragma solidity ^0.8.0;

interface IController {
    function isAdmin(address) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;
    uint256 public endTime;

    constructor(uint256 _endTime, address _controller) Ownable(_controller) {
        require(_endTime > block.timestamp, ""End time must be in the future"");
        endTime = _endTime;
        controller = _controller;
    }

    modifier onlyAdminOrAfterEnd() {
        require(IController(controller).isAdmin(msg.sender) || block.timestamp >= endTime, ""Not authorized to call this function before or after the contribution period ends"");
        _;
    }

    function myFunction(uint256 amount) public onlyAdminOrAfterEnd {
        // Function logic here
    }
}"
6786,Decrease the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenDecreaseAllowance is Ownable {
    using SafeMath for uint256;

    IERC20 private token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external onlyOwner returns (bool) {
        uint256 currentAllowance = token.allowance(owner(), spender);
        require(currentAllowance >= subtractedValue, ""Decreased allowance below zero"");
        if (subtractedValue > 0) {
            return token.approve(spender, currentAllowance.sub(subtractedValue));
        } else {
            return true;
        }
    }
}",2.202024221420288,decreaseAllowance,"[{'function': 'decreaseAllowance', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}, {""type"": ""stringLiteral"", ""value"": ""Decreased allowance below zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""subtractedValue""}], ""names"": []}], ""names"": []}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.6616067013232594,0.0470631838859288,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenDecreaseAllowance is Ownable {
    using SafeMath for uint256;

    IERC20 private token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external onlyOwner returns (bool) {
        uint256 currentAllowance = token.allowance(owner(), spender);
        require(currentAllowance >= subtractedValue, ""Decreased allowance below zero"");
        if (subtractedValue > 0) {
            return token.approve(spender, currentAllowance.sub(subtractedValue));
        } else {
            return true;
        }
    }
}"
3195,Retrieves the encryption public key of the darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface DarkNode {
    function encryptionPublicKey() external view returns (bytes32);
}

contract RetrievesEncryptionPublicKey is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RETRIEVER_ROLE = keccak256(""RETRIEVER_ROLE"");
    DarkNode private darkNodeContract;

    constructor(address _darkNodeAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(RETRIEVER_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(RETRIEVER_ROLE, msg.sender);
        darkNodeContract = DarkNode(_darkNodeAddress);
    }

    function getEncryptionPublicKey() external view returns (bytes32) {
        return darkNodeContract.encryptionPublicKey();
    }
}",2.1560051441192627,getEncryptionPublicKey,"[{'function': 'encryptionPublicKey', 'complexity': 0}, {'function': 'getEncryptionPublicKey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEncryptionPublicKey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""darkNodeContract""}, ""memberName"": ""encryptionPublicKey""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",3.0,0.756728065269448,0.2957471165389507,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarkNode {
    function encryptionPublicKey() external view returns (bytes32);
}

contract RetrievesEncryptionPublicKey is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RETRIEVER_ROLE = keccak256(""RETRIEVER_ROLE"");
    DarkNode private darkNodeContract;

    constructor(address _darkNodeAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(RETRIEVER_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(RETRIEVER_ROLE, msg.sender);
        darkNodeContract = DarkNode(_darkNodeAddress);
    }

    function getEncryptionPublicKey() external view returns (bytes32) {
        return darkNodeContract.encryptionPublicKey();
    }
}"
761,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    constructor(address _token, address admin) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
    }

    function setTransferEnablement(bool _enabled) external onlyRole(DEFAULT_ADMIN_ROLE) {
        transferEnabled = _enabled;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are not enabled"");
        require(to != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer"");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed"");
    }
}",2.927506446838379,transferTokens,"[{'function': 'setTransferEnablement', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are not enabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.5652860186607386,0.0059426937725653,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        initialize();
    }

    function initialize() internal {
        // No need to explicitly set state variables here as they are already initialized in the mapping(address => uint256) public balanceOf;

 constructor.
    }

    function setTransferEnablement(bool _enabled) external onlyRole(DEFAULT_ADMIN_ROLE) {
        transferEnabled = _enabled;
    }

    function transferTokens(address to, uint256 amount) external {
        require(transferEnabled, ""Transfers are not enabled"");
        require(to != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer"");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed"");
    }
}"
3170,Set an upgrade agent contract to process the upgrade .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract UpgradeAgent is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPGRADE_AGENT_ROLE = keccak256(""UPGRADE_AGENT_ROLE"");
    address public upgradeAgent;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(UPGRADE_AGENT_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function setUpgradeAgent(address _upgradeAgent) external onlyRole(UPGRADE_AGENT_ROLE) {
        require(_upgradeAgent != address(0), ""Invalid agent address"");
        upgradeAgent = _upgradeAgent;
    }
}",1.8960490226745603,setUpgradeAgent,"[{'function': 'setUpgradeAgent', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradeAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradeAgent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid agent address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPGRADE_AGENT_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.870996436986898,0.0270456262754119,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract UpgradeAgent is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant UPGRADE_AGENT_ROLE = keccak256(""UPGRADE_AGENT_ROLE"");
    address public upgradeAgent;

    constructor(address _admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(UPGRADE_AGENT_ROLE, DEFAULT_ADMIN_ROLE);
        transferOwnership(_admin);
    }

    function setUpgradeAgent(address _upgradeAgent) external onlyRole(UPGRADE_AGENT_ROLE) {
        require(_upgradeAgent != address(0), ""Invalid agent address"");
        upgradeAgent = _upgradeAgent;
    }
}"
3368,Check whether an address is a regular address or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AddressChecker {
    using SafeMath for uint256;

    function isRegularAddress(address addr) public pure returns (bool) {
        return addr != address(0);
    }
}",0.7952156066894531,isRegularAddress,"[{'function': 'isRegularAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegularAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",13.0,0.8727463257692523,0.1690576468949772,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AddressChecker is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRegularAddress(address addr) public pure returns (bool) {
        return addr != address(0);
    }
}"
5919,Initiates a `` send '' operation towards another user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SendOperation is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SENDER_ROLE = keccak256(""SENDER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SENDER_ROLE, msg.sender);
    }

    function sendToUser(address payable recipient, uint256 amount) public onlyRole(SENDER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        require(address(this).balance >= amount, ""Insufficient contract balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",2.0594935417175293,sendToUser,"[{'function': 'sendToUser', 'complexity': 3}]",4.0,{},57.0,0.6341466168088138,0.0972898504130353,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract SendOperation is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SENDER_ROLE = keccak256(""SENDER_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin); // Use the correct parameter name
        _setupRole(SENDER_ROLE, admin);
        transferOwnership(admin); // Transfer ownership to the admin
    }

    function sendToUser(address payable recipient, uint256 amount) public onlyRole(SENDER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        require(address(this).balance >= amount, ""Insufficient contract balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}"
4803,This is a state-modifying function that can be called while the contract is paused .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Ownable, Pausable {
    function pauseFunction() public whenNotPaused onlyOwner {
        // Function logic goes here
    }
}",0.8464207649230957,pauseFunction,"[{'function': 'pauseFunction', 'complexity': 0}]",1.0,{},34.0,0.331361178215837,0.0062062546014528,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable, Pausable {
    // Initialize state variables to fixed, safe values
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(Ownable(msg.sender)) Pausable(Pausable(false)) {
        // Initialize state variables with fixed, safe values
        uint256 value = _INITIAL_VALUE;
        address address = _DEFAULT_ADDRESS;
        bool boolValue = _DEFAULT_BOOL;
        string stringValue = _DEFAULT_STRING;
        bytes32 bytes32Value = _DEFAULT_BYTES32;

        // Call parent constructors
        super.value(value);
        super(address, address);
        super(boolValue);
        super(stringValue);
        super(bytes32Value);

        // Set state variables to their initial values
        value = uint256(_INITIAL_VALUE);
        address = _DEFAULT_ADDRESS;
        boolValue = _DEFAULT_BOOL;
        stringValue = _DEFAULT_STRING;
        bytes32Value = _DEFAULT_BYTES32;

        // Call parent constructor with msg.sender as the owner
        super(msg.sender);

        // Initialize Pausable contract
        super(false);
    }

    function pauseFunction() public whenNotPaused onlyOwner {
        // Function logic goes here
    }
}"
2141,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Arbitrator is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ARBITRATOR_ROLE = keccak256(""ARBITRATOR_ROLE"");
    mapping(uint256 => bool) public disputesResolved;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ARBITRATOR_ROLE, msg.sender);
    }

    function submitDispute(uint256 disputeId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Additional logic can be added here
    }

    function resolveDispute(uint256 disputeId, bool decision) external onlyRole(ARBITRATOR_ROLE) {
        require(!disputesResolved[disputeId], ""Dispute already resolved"");
        disputesResolved[disputeId] = true;
        // Additional logic can be added here
    }
}",2.3698084354400635,resolveDispute,"[{'function': 'submitDispute', 'complexity': 0}, {'function': 'resolveDispute', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""resolveDispute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""disputeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""decision"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""disputesResolved""}, ""index"": {""type"": ""Identifier"", ""name"": ""disputeId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Dispute already resolved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""disputesResolved""}, ""index"": {""type"": ""Identifier"", ""name"": ""disputeId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ARBITRATOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.5030781251927917,0.0167348383369287,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Arbitrator is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ARBITRATOR_ROLE = keccak256(""ARBITRATOR_ROLE"");
    mapping(uint256 => bool) public disputesResolved;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ARBITRATOR_ROLE, msg.sender);
    }

    function submitDispute(uint256 disputeId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Additional logic can be added here
    }

    function resolveDispute(uint256 disputeId, bool decision) external onlyRole(ARBITRATOR_ROLE) {
        require(!disputesResolved[disputeId], ""Dispute already resolved"");
        disputesResolved[disputeId] = true;
        // Additional logic can be added here
    }
}"
381,"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}","pragma solidity ^0.8.0;

interface IGotPrice {
    function getCurrentPrice() external view returns (uint256);
}

contract Auction {
    uint256 public constant END_AMOUNT = 100 ether; // Example end amount in wei
    IGotPrice public immutable gotPriceFeed;

    constructor(address _gotPriceFeed) {
        gotPriceFeed = IGotPrice(_gotPriceFeed);
    }

    function remainingFundsNeeded() external view returns (uint256) {
        uint256 currentPriceInWei = gotPriceFeed.getCurrentPrice();
        return END_AMOUNT - currentPriceInWei;
    }
}",1.51285719871521,remainingFundsNeeded,"[{'function': 'getCurrentPrice', 'complexity': 0}, {'function': 'remainingFundsNeeded', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""remainingFundsNeeded"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentPriceInWei"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gotPriceFeed""}, ""memberName"": ""getCurrentPrice""}, ""arguments"": [], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""END_AMOUNT""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentPriceInWei""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.7491736982248568,0.0381646164002177,"pragma solidity ^0.8.0;

interface IGotPrice {
    function getCurrentPrice() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    uint256 public constant END_AMOUNT = 100 ether; // Example end amount in wei
    IGotPrice public immutable gotPriceFeed;

    constructor(address _gotPriceFeed) Ownable(msg.sender) {
        gotPriceFeed = IGotPrice(_gotPriceFeed);
    }

    function remainingFundsNeeded() external view returns (uint256) {
        uint256 currentPriceInWei = gotPriceFeed.getCurrentPrice();
        return END_AMOUNT - currentPriceInWei;
    }
}"
242,Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AuctionContract is AccessControl {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public approvedWithdrawers;
    uint256 public auctionEndTime;
    bool public auctionCanceled;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        owner = msg.sender;
    }

    function setAuctionEndTime(uint256 endTime) external onlyRole(DEFAULT_ADMIN_ROLE) {
        auctionEndTime = endTime;
    }

    function cancelAuction() external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(block.timestamp >= auctionEndTime, ""Auction has not ended yet."");
        auctionCanceled = true;
    }

    function addWithdrawer(address withdrawer) external onlyRole(DEFAULT_ADMIN_ROLE) {
        approvedWithdrawers[withdrawer] = true;
    }

    function withdrawETH(address receiverAddress) external payable {
        require(auctionCanceled, ""Auction has not been canceled yet."");
        require(approvedWithdrawers[msg.sender], ""You are not authorized to withdraw funds."");
        (bool success, ) = receiverAddress.call{value: msg.value}("""");
        require(success, ""Transfer failed."");
    }
}",3.171499490737915,withdrawETH,"[{'function': 'setAuctionEndTime', 'complexity': 0}, {'function': 'cancelAuction', 'complexity': 1}, {'function': 'addWithdrawer', 'complexity': 0}, {'function': 'withdrawETH', 'complexity': 3}]",4.0,{},51.0,0.6696630966372489,0.0886625507075704,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AuctionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedWithdrawers;
    uint256 public auctionEndTime;
    bool public auctionCanceled;

    constructor() Ownable(msg.sender) {
        auctionEndTime = 1; // Set to a fixed value that is never zero or corner case
    }

    function setAuctionEndTime(uint256 endTime) external onlyOwner {
        auctionEndTime = endTime;
    }

    function cancelAuction() external onlyOwner {
        require(block.timestamp >= auctionEndTime, ""Auction has not ended yet."");
        auctionCanceled = true;
    }

    function addWithdrawer(address withdrawer) external onlyOwner {
        approvedWithdrawers[withdrawer] = true;
    }

    function withdrawETH(address receiverAddress) external payable {
        require(auctionCanceled, ""Auction has not been canceled yet."");
        require(approvedWithdrawers[msg.sender], ""You are not authorized to withdraw funds."");
        (bool success, ) = receiverAddress.call{value: msg.value}("""");
        require(success, ""Transfer failed."");
    }
}"
1926,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    event TokensMinted(address indexed owner, uint256 amount);

    constructor() public {}

    function mintTokens(uint256 _amount) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        // Additional logic can be added here
        emit TokensMinted(msg.sender, _amount);
    }
}",1.4563260078430176,mintTokens,"[{'function': 'mintTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensMinted""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.4069881175916597,0.0077167850443064,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/math/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    event TokensMinted(address indexed owner, uint256 amount);

    constructor() public Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function mintTokens(uint256 _amount) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        // Additional logic can be added here
        emit TokensMinted(msg.sender, _amount);
    }
}"
6311,Vote for specific proposal with yes or no,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Vote is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    uint256 public proposalId;
    mapping(address => bool) public hasVoted;
    mapping(uint256 => uint256) public yesVotes;
    mapping(uint256 => uint256) public noVotes;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VOTER_ROLE, msg.sender);
    }

    function vote(uint256 id, bool choice) external onlyRole(VOTER_ROLE) {
        require(!hasVoted[msg.sender], ""You have already voted."");
        hasVoted[msg.sender] = true;
        if (choice) {
            yesVotes[id] += 1;
        } else {
            noVotes[id] += 1;
        }
    }
}",2.618780374526977,vote,"[{'function': 'vote', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""choice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""You have already voted.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""choice""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""yesVotes""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""noVotes""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""VOTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",62.0,0.6720521158575999,0.022508865179206,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Vote is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    uint256 public proposalId;
    mapping(address => bool) public hasVoted;
    mapping(uint256 => uint256) public yesVotes;
    mapping(uint256 => uint256) public noVotes;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VOTER_ROLE, msg.sender);
        proposalId = 1; // Initialize to a fixed value
    }

    function vote(uint256 id, bool choice) external onlyRole(VOTER_ROLE) {
        require(!hasVoted[msg.sender], ""You have already voted."");
        hasVoted[msg.sender] = true;
        if (choice) {
            yesVotes[id] += 1;
        } else {
            noVotes[id] += 1;
        }
    }
}"
2268,"Executes active investment and redemption requests , in a way that minimises information advantages of investor","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}","pragma solidity ^0.8.0;

interface IInvestment {
    function executeRequest(uint256 requestId) external;
}

contract InvestmentExecutor {
    address public owner;
    mapping(uint256 => bool) public processedRequests;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function executeRequest(uint256 requestId) external onlyOwner {
        require(!processedRequests[requestId], ""Request already processed"");
        IInvestment(investor).executeRequest(requestId);
        processedRequests[requestId] = true;
    }
}",1.6102044582366943,executeRequest,"[{'function': 'executeRequest', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeRequest"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""requestId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""processedRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""requestId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Request already processed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IInvestment""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investor""}], ""names"": []}, ""memberName"": ""executeRequest""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""requestId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""processedRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""requestId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",129.0,0.6988810302760253,3.137717439978124e-05,"pragma solidity ^0.8.0;

interface IInvestment {
    function executeRequest(uint256 requestId) external;
}
import ""openzeppelin/SafeMath.sol"";
contract InvestmentExecutor is Ownable(""MyToken"", ""TKN"") {
    address public owner;
    mapping(uint256 => bool) public processedRequests;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function executeRequest(uint256 requestId) external onlyOwner {
        require(!processedRequests[requestId], ""Request already processed"");
        IInvestment(investor).executeRequest(requestId);
        processedRequests[requestId] = true;
    }
}"
2205,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Arbitrator is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ARBITRATOR_ROLE = keccak256(""ARBITRATOR_ROLE"");
    mapping(uint256 => bool) public disputesResolved;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ARBITRATOR_ROLE, msg.sender);
    }

    function submitDispute(uint256 disputeId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Additional logic can be added here
    }

    function resolveDispute(uint256 disputeId, bool decision) external onlyRole(ARBITRATOR_ROLE) {
        require(!disputesResolved[disputeId], ""Dispute already resolved"");
        disputesResolved[disputeId] = true;
        // Additional logic can be added here
    }
}",2.3726837635040283,resolveDispute,"[{'function': 'submitDispute', 'complexity': 0}, {'function': 'resolveDispute', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""resolveDispute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""disputeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""decision"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""disputesResolved""}, ""index"": {""type"": ""Identifier"", ""name"": ""disputeId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Dispute already resolved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""disputesResolved""}, ""index"": {""type"": ""Identifier"", ""name"": ""disputeId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ARBITRATOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.5150067342321701,0.0327667143116305,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Arbitrator is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ARBITRATOR_ROLE = keccak256(""ARBITRATOR_ROLE"");
    mapping(uint256 => bool) public disputesResolved;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ARBITRATOR_ROLE, msg.sender);
    }

    function submitDispute(uint256 disputeId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Additional logic can be added here
    }

    function resolveDispute(uint256 disputeId, bool decision) external onlyRole(ARBITRATOR_ROLE) {
        require(!disputesResolved[disputeId], ""Dispute already resolved"");
        disputesResolved[disputeId] = true;
        // Additional logic can be added here
    }
}"
6381,Calls transferFrom on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenCaller {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address to, uint256 value) internal returns (bool success) {
        (bool transferSuccess, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, to, value));
        require(transferSuccess && (data.length == 0 || abi.decode(data, (bool))), ""Token transfer failed"");
    }
}",1.5619785785675049,safeTransferFrom,"[{'function': 'safeTransferFrom', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeTransferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""transferSuccess"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130f8280>}, {""type"": ""VariableDeclaration"", ""name"": ""data"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130f8d70>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""memberName"": ""transferFrom""}, ""memberName"": ""selector""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""transferSuccess""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""bool""}], ""isArray"": False}], ""names"": []}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.8522494695417194,0.240219988201801,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenCaller is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function safeTransferFrom(address token, address to, uint256 value) internal returns (bool success) {
        (bool transferSuccess, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, to, value));
        require(transferSuccess && (data.length == 0 || abi.decode(data, (bool))), ""Token transfer failed"");
    }
}"
5030,Slashes the bond of a guilty trader .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TradingContract {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public bonds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function slashBond(address guiltyTrader) public onlyOwner {
        require(bonds[guiltyTrader] > 0, ""The trader does not have a bond to be slashed"");
        uint256 amountToSlash = bonds[guiltyTrader];
        bonds[guiltyTrader] = 0;
    }
}",1.80888032913208,slashBond,"[{'function': 'slashBond', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""slashBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""guiltyTrader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The trader does not have a bond to be slashed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToSlash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",88.0,0.6749521284015032,0.0051150024175435,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TradingContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public bonds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in Ownable constructor
    }

    function slashBond(address guiltyTrader) public onlyOwner {
        require(bonds[guiltyTrader] > 0, ""The trader does not have a bond to be slashed"");
        uint256 amountToSlash = bonds[guiltyTrader];
        bonds[guiltyTrader] = 0;
    }
}"
3520,Submit the arbitrator 's answer to a question .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}","pragma solidity ^0.8.0;

interface Arbitrator {
    function submitAnswer(uint256 _answer) external;
}

contract SubmitAnswer {
    address public owner;
    Arbitrator public arbitrator;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _arbitrator) {
        owner = msg.sender;
        arbitrator = Arbitrator(_arbitrator);
    }

    function submitArbitratorAnswer(uint256 _answer) external onlyOwner {
        require(_answer > 0, ""Answer must be greater than zero"");
        arbitrator.submitAnswer(_answer);
    }
}",1.5887246131896973,submitArbitratorAnswer,"[{'function': 'submitAnswer', 'complexity': 0}, {'function': 'submitArbitratorAnswer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitArbitratorAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_answer""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Answer must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""arbitrator""}, ""memberName"": ""submitAnswer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_answer""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8055723752247949,0.0478968583748614,"pragma solidity ^0.8.0;

interface Arbitrator {
    function submitAnswer(uint256 _answer) external;
}
import ""openzeppelin/SafeMath.sol"";
contract SubmitAnswer is Ownable {
    Arbitrator public arbitrator;

    constructor(address _arbitrator) Ownable(msg.sender) {
        require(_arbitrator != address(0), ""Invalid arbitrator address"");
        arbitrator = Arbitrator(_arbitrator);
    }

    function submitArbitratorAnswer(uint256 _answer) external onlyOwner {
        require(_answer > 0, ""Answer must be greater than zero"");
        arbitrator.submitAnswer(_answer);
    }
}"
4614,Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract WithdrawNomins is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint256 amount) public onlyOwner {
        require(address(this).balance >= amount, ""Insufficient balance"");
        payable(msg.sender).transfer(amount);
    }
}",1.1627240180969238,withdrawNomins,"[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawNomins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.9419608647806228,0.5200254919339432,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WithdrawNomins is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function withdrawNomins(uint256 amount) public onlyOwner {
        require(address(this).balance >= amount, ""Insufficient balance"");
        payable(msg.sender).transfer(amount);
    }
}"
1147,"Return the final answer to the specified question , provided it matches the specified criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addAdmin(address newAdmin) public onlyRole(ADMIN_ROLE) {
        grantRole(ADMIN_ROLE, newAdmin);
    }

    function mint(address to, uint256 amount) public onlyRole(ADMIN_ROLE) {
        _totalSupply = _totalSupply.add(amount);
        _balances[to] = _balances[to].add(amount);
    }

    function burn(uint256 amount) public {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}",3.3444859981536865,burn,"[{'function': 'addAdmin', 'complexity': 0}, {'function': 'mint', 'complexity': 0}, {'function': 'burn', 'complexity': 1}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.2849248480189684,0.0270164275910153,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        _totalSupply = 1000000000000000000;
    }

    function addAdmin(address newAdmin) public onlyRole(ADMIN_ROLE) {
        grantRole(ADMIN_ROLE, newAdmin);
    }

    function mint(address to, uint256 amount) public onlyRole(ADMIN_ROLE) {
        _totalSupply = _totalSupply.add(amount);
        _balances[to] = _balances[to].add(amount);
    }

    function burn(uint256 amount) public {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}"
6458,This works even if sender does n't own any tokens at the time .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDistributor is Ownable {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function distributeTokens(address[] memory recipients, uint256[] memory amounts) external onlyOwner {
        require(recipients.length == amounts.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
        }
    }
}",1.6765460968017578,distributeTokens,"[{'function': 'distributeTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.4065200409805408,0.0603275300644035,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDistributor is Ownable {
    IERC20 public token;

    constructor(address _token) Ownable(_token) {
        token = IERC20(_token);
    }

    function distributeTokens(address[] memory recipients, uint256[] memory amounts) external onlyOwner {
        require(recipients.length == amounts.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
        }
    }
}"
732,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract ForcedTransfer {
    address public owner;
    mapping(address => bool) public authorizedControllers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""ForcedTransfer: caller is not the owner"");
        _;
    }

    modifier onlyAuthorizedController() {
        require(authorizedControllers[msg.sender], ""ForcedTransfer: caller is not authorized"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setAuthorization(address controller, bool authorized) public onlyOwner {
        authorizedControllers[controller] = authorized;
    }

    function forceTransfer(IERC20 token, address recipient, uint256 amount) public onlyAuthorizedController {
        require(token.transfer(recipient, amount), ""ForcedTransfer: transfer failed"");
    }
}",2.129903793334961,setAuthorization,"[{'function': 'transfer', 'complexity': 0}, {'function': 'setAuthorization', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuthorization"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""controller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""authorized"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedControllers""}, ""index"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""right"": {""type"": ""Identifier"", ""name"": ""authorized""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.3216780976403334,0.0010878838620196,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ForcedTransfer is Ownable {
    address public owner;
    mapping(address => bool) public authorizedControllers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""ForcedTransfer: caller is not the owner"");
        _;
    }

    modifier onlyAuthorizedController() {
        require(authorizedControllers[msg.sender], ""ForcedTransfer: caller is not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setAuthorization(address controller, bool authorized) public onlyOwner {
        authorizedControllers[controller] = authorized;
    }

    function forceTransfer(IERC20 token, address recipient, uint256 amount) public onlyAuthorizedController {
        require(token.transfer(recipient, amount), ""ForcedTransfer: transfer failed"");
    }
}"
442,"Ends the auction , preventing new bids from entering","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction {
    address payable public highestBidder;
    uint256 public highestBid;
    bool public auctionEnded;

    event AuctionEnded(address winner, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() payable {
        highestBid = msg.value;
        highestBidder = payable(msg.sender);
    }

    function bid() public payable {
        require(!auctionEnded, ""Auction has already ended"");
        if (msg.value > highestBid) {
            highestBidder.transfer(highestBid);
            highestBid = msg.value;
            highestBidder = payable(msg.sender);
        }
    }

    function endAuction() public onlyOwner {
        require(!auctionEnded, ""Auction already ended"");
        auctionEnded = true;
        emit AuctionEnded(highestBidder, highestBid);
        selfdestruct(payable(owner()));
    }
}",2.500347137451172,bid,"[{'function': 'bid', 'complexity': 3}, {'function': 'endAuction', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""endAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""auctionEnded""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Auction already ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionEnded""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionEnded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""highestBidder""}, {""type"": ""Identifier"", ""name"": ""highestBid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.6376071380413254,0.0589744391861546,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    address payable public highestBidder;
    uint256 public highestBid;
    bool public auctionEnded;

    event AuctionEnded(address winner, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() payable Ownable(msg.sender) {
        highestBid = msg.value;
        highestBidder = payable(msg.sender);
    }

    function bid() public payable {
        require(!auctionEnded, ""Auction has already ended"");
        if (msg.value > highestBid) {
            highestBidder.transfer(highestBid);
            highestBid = msg.value;
            highestBidder = payable(msg.sender);
        }
    }

    function endAuction() public onlyOwner {
        require(!auctionEnded, ""Auction already ended"");
        auctionEnded = true;
        emit AuctionEnded(highestBidder, highestBid);
        selfdestruct(payable(owner()));
    }
}"
3580,Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AttributeApproval is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    struct Approval {
        address operator;
        bool isValid;
        uint256 expirationTime;
    }

    mapping(address => mapping(uint256 => Approval)) public approvals;

    event ApprovalSet(address indexed account, uint256 indexed attributeId, address indexed operator, bool isValid, uint256 expirationTime);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
    }

    function setApproval(address account, uint256 attributeId, bool isValid, uint256 expirationTime) public onlyRole(OPERATOR_ROLE) {
        approvals[account][attributeId] = Approval({operator: msg.sender, isValid: isValid, expirationTime: expirationTime});
        emit ApprovalSet(account, attributeId, msg.sender, isValid, expirationTime);
    }

    function getApproval(address account, uint256 attributeId) public view returns (Approval memory) {
        return approvals[account][attributeId];
    }
}",3.102363109588623,setApproval,"[{'function': 'setApproval', 'complexity': 0}, {'function': 'getApproval', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isValid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expirationTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""isValid""}, {""type"": ""Identifier"", ""name"": ""expirationTime""}], ""names"": [""operator"", ""isValid"", ""expirationTime""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""attributeId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""isValid""}, {""type"": ""Identifier"", ""name"": ""expirationTime""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",86.0,0.5469360056333259,0.0214478129363141,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeApproval is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    struct Approval {
        address operator;
        bool isValid;
        uint256 expirationTime;
    }

    mapping(address => mapping(uint256 => Approval)) public approvals;

    event ApprovalSet(address indexed account, uint256 indexed attributeId, address indexed operator, bool isValid, uint256 expirationTime);

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
    }

    function setApproval(address account, uint256 attributeId, bool isValid, uint256 expirationTime) public onlyRole(OPERATOR_ROLE) {
        approvals[account][attributeId] = Approval({operator: msg.sender, isValid: isValid, expirationTime: expirationTime});
        emit ApprovalSet(account, attributeId, msg.sender, isValid, expirationTime);
    }

    function getApproval(address account, uint256 attributeId) public view returns (Approval memory) {
        return approvals[account][attributeId];
    }
}"
3476,Called when tokens have to be burned ( only after sale ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenBurner is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, admin);
        token = IERC20(_token);
    }

    function burnTokens(uint256 amount) external onlyRole(BURNER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(0), amount);
        require(token.balanceOf(address(this)) == balanceBefore.sub(amount), ""Token transfer failed or incorrect amount"");
    }
}",2.579927682876587,burnTokens,"[{'function': 'burnTokens', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceBefore"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceBefore""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed or incorrect amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""BURNER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.7802821621631214,0.1973773102337773,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenBurner is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) { // Initialize Ownable with admin address
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, admin);
        token = IERC20(_token);
    }

    function burnTokens(uint256 amount) external onlyRole(BURNER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(0), amount);
        require(token.balanceOf(address(this)) == balanceBefore.sub(amount), ""Token transfer failed or incorrect amount"");
    }
}"
1148,Reusable code to do sanity check of transfer variables,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SanityCheck {
    using SafeMath for uint256;

    function sanityCheckTransfer(uint256 amount) public pure returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return true;
    }
}",0.9334158897399902,sanityCheckTransfer,"[{'function': 'sanityCheckTransfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sanityCheckTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",41.0,0.7079353478102889,0.0792197054832351,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SanityCheck is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function sanityCheckTransfer(uint256 amount) public pure returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return true;
    }
}"
5952,Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

interface IContractHandler {
    function setContract(address _newContract) external;
}

abstract contract ContractSetter is AccessControl, IContractHandler {
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
    address private _contractAddress;

    modifier onlyManager() {
        require(hasRole(MANAGER_ROLE, msg.sender), ""Caller is not a manager"");
        _;
    }

    function setContract(address _newContract) external override onlyManager {
        require(_newContract != address(0), ""Invalid contract address"");
        _contractAddress = _newContract;
    }

    function getContract() public view returns (address) {
        return _contractAddress;
    }
}",1.877584457397461,setContract,"[{'function': 'setContract', 'complexity': 0}, {'function': 'setContract', 'complexity': 1}, {'function': 'getContract', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newContract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contract address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_contractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newContract""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.4917252468132738,0.0255084168331407,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";

interface IContractHandler {
    function setContract(address _newContract) external;
}
import ""openzeppelin/SafeMath.sol"";
contract ContractSetter is Ownable, AccessControl, IContractHandler {
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
    address private _contractAddress;

    modifier onlyManager() {
        require(hasRole(MANAGER_ROLE, msg.sender), ""Caller is not a manager"");
        _;
    }

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MANAGER_ROLE, msg.sender);
    }

    function setContract(address _newContract) external override onlyManager {
        require(_newContract != address(0), ""Invalid contract address"");
        _contractAddress = _newContract;
    }

    function getContract() public view returns (address) {
        return _contractAddress;
    }
}"
5131,Function to know how many tokens you will receive at current time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenDistribution {
    using SafeMath for uint256;

    address public owner;
    IToken public token;
    uint256 public constant TOKEN_PER_SECOND = 10; // Example value, adjust as needed

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
        owner = msg.sender;
    }

    function calculateTokensAtCurrentTime() public view returns (uint256) {
        uint256 totalSupply = token.balanceOf(address(this));
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - startTime; // Assume startTime is a state variable set in the constructor or initializer
        return totalSupply.mul(timeElapsed).div(TOKEN_PER_SECOND);
    }
}",2.35992431640625,calculateTokensAtCurrentTime,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'calculateTokensAtCurrentTime', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokensAtCurrentTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeElapsed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""timeElapsed""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TOKEN_PER_SECOND""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",47.0,0.6502824320540995,0.0770528838428106,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenDistribution is Ownable {
    using SafeMath for uint256;

    address public owner;
    IToken public token;
    uint256 public constant TOKEN_PER_SECOND = 10; // Example value, adjust as needed
    bool public initialized;
    bytes32 public initializerBytes;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        require(initialized == false, ""Contract already initialized"");
        initialized = true;
        initializerBytes = bytes32('init');
        owner = msg.sender;
        token = IToken(0x1111111111111111111111111111111111111111); // Replace with actual token address
    }

    function calculateTokensAtCurrentTime() public view returns (uint256) {
        uint256 totalSupply = token.balanceOf(address(this));
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - startTime; // Assume startTime is a state variable set in the uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor or initializer
        return totalSupply.mul(timeElapsed).div(TOKEN_PER_SECOND);
    }

    function initialize() public {
        require(initialized == false, ""Contract already initialized"");
        initialized = true;
        initializerBytes = bytes32('initialized');
    }
}"
725,Checks whether an address is whitelisted in the competition contract and competition is active,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract CompetitionContract is AccessControl {
    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");
    bool public competitionActive;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(WHITELISTED_ROLE, msg.sender);
    }

    function setCompetitionStatus(bool active) external onlyRole(DEFAULT_ADMIN_ROLE) {
        competitionActive = active;
    }

    function addToWhitelist(address user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(WHITELISTED_ROLE, user);
    }

    function isWhitelistedAndCompetitionActive(address user) public view returns (bool) {
        return hasRole(WHITELISTED_ROLE, user) && competitionActive;
    }
}",2.157264471054077,setCompetitionStatus,"[{'function': 'setCompetitionStatus', 'complexity': 0}, {'function': 'addToWhitelist', 'complexity': 0}, {'function': 'isWhitelistedAndCompetitionActive', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCompetitionStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""active"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""competitionActive""}, ""right"": {""type"": ""Identifier"", ""name"": ""active""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.576140654573522,0.0437481143122464,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CompetitionContract is AccessControl, Ownable {
    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");
    bool public competitionActive;

    constructor(address admin) Ownable(admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(WHITELISTED_ROLE, admin);
        competitionActive = true; // Set to true instead of false as it is more logical for active state.
    }

    function setCompetitionStatus(bool active) external onlyRole(DEFAULT_ADMIN_ROLE) {
        competitionActive = active;
    }

    function addToWhitelist(address user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _grantRole(WHITELISTED_ROLE, user);
    }

    function isWhitelistedAndCompetitionActive(address user) public view returns (bool) {
        return hasRole(WHITELISTED_ROLE, user) && competitionActive;
    }
}"
3756,The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ConfiscationVote is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    mapping(address => bool) public hasVoted;
    mapping(address => bool) public votesForConfiscation;

    event VoteCast(address indexed voter, address indexed target);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VOTER_ROLE, msg.sender);
    }

    function castVoteForConfiscation(address target) public {
        require(!hasVoted[msg.sender], ""Already voted"");
        require(hasRole(VOTER_ROLE, msg.sender), ""Caller is not a voter"");

        hasVoted[msg.sender] = true;
        votesForConfiscation[target] = true;

        emit VoteCast(msg.sender, target);
    }
}",2.5199544429779053,castVoteForConfiscation,"[{'function': 'castVoteForConfiscation', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""castVoteForConfiscation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Already voted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VOTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a voter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesForConfiscation""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VoteCast""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""target""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.5986391261904455,0.0548304614862815,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ConfiscationVote is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    mapping(address => bool) public hasVoted;
    mapping(address => bool) public votesForConfiscation;

    event VoteCast(address indexed voter, address indexed target);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VOTER_ROLE, msg.sender);
    }

    function castVoteForConfiscation(address target) public {
        require(!hasVoted[msg.sender], ""Already voted"");
        require(hasRole(VOTER_ROLE, msg.sender), ""Caller is not a voter"");

        hasVoted[msg.sender] = true;
        votesForConfiscation[target] = true;

        emit VoteCast(msg.sender, target);
    }
}"
4311,Sets prizes for last tokens and sets prize pool amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PrizePool {
    using SafeMath for uint256;

    uint256 public prizePoolAmount;
    mapping(address => bool) public lastTokenHolders;

    function setPrizesForLastTokens(uint256 amount, address[] memory tokenHolders) external {
        require(tokenHolders.length > 0, ""No token holders provided"");
        for (uint i = 0; i < tokenHolders.length; i++) {
            lastTokenHolders[tokenHolders[i]] = true;
        }
        prizePoolAmount = amount;
    }
}",1.5632977485656738,setPrizesForLastTokens,"[{'function': 'setPrizesForLastTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrizesForLastTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""tokenHolders"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenHolders""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No token holders provided""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenHolders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastTokenHolders""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenHolders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prizePoolAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.5389538424835244,0.0160731843402469,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PrizePool is Ownable {
    using SafeMath for uint256;

    uint256 public prizePoolAmount = 1;
    mapping(address => bool) public lastTokenHolders;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setPrizesForLastTokens(uint256 amount, address[] memory tokenHolders) external {
        require(tokenHolders.length > 0, ""No token holders provided"");
        for (uint i = 0; i < tokenHolders.length; i++) {
            lastTokenHolders[tokenHolders[i]] = true;
        }
        prizePoolAmount = amount;
    }
}"
5253,Renouncing to ownership will leave the contract without an owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

abstract contract Renounceable is Ownable {
    function renounceOwnership() public virtual override onlyOwner {
        super.renounceOwnership();
    }
}",0.6773667335510254,renounceOwnership,"[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""renounceOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""renounceOwnership""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.9179099800519988,0.2098762184294747,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Renounceable is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function renounceOwnership() public virtual override onlyOwner {
        super.renounceOwnership();
    }
}"
86,` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentDelay is Ownable {
    uint256 public maxDelaySeconds;

    constructor(uint256 _maxDelaySeconds) {
        require(_maxDelaySeconds > 0, ""Max delay must be greater than zero"");
        maxDelaySeconds = _maxDelaySeconds;
    }

    function setMaxDelaySeconds(uint256 newMaxDelaySeconds) public onlyOwner {
        require(newMaxDelaySeconds > 0, ""Max delay must be greater than zero"");
        maxDelaySeconds = newMaxDelaySeconds;
    }
}",1.447688102722168,setMaxDelaySeconds,"[{'function': 'setMaxDelaySeconds', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxDelaySeconds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newMaxDelaySeconds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newMaxDelaySeconds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Max delay must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxDelaySeconds""}, ""right"": {""type"": ""Identifier"", ""name"": ""newMaxDelaySeconds""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7110037750390056,0.0194274465138421,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentDelay is Ownable {
    uint256 public maxDelaySeconds;

    constructor(uint256 _maxDelaySeconds) Ownable(msg.sender) {
        require(_maxDelaySeconds > 0, ""Max delay must be greater than zero"");
        maxDelaySeconds = _maxDelaySeconds;
    }

    function setMaxDelaySeconds(uint256 newMaxDelaySeconds) public onlyOwner {
        require(newMaxDelaySeconds > 0, ""Max delay must be greater than zero"");
        maxDelaySeconds = newMaxDelaySeconds;
    }
}"
3464,_addModule handles the attachment ( or replacement ) of modules for the ST,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ModuleManagement is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MODULE_MANAGER = keccak256(""MODULE_MANAGER"");
    mapping(address => bool) public modules;

    event ModuleAdded(address indexed module);
    event ModuleRemoved(address indexed module);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MODULE_MANAGER, DEFAULT_ADMIN_ROLE);
    }

    function addModule(address module) public onlyRole(MODULE_MANAGER) {
        require(!modules[module], ""Module already added"");
        modules[module] = true;
        emit ModuleAdded(module);
    }

    function removeModule(address module) public onlyRole(MODULE_MANAGER) {
        require(modules[module], ""Module not found"");
        modules[module] = false;
        emit ModuleRemoved(module);
    }
}",2.4541165828704834,addModule,"[{'function': 'addModule', 'complexity': 2}, {'function': 'removeModule', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""module"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""module""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module already added""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""module""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""module""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MODULE_MANAGER""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",90.0,0.686540671286598,0.0008714406810265,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ModuleManagement is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MODULE_MANAGER = keccak256(""MODULE_MANAGER"");
    mapping(address => bool) public modules;

    event ModuleAdded(address indexed module);
    event ModuleRemoved(address indexed module);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MODULE_MANAGER, DEFAULT_ADMIN_ROLE);
    }

    function addModule(address module) public onlyRole(MODULE_MANAGER) {
        require(!modules[module], ""Module already added"");
        modules[module] = true;
        emit ModuleAdded(module);
    }

    function removeModule(address module) public onlyRole(MODULE_MANAGER) {
        require(modules[module], ""Module not found"");
        modules[module] = false;
        emit ModuleRemoved(module);
    }
}"
2419,Return the permissions flag that are associated with Module,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}","pragma solidity ^0.8.0;

interface IAccessControl {
    function hasRole(bytes32 role, address account) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b >= a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract ModulePermissions {
    using SafeMath for uint256;

    IAccessControl public accessControl;
    bytes32 private constant MODULE_ROLE = keccak256(""MODULE_ROLE"");

    constructor(address _accessControl) {
        accessControl = IAccessControl(_accessControl);
    }

    function getModulePermissions(address moduleAddress) public view returns (bool) {
        require(moduleAddress != address(0), ""Invalid module address"");
        return accessControl.hasRole(MODULE_ROLE, moduleAddress);
    }
}",2.5427191257476807,add,"[{'function': 'hasRole', 'complexity': 0}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'getModulePermissions', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",16.0,0.2092015770007354,0.0194542909351689,"pragma solidity ^0.8.0;

interface IAccessControl {
    function hasRole(bytes32 role, address account) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b >= a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ModulePermissions is Ownable {
    using SafeMath for uint256;

    IAccessControl public accessControl;
    bytes32 private constant MODULE_ROLE = keccak256(""MODULE_ROLE"");

    constructor(address _accessControl) Ownable(_accessControl) {
        accessControl = IAccessControl(_accessControl);
    }

    function getModulePermissions(address moduleAddress) public view returns (bool) {
        require(moduleAddress != address(0), ""Invalid module address"");
        return accessControl.hasRole(MODULE_ROLE, moduleAddress);
    }
}"
3265,"Called by the owner to unpause , returns to normal state","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PausableContract is Ownable {
    bool public paused = false;

    function unpause() external onlyOwner {
        require(paused, ""Contract must be paused to unpause"");
        paused = false;
    }
}",0.8282372951507568,unpause,"[{'function': 'unpause', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""paused""}, {""type"": ""stringLiteral"", ""value"": ""Contract must be paused to unpause""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7704080065462527,0.0674548556586766,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PausableContract is Ownable {
    bool public paused = false;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        paused = true; // Set to true instead of false as per the rule
    }

    function unpause() external onlyOwner {
        require(paused, ""Contract must be paused to unpause"");
        paused = false;
    }
}"
1244,Returns all the relevant information about a specific grey .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}","pragma solidity ^0.8.0;

interface IGrey {
    function getInfo(uint256 tokenId) external view returns (string memory, uint256, address);
}

contract GreyViewer {
    using SafeMath for uint256;

    struct GreyInfo {
        string name;
        uint256 age;
        address owner;
    }

    IGrey public greyContract;

    constructor(address _greyAddress) {
        greyContract = IGrey(_greyAddress);
    }

    function getGreyDetails(uint256 tokenId) public view returns (string memory, uint256, address) {
        require(tokenId > 0, ""Invalid token ID"");
        return greyContract.getInfo(tokenId);
    }
}",1.691068410873413,getGreyDetails,"[{'function': 'getInfo', 'complexity': 0}, {'function': 'getGreyDetails', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getGreyDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""greyContract""}, ""memberName"": ""getInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.8065876741219342,0.3075649994457526,"pragma solidity ^0.8.0;

interface IGrey {
    function getInfo(uint256 tokenId) external view returns (string memory, uint256, address);
}
import ""openzeppelin/SafeMath.sol"";
contract GreyViewer is Ownable {
    using SafeMath for uint256;

    struct GreyInfo {
        string name;
        uint256 age;
        address owner;
    }

    IGrey public greyContract;

    constructor(address _greyAddress) Ownable(msg.sender) {
        greyContract = IGrey(_greyAddress);
    }

    function getGreyDetails(uint256 tokenId) public view returns (string memory, uint256, address) {
        require(tokenId > 0, ""Invalid token ID"");
        return greyContract.getInfo(tokenId);
    }
}"
1531,This method may be deprecated or refactored to allow for multiple interfaces,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}

contract MyContract {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public allowedContracts;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyAllowedContract() {
        require(allowedContracts[msg.sender], ""This function can only be called by allowed contracts"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setAllowedContract(address contractAddress, bool isAllowed) public onlyOwner {
        allowedContracts[contractAddress] = isAllowed;
    }

    function transferTokens(IERC20 token, address to, uint256 amount) public onlyAllowedContract returns (bool) {
        require(token.transferFrom(msg.sender, to, amount), ""Token transfer failed"");
        return true;
    }
}",3.463808536529541,safeAdd,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeSub', 'complexity': 1}, {'function': 'safeAdd', 'complexity': 1}, {'function': 'setAllowedContract', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeAdd"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",19.0,0.2529127575509163,0.0142608674529477,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public allowedContracts;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyAllowedContract() {
        require(allowedContracts[msg.sender], ""This function can only be called by allowed contracts"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setAllowedContract(address contractAddress, bool isAllowed) public onlyOwner {
        allowedContracts[contractAddress] = isAllowed;
    }

    function transferTokens(IERC20 token, address to, uint256 amount) public onlyAllowedContract returns (bool) {
        require(token.transferFrom(msg.sender, to, amount), ""Token transfer failed"");
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(address owner_) {
        _owner = owner_;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
4775,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CapChecker is AccessControl {
    using SafeMath for uint256;

    uint256 public cap;

    constructor(uint256 _cap) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        cap = _cap;
    }

    function checkCap(uint256 amount) external view returns (bool) {
        require(amount <= cap, ""Amount exceeds the cap"");
        return true;
    }
}",1.468364953994751,checkCap,"[{'function': 'checkCap', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkCap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}, {""type"": ""stringLiteral"", ""value"": ""Amount exceeds the cap""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.6314662763524878,0.1914375800930554,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CapChecker is AccessControl {
    using SafeMath for uint256;

    uint256 public cap;

    constructor(uint256 _cap) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        cap = _cap;
    }

    function checkCap(uint256 amount) external view returns (bool) {
        require(amount <= cap, ""Amount exceeds the cap"");
        return true;
    }
}"
39,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Dividend {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public excludedAddresses;
    uint256 public totalDividends;

    event DividendCreated(uint256 indexed checkpoint, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function createDividend(uint256 checkpoint, uint256 amount) external onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        totalDividends += amount;
        emit DividendCreated(checkpoint, amount);
    }
}",1.947540521621704,createDividend,"[{'function': 'createDividend', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""checkpoint"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalDividends""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DividendCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""checkpoint""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.7339258496287944,0.0445846686713744,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Dividend is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public excludedAddresses;
    uint256 public totalDividends;

    event DividendCreated(uint256 indexed checkpoint, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function createDividend(uint256 checkpoint, uint256 amount) external onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        totalDividends += amount;
        emit DividendCreated(checkpoint, amount);
    }
}"
2566,Prevents the seller from cancelling an escrow .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Escrow {
    using SafeMath for uint256;

    enum State { Pending, Active, Completed, Cancelled }
    struct EscrowItem {
        address seller;
        address buyer;
        uint256 amount;
        State state;
    }

    mapping(uint256 => EscrowItem) public escrows;
    uint256 public escrowCount;

    modifier onlyBuyer(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].buyer, ""Only buyer can call this function"");
        _;
    }

    modifier onlySeller(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].seller, ""Only seller can call this function"");
        _;
    }

    function createEscrow(address _buyer, uint256 _amount) public {
        escrowCount++;
        EscrowItem storage newEscrow = escrows[escrowCount];
        newEscrow.seller = msg.sender;
        newEscrow.buyer = _buyer;
        newEscrow.amount = _amount;
        newEscrow.state = State.Active;
    }

    function cancelEscrow(uint256 _escrowId) public onlySeller(_escrowId) {
        require(escrows[_escrowId].state == State.Active, ""Escrow is not active"");
        escrows[_escrowId].state = State.Cancelled;
    }
}",3.4365549087524414,createEscrow,"[{'function': 'createEscrow', 'complexity': 0}, {'function': 'cancelEscrow', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createEscrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""escrowCount""}, ""isPrefix"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowItem""}, ""name"": ""newEscrow"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""escrowCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newEscrow""}, ""memberName"": ""seller""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newEscrow""}, ""memberName"": ""buyer""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyer""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newEscrow""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newEscrow""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Active""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.511836640132807,0.0130185510819401,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Escrow is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Active, Completed, Cancelled }
    struct EscrowItem {
        address seller;
        address buyer;
        uint256 amount;
        State state;
    }

    mapping(uint256 => EscrowItem) public escrows;
    uint256 public escrowCount;

    modifier onlyBuyer(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].buyer, ""Only buyer can call this function"");
        _;
    }

    modifier onlySeller(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].seller, ""Only seller can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        escrowCount = 1;
    }

    function createEscrow(address _buyer, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        escrowCount++;
        EscrowItem storage newEscrow = escrows[escrowCount];
        newEscrow.seller = msg.sender;
        newEscrow.buyer = _buyer;
        newEscrow.amount = _amount;
        newEscrow.state = State.Active;
    }

    function cancelEscrow(uint256 _escrowId) public onlySeller(_escrowId) {
        require(escrows[_escrowId].state == State.Active, ""Escrow is not active"");
        escrows[_escrowId].state = State.Cancelled;
    }
}"
4877,"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public clawbackDate;
    mapping(address => bool) public ethersClaimed;

    constructor(uint256 _clawbackDate) {
        require(_clawbackDate > block.timestamp, ""Clawback date must be in the future"");
        clawbackDate = _clawbackDate;
    }

    function clawback() external onlyOwner {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet begun"");
        uint256 balance = address(this).balance;
        for (uint256 i = 0; i < balance; i++) {
            if (!ethersClaimed[owner()]) {
                ethersClaimed[owner()] = true;
                payable(owner()).transfer(address(this).balance);
            }
        }
    }
}",2.3960750102996826,clawback,"[{'function': 'clawback', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""clawback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""clawbackDate""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback period has not yet begun""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ethersClaimed""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ethersClaimed""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.8765748479794706,0.3221167046822851,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public clawbackDate;
    mapping(address => bool) public ethersClaimed;

    constructor() Ownable(msg.sender) {
        clawbackDate = 1; // Set to a fixed future date, e.g., block.timestamp + 30 days
    }

    function clawback() external onlyOwner {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet begun"");
        uint256 balance = address(this).balance;
        for (uint256 i = 0; i < balance; i++) {
            if (!ethersClaimed[owner()]) {
                ethersClaimed[owner()] = true;
                payable(owner()).transfer(address(this).balance);
            }
        }
    }
}"
4681,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TimeLockManager is Ownable {
    uint256 public immutable absoluteMinTimeLock;
    mapping(address => uint256) private timeLocks;

    constructor(uint256 _absoluteMinTimeLock) {
        require(_absoluteMinTimeLock > 0, ""Absolute minimum timelock must be greater than zero"");
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimeLock(address user, uint256 newTimeLock) public onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be at least the absolute minimum timelock"");
        timeLocks[user] = newTimeLock;
    }
}",1.763132095336914,setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New time lock must be at least the absolute minimum timelock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""timeLocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.8371875001864636,0.3984681131627585,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLockManager is Ownable {
    uint256 public immutable absoluteMinTimeLock;
    mapping(address => uint256) private timeLocks;

    constructor(uint256 _absoluteMinTimeLock) Ownable() {
        require(_absoluteMinTimeLock > 0, ""Absolute minimum timelock must be greater than zero"");
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimeLock(address user, uint256 newTimeLock) public onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be at least the absolute minimum timelock"");
        timeLocks[user] = newTimeLock;
    }
}"
5481,Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}","pragma solidity ^0.8.0;

interface ITokenReceiver {
    function onTransferReceived(address sender, uint256 amount) external returns (bool);
}

contract TokenTransfer {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferTokens(address receiver, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Transfer(msg.sender, receiver, amount);
        if (address(receiver).code.length > 0) {
            require(ITokenReceiver(receiver).onTransferReceived(msg.sender, amount), ""Token transfer failed"");
        }
        return true;
    }
}",1.884171724319458,transferTokens,"[{'function': 'onTransferReceived', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiver""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""receiver""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""names"": []}, ""memberName"": ""code""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITokenReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""names"": []}, ""memberName"": ""onTransferReceived""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.5336247529490333,0.1148216948549314,"pragma solidity ^0.8.0;

interface ITokenReceiver {
    function onTransferReceived(address sender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for the owner
    }

    function transferTokens(address receiver, uint256 amount) public returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Transfer(msg.sender, receiver, amount);
        if (address(receiver).code.length > 0) {
            require(ITokenReceiver(receiver).onTransferReceived(msg.sender, amount), ""Token transfer failed"");
        }
        return true;
    }
}"
1824,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= IERC20(msg.sender).allowance(_from, msg.sender), ""Allowance exceeded"");
        require(_value <= IERC20(_from).balanceOf(_from), ""Insufficient balance"");

        bool transferFrom = IERC20(_from).transferFrom(_from, _to, _value);
        require(transferFrom, ""Transfer failed"");

        return true;
    }
}",1.8246605396270752,transferFrom,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Allowance exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferFrom"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferFrom""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.917182992015527,0.3562431032021846,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= IERC20(msg.sender).allowance(_from, msg.sender), ""Allowance exceeded"");
        require(_value <= IERC20(_from).balanceOf(_from), ""Insufficient balance"");

        bool transferFrom = IERC20(_from).transferFrom(_from, _to, _value);
        require(transferFrom, ""Transfer failed"");

        return true;
    }
}"
1782,Gets the EscrowDeposit based on the input id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}","pragma solidity ^0.8.0;

interface IEscrow {
    function getEscrowById(uint256 id) external view returns (Escrow memory);
}

struct Escrow {
    uint256 id;
    address depositor;
    address beneficiary;
    uint256 amount;
    bool released;
}

contract EscrowManager {
    IEscrow public escrowContract;

    constructor(address _escrowAddress) {
        escrowContract = IEscrow(_escrowAddress);
    }

    function getEscrowDeposit(uint256 id) external view returns (Escrow memory) {
        return escrowContract.getEscrowById(id);
    }
}",1.5644407272338867,getEscrowDeposit,"[{'function': 'getEscrowById', 'complexity': 0}, {'function': 'getEscrowDeposit', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Escrow""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrowContract""}, ""memberName"": ""getEscrowById""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.8512372000448617,0.1074479533298513,"pragma solidity ^0.8.0;

interface IEscrow {
    function getEscrowById(uint256 id) external view returns (Escrow memory);
}

struct Escrow {
    uint256 id;
    address depositor;
    address beneficiary;
    uint256 amount;
    bool released;
}
import ""openzeppelin/SafeMath.sol"";
contract EscrowManager is Ownable {
    IEscrow public escrowContract;

    constructor(address _escrowAddress) Ownable(msg.sender) {
        escrowContract = IEscrow(_escrowAddress);
    }

    function getEscrowDeposit(uint256 id) external view returns (Escrow memory) {
        return escrowContract.getEscrowById(id);
    }
}"
3204,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenBurner {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function burnTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), _amount);
        uint256 balanceAfter = token.balanceOf(address(this));
        require(balanceBefore.add(balanceAfter) == 0, ""Burn failed"");
    }
}",1.95899510383606,burnTokens,"[{'function': 'burnTokens', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceBefore"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceAfter"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceBefore""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balanceAfter""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Burn failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.6808565072774193,0.0378155496190516,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenBurner is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function burnTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), _amount);
        uint256 balanceAfter = token.balanceOf(address(this));
        require(balanceBefore.add(balanceAfter) == 0, ""Burn failed"");
    }
}"
1281,Function for attester to submit attestation from their own account ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AttestationContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ATTSTER_ROLE = keccak256(""ATTSTER_ROLE"");
    mapping(address => bool) public attesters;
    mapping(address => uint256) public attestationsCount;

    event AttestationSubmitted(address indexed attester, address indexed user);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ATTSTER_ROLE, msg.sender);
    }

    function submitAttestation(address user) public onlyRole(ATTSTER_ROLE) {
        require(user != address(0), ""Invalid user address"");
        attestationsCount[msg.sender] = attestationsCount[msg.sender].add(1);
        emit AttestationSubmitted(msg.sender, user);
    }
}",2.265698432922364,submitAttestation,"[{'function': 'submitAttestation', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAttestation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid user address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attestationsCount""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attestationsCount""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AttestationSubmitted""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ATTSTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.6743705301614595,0.0435455896261571,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AttestationContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ATTSTER_ROLE = keccak256(""ATTSTER_ROLE"");
    mapping(address => bool) public attesters;
    mapping(address => uint256) public attestationsCount;

    event AttestationSubmitted(address indexed attester, address indexed user);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ATTSTER_ROLE, msg.sender);
    }

    function submitAttestation(address user) public onlyRole(ATTSTER_ROLE) {
        require(user != address(0), ""Invalid user address"");
        attestationsCount[msg.sender] = attestationsCount[msg.sender].add(1);
        emit AttestationSubmitted(msg.sender, user);
    }
}"
4148,"Escrows the ERC721 Token , assigning ownership to this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Escrow {
    IERC721 public token;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress) {
        token = IERC721(_tokenAddress);
        owner = msg.sender;
    }

    function escrowToken(uint256 tokenId, address recipient) external onlyOwner {
        require(token.ownerOf(tokenId) == address(this), ""Token is already owned by another contract"");
        token.transferFrom(address(this), recipient, tokenId);
    }
}",1.928084135055542,escrowToken,"[{'function': 'escrowToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""escrowToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token is already owned by another contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8026539152134254,0.1458846658888317,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable, ReentrancyGuard {
    IERC721 public token;
    address public owner = msg.sender;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC721(_tokenAddress);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function escrowToken(uint256 tokenId, address recipient) external onlyOwner nonReentrant {
        require(token.ownerOf(tokenId) == address(this), ""Token is already owned by another contract"");
        token.transferFrom(address(this), recipient, tokenId);
    }
}"
6515,"Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/cryptography/Keccak256.sol"";

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}

contract GroveIndex {
    using SafeMath for uint256;
    using Keccak256 for bytes32;

    function computeNodeId(uint256 indexId, uint256 id) public pure returns (uint256) {
        return keccak256(abi.encodePacked(indexId, id)).toUint256();
    }
}",1.8138878345489504,add,"[{'function': 'add', 'complexity': 1}, {'function': 'computeNodeId', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",11.0,0.3668434510978866,0.0441087769732876,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/cryptography/Keccak256.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract GroveIndex is Ownable {
    using SafeMath for uint256;
    using Keccak256 for bytes32;

    function computeNodeId(uint256 indexId, uint256 id) public pure returns (uint256) {
        return keccak256(abi.encodePacked(indexId, id)).toUint256();
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        indexId = 1;
        nodeId = keccak256(abi.encodePacked(1, 1)).toUint256();
    }

    uint256 private indexId;
    uint256 private nodeId;
}"
211,Uses the same signature as initializeTokenSale ( ) with :,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;
    uint256 public cap;
    uint256 public raisedAmount;
    mapping(address => uint256) public balances;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    constructor(uint256 _rate, IERC20 _token, uint256 _cap) {
        require(_rate > 0, ""Rate must be greater than zero"");
        require(_cap > 0, ""Cap must be greater than zero"");
        rate = _rate;
        token = _token;
        cap = _cap;
    }

    function buyTokens(address beneficiary) public payable {
        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(rate);
        require(tokens > 0, ""Token amount must be greater than zero"");
        require(raisedAmount.add(tokens) <= cap, ""Cap exceeded"");

        balances[beneficiary] = balances[beneficiary].add(tokens);
        raisedAmount = raisedAmount.add(tokens);

        token.transfer(beneficiary, tokens);
        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    }
}",3.5005900859832764,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""raisedAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}, {""type"": ""stringLiteral"", ""value"": ""Cap exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""raisedAmount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""raisedAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenPurchase""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",52.0,0.6104131093124939,0.0187060332641712,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;
    uint256 public cap;
    uint256 public raisedAmount;
    mapping(address => uint256) public balances;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    constructor(uint256 _rate, IERC20 _token, uint256 _cap) Ownable(msg.sender) {
        require(_rate > 0, ""Rate must be greater than zero"");
        require(_cap > 0, ""Cap must be greater than zero"");
        rate = _rate;
        token = _token;
        cap = _cap;
    }

    function buyTokens(address beneficiary) public payable {
        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(rate);
        require(tokens > 0, ""Token amount must be greater than zero"");
        require(raisedAmount.add(tokens) <= cap, ""Cap exceeded"");

        balances[beneficiary] = balances[beneficiary].add(tokens);
        raisedAmount = raisedAmount.add(tokens);

        token.transfer(beneficiary, tokens);
        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    }
}"
5005,If this function is called again it overwrites the current allowance with _value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
}

contract MyContract {
    using SafeMath for uint256;

    IERC20 public token;
    address public owner;

    constructor(address _token) {
        token = IERC20(_token);
        owner = msg.sender;
    }

    function setAllowance(uint256 _value, address spender) external returns (bool) {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        return token.approve(spender, _value);
    }
}",2.378992080688477,safeMul,"[{'function': 'approve', 'complexity': 0}, {'function': 'safeMul', 'complexity': 3}, {'function': 'setAllowance', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeMul"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: multiplication overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",26.0,0.3675241638431498,0.0203278039290766,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeMath {
    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public owner;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
        owner = msg.sender;
    }

    function setAllowance(uint256 _value, address spender) external returns (bool) {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        return token.approve(spender, _value);
    }
}"
2436,Function for transfering tokens from one account to another .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function transferTokens(address recipient, uint256 amount) external onlyOwner returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient contract balance"");

        bool success = token.transfer(recipient, amount);
        require(success, ""Token transfer failed"");

        return true;
    }
}",2.100196361541748,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient contract balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.3658939408235183,0.0766254222678318,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function transferTokens(address recipient, uint256 amount) external onlyOwner returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient contract balance"");

        bool success = token.transfer(recipient, amount);
        require(success, ""Token transfer failed"");

        return true;
    }
}"
2602,` onlyOwner ` An efficient way to confirm multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MultiPaymentConfirmation is Ownable {
    using SafeMath for uint256;

    event PaymentConfirmed(address indexed payee, uint256 amount);

    mapping(address => bool) public confirmedPayments;
    uint256 public totalAmount;

    function confirmPayment(uint256 _amount) external onlyOwner {
        require(!confirmedPayments[msg.sender], ""Payment already confirmed"");
        confirmedPayments[msg.sender] = true;
        totalAmount += _amount;
        emit PaymentConfirmed(msg.sender, _amount);
    }
}",1.5151102542877195,confirmPayment,"[{'function': 'confirmPayment', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""confirmPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""confirmedPayments""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment already confirmed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""confirmedPayments""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentConfirmed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7133040330234363,0.0437561304581279,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiPaymentConfirmation is Ownable {
    using SafeMath for uint256;

    event PaymentConfirmed(address indexed payee, uint256 amount);

    mapping(address => bool) public confirmedPayments;
    uint256 public totalAmount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalAmount = 1; // Set to 1 instead of 0
    }

    function confirmPayment(uint256 _amount) external onlyOwner {
        require(!confirmedPayments[msg.sender], ""Payment already confirmed"");
        confirmedPayments[msg.sender] = true;
        totalAmount += _amount;
        emit PaymentConfirmed(msg.sender, _amount);
    }
}"
1905,Function used by the client to block the transfer of shares from and to a share holder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ShareHolderBlocker is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BLOCKER_ROLE = keccak256(""BLOCKER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BLOCKER_ROLE, msg.sender);
    }

    function blockTransfer(address from, address to) external onlyRole(BLOCKER_ROLE) returns (bool) {
        require(!isBlocked(from), ""Sender is blocked"");
        require(!isBlocked(to), ""Recipient is blocked"");
        return true;
    }

    function isBlocked(address account) public view returns (bool) {
        return hasRole(BLOCKER_ROLE, account);
    }
}",2.110869646072388,blockTransfer,"[{'function': 'blockTransfer', 'complexity': 4}, {'function': 'isBlocked', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""blockTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isBlocked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sender is blocked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isBlocked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Recipient is blocked""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""BLOCKER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6503645478194398,0.0654802388233743,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ShareHolderBlocker is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant BLOCKER_ROLE = keccak256(""BLOCKER_ROLE"");

    constructor(address admin) Ownable(admin) { // Correctly initialize Ownable with the provided address
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BLOCKER_ROLE, msg.sender);
    }

    function blockTransfer(address from, address to) external onlyRole(BLOCKER_ROLE) returns (bool) {
        require(!isBlocked(from), ""Sender is blocked"");
        require(!isBlocked(to), ""Recipient is blocked"");
        return true;
    }

    function isBlocked(address account) public view returns (bool) {
        return hasRole(BLOCKER_ROLE, account);
    }
}"
6047,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    function sendTokens(address tokenAddress, address to, uint256 value) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= value, ""Insufficient balance"");
        return token.transfer(to, value);
    }
}",1.3036067485809326,sendTokens,"[{'function': 'sendTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.6600140557741409,0.1573147408334447,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    // Fixed, safe values for uint and address
    uint256 public constant DEFAULT_VALUE = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address

    // Safe initialization of bool and string variables
    bool public initialized = true;
    string public constant INITIALIZED_STRING = 'initialized';

    // Bytes32 initialization using a fixed value
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(DEFAULT_ADDRESS) {
        // Initialize instance variables with safe values
        initialized = true;
        DEFAULT_VALUE = 1; // Assign default value to uint variable
        DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Assign fixed address to address variable
        INIT_BYTES32 = bytes32('init'); // Assign fixed bytes32 value
    }

    function sendTokens(address tokenAddress, address to, uint256 value) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= value, ""Insufficient balance"");
        return token.transfer(to, value);
    }
}"
189,To be called by the account that holds Mio tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract is Ownable {
    IERC20 public mioToken;

    constructor(address _mioToken) {
        require(_mioToken != address(0), ""Invalid token address"");
        mioToken = IERC20(_mioToken);
    }

    function transferTokens(uint256 amount) external onlyOwner {
        require(mioToken.balanceOf(address(this)) >= amount, ""Insufficient balance"");
        require(mioToken.transfer(msg.sender, amount), ""Transfer failed"");
    }
}",1.6602182388305664,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mioToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mioToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.6599754671800058,0.2470209158987234,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public mioToken;

    mapping(address => uint256) public balanceOf;

 constructor(address _mioToken) Ownable(msg.sender) {
        require(_mioToken != address(0), ""Invalid token address"");
        mioToken = IERC20(_mioToken);
    }

    function transferTokens(uint256 amount) external onlyOwner {
        require(mioToken.balanceOf(address(this)) >= amount, ""Insufficient balance"");
        require(mioToken.transfer(msg.sender, amount), ""Transfer failed"");
    }
}"
3776,Ability to transfer where the sender pays the fees ( not ERC20 ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeeTransfer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant FEE_ROLE = keccak256(""FEE_ROLE"");
    uint256 public feeAmount;
    address payable public feeReceiver;

    constructor(uint256 _feeAmount, address payable _feeReceiver) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(FEE_ROLE, DEFAULT_ADMIN_ROLE);
        setFee(_feeAmount, _feeReceiver);
    }

    function setFee(uint256 _feeAmount, address payable _feeReceiver) public onlyRole(DEFAULT_ADMIN_ROLE) {
        feeAmount = _feeAmount;
        feeReceiver = _feeReceiver;
    }

    function transferWithFee(address payable recipient, uint256 amount) public payable {
        require(msg.value >= feeAmount, ""Insufficient fee sent"");
        uint256 remainingAmount = msg.value.sub(feeAmount);
        if (remainingAmount > 0) {
            (bool success, ) = msg.sender.call{value: remainingAmount}("""");
            require(success, ""Transfer failed"");
        }
        recipient.transfer(amount);
    }
}",3.0550668239593506,transferWithFee,"[{'function': 'setFee', 'complexity': 0}, {'function': 'transferWithFee', 'complexity': 3}]",4.0,{},73.0,0.7181179181028133,0.021091181482555,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FeeTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant FEE_ROLE = keccak256(""FEE_ROLE"");
    uint256 public feeAmount;
    address payable public feeReceiver;

    constructor(uint256 _feeAmount, address payable _feeReceiver) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(FEE_ROLE, DEFAULT_ADMIN_ROLE);
        feeAmount = _feeAmount;
        feeReceiver = _feeReceiver;
    }

    function setFee(uint256 _feeAmount, address payable _feeReceiver) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_msgSender() == owner(), ""Caller is not the owner"");
        feeAmount = _feeAmount;
        feeReceiver = _feeReceiver;
    }

    function transferWithFee(address payable recipient, uint256 amount) public payable {
        require(msg.value >= feeAmount, ""Insufficient fee sent"");
        uint256 remainingAmount = msg.value.sub(feeAmount);
        if (remainingAmount > 0) {
            (bool success, ) = recipient.call{value: remainingAmount}("""");
            require(success, ""Transfer failed"");
        }
        recipient.transfer(amount);
    }
}"
4464,"Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}","pragma solidity ^0.8.0;

contract CosignerCost {
    uint256 public constant COST_OF_COSIGNER = 0 ether; // The cost of the cosigner is set to 0 ether as it has no risk or maintenance cost.

    function getCosignerCost() external pure returns (uint256) {
        return COST_OF_COSIGNER;
    }
}",0.9474897384643556,getCosignerCost,"[{'function': 'getCosignerCost', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCosignerCost"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""COST_OF_COSIGNER""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",17.0,0.6196414765458359,0.0211177095678931,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CosignerCost is Ownable {
    uint256 public constant COST_OF_COSIGNER = 1 ether; // The cost of the cosigner is set to 1 ether as it has no risk or maintenance cost.

    constructor() Ownable(msg.sender) {
        // No need to initialize other state variables as they are already initialized with safe, non-corner-case values.
    }

    function getCosignerCost() external pure returns (uint256) {
        return COST_OF_COSIGNER;
    }
}"
1265,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CapChecker is AccessControl {
    using SafeMath for uint256;

    uint256 public cap;

    constructor(uint256 _cap) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        cap = _cap;
    }

    function checkCap(uint256 amount) external view returns (bool) {
        require(amount <= cap, ""Amount exceeds the cap"");
        return true;
    }
}",1.4712111949920654,checkCap,"[{'function': 'checkCap', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkCap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}, {""type"": ""stringLiteral"", ""value"": ""Amount exceeds the cap""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.6416011060593998,0.1858419818538615,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CapChecker is AccessControl, Ownable {
    using SafeMath for uint256;

    uint256 public cap;

    constructor(uint256 _cap) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        cap = _cap;
    }

    function checkCap(uint256 amount) external view returns (bool) {
        require(amount <= cap, ""Amount exceeds the cap"");
        return true;
    }
}"
4986,Returns the number of decimals the token uses .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function decimals() external view returns (uint8);
}

contract TokenDecimalsGetter {
    using SafeMath for uint256;

    function getTokenDecimals(address tokenAddress) public view returns (uint8) {
        IERC20 token = IERC20(tokenAddress);
        return token.decimals();
    }
}",1.1423277854919434,getTokenDecimals,"[{'function': 'decimals', 'complexity': 0}, {'function': 'getTokenDecimals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenDecimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.684798869287632,0.2211785682362168,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function decimals() external view returns (uint8);
}

contract TokenDecimalsGetter is Ownable(msg.sender) {
    using SafeMath for uint256;

    constructor() {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getTokenDecimals(address tokenAddress) public view returns (uint8) {
        IERC20 token = IERC20(tokenAddress);
        return token.decimals();
    }
}"
6318,Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenNetwork is AccessControl, ReentrancyGuard {
    bytes32 public constant TOKEN_ROLE = keccak256(""TOKEN_ROLE"");
    IERC20 private immutable _token;

    constructor(address _token_address) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(TOKEN_ROLE, DEFAULT_ADMIN_ROLE);
        _token = IERC20(_token_address);
        grantRole(TOKEN_ROLE, msg.sender);
    }

    function transferTokens(address recipient, uint256 amount) external nonReentrant {
        require(hasRole(TOKEN_ROLE, msg.sender), ""Caller is not authorized"");
        _token.transferFrom(msg.sender, recipient, amount);
    }
}",2.382219791412353,transferTokens,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""TOKEN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.4541130332380672,0.0203012161501331,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenNetwork is AccessControl, ReentrancyGuard {
    bytes32 public constant TOKEN_ROLE = keccak256(""TOKEN_ROLE"");
    IERC20 private immutable _token;

    constructor(address _token_address) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(TOKEN_ROLE, DEFAULT_ADMIN_ROLE);
        _token = IERC20(_token_address);
        grantRole(TOKEN_ROLE, msg.sender);
    }

    function transferTokens(address recipient, uint256 amount) external nonReentrant {
        require(hasRole(TOKEN_ROLE, msg.sender), ""Caller is not authorized"");
        _token.transferFrom(msg.sender, recipient, amount);
    }
}"
2003,Refund a given address for all the Ether they have contributed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}","pragma solidity ^0.8.0;

interface Contributor {
    function contribute() external payable;
}

contract RefundContract {
    mapping(address => uint256) public contributions;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function refund(address payable contributor) public onlyOwner {
        uint256 amount = contributions[contributor];
        require(amount > 0, ""No contribution found for this address"");
        (bool success, ) = contributor.call{value: amount}("""");
        require(success, ""Refund transfer failed"");
        delete contributions[contributor];
    }

    function contributeToContract() external payable {
        contributions[msg.sender] += msg.value;
    }

    receive() external payable {}
}",2.0444412231445312,refund,"[{'function': 'contribute', 'complexity': 0}, {'function': 'refund', 'complexity': 2}, {'function': 'contributeToContract', 'complexity': 0}]",4.0,{},14.0,0.6918126841996423,0.0147743109801411,"pragma solidity ^0.8.0;

interface Contributor {
    function contribute() external payable;
}
import ""openzeppelin/SafeMath.sol"";
contract RefundContract is Ownable {
    mapping(address => uint256) public contributions;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is handled in the base class constructor
    }

    function refund(address payable contributor) public onlyOwner {
        uint256 amount = contributions[contributor];
        require(amount > 0, ""No contribution found for this address"");
        (bool success, ) = contributor.call{value: amount}("""");
        require(success, ""Refund transfer failed"");
        delete contributions[contributor];
    }

    function contributeToContract() external payable {
        contributions[msg.sender] += msg.value;
    }

    receive() external payable {}
}"
1814,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DelayedPayment is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SECURITY_GUARD = keccak256(""SECURITY_GUARD"");
    uint256 public delaySeconds;

    constructor(uint256 _delaySeconds) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SECURITY_GUARD, msg.sender);
        delaySeconds = _delaySeconds;
    }

    function setDelaySeconds(uint256 _newDelay) public onlyRole(SECURITY_GUARD) {
        delaySeconds = _newDelay;
    }

    function payWithDelay(address payable recipient, uint256 amount) public onlyRole(SECURITY_GUARD) {
        require(delaySeconds > 0, ""Delay must be greater than zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Transfer the funds after the delay
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed"");

        // Delay the payment by the specified number of seconds
        uint256 releaseTime = block.timestamp.add(delaySeconds);
        emit PaymentScheduled(recipient, amount, releaseTime);
    }

    event PaymentScheduled(address indexed recipient, uint256 amount, uint256 releaseTime);
}",3.319082260131836,payWithDelay,"[{'function': 'setDelaySeconds', 'complexity': 0}, {'function': 'payWithDelay', 'complexity': 3}]",4.0,{},58.0,0.7140253117606825,0.0212257955730307,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract DelayedPayment is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SECURITY_GUARD = keccak256(""SECURITY_GUARD"");
    uint256 public delaySeconds;

    constructor(uint256 _delaySeconds) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SECURITY_GUARD, msg.sender);
        transferOwnership(msg.sender); // Initialize Ownable
        delaySeconds = _delaySeconds;
    }

    function setDelaySeconds(uint256 _newDelay) public onlyRole(SECURITY_GUARD) {
        require(_newDelay > 0, ""Delay must be greater than zero"");
        delaySeconds = _newDelay;
    }

    function payWithDelay(address payable recipient, uint256 amount) public onlyRole(SECURITY_GUARD) {
        require(delaySeconds > 0, ""Delay must be greater than zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Transfer the funds after the delay
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed"");

        // Delay the payment by the specified number of seconds
        uint256 releaseTime = block.timestamp.add(delaySeconds);
        emit PaymentScheduled(recipient, amount, releaseTime);
    }

    event PaymentScheduled(address indexed recipient, uint256 amount, uint256 releaseTime);
}"
4481,This is a private function which should be called from user-implemented external burn function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");
    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, msg.sender);
    }

    function burn(uint256 amount) external onlyRole(BURNER_ROLE) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _totalSupply = _totalSupply.sub(amount);
    }
}",2.140880823135376,burn,"[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""BURNER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.5927535855037839,0.0438124032231925,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");
    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, msg.sender);
        _totalSupply = 1000000000000000000; // Set to a non-zero value
    }

    function burn(uint256 amount) external onlyRole(BURNER_ROLE) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _totalSupply = _totalSupply.sub(amount);
    }
}"
3728,"Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Allowance is AccessControl {
    using SafeMath for uint256;

    IERC20 private token;
    address public owner;

    struct AllowedSpender {
        bool allowed;
        uint256 allowance;
    }

    mapping(address => AllowedSpender) public allowances;

    event AllowanceSet(address indexed spender, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(address _tokenAddress, address _owner) {
        token = IERC20(_tokenAddress);
        owner = _owner;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setAllowance(address _spender, uint256 _value) public onlyOwner {
        require(_value > 0, ""Value must be greater than zero"");
        allowances[_spender] = AllowedSpender({allowed: true, allowance: _value});
        emit AllowanceSet(_spender, _value);
    }

    function withdraw(uint256 amount) public {
        require(allowances[msg.sender].allowed, ""Spender not allowed"");
        require(allowances[msg.sender].allowance >= amount, ""Allowance exceeded"");
        token.transferFrom(msg.sender, owner, amount);
        allowances[msg.sender].allowance = allowances[msg.sender].allowance.sub(amount);
    }
}",3.774097681045532,withdraw,"[{'function': 'setAllowance', 'complexity': 1}, {'function': 'withdraw', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""allowed""}, {""type"": ""stringLiteral"", ""value"": ""Spender not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""allowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""allowance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""allowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.4865020411459965,0.1181434869018521,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract Allowance is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 private token;
    address public owner;

    struct AllowedSpender {
        bool allowed;
        uint256 allowance;
    }

    mapping(address => AllowedSpender) public allowances;

    event AllowanceSet(address indexed spender, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(address _tokenAddress, address _owner) Ownable(_owner) { // Initialize Ownable with _owner
        token = IERC20(_tokenAddress);
        owner = _owner;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setAllowance(address _spender, uint256 _value) public onlyOwner {
        require(_value > 0, ""Value must be greater than zero"");
        allowances[_spender] = AllowedSpender({allowed: true, allowance: _value});
        emit AllowanceSet(_spender, _value);
    }

    function withdraw(uint256 amount) public {
        require(allowances[msg.sender].allowed, ""Spender not allowed"");
        require(allowances[msg.sender].allowance >= amount, ""Allowance exceeded"");
        token.transferFrom(msg.sender, owner, amount);
        allowances[msg.sender].allowance = allowances[msg.sender].allowance.sub(amount);
    }
}"
213,Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}","pragma solidity ^0.8.0;

interface ICampaign {
    function getPricePerProofOfAttention(uint256 campaignId) external view returns (uint256);
}

contract CampaignPriceGetter {
    address public immutable owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function getCampaignPrice(address campaignAddress, uint256 campaignId) external view returns (uint256) {
        ICampaign campaign = ICampaign(campaignAddress);
        return campaign.getPricePerProofOfAttention(campaignId);
    }
}",1.6024417877197266,getCampaignPrice,"[{'function': 'getPricePerProofOfAttention', 'complexity': 0}, {'function': 'getCampaignPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCampaignPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""campaignAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ICampaign""}, ""name"": ""campaign"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ICampaign""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""campaignAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""getPricePerProofOfAttention""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""campaignId""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",10.0,0.759327666932205,0.0446447678735127,"pragma solidity ^0.8.0;

interface ICampaign {
    function getPricePerProofOfAttention(uint256 campaignId) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract CampaignPriceGetter is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCampaignPrice(address campaignAddress, uint256 campaignId) external view onlyOwner returns (uint256) {
        ICampaign campaign = ICampaign(campaignAddress);
        return campaign.getPricePerProofOfAttention(campaignId);
    }
}"
2236,Deposit fees into the vault for a Darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Vault is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant DEPOSIT_ROLE = keccak256(""DEPOSIT_ROLE"");
    mapping(address => uint256) private balances;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(DEPOSIT_ROLE, msg.sender);
    }

    function depositFeesForDarknode(uint256 amount, address darknode) public onlyRole(DEPOSIT_ROLE) {
        balances[darknode] = balances[darknode].add(amount);
    }
}",1.829620361328125,depositFeesForDarknode,"[{'function': 'depositFeesForDarknode', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositFeesForDarknode"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknode""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknode""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEPOSIT_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.7525988456029973,0.0035177678932607,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract Vault is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant DEPOSIT_ROLE = keccak256(""DEPOSIT_ROLE"");
    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(DEPOSIT_ROLE, msg.sender);
    }

    function depositFeesForDarknode(uint256 amount, address darknode) public onlyRole(DEPOSIT_ROLE) {
        balances[darknode] = balances[darknode].add(amount);
    }
}"
3103,Checks whether redemption is permitted for a participant,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RedemptionPermitter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant REDEEMER_ROLE = keccak256(""REDEEMER_ROLE"");
    mapping(address => bool) public allowedParticipants;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(REDEEMER_ROLE, msg.sender);
    }

    function setRedemptionPermission(address participant, bool permitted) external onlyRole(REDEEMER_ROLE) {
        allowedParticipants[participant] = permitted;
    }

    function isRedemptionPermitted(address participant) public view returns (bool) {
        return allowedParticipants[participant];
    }
}",2.020271062850952,setRedemptionPermission,"[{'function': 'setRedemptionPermission', 'complexity': 0}, {'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRedemptionPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""participant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""permitted"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowedParticipants""}, ""index"": {""type"": ""Identifier"", ""name"": ""participant""}}, ""right"": {""type"": ""Identifier"", ""name"": ""permitted""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""REDEEMER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6635732065957894,0.0326991100910481,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract RedemptionPermitter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant REDEEMER_ROLE = keccak256(""REDEEMER_ROLE"");
    mapping(address => bool) public allowedParticipants;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(REDEEMER_ROLE, msg.sender);
    }

    function setRedemptionPermission(address participant, bool permitted) external onlyRole(REDEEMER_ROLE) {
        allowedParticipants[participant] = permitted;
    }

    function isRedemptionPermitted(address participant) public view returns (bool) {
        return allowedParticipants[participant];
    }
}"
5733,Function which decodes bytes32 to array of integers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}","pragma solidity ^0.8.0;

contract DecodeBytes32ToArray {
    function decodeBytes32ToIntegerArray(bytes32 input) public pure returns (uint256[] memory result) {
        require(input != bytes32(0), ""Input must not be zero"");

        uint256 length = 4; // Assuming the array contains 4 integers for this example. Adjust as needed.
        result = new uint256[](length);

        for (uint256 i = 0; i < length; i++) {
            bytes memory byteArray = new bytes(32);
            for (uint256 j = 0; j < 32; j++) {
                byteArray[j] = input[i * 32 + j];
            }
            result[i] = uint256(bytes32(byteArray));
        }

        return result;
    }
}",1.9979331493377688,decodeBytes32ToIntegerArray,"[{'function': 'decodeBytes32ToIntegerArray', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeBytes32ToIntegerArray"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""input"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""result"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""input""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Input must not be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""length""}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""byteArray"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""byteArray""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""input""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""j""}}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""result""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""byteArray""}], ""names"": []}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""result""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",88.0,0.5363926242043227,0.1450653021618348,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DecodeBytes32ToArray is Ownable {
    function decodeBytes32ToIntegerArray(bytes32 input) public pure returns (uint256[] memory result) {
        require(input != bytes32(0), ""Input must not be zero"");

        uint256 length = 4; // Assuming the array contains 4 integers for this example. Adjust as needed.
        result = new uint256[](length);

        for (uint256 i = 0; i < length; i++) {
            bytes memory byteArray = new bytes(32);
            for (uint256 j = 0; j < 32; j++) {
                byteArray[j] = input[i * 32 + j];
            }
            result[i] = uint256(bytes32(byteArray));
        }

        return result;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
5459,Begins the token sale for this token instance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate; // tokens per ether
    uint256 public weiRaised;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor(IERC20 _token, uint256 _rate) {
        token = _token;
        rate = _rate;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function startSale() external onlyRole(ADMIN_ROLE) {
        require(!saleStarted(), ""Sale is already started"");
        // Additional logic can be added here
    }

    function buyTokens(uint256 weiAmount) public payable {
        uint256 tokens = calculateTokenPurchase(weiAmount);
        require(tokens > 0, ""Invalid token purchase amount"");

        weiRaised += weiAmount;
        token.transfer(msg.sender, tokens);
    }

    function calculateTokenPurchase(uint256 weiAmount) public view returns (uint256) {
        return weiAmount.mul(rate);
    }

    function saleStarted() internal view returns (bool) {
        // Additional logic can be added here
        return true; // Placeholder for actual implementation
    }
}",3.677133560180664,buyTokens,"[{'function': 'startSale', 'complexity': 2}, {'function': 'buyTokens', 'complexity': 1}, {'function': 'calculateTokenPurchase', 'complexity': 0}, {'function': 'saleStarted', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateTokenPurchase""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token purchase amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""right"": {""type"": ""Identifier"", ""name"": ""weiAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",26.0,0.522875167891821,0.0350228113814783,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenSale is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate; // tokens per ether
    uint256 public weiRaised;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor(IERC20 _token, uint256 _rate) Ownable(msg.sender) { // Initialize Ownable with msg.sender
        token = _token;
        rate = _rate;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function startSale() external onlyRole(ADMIN_ROLE) {
        require(!saleStarted(), ""Sale is already started"");
        // Additional logic can be added here
    }

    function buyTokens(uint256 weiAmount) public payable {
        uint256 tokens = calculateTokenPurchase(weiAmount);
        require(tokens > 0, ""Invalid token purchase amount"");

        weiRaised += weiAmount;
        token.transfer(msg.sender, tokens);
    }

    function calculateTokenPurchase(uint256 weiAmount) public view returns (uint256) {
        return weiAmount.mul(rate);
    }

    function saleStarted() internal view returns (bool) {
        // Additional logic can be added here
        return true; // Placeholder for actual implementation
    }
}"
6434,Set current preICO price in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PreICO is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public preICOPriceInWei;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setPreICOPrice(uint256 price) external onlyRole(ADMIN_ROLE) {
        preICOPriceInWei = price;
    }
}",1.6945066452026367,setPreICOPrice,"[{'function': 'setPreICOPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreICOPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOPriceInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""price""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8270606096960984,0.0250658800768906,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract PreICO is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public preICOPriceInWei;

    constructor(address admin) Ownable(admin) { // Correctly initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setPreICOPrice(uint256 price) external onlyRole(ADMIN_ROLE) {
        preICOPriceInWei = price;
    }
}"
30,Called in order to get the number of members on the platform,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PlatformMembers is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MEMBER_ROLE = keccak256(""MEMBER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MEMBER_ROLE, msg.sender);
    }

    function getNumberOfMembers() public view returns (uint256) {
        // Additional logic can be added here
        return totalSupply();
    }

    function totalSupply() internal view virtual returns (uint256) {
        // This should be implemented to count the number of members
        // For demonstration, let's assume it counts all accounts with the MEMBER_ROLE
        uint256 count = 0;
        for (uint256 i = 0; i < totalSupply(); i++) {
            if (hasRole(MEMBER_ROLE, address(i))) {
                count++;
            }
        }
        return count;
    }
}",2.52832293510437,totalSupply,"[{'function': 'getNumberOfMembers', 'complexity': 0}, {'function': 'totalSupply', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MEMBER_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""count""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""count""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",24.0,0.5204063105158675,0.0587952347524061,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PlatformMembers is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MEMBER_ROLE = keccak256(""MEMBER_ROLE"");

    uint256 public totalSupply;

 constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MEMBER_ROLE, msg.sender);
    }

    function getNumberOfMembers() public view returns (uint256) {
        // Additional logic can be added here
        return totalSupply();
    }

    function totalSupply() internal view virtual returns (uint256) {
        // This should be implemented to count the number of members
        // For demonstration, let's assume it counts all accounts with the MEMBER_ROLE
        uint256 count = 0;
        for (uint256 i = 0; i < totalSupply(); i++) {
            if (hasRole(MEMBER_ROLE, address(i))) {
                count++;
            }
        }
        return count;
    }
}"
3380,Count the number of validators defined by the jurisdiction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ValidatorCounter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    uint256 private _validatorCount;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addValidator() external onlyRole(VALIDATOR_ROLE) {
        _validatorCount++;
    }

    function countValidators() public view returns (uint256) {
        return _validatorCount;
    }
}",1.6889562606811523,addValidator,"[{'function': 'addValidator', 'complexity': 0}, {'function': 'countValidators', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addValidator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_validatorCount""}, ""isPrefix"": False}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.62354646385426,0.100917454289981,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ValidatorCounter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    uint256 private _validatorCount;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _validatorCount = 1; // Initialize to a non-zero value
    }

    function addValidator() external onlyRole(VALIDATOR_ROLE) {
        _validatorCount++;
    }

    function countValidators() public view returns (uint256) {
        return _validatorCount;
    }
}"
5188,allows to retreive multiple exchange rates in once call,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}","pragma solidity ^0.8.0;

interface IExchangeRateProvider {
    function getExchangeRates(address[] memory tokens) external view returns (uint256[] memory);
}

contract MultiExchangeRateRetriever {
    address public exchangeRateProviderAddress;

    constructor(address _exchangeRateProviderAddress) {
        require(_exchangeRateProviderAddress != address(0), ""Invalid provider address"");
        exchangeRateProviderAddress = _exchangeRateProviderAddress;
    }

    function getExchangeRates(address[] memory tokens) public view returns (uint256[] memory) {
        IExchangeRateProvider provider = IExchangeRateProvider(exchangeRateProviderAddress);
        return provider.getExchangeRates(tokens);
    }
}",1.5318255424499512,getExchangeRates,"[{'function': 'getExchangeRates', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""tokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IExchangeRateProvider""}, ""name"": ""provider"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IExchangeRateProvider""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""exchangeRateProviderAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""provider""}, ""memberName"": ""getExchangeRates""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",117.0,0.7745844015274913,0.0122691318717811,"pragma solidity ^0.8.0;

interface IExchangeRateProvider {
    function getExchangeRates(address[] memory tokens) external view returns (uint256[] memory);
}
import ""openzeppelin/SafeMath.sol"";
contract MultiExchangeRateRetriever is Ownable {
    address public exchangeRateProviderAddress;

    constructor(address _exchangeRateProviderAddress) Ownable(msg.sender) {
        require(_exchangeRateProviderAddress != address(0), ""Invalid provider address"");
        exchangeRateProviderAddress = _exchangeRateProviderAddress;
    }

    function getExchangeRates(address[] memory tokens) public view returns (uint256[] memory) {
        IExchangeRateProvider provider = IExchangeRateProvider(exchangeRateProviderAddress);
        return provider.getExchangeRates(tokens);
    }
}"
316,send ` _value ` token to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSender is Ownable {
    using SafeMath for uint256;

    function sendToken(address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        IERC20 token = IERC20(owner());
        require(token.balanceOf(address(this)) >= _value, ""Insufficient balance"");
        bool transferSuccess = token.transfer(_to, _value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}",1.8611056804656985,sendToken,"[{'function': 'sendToken', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.6987025913124962,0.3340733496289986,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSender is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendToken(address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        IERC20 token = IERC20(owner());
        require(token.balanceOf(address(this)) >= _value, ""Insufficient balance"");
        bool transferSuccess = token.transfer(_to, _value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}"
4609,"Add beneficiaries to the contract , allowing them to withdraw tokens .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BeneficiaryToken is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public beneficiaries;
    mapping(address => bool) public isBeneficiary;

    constructor(address _token, address[] memory _beneficiaries) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        for (uint i = 0; i < _beneficiaries.length; i++) {
            beneficiaries.push(_beneficiaries[i]);
            isBeneficiary[_beneficiaries[i]] = true;
        }
    }

    function addBeneficiary(address beneficiary) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!isBeneficiary[beneficiary], ""Beneficiary already added"");
        beneficiaries.push(beneficiary);
        isBeneficiary[beneficiary] = true;
    }

    function withdrawTokens() public {
        require(isBeneficiary[msg.sender], ""You are not a beneficiary"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to withdraw"");
        token.transfer(msg.sender, token.balanceOf(msg.sender));
    }
}",3.252650260925293,withdrawTokens,"[{'function': 'addBeneficiary', 'complexity': 2}, {'function': 'withdrawTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBeneficiary""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You are not a beneficiary""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available to withdraw""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.4929620705182792,0.0495002196712612,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BeneficiaryToken is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public beneficiaries;
    mapping(address => bool) public isBeneficiary;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address[] memory _beneficiaries) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        for (uint i = 0; i < _beneficiaries.length; i++) {
            beneficiaries.push(_beneficiaries[i]);
            isBeneficiary[_beneficiaries[i]] = true;
        }
    }

    function addBeneficiary(address beneficiary) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!isBeneficiary[beneficiary], ""Beneficiary already added"");
        beneficiaries.push(beneficiary);
        isBeneficiary[beneficiary] = true;
    }

    function withdrawTokens() public {
        require(isBeneficiary[msg.sender], ""You are not a beneficiary"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to withdraw"");
        token.transfer(msg.sender, token.balanceOf(msg.sender));
    }
}"
5346,You must send some ETH to cover the oraclize_query fees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}","pragma solidity ^0.8.0;

interface IOraclize {
    function query(uint256 _amount, bytes memory _callbackFunction) external payable returns (bytes32);
}

contract OraclizeFeeCover {
    address public oraclizeAddress;
    uint256 public minAmountForQuery;

    constructor(address _oraclizeAddress, uint256 _minAmountForQuery) {
        require(_oraclizeAddress != address(0), ""Invalid Oraclize address"");
        oraclizeAddress = _oraclizeAddress;
        minAmountForQuery = _minAmountForQuery;
    }

    function coverOraclizeFee() public payable {
        require(msg.value >= minAmountForQuery, ""Insufficient funds to cover Oraclize query fees"");
        IOraclize(oraclizeAddress).query{value: msg.value}(0, bytes(""""));
    }
}",1.95383095741272,coverOraclizeFee,"[{'function': 'query', 'complexity': 0}, {'function': 'coverOraclizeFee', 'complexity': 1}]",2.0,{},95.0,0.3685883019305634,0.0164092884050769,"pragma solidity ^0.8.0;

interface IOraclize {
    function query(uint256 _amount, bytes memory _callbackFunction) external payable returns (bytes32);
}
import ""openzeppelin/SafeMath.sol"";
contract OraclizeFeeCover is Ownable {
    address public oraclizeAddress;
    uint256 public minAmountForQuery;

    constructor(address _oraclizeAddress, uint256 _minAmountForQuery) Ownable(msg.sender) {
        require(_oraclizeAddress != address(0), ""Invalid Oraclize address"");
        oraclizeAddress = _oraclizeAddress;
        minAmountForQuery = _minAmountForQuery;
    }

    function coverOraclizeFee() public payable {
        require(msg.value >= minAmountForQuery, ""Insufficient funds to cover Oraclize query fees"");
        IOraclize(oraclizeAddress).query{value: msg.value}(0, bytes(""""));
    }
}"
2424,Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ICloneFactory {
    function createClone(address target) external returns (address);
}

contract CloneToken is ERC20, Ownable {
    using SafeMath for uint256;

    address private _controller;
    ICloneFactory public cloneFactory;

    modifier onlyController() {
        require(_msgSender() == _controller, ""Caller is not the controller"");
        _;
    }

    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {
        _mint(_msgSender(), initialSupply);
        _controller = _msgSender();
    }

    function setCloneFactory(address factory) external onlyController {
        cloneFactory = ICloneFactory(factory);
    }

    function createClone() external returns (address) {
        require(address(cloneFactory) != address(0), ""Clone factory not set"");
        return cloneFactory.createClone(address(this));
    }
}",2.6568071842193604,createClone,"[{'function': 'createClone', 'complexity': 0}, {'function': 'setCloneFactory', 'complexity': 0}, {'function': 'createClone', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createClone"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneFactory""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Clone factory not set""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cloneFactory""}, ""memberName"": ""createClone""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.5261947069770176,0.0297550855511847,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICloneFactory {
    function createClone(address target) external returns (address);
}

contract CloneToken is ERC20, Ownable {
    using SafeMath for uint256;

    address private _controller;
    ICloneFactory public cloneFactory;

    modifier onlyController() {
        require(_msgSender() == _controller, ""Caller is not the controller"");
        _;
    }

    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        _mint(_msgSender(), initialSupply);
        _controller = msg.sender;
    }

    function setCloneFactory(address factory) external onlyController {
        cloneFactory = ICloneFactory(factory);
    }

    function createClone() external returns (address) {
        require(address(cloneFactory) != address(0), ""Clone factory not set"");
        return cloneFactory.createClone(address(this));
    }
}"
474,Burns the coins held by the sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BurnTokens {
    using SafeMath for uint256;

    function burnTokens(uint256 amount, IERC20 token) public {
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to burn"");

        _burnTokens(amount, token);
    }

    function _burnTokens(uint2atural amount, IERC20 token) internal {
        token.transferFrom(msg.sender, address(this), amount);
        token.burn(amount);
    }
}",1.8671855926513672,burnTokens,"[{'function': 'burnTokens', 'complexity': 2}, {'function': '_burnTokens', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burnTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.5691054488891674,0.0274669318158554,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BurnTokens is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burnTokens(uint256 amount, IERC20 token) public {
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to burn"");

        _burnTokens(amount, token);
    }

    function _burnTokens(uint256 amount, IERC20 token) internal {
        token.transferFrom(msg.sender, address(this), amount);
        token.burn(amount);
    }
}"
1413,Overwrite leaderboard name and desctiption as owner only,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Leaderboard is Ownable {
    string private _name;
    string private _description;

    function setLeaderboardName(string memory name) public onlyOwner {
        _name = name;
    }

    function setLeaderboardDescription(string memory description) public onlyOwner {
        _description = description;
    }
}",1.0182464122772217,setLeaderboardName,"[{'function': 'setLeaderboardName', 'complexity': 0}, {'function': 'setLeaderboardDescription', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLeaderboardName"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_name""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5167266704830183,0.0246993896948029,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Leaderboard is Ownable {
    string private _name;
    string private _description;

    constructor() Ownable(msg.sender) {
        _name = 'initialized';
        _description = 'initialized';
    }

    function setLeaderboardName(string memory name) public onlyOwner {
        _name = name;
    }

    function setLeaderboardDescription(string memory description) public onlyOwner {
        _description = description;
    }
}"
6348,"Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetToken is ERC721, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant GENERATOR_ROLE = keccak256(""GENERATOR_ROLE"");
    uint256 public generationLimit;
    uint256 private tokenIdCounter;

    struct Asset {
        string name;
        string symbol;
        uint256 limit;
    }

    mapping(uint256 => Asset) public assets;

    constructor(string memory _name, string memory _symbol, uint256 _limit) ERC721(_name, _symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(GENERATOR_ROLE, DEFAULT_ADMIN_ROLE);
        generationLimit = _limit;
    }

    function mintAsset(address to, uint256 assetId) public {
        require(hasRole(GENERATOR_ROLE, msg.sender), ""Caller is not a generator"");
        require(assetId <= generationLimit, ""Generation limit exceeded"");
        tokenIdCounter++;
        _mint(to, tokenIdCounter);
        assets[tokenIdCounter] = Asset({name: ""Asset"", symbol: ""AST"", limit: assetId});
    }
}",3.2985191345214844,mintAsset,"[{'function': 'mintAsset', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintAsset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""GENERATOR_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a generator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""assetId""}, ""right"": {""type"": ""Identifier"", ""name"": ""generationLimit""}}, {""type"": ""stringLiteral"", ""value"": ""Generation limit exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tokenIdCounter""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenIdCounter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenIdCounter""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Asset""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Asset""}, {""type"": ""stringLiteral"", ""value"": ""AST""}, {""type"": ""Identifier"", ""name"": ""assetId""}], ""names"": [""name"", ""symbol"", ""limit""]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",72.0,0.4565228940827939,0.0130627938524654,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetToken is ERC721, AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant GENERATOR_ROLE = keccak256(""GENERATOR_ROLE"");
    uint256 public generationLimit;
    uint256 private tokenIdCounter;

    struct Asset {
        string name;
        string symbol;
        uint256 limit;
    }

    mapping(uint256 => Asset) public assets;

    constructor(string memory _name, string memory _symbol, uint256 _limit) ERC721(_name, _symbol) {
        Ownable.initialize(msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(GENERATOR_ROLE, DEFAULT_ADMIN_ROLE);
        generationLimit = _limit;
    }

    function mintAsset(address to, uint256 assetId) public {
        require(hasRole(GENERATOR_ROLE, msg.sender), ""Caller is not a generator"");
        require(assetId <= generationLimit, ""Generation limit exceeded"");
        tokenIdCounter++;
        _mint(to, tokenIdCounter);
        assets[tokenIdCounter] = Asset({name: ""Asset"", symbol: ""AST"", limit: assetId});
    }
}"
6764,"This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RefundFee is AccessControl {
    bytes32 public constant AUTHORIZED_ROLE = keccak256(""AUTHORIZED_ROLE"");
    mapping(address => uint256) private feesPaid;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(AUTHORIZED_ROLE, msg.sender);
    }

    function issueRefund(address payable who) public onlyRole(AUTHORIZED_ROLE) {
        require(feesPaid[who] > 0, ""No fee paid by this address"");
        uint256 refundAmount = feesPaid[who];
        feesPaid[who] = 0;
        who.transfer(refundAmount);
    }
}",1.870832681655884,issueRefund,"[{'function': 'issueRefund', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""issueRefund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""feesPaid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No fee paid by this address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""feesPaid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""feesPaid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""who""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""AUTHORIZED_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.5934525029131482,0.0172494542704211,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundFee is AccessControl, Ownable {
    bytes32 public constant AUTHORIZED_ROLE = keccak256(""AUTHORIZED_ROLE"");
    mapping(address => uint256) private feesPaid;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(AUTHORIZED_ROLE, msg.sender);
    }

    function issueRefund(address payable who) public onlyRole(AUTHORIZED_ROLE) {
        require(feesPaid[who] > 0, ""No fee paid by this address"");
        uint256 refundAmount = feesPaid[who];
        feesPaid[who] = 0;
        who.transfer(refundAmount);
    }
}"
5397,Transfers tokens held by timelock to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TimedTokenRelease is Ownable {
    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    constructor(address _token, address _beneficiary, uint256 _releaseTime) {
        require(_releaseTime > block.timestamp, ""Release time must be in the future"");
        token = IERC20(_token);
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function releaseTokens() public onlyOwner {
        require(block.timestamp >= releaseTime, ""Tokens are not yet released"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(beneficiary, balance);
    }
}",2.136960744857788,releaseTokens,"[{'function': 'releaseTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Tokens are not yet released""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7309295887916719,0.0622484402009115,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimedTokenRelease is Ownable {
    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _beneficiary, uint256 _releaseTime) Ownable(msg.sender) {
        require(_releaseTime > block.timestamp, ""Release time must be in the future"");
        token = IERC20(_token);
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function releaseTokens() public onlyOwner {
        require(block.timestamp >= releaseTime, ""Tokens are not yet released"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(beneficiary, balance);
    }
}"
4047,Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OrderVerifier {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
        uint256 points;
    }

    mapping(bytes32 => Order) public orders;

    function verifyOrder(
        bytes32 orderHash,
        address userAddress,
        uint256 amount,
        uint256 points
    ) public view returns (bool) {
        require(orderHash != 0x0, ""Invalid order hash"");
        Order memory storedOrder = orders[orderHash];
        return (storedOrder.userAddress == userAddress && storedOrder.amount == amount && storedOrder.points == points);
    }
}",1.8146119117736816,verifyOrder,"[{'function': 'verifyOrder', 'complexity': -1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""points"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""orderHash""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid order hash""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""storedOrder"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderHash""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""storedOrder""}, ""memberName"": ""userAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""userAddress""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""storedOrder""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""storedOrder""}, ""memberName"": ""points""}, ""right"": {""type"": ""Identifier"", ""name"": ""points""}}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",85.0,0.6167989004394137,0.0179969315534806,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract OrderVerifier is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
        uint256 points;
    }

    mapping(bytes32 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function verifyOrder(
        bytes32 orderHash,
        address userAddress,
        uint256 amount,
        uint256 points
    ) public view returns (bool) {
        require(orderHash != 0x0, ""Invalid order hash"");
        Order memory storedOrder = orders[orderHash];
        return (storedOrder.userAddress == userAddress && storedOrder.amount == amount && storedOrder.points == points);
    }
}"
527,The value in HAV for a given amount of USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IHAV {
    function getAmountInUSD(uint256 usdAmount) external view returns (uint256);
}

contract HAVCalculator {
    using SafeMath for uint256;

    address public immutable havAddress;

    constructor(address _havAddress) {
        require(_havAddress != address(0), ""Invalid HAV contract address"");
        havAddress = _havAddress;
    }

    function getValueInHAV(uint256 usdAmount) external view returns (uint256) {
        IHAV hav = IHAV(havAddress);
        uint256 amountInHAV = hav.getAmountInUSD(usdAmount);
        return amountInHAV;
    }
}",1.8785481452941888,getValueInHAV,"[{'function': 'getAmountInUSD', 'complexity': 0}, {'function': 'getValueInHAV', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValueInHAV"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""usdAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IHAV""}, ""name"": ""hav"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IHAV""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""havAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountInHAV"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hav""}, ""memberName"": ""getAmountInUSD""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdAmount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""amountInHAV""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.6193006956208515,0.0397244846787269,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IHAV {
    function getAmountInUSD(uint256 usdAmount) external view returns (uint256);
}

contract HAVCalculator is Ownable {
    using SafeMath for uint256;

    address public immutable havAddress;

    constructor(address _havAddress) Ownable() {
        require(_havAddress != address(0), ""Invalid HAV contract address"");
        havAddress = _havAddress;
    }

    function getValueInHAV(uint256 usdAmount) external view returns (uint256) {
        IHAV hav = IHAV(havAddress);
        uint256 amountInHAV = hav.getAmountInUSD(usdAmount);
        return amountInHAV;
    }
}"
3318,Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CarbonDollar {
    function burn(uint256 amount) external;
}

contract BurnMetaTransaction is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    CarbonDollar public carbonDollarContract;

    constructor(address _carbonDollar, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(MINTER_ROLE, admin);
        carbonDollarContract = CarbonDollar(_carbonDollar);
    }

    function burnCarbonDollar(uint256 amount) external onlyRole(MINTER_ROLE) {
        carbonDollarContract.burn(amount);
    }

    function getBurnInfoHash() external pure returns (bytes32) {
        return keccak256(""BurnMetaTransaction: burnCarbonDollar"");
    }
}",2.391930341720581,burnCarbonDollar,"[{'function': 'burn', 'complexity': 0}, {'function': 'burnCarbonDollar', 'complexity': 0}, {'function': 'getBurnInfoHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnCarbonDollar"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""carbonDollarContract""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6229496282890717,0.0182685296783626,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CarbonDollar {
    function burn(uint256 amount) external;
}

contract BurnMetaTransaction is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    CarbonDollar public carbonDollarContract;

    constructor(address _carbonDollar, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(MINTER_ROLE, admin);
        carbonDollarContract = CarbonDollar(_carbonDollar);
    }

    function burnCarbonDollar(uint256 amount) external onlyRole(MINTER_ROLE) {
        carbonDollarContract.burn(amount);
    }

    function getBurnInfoHash() external pure returns (bytes32) {
        return keccak256(""BurnMetaTransaction: burnCarbonDollar"");
    }
}"
1663,Access point for the oracle to update the price of havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HavvenOracle is Ownable {
    using SafeMath for uint256;

    struct PriceData {
        uint256 price;
        bool isValid;
    }

    mapping(address => PriceData) public prices;

    function updatePrice(address token, uint256 newPrice) external onlyOwner {
        require(newPrice > 0, ""Invalid price"");
        prices[token] = PriceData({price: newPrice, isValid: true});
    }
}",1.4930334091186523,updatePrice,"[{'function': 'updatePrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""prices""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPrice""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""price"", ""isValid""]}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.7649702062691822,0.1275547083598009,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenOracle is Ownable {
    using SafeMath for uint256;

    struct PriceData {
        uint256 price;
        bool isValid;
    }

    mapping(address => PriceData) public prices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            prices[addr] = PriceData({price: uint256(i), isValid: true});
        }
    }

    function updatePrice(address token, uint256 newPrice) external onlyOwner {
        require(newPrice > 0, ""Invalid price"");
        prices[token] = PriceData({price: newPrice, isValid: true});
    }
}"
6383,Approve address to become creator of that pack,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract PackCreatorApprover is AccessControl {
    bytes32 public constant CREATOR_ROLE = keccak256(""CREATOR_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function approveCreator(address creator) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        grantRole(CREATOR_ROLE, creator);
    }
}",1.3012924194335938,approveCreator,"[{'function': 'approveCreator', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveCreator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""CREATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""creator""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.677890107387108,0.0485626724262873,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PackCreatorApprover is AccessControl, Ownable {
    bytes32 public constant CREATOR_ROLE = keccak256(""CREATOR_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        transferOwnership(admin);
    }

    function approveCreator(address creator) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        grantRole(CREATOR_ROLE, creator);
    }
}"
5701,Returns the division of two numbers Function used for division operations inside the smartcontract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DivisionFunction {
    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        require(b > 0, ""Division by zero is not allowed"");
        return a.div(b);
    }
}",1.016608476638794,divide,"[{'function': 'divide', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""divide"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Division by zero is not allowed""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",1.0,0.6800107056858942,0.2114382212934748,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract DivisionFunction is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        require(b > 0, ""Division by zero is not allowed"");
        return a.div(b);
    }
}"
2851,Function used by the creator to set the presale limits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PresaleLimitsSetter is Ownable {
    uint256 public maxTokensPerWalletDuringPresale;
    uint256 public minTokensToBuyDuringPresale;

    function setPresaleLimits(uint256 _maxTokensPerWallet, uint256 _minTokensToBuy) external onlyOwner {
        require(_maxTokensPerWallet > 0 && _minTokensToBuy > 0, ""Invalid input values"");
        maxTokensPerWalletDuringPresale = _maxTokensPerWallet;
        minTokensToBuyDuringPresale = _minTokensToBuy;
    }
}",1.505246877670288,setPresaleLimits,"[{'function': 'setPresaleLimits', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPresaleLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxTokensPerWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minTokensToBuy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_maxTokensPerWallet""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minTokensToBuy""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input values""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxTokensPerWalletDuringPresale""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxTokensPerWallet""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minTokensToBuyDuringPresale""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minTokensToBuy""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8137706338551631,0.0274326868569645,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PresaleLimitsSetter is Ownable {
    uint256 public maxTokensPerWalletDuringPresale;
    uint256 public minTokensToBuyDuringPresale;

    constructor() Ownable(msg.sender) {
        maxTokensPerWalletDuringPresale = 1;
        minTokensToBuyDuringPresale = 1;
    }

    function setPresaleLimits(uint256 _maxTokensPerWallet, uint256 _minTokensToBuy) external onlyOwner {
        require(_maxTokensPerWallet > 0 && _minTokensToBuy > 0, ""Invalid input values"");
        maxTokensPerWalletDuringPresale = _maxTokensPerWallet;
        minTokensToBuyDuringPresale = _minTokensToBuy;
    }
}"
5928,Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 value) external returns (bool);
}

contract TokenManager is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public authorizedOperators;
    IToken public tokenContract;

    event AuthorizedOperator(address indexed operator, address indexed owner);
    event RevokedOperator(address indexed operator, address indexed owner);

    modifier onlyAuthorized() {
        require(authorizedOperators[msg.sender], ""Not an authorized operator"");
        _;
    }

    constructor(address _tokenContract) {
        tokenContract = IToken(_tokenContract);
    }

    function authorizeOperator(address _operator) public onlyOwner {
        authorizedOperators[_operator] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }

    function revokeOperator(address _operator) public onlyOwner {
        require(authorizedOperators[_operator], ""Operator is not authorized"");
        authorizedOperators[_operator] = false;
        emit RevokedOperator(_operator, msg.sender);
    }

    function transferTokens(address to, uint256 value) external onlyAuthorized {
        tokenContract.transfer(to, value);
    }
}",3.0032334327697754,revokeOperator,"[{'function': 'transfer', 'complexity': 0}, {'function': 'authorizeOperator', 'complexity': 0}, {'function': 'revokeOperator', 'complexity': 1}, {'function': 'transferTokens', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, {""type"": ""stringLiteral"", ""value"": ""Operator is not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RevokedOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.7958682781145285,0.327971381170259,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 value) external returns (bool);
}

contract TokenManager is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public authorizedOperators;
    IToken public tokenContract;

    event AuthorizedOperator(address indexed operator, address indexed owner);
    event RevokedOperator(address indexed operator, address indexed owner);

    modifier onlyAuthorized() {
        require(authorizedOperators[msg.sender], ""Not an authorized operator"");
        _;
    }

    constructor(address _tokenContract) Ownable() {
        tokenContract = IToken(_tokenContract);
    }

    function authorizeOperator(address _operator) public onlyOwner {
        authorizedOperators[_operator] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }

    function revokeOperator(address _operator) public onlyOwner {
        require(authorizedOperators[_operator], ""Operator is not authorized"");
        authorizedOperators[_operator] = false;
        emit RevokedOperator(_operator, msg.sender);
    }

    function transferTokens(address to, uint256 value) external onlyAuthorized {
        tokenContract.transfer(to, value);
    }
}"
1383,Performs allowance transfer of asset balance between holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AllowanceTransfer {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public allowances;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function transferFromWithAllowance(address from, address to, uint256 amount) external returns (bool) {
        require(allowances[msg.sender] >= amount, ""Insufficient allowance"");
        require(token.transferFrom(from, to, amount), ""Transfer failed"");
        allowances[msg.sender] = allowances[msg.sender].sub(amount);
        return true;
    }
}",1.9451439380645752,transferFromWithAllowance,"[{'function': 'transferFromWithAllowance', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromWithAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.7390467603237808,0.1154380010787409,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AllowanceTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public allowances;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        allowances[owner()] = 1; // Set initial allowance to a fixed value of 1
    }

    function transferFromWithAllowance(address from, address to, uint256 amount) external returns (bool) {
        require(allowances[msg.sender] >= amount, ""Insufficient allowance"");
        require(token.transferFrom(from, to, amount), ""Transfer failed"");
        allowances[msg.sender] = allowances[msg.sender].sub(amount);
        return true;
    }
}"
5667,Returns the address currently assigned ownership of a given token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}","pragma solidity ^0.8.0;

interface IToken {
    function ownerOf(uint256 tokenId) external view returns (address);
}

contract TokenOwnershipChecker {
    using SafeMath for uint256;

    function getTokenOwner(IToken tokenContract, uint256 tokenId) public view returns (address) {
        require(tokenId > 0, ""Invalid token ID"");
        return tokenContract.ownerOf(tokenId);
    }
}",1.0949196815490725,getTokenOwner,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'getTokenOwner', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IToken""}, ""name"": ""tokenContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.7748662293467562,0.2671588912784885,"pragma solidity ^0.8.0;

interface IToken {
    function ownerOf(uint256 tokenId) external view returns (address);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnershipChecker is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenOwner(IToken tokenContract, uint256 tokenId) public view returns (address) {
        require(tokenId > 0, ""Invalid token ID"");
        return tokenContract.ownerOf(tokenId);
    }
}"
5392,"Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Loan {
    enum Status { pending, lent, repaid, defaulted }
    function status() external view returns (Status);
}

contract LoanTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedTransfers;

    event TransferApproved(address indexed lender);
    event LoanTransferred(address indexed oldLender, address indexed newLender);

    function approveTransfer() external onlyOwner {
        approvedTransfers[msg.sender] = true;
        emit TransferApproved(msg.sender);
    }

    function transferLoan(address loanAddress) external {
        require(approvedTransfers[msg.sender], ""You are not authorized to transfer this loan."");
        Loan loan = Loan(loanAddress);
        require(loan.status() == Loan.Status.lent, ""This loan is not in the lent status and cannot be transferred."");
        address oldLender = ownerOfLoan(loanAddress);
        require(oldLender != msg.sender, ""The caller is already the lender of this loan."");
        transferLoanToNewLender(loanAddress, msg.sender);
    }

    function transferLoanToNewLender(address loanAddress, address newLender) internal {
        Loan loan = Loan(loanAddress);
        require(approvedTransfers[newLender], ""The new lender is not authorized to receive this loan."");
        require(loan.status() == Loan.Status.lent, ""This loan is not in the lent status and cannot be transferred."");
        address oldLender = ownerOfLoan(loanAddress);
        require(oldLender != msg.sender, ""The caller is already the lender of this loan."");
        approvedTransfers[oldLender] = false;
        approvedTransfers[newLender] = true;
        emit LoanTransferred(oldLender, newLender);
    }

    function ownerOfLoan(address loanAddress) internal view returns (address) {
        return Ownable(loanAddress).owner();
    }
}",4.59191370010376,transferLoanToNewLender,"[{'function': 'status', 'complexity': 0}, {'function': 'approveTransfer', 'complexity': 0}, {'function': 'transferLoan', 'complexity': 3}, {'function': 'transferLoanToNewLender', 'complexity': 3}, {'function': 'ownerOfLoan', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLoanToNewLender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""loanAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newLender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Loan""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""loanAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""newLender""}}, {""type"": ""stringLiteral"", ""value"": ""The new lender is not authorized to receive this loan.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""status""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Loan""}, ""memberName"": ""Status""}, ""memberName"": ""lent""}}, {""type"": ""stringLiteral"", ""value"": ""This loan is not in the lent status and cannot be transferred.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldLender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOfLoan""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""loanAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldLender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""The caller is already the lender of this loan.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""oldLender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""newLender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LoanTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldLender""}, {""type"": ""Identifier"", ""name"": ""newLender""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.7162345952352651,0.0600319336447162,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Loan {
    enum Status { pending, lent, repaid, defaulted }
    function status() external view returns (Status);
}

contract LoanTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedTransfers;

    event TransferApproved(address indexed lender);
    event LoanTransferred(address indexed oldLender, address indexed newLender);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        approvedTransfers[address(0x111)] = true;
        approvedTransfers[address(0x222)] = true;
        approvedTransfers[address(0x333)] = true;
    }

    function approveTransfer() external onlyOwner {
        approvedTransfers[msg.sender] = true;
        emit TransferApproved(msg.sender);
    }

    function transferLoan(address loanAddress) external {
        require(approvedTransfers[msg.sender], ""You are not authorized to transfer this loan."");
        Loan loan = Loan(loanAddress);
        require(loan.status() == Loan.Status.lent, ""This loan is not in the lent status and cannot be transferred."");
        address oldLender = ownerOfLoan(loanAddress);
        require(oldLender != msg.sender, ""The caller is already the lender of this loan."");
        transferLoanToNewLender(loanAddress, msg.sender);
    }

    function transferLoanToNewLender(address loanAddress, address newLender) internal {
        Loan loan = Loan(loanAddress);
        require(approvedTransfers[newLender], ""The new lender is not authorized to receive this loan."");
        require(loan.status() == Loan.Status.lent, ""This loan is not in the lent status and cannot be transferred."");
        address oldLender = ownerOfLoan(loanAddress);
        require(oldLender != msg.sender, ""The caller is already the lender of this loan."");
        approvedTransfers[oldLender] = false;
        approvedTransfers[newLender] = true;
        emit LoanTransferred(oldLender, newLender);
    }

    function ownerOfLoan(address loanAddress) internal view returns (address) {
        return Ownable(loanAddress).owner();
    }
}"
6100,Allows a grant recipient to claim their vested tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenVesting {
    using SafeMath for uint256;

    IERC20 public token;
    address public grantRecipient;
    uint256 public vestingDuration;
    uint256 public startTime;
    bool public initialized;

    mapping(address => uint256) public vestedTokensClaimed;

    modifier onlyGrantRecipient() {
        require(msg.sender == grantRecipient, ""Only the grant recipient can call this function"");
        _;
    }

    constructor(address _token, address _grantRecipient, uint256 _vestingDuration) {
        token = IERC20(_token);
        grantRecipient = _grantRecipient;
        vestingDuration = _vestingDuration;
    }

    function initializeVesting(uint256 _startTime) external {
        require(!initialized, ""Already initialized"");
        startTime = _startTime;
        initialized = true;
    }

    function claimTokens() external onlyGrantRecipient {
        require(block.timestamp >= startTime && block.timestamp <= startTime + vestingDuration, ""Vesting period not active or ended"");
        uint256 totalTokensToClaim = token.balanceOf(address(this)).sub(vestedTokensClaimed[grantRecipient]);
        vestedTokensClaimed[grantRecipient] += totalTokensToClaim;
        require(token.transfer(grantRecipient, totalTokensToClaim), ""Token transfer failed"");
    }
}",3.3802361488342285,claimTokens,"[{'function': 'initializeVesting', 'complexity': 2}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""vestingDuration""}}}}, {""type"": ""stringLiteral"", ""value"": ""Vesting period not active or ended""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalTokensToClaim"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedTokensClaimed""}, ""index"": {""type"": ""Identifier"", ""name"": ""grantRecipient""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedTokensClaimed""}, ""index"": {""type"": ""Identifier"", ""name"": ""grantRecipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalTokensToClaim""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""grantRecipient""}, {""type"": ""Identifier"", ""name"": ""totalTokensToClaim""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyGrantRecipient"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.8749333826217011,0.0798383615643282,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenVesting is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public grantRecipient;
    uint256 public vestingDuration;
    uint256 public startTime;
    bool public initialized;

    mapping(address => uint256) public vestedTokensClaimed;

    modifier onlyGrantRecipient() {
        require(msg.sender == grantRecipient, ""Only the grant recipient can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _grantRecipient, uint256 _vestingDuration) Ownable(msg.sender) {
        token = IERC20(_token);
        grantRecipient = _grantRecipient;
        vestingDuration = _vestingDuration;
        startTime = 1; // Set to a fixed value that is not zero and represents an initial time
        initialized = true; // Set to true as per the initialization rules
    }

    function initializeVesting(uint256 _startTime) external {
        require(!initialized, ""Already initialized"");
        startTime = _startTime;
        initialized = true;
    }

    function claimTokens() external onlyGrantRecipient {
        require(block.timestamp >= startTime && block.timestamp <= startTime + vestingDuration, ""Vesting period not active or ended"");
        uint256 totalTokensToClaim = token.balanceOf(address(this)).sub(vestedTokensClaimed[grantRecipient]);
        vestedTokensClaimed[grantRecipient] += totalTokensToClaim;
        require(token.transfer(grantRecipient, totalTokensToClaim), ""Token transfer failed"");
    }
}"
949,Emits ERC20 Approval event on this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function approveToken(address spender, uint256 amount) external returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        bool success = token.approve(spender, amount);
        require(success, ""Approval failed"");
        return true;
    }
}",1.626356601715088,approveToken,"[{'function': 'approveToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.620118529531331,0.0147270934314369,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _token) Ownable(_msgSender()) {
        token = IERC20(_token);
    }

    function approveToken(address spender, uint256 amount) external returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        bool success = token.approve(spender, amount);
        require(success, ""Approval failed"");
        return true;
    }
}"
6735,Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ProfiteroleBonusDeposit is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function depositTokensForBonuses(uint256 amount) external onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(address(this)) >= amount, ""Insufficient balance to deposit"");
        token.transfer(owner(), amount);
    }
}",1.833157539367676,depositTokensForBonuses,"[{'function': 'depositTokensForBonuses', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositTokensForBonuses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to deposit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",62.0,0.6914288642159405,0.0295669392728834,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ProfiteroleBonusDeposit is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function depositTokensForBonuses(uint256 amount) external onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(address(this)) >= amount, ""Insufficient balance to deposit"");
        token.transfer(owner(), amount);
    }
}"
2614,Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApprovalChanged(address indexed operator, bool approved);

    function setOperatorApproval(address operator, bool approved) external onlyOwner {
        require(operator != address(0), ""Invalid operator address"");
        approvedOperators[operator] = approved;
        emit OperatorApprovalChanged(operator, approved);
    }
}",1.4620065689086914,setOperatorApproval,"[{'function': 'setOperatorApproval', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOperatorApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid operator address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OperatorApprovalChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8608842011980162,0.0460981535623517,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApprovalChanged(address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setOperatorApproval(address operator, bool approved) external onlyOwner {
        require(operator != address(0), ""Invalid operator address"");
        approvedOperators[operator] = approved;
        emit OperatorApprovalChanged(operator, approved);
    }
}"
5641,Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Destructible is Ownable {
    function destructContract() public onlyOwner {
        selfdestruct(payable(owner()));
    }
}",0.6704404354095459,destructContract,"[{'function': 'destructContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destructContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.8037119475964575,0.6325846704849246,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Destructible is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function destructContract() public onlyOwner {
        selfdestruct(payable(owner()));
    }
}"
2847,Change the wallet where ether will be sent to when tokens are bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    address public oldWallet;
    address public newWallet;

    event WalletChanged(address indexed previousWallet, address indexed newWallet);

    constructor(address _oldWallet, address _newWallet) {
        require(_oldWallet != address(0), ""Invalid old wallet address"");
        require(_newWallet != address(0), ""Invalid new wallet address"");
        oldWallet = _oldWallet;
        newWallet = _newWallet;
    }

    function changeWallet(address _newWallet) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_newWallet != address(0), ""Invalid new wallet address"");
        emit WalletChanged(oldWallet, _newWallet);
        oldWallet = _newWallet;
    }
}",2.119080305099488,changeWallet,"[{'function': 'changeWallet', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeWallet"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newWallet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid new wallet address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WalletChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldWallet""}, {""type"": ""Identifier"", ""name"": ""_newWallet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""oldWallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newWallet""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7993587968146751,0.1324489913317266,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    address public oldWallet = 0x1111111111111111111111111111111111111111; // fixed value
    address public newWallet = 0x2222222222222222222222222222222222222222; // fixed value

    event WalletChanged(address indexed previousWallet, address indexed newWallet);

    constructor()
        Ownable(msg.sender) // invoke Ownable constructor with msg.sender
    {
        require(oldWallet != address(0), ""Invalid old wallet address"");
        require(newWallet != address(0), ""Invalid new wallet address"");

        // Initialize other variables here if needed
        // For example:
        bool initialized = true;
        bytes32 initBytes = bytes32('init');
        uint256 defaultUint = 1; // never 0

        oldWallet = 0x1111111111111111111111111111111111111111; // fixed value
        newWallet = 0x2222222222222222222222222222222222222222; // fixed value
    }

    function changeWallet(address _newWallet) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_newWallet != address(0), ""Invalid new wallet address"");
        emit WalletChanged(oldWallet, _newWallet);
        oldWallet = _newWallet;
    }
}"
6644,"challenge the provided proposal ID , and put tokens at stake to do so .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}","pragma solidity ^0.8.0;

interface IToken {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract ProposalChallenge {
    address public owner;
    mapping(uint256 => bool) public challengedProposals;
    IToken public token;
    uint256 public challengeBond = 100 ether; // Example challenge bond in wei

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress) {
        owner = msg.sender;
        token = IToken(_tokenAddress);
    }

    function challengeProposal(uint256 proposalId) public {
        require(!challengedProposals[proposalId], ""Proposal already challenged"");
        require(token.transferFrom(msg.sender, address(this), challengeBond), ""Transfer failed"");
        challengedProposals[proposalId] = true;
    }
}",2.2930705547332764,challengeProposal,"[{'function': 'approve', 'complexity': 0}, {'function': 'challengeProposal', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""challengeProposal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""challengedProposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Proposal already challenged""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""challengeBond""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""challengedProposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",83.0,0.7490735282563661,0.0197368443085731,"pragma solidity ^0.8.0;

interface IToken {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ProposalChallenge is Ownable {
    address public owner;
    mapping(uint256 => bool) public challengedProposals;
    IToken public token;
    uint256 public challengeBond = 100 ether; // Example challenge bond in wei

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IToken(_tokenAddress);
        owner = msg.sender; // Ensure the owner is set correctly
    }

    function challengeProposal(uint256 proposalId) public {
        require(!challengedProposals[proposalId], ""Proposal already challenged"");
        require(token.transferFrom(msg.sender, address(this), challengeBond), ""Transfer failed"");
        challengedProposals[proposalId] = true;
    }
}"
3277,Computes ( _numerator / _denominator ) 10 _scale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ScaleCalculator {
    using SafeMath for uint256;

    function computeScale(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {
        require(_denominator != 0, ""Division by zero is not allowed"");
        return _numerator.mul(10**10).div(_denominator);
    }
}",1.1655468940734863,computeScale,"[{'function': 'computeScale', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeScale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_denominator""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Division by zero is not allowed""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_denominator""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",18.0,0.8188935752188423,0.2446150389493811,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ScaleCalculator is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _numerator = 1;
        _denominator = 1;
    }

    uint256 private _numerator;
    uint256 private _denominator;

    function computeScale(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {
        require(_denominator != 0, ""Division by zero is not allowed"");
        return _numerator.mul(10**10).div(_denominator);
    }
}"
5822,Get current amount of tokens on Vault address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Vault {
    using SafeMath for uint256;
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function getTokenAmount() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}",1.2827160358428955,getTokenAmount,"[{'function': 'getTokenAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,0.6914097045577723,0.3809137041667079,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Vault is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function getTokenAmount() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}"
1522,Transfer an amount of currency token from msg.sender account to another specified account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CurrencyTokenTransfer is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address to, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(to != address(0), ""Invalid recipient address"");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed"");
    }
}",1.665379285812378,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.7565111616103494,0.1135265568076707,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CurrencyTokenTransfer is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address to, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(to != address(0), ""Invalid recipient address"");

        bool success = token.transferFrom(msg.sender, to, amount);
        require(success, ""Token transfer failed"");
    }
}"
3064,Sender should check whether he has enough tokens to be transferred,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer"");
        bool success = token.transferFrom(msg.sender, recipient, amount);
        require(success, ""Token transfer failed"");
    }
}",1.8596556186676023,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.5749029352569162,0.033796738640279,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 private token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance to transfer"");
        bool success = token.transferFrom(msg.sender, recipient, amount);
        require(success, ""Token transfer failed"");
    }
}"
6408,"owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RefundVault is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public refunds;

    event RefundProcessed(address indexed to, uint256 value);

    function sendTokensToAddress(address payable to, uint256 value) external onlyOwner {
        require(value > 0, ""Value must be greater than zero"");
        require(to != address(0), ""Invalid recipient address"");

        refunds[to] = value;
        emit RefundProcessed(to, value);
    }
}",1.6749110221862793,sendTokensToAddress,"[{'function': 'sendTokensToAddress', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokensToAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""refunds""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RefundProcessed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.889302880811073,0.2624045732548704,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RefundVault is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public refunds;

    event RefundProcessed(address indexed to, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendTokensToAddress(address payable to, uint256 value) external onlyOwner {
        require(value > 0, ""Value must be greater than zero"");
        require(to != address(0), ""Invalid recipient address"");

        refunds[to] = value;
        emit RefundProcessed(to, value);
    }
}"
6613,Sets the ` _newManager ` as manager for the ` _addr ` address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ManagerSetter is Ownable {
    mapping(address => address) private managers;

    function setManager(address _addr, address _newManager) public onlyOwner {
        require(_newManager != address(0), ""Invalid manager address"");
        managers[_addr] = _newManager;
    }
}",0.9746015071868896,setManager,"[{'function': 'setManager', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newManager""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid manager address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newManager""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.9173617300664914,0.2496193243936977,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManagerSetter is Ownable {
    mapping(address => address) private managers;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        managers[address(0x111)] = address(0x222);
        managers[address(0x333)] = address(0x444);
        managers[address(0x555)] = address(0x666);
    }

    function setManager(address _addr, address _newManager) public onlyOwner {
        require(_newManager != address(0), ""Invalid manager address"");
        managers[_addr] = _newManager;
    }
}"
799,Returns all the relevant information about a specific collectible .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Collectible is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant COLLECTOR_ROLE = keccak256(""COLLECTOR_ROLE"");

    struct CollectibleInfo {
        string name;
        string symbol;
        uint256 totalSupply;
        mapping(uint256 => uint256) tokenBalances;
    }

    CollectibleInfo private collectibleInfo;

    constructor(string memory _name, string memory _symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(COLLECTOR_ROLE, msg.sender);
        collectibleInfo.name = _name;
        collectibleInfo.symbol = _symbol;
    }

    function mint(uint256 tokenId, uint256 amount) public onlyRole(COLLECTOR_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        collectibleInfo.totalSupply = collectibleInfo.totalSupply.add(amount);
        collectibleInfo.tokenBalances[tokenId] += amount;
    }

    function balanceOf(uint256 tokenId) public view returns (uint256) {
        return collectibleInfo.tokenBalances[tokenId];
    }

    function totalSupply() public view returns (uint256) {
        return collectibleInfo.totalSupply;
    }
}",3.3948400020599365,mint,"[{'function': 'mint', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'totalSupply', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectibleInfo""}, ""memberName"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectibleInfo""}, ""memberName"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectibleInfo""}, ""memberName"": ""tokenBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""COLLECTOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.5253152332571793,0.084474511346151,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Collectible is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant COLLECTOR_ROLE = keccak256(""COLLECTOR_ROLE"");

    struct CollectibleInfo {
        string name;
        string symbol;
        uint256 totalSupply;
        mapping(uint256 => uint256) tokenBalances;
    }

    CollectibleInfo private collectibleInfo;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(string memory _name, string memory _symbol) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(COLLECTOR_ROLE, msg.sender);
        collectibleInfo.name = _name;
        collectibleInfo.symbol = _symbol;
    }

    function mint(uint256 tokenId, uint256 amount) public onlyRole(COLLECTOR_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        collectibleInfo.totalSupply = collectibleInfo.totalSupply.add(amount);
        collectibleInfo.tokenBalances[tokenId] += amount;
    }

    function balanceOf(uint256 tokenId) public view returns (uint256) {
        return collectibleInfo.tokenBalances[tokenId];
    }

    function totalSupply() public view returns (uint256) {
        return collectibleInfo.totalSupply;
    }
}"
5627,Changing versions does not affect existing tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenUpgradeGuard is Ownable {
    using SafeMath for uint256;

    IERC20 public immutable token;

    constructor(address _token) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function changeTokenVersion(uint256 amount) external onlyOwner {
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient token balance"");
        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Token transfer failed"");
    }
}",2.0300238132476807,changeTokenVersion,"[{'function': 'changeTokenVersion', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeTokenVersion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.4489039261470636,0.1344295701489427,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenUpgradeGuard is Ownable {
    using SafeMath for uint256;

    IERC20 public immutable token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function changeTokenVersion(uint256 amount) external onlyOwner {
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient token balance"");
        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Token transfer failed"");
    }
}"
2373,Transfers tokens from a specified wallet address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    function transferTokens(address tokenAddress, address recipient, uint256 amount) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool transferSuccess = token.transfer(recipient, amount);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}",1.4781291484832764,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.5893469461676768,0.0463535129077911,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(address tokenAddress, address recipient, uint256 amount) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool transferSuccess = token.transfer(recipient, amount);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}"
3161,"Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AuctionPriceSetter {
    using SafeMath for uint256;

    uint256 private _price_start;
    uint256 private _price_constant1;
    uint256 private _price_exponent1;
    uint256 private _price_constant2;
    uint256 private _price_exponent2;

    function setPriceParameters(uint256 priceStart, uint256 priceConstant1, uint256 priceExponent1, uint256 priceConstant2, uint256 priceExponent2) public {
        require(_price_start == 0 && _price_constant1 == 0 && _price_exponent1 == 0 && _price_constant2 == 0 && _price_exponent2 == 0, ""Parameters already set"");
        _price_start = priceStart;
        _price_constant1 = priceConstant1;
        _price_exponent1 = priceExponent1;
        _price_constant2 = priceConstant2;
        _price_exponent2 = priceExponent2;
    }
}",2.589935064315796,setPriceParameters,"[{'function': 'setPriceParameters', 'complexity': 2}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceParameters"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceStart"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceConstant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceExponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceConstant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceExponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_start""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Parameters already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_start""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceStart""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceConstant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceExponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceConstant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceExponent2""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7053053809708414,0.0433653863166834,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AuctionPriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 private _price_start = 1;
    uint256 private _price_constant1 = 1;
    uint256 private _price_exponent1 = 1;
    uint256 private _price_constant2 = 1;
    uint256 private _price_exponent2 = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here
    }

    function setPriceParameters(uint256 priceStart, uint256 priceConstant1, uint256 priceExponent1, uint256 priceConstant2, uint256 priceExponent2) public {
        require(_price_start == 0 && _price_constant1 == 0 && _price_exponent1 == 0 && _price_constant2 == 0 && _price_exponent2 == 0, ""Parameters already set"");
        _price_start = priceStart;
        _price_constant1 = priceConstant1;
        _price_exponent1 = priceExponent1;
        _price_constant2 = priceConstant2;
        _price_exponent2 = priceExponent2;
    }
}"
1809,Nominate a new owner of this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Contract is Ownable {
    mapping(address => bool) public nominees;

    function nominateNewOwner(address nominee) external onlyOwner {
        require(!nominees[nominee], ""Nominee already nominated"");
        nominees[nominee] = true;
    }
}",0.8995938301086426,nominateNewOwner,"[{'function': 'nominateNewOwner', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""nominateNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""nominee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nominees""}, ""index"": {""type"": ""Identifier"", ""name"": ""nominee""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Nominee already nominated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nominees""}, ""index"": {""type"": ""Identifier"", ""name"": ""nominee""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8910417375129203,0.25376192011638,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Contract is Ownable {
    mapping(address => bool) public nominees;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        nominees[address(0x111)] = true;
        nominees[address(0x222)] = true;
        nominees[address(0x333)] = true;
    }

    function nominateNewOwner(address nominee) external onlyOwner {
        require(!nominees[nominee], ""Nominee already nominated"");
        nominees[nominee] = true;
    }
}"
5765,set minimal amount of ether which can be used to buy tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint2藏56 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public minPurchaseAmount;

    constructor(uint256 _minPurchaseAmount) {
        require(_minPurchaseAmount > 0, ""Min purchase amount must be greater than zero"");
        minPurchaseAmount = _minPurchaseAmount;
    }

    function setMinPurchaseAmount(uint256 _newMinPurchaseAmount) external onlyOwner {
        require(_newMinPurchaseAmount > 0, ""Min purchase amount must be greater than zero"");
        minPurchaseAmount = _newMinPurchaseAmount;
    }
}",1.7249243259429932,setMinPurchaseAmount,"[{'function': 'setMinPurchaseAmount', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinPurchaseAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newMinPurchaseAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newMinPurchaseAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Min purchase amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minPurchaseAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMinPurchaseAmount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8195257162244787,0.0230174236008625,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public minPurchaseAmount;

    constructor(uint256 _minPurchaseAmount) Ownable(msg.sender) {
        require(_minPurchaseAmount > 0, ""Min purchase amount must be greater than zero"");
        minPurchaseAmount = _minPurchaseAmount;
    }

    function setMinPurchaseAmount(uint256 _newMinPurchaseAmount) external onlyOwner {
        require(_newMinPurchaseAmount > 0, ""Min purchase amount must be greater than zero"");
        minPurchaseAmount = _newMinPurchaseAmount;
    }
}"
1032,Obtain the quantity which the next schedule entry will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingSchedule is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public vestingPeriod;
    mapping(address => uint256) public vestedAmounts;
    mapping(address => uint256) public lastVestedTime;
    uint256 public totalVestingAmount;

    constructor(uint256 _vestingPeriod, address admin) {
        vestingPeriod = _vestingPeriod;
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, admin);
    }

    function setVestingAmount(address user, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        vestedAmounts[user] = amount;
        totalVestingAmount += amount;
        lastVestedTime[user] = block.timestamp;
    }

    function getNextScheduleEntry(address user) public view returns (uint256) {
        require(vestedAmounts[user] > 0, ""No vesting schedule set for this user"");
        uint256 timeSinceLastVested = block.timestamp.sub(lastVestedTime[user]);
        if (timeSinceLastVested >= vestingPeriod) {
            return vestedAmounts[user];
        } else {
            return 0;
        }
    }
}",3.689663410186768,getNextScheduleEntry,"[{'function': 'setVestingAmount', 'complexity': 1}, {'function': 'getNextScheduleEntry', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setVestingAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVestingAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastVestedTime""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.5756935758918562,0.0276211661192587,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingSchedule is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public vestingPeriod;
    mapping(address => uint256) public vestedAmounts;
    mapping(address => uint256) public lastVestedTime;
    uint256 public totalVestingAmount;

    constructor(uint256 _vestingPeriod, address admin) {
        vestingPeriod = _vestingPeriod;
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, admin);
    }

    function setVestingAmount(address user, uint256 amount) external onlyRole(ADMIN_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        vestedAmounts[user] = amount;
        totalVestingAmount += amount;
        lastVestedTime[user] = block.timestamp;
    }

    function getNextScheduleEntry(address user) public view returns (uint256) {
        require(vestedAmounts[user] > 0, ""No vesting schedule set for this user"");
        uint256 timeSinceLastVested = block.timestamp.sub(lastVestedTime[user]);
        if (timeSinceLastVested >= vestingPeriod) {
            return vestedAmounts[user];
        } else {
            return 0;
        }
    }
}"
2223,Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenVerifier {
    using SafeMath for uint256;

    struct TokenRequirement {
        address tokenAddress;
        uint256 requiredAmount;
    }

    function verifyTokens(TokenRequirement[2] memory requirements) internal view returns (bool) {
        require(requirements.length == 2, ""Invalid number of token requirements"");

        for (uint i = 0; i < requirements.length; i++) {
            IToken token = IToken(requirements[i].tokenAddress);
            uint256 balance = token.balanceOf(address(this));
            require(balance >= requirements[i].requiredAmount, ""Insufficient tokens"");
        }

        return true;
    }
}",2.0075294971466064,verifyTokens,"[{'function': 'balanceOf', 'complexity': -1}, {'function': 'verifyTokens', 'complexity': 6}]",12.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenRequirement""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""name"": ""requirements"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requirements""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid number of token requirements""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requirements""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IToken""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requirements""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requirements""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""requiredAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient tokens""}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",54.0,0.6514836209411761,0.103267765974883,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
}

contract TokenVerifier is Ownable {;
    struct TokenRequirement {
        address tokenAddress;
        uint256 requiredAmount;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function verifyTokens(TokenRequirement[2] memory requirements) internal view returns (bool) {
        require(requirements.length == 2, ""Invalid number of token requirements"");

        for (uint i = 0; i < requirements.length; i++) {
            IToken token = IToken(requirements[i].tokenAddress);
            uint256 balance = token.balanceOf(address(this));
            require(balance >= requirements[i].requiredAmount, ""Insufficient tokens"");
        }

        return true;
    }
}"
3500,"Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transferToken(address token, address dest, uint256 amount) public returns (bool success) {
        require(IERC20(token).balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool callSuccess = IERC20(token).transfer(dest, amount);
        require(callSuccess, ""Token transfer failed"");
        return true;
    }
}",1.5192036628723145,transferToken,"[{'function': 'transferToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""dest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""callSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dest""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""callSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6885873152303659,0.1603955906872386,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferToken(address token, address dest, uint256 amount) public returns (bool success) {
        require(IERC20(token).balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool callSuccess = IERC20(token).transfer(dest, amount);
        require(callSuccess, ""Token transfer failed"");
        return true;
    }
}"
4517,returns the block number when the order being last modified .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}","pragma solidity ^0.8.0;

interface IOrder {
    function getLastModifiedBlock() external view returns (uint256);
}

contract OrderModifier {
    uint256 private constant MODIFIER_ROLE = 1;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyRole(uint256 role) {
        require(hasRole(role, msg.sender), ""Caller does not have the required role"");
        _;
    }

    mapping(address => uint256) public roles;

    function hasRole(uint256 role, address account) internal view returns (bool) {
        return roles[account] == role;
    }

    constructor() {
        owner = msg.sender;
        roles[msg.sender] = MODIFIER_ROLE;
    }

    function getLastModifiedBlock(address orderAddress) external view onlyRole(MODIFIER_ROLE) returns (uint256) {
        return IOrder(orderAddress).getLastModifiedBlock();
    }
}",2.4284188747406006,hasRole,"[{'function': 'getLastModifiedBlock', 'complexity': -2}, {'function': 'hasRole', 'complexity': 0}, {'function': 'getLastModifiedBlock', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasRole"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""roles""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""Identifier"", ""name"": ""role""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,0.3170664052280555,0.093546883188256,"pragma solidity ^0.8.0;

interface IOrder {
    function getLastModifiedBlock() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract OrderModifier is Ownable {
    uint256 private constant MODIFIER_ROLE = 1;
    mapping(address => uint256) public roles;

    modifier onlyRole(uint256 role) {
        require(hasRole(role, msg.sender), ""Caller does not have the required role"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        roles[msg.sender] = MODIFIER_ROLE;
    }

    function hasRole(uint256 role, address account) internal view returns (bool) {
        return roles[account] == role;
    }

    function getLastModifiedBlock(address orderAddress) external view onlyRole(MODIFIER_ROLE) returns (uint256) {
        return IOrder(orderAddress).getLastModifiedBlock();
    }
}"
868,batch send the current balance to the new version contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BatchTransfer is AccessControl {
    using SafeMath for uint256;

    address public newVersionContract;

    constructor(address _newVersionContract) {
        require(_newVersionContract != address(0), ""Invalid contract address"");
        newVersionContract = _newVersionContract;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function batchSendBalance() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 balance = IERC20(address(this)).balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");

        for (uint256 i = 0; i < balance / 10**18; i++) {
            IERC20(address(this)).transfer(newVersionContract, 10**18);
        }
    }
}",2.4565396308898926,batchSendBalance,"[{'function': 'batchSendBalance', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""batchSendBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to transfer""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newVersionContract""}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",130.0,0.5461359208327017,0.0171575778358181,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BatchTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    address public newVersionContract;

    mapping(address => uint256) public balanceOf;

 constructor(address _newVersionContract) Ownable(msg.sender) {
        require(_newVersionContract != address(0), ""Invalid contract address"");
        newVersionContract = _newVersionContract;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function batchSendBalance() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 balance = IERC20(address(this)).balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");

        for (uint256 i = 0; i < balance / 10**18; i++) {
            IERC20(address(this)).transfer(newVersionContract, 10**18);
        }
    }
}"
2092,Get a player 's current instant pot winnings .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}","pragma solidity ^0.8.0;

interface IPlayer {
    function getInstantPotWinnings(address player) external view returns (uint256);
}

contract Game {
    using SafeMath for uint256;

    mapping(address => uint256) private instantPotWinnings;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function setInstantPotWinnings(address player, uint256 amount) external onlyOwner {
        instantPotWinnings[player] = amount;
    }

    function getInstantPotWinnings(address player) external view returns (uint256) {
        return instantPotWinnings[player];
    }
}",1.9271998405456543,setInstantPotWinnings,"[{'function': 'getInstantPotWinnings', 'complexity': 0}, {'function': 'setInstantPotWinnings', 'complexity': 0}, {'function': 'getInstantPotWinnings', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInstantPotWinnings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""player"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""instantPotWinnings""}, ""index"": {""type"": ""Identifier"", ""name"": ""player""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.4740631946233556,0.0037500863528514,"pragma solidity ^0.8.0;

interface IPlayer {
    function getInstantPotWinnings(address player) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Game is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private instantPotWinnings;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setInstantPotWinnings(address player, uint256 amount) external onlyOwner {
        instantPotWinnings[player] = amount;
    }

    function getInstantPotWinnings(address player) external view returns (uint256) {
        return instantPotWinnings[player];
    }
}"
1597,add more ether to use in oraclize queries,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OraclizeFunds {
    using SafeMath for uint256;

    address public owner;
    uint256 public minBalanceForQuery;

    constructor(uint256 _minBalance) {
        owner = msg.sender;
        minBalanceForQuery = _minBalance;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function addFundsForOraclize(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        require(address(this).balance.add(amount) >= minBalanceForQuery, ""Insufficient balance to cover Oraclize queries"");

        // Additional logic can be added here
    }
}",2.051713228225708,addFundsForOraclize,"[{'function': 'addFundsForOraclize', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addFundsForOraclize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""minBalanceForQuery""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to cover Oraclize queries""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",25.0,0.3925322340435679,0.0125269428077597,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract OraclizeFunds is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public minBalanceForQuery = 1;

    constructor(uint256 _minBalance) Ownable(msg.sender) {
        minBalanceForQuery = _minBalance;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function addFundsForOraclize(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        require(address(this).balance.add(amount) >= minBalanceForQuery, ""Insufficient balance to cover Oraclize queries"");

        // Additional logic can be added here
    }
}"
3185,To check if an address is a contract or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}","pragma solidity ^0.8.0;

interface IContractChecker {
    function isContract(address addr) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction underflow"");
        return a - b;
    }
}

contract ContractChecker is IContractChecker {
    using SafeMath for uint256;

    function isContract(address addr) public override view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",2.0043647289276123,isContract,"[{'function': 'isContract', 'complexity': 0}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.8754164745742989,0.3264524516731021,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IContractChecker {
    function isContract(address addr) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction underflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ContractChecker is IContractChecker, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isContract(address addr) public override view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
146,Add to the amount this member has bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MemberPurchase is AccessControl {
    using SafeMath for uint256;

    struct Member {
        uint256 amountBought;
    }

    mapping(address => Member) public members;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addToAmountBought(uint256 amount, address member) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        members[member].amountBought = members[member].amountBought.add(amount);
    }
}",1.7797958850860596,addToAmountBought,"[{'function': 'addToAmountBought', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToAmountBought"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""member""}}, ""memberName"": ""amountBought""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""member""}}, ""memberName"": ""amountBought""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.864439045204558,0.040345910988383,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MemberPurchase is AccessControl, Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 amountBought;
    }

    mapping(address => Member) public members;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addToAmountBought(uint256 amount, address member) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        members[member].amountBought = members[member].amountBought.add(amount);
    }
}"
5173,` msg.sender ` approves ` spender ` to spend ` value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApproval is Ownable {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function approveTokenSpend(address spender, uint256 value) external onlyOwner returns (bool) {
        return token.approve(spender, value);
    }
}",1.2943172454833984,approveTokenSpend,"[{'function': 'approveTokenSpend', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTokenSpend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.8257032498740368,0.2141201816994799,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function approveTokenSpend(address spender, uint256 value) external onlyOwner returns (bool) {
        return token.approve(spender, value);
    }
}"
4527,Funtion to let users claim their tokens at the end of ico process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenClaim is Ownable {
    IERC20 public token;
    mapping(address => bool) public claimed;

    event TokensClaimed(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function claimTokens() external {
        require(!claimed[msg.sender], ""Tokens already claimed"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to claim"");
        token.transfer(msg.sender, balance);
        claimed[msg.sender] = true;
        emit TokensClaimed(msg.sender, balance);
    }
}",2.021556854248047,claimTokens,"[{'function': 'claimTokens', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens already claimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensClaimed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.786403095664883,0.0650211214283644,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenClaim is Ownable {
    IERC20 public token;
    mapping(address => bool) public claimed;

    event TokensClaimed(address indexed user, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function claimTokens() external {
        require(!claimed[msg.sender], ""Tokens already claimed"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to claim"");
        token.transfer(msg.sender, balance);
        claimed[msg.sender] = true;
        emit TokensClaimed(msg.sender, balance);
    }
}"
5993,"Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    function transferToken(address tokenAddress, address recipient, uint256 amount) public onlyOwner returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(address(this)) >= amount, ""Insufficient balance"");
        bool success = token.transferFrom(owner(), recipient, amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}",1.495537519454956,transferToken,"[{'function': 'transferToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.6111870016542646,0.107627467740405,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferToken(address tokenAddress, address recipient, uint256 amount) public onlyOwner returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(address(this)) >= amount, ""Insufficient balance"");
        bool success = token.transferFrom(owner(), recipient, amount);
        require(success, ""Token transfer failed"");
        return true;
    }
}"
2061,Checks if the notary 's signature to close the ` DataResponse ` is valid .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}","pragma solidity ^0.8.0;

interface IDataResponse {
    function getNotarySignature() external view returns (bytes memory);
}

contract DataResponseValidator {
    address public notaryAddress;

    constructor(address _notaryAddress) {
        notaryAddress = _notaryAddress;
    }

    modifier onlyNotary() {
        require(msg.sender == notaryAddress, ""Only the notary can call this function"");
        _;
    }

    function isValidSignature(IDataResponse dataResponse) public view returns (bool) {
        bytes memory signature = dataResponse.getNotarySignature();
        // Assuming there's a way to validate the signature, e.g., using ECDSA for simplicity
        require(signature.length == 65, ""Invalid signature length"");
        return true; // Placeholder until actual validation logic is implemented
    }
}",1.842764139175415,isValidSignature,"[{'function': 'getNotarySignature', 'complexity': 0}, {'function': 'isValidSignature', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValidSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IDataResponse""}, ""name"": ""dataResponse"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dataResponse""}, ""memberName"": ""getNotarySignature""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signature""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""65"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature length""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.5342210611651306,0.0716363961403813,"pragma solidity ^0.8.0;

interface IDataResponse {
    function getNotarySignature() external view returns (bytes memory);
}
import ""openzeppelin/SafeMath.sol"";
contract DataResponseValidator is Ownable {
    address public notaryAddress;

    constructor(address _notaryAddress) Ownable(msg.sender) {
        notaryAddress = _notaryAddress;
    }

    modifier onlyNotary() {
        require(msg.sender == notaryAddress, ""Only the notary can call this function"");
        _;
    }

    function isValidSignature(IDataResponse dataResponse) public view returns (bool) {
        bytes memory signature = dataResponse.getNotarySignature();
        // Assuming there's a way to validate the signature, e.g., using ECDSA for simplicity
        require(signature.length == 65, ""Invalid signature length"");
        return true; // Placeholder until actual validation logic is implemented
    }
}"
1609,Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CloneTokenCreation {
    using SafeMath for uint256;

    address public owner;
    IERC20 public originalToken;
    uint256 public snapshotBlock;

    constructor(address _originalToken, uint256 _snapshotBlock) {
        require(_originalToken != address(0), ""Invalid token address"");
        originalToken = IERC20(_originalToken);
        snapshotBlock = _snapshotBlock;
        owner = msg.sender;
    }

    function createCloneToken() external {
        require(msg.sender == owner, ""Only owner can create clone tokens"");
        uint256 balanceAtSnapshot = originalToken.balanceOf(address(this)).sub(originalToken.allowance(address(this), address(this)));
        IERC20 newToken = new ERC20Detailed(""Clone of Original Token"", ""CLONE"", snapshotBlock);
        require(newToken.transfer(msg.sender, balanceAtSnapshot), ""Transfer failed"");
    }
}",2.524116277694702,createCloneToken,"[{'function': 'createCloneToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owner can create clone tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceAtSnapshot"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""originalToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""originalToken""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20Detailed""}}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Clone of Original Token""}, {""type"": ""stringLiteral"", ""value"": ""CLONE""}, {""type"": ""Identifier"", ""name"": ""snapshotBlock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balanceAtSnapshot""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.7394477788418283,0.1374050478168771,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol"";

contract CloneTokenCreation is Ownable, ERC20Detailed {
    using SafeMath for uint256;

    IERC20 public originalToken;
    uint256 public snapshotBlock;

    mapping(address => uint256) public balanceOf;

 constructor(address _originalToken, uint256 _snapshotBlock)
        ERC20Detailed(""Clone of Original Token"", ""CLONE"", _snapshotBlock)
        Ownable() {
        require(_originalToken != address(0), ""Invalid token address"");
        originalToken = IERC20(_originalToken);
        snapshotBlock = _snapshotBlock;
        owner = msg.sender;
    }

    function createCloneToken() external {
        require(msg.sender == owner, ""Only owner can create clone tokens"");
        uint256 balanceAtSnapshot = originalToken.balanceOf(address(this)).sub(originalToken.allowance(address(this), address(this)));
        IERC20 newToken = new ERC20Detailed(""Clone of Original Token"", ""CLONE"", snapshotBlock);
        require(newToken.transfer(msg.sender, balanceAtSnapshot), ""Transfer failed"");
    }
}"
2752,"If you lock 50 % , the lockout time is six months .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LockContract {
    using SafeMath for uint256;

    enum LockStatus { Locked, Unlocked }

    struct LockInfo {
        uint256 amountLocked;
        uint256 unlockTime;
        LockStatus status;
    }

    mapping(address => LockInfo) public lockInfos;

    function lockTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 sixMonths = block.timestamp + 180 days; // Assuming each month is 30 days for simplicity
        lockInfos[msg.sender] = LockInfo({
            amountLocked: _amount,
            unlockTime: sixMonths,
            status: LockStatus.Locked
        });
    }
}",1.9399309158325195,lockTokens,"[{'function': 'lockTokens', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""lockTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sixMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""180"", ""subdenomination"": ""days""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockInfos""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LockInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""sixMonths""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""LockStatus""}, ""memberName"": ""Locked""}], ""names"": [""amountLocked"", ""unlockTime"", ""status""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",105.0,0.5238449773087042,0.0097598174811636,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract LockContract is Ownable {
    using SafeMath for uint256;

    enum LockStatus { Locked, Unlocked }

    struct LockInfo {
        uint256 amountLocked;
        uint256 unlockTime;
        LockStatus status;
    }

    mapping(address => LockInfo) public lockInfos;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            lockInfos[addr] = LockInfo({
                amountLocked: 1,
                unlockTime: block.timestamp + 180 days,
                status: LockStatus.Locked
            });
        }
    }

    function lockTokens(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 sixMonths = block.timestamp + 180 days; // Assuming each month is 30 days for simplicity
        lockInfos[msg.sender] = LockInfo({
            amountLocked: _amount,
            unlockTime: sixMonths,
            status: LockStatus.Locked
        });
    }
}"
6641,Make bulk transfer of tokens to many addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BulkTokenTransfer {
    using SafeMath for uint256;

    function bulkTransferTokens(address[] memory recipients, uint256 amount) public returns (bool success) {
        require(recipients.length > 0, ""No recipients provided"");

        IERC20 token = IERC20(0xYourTokenAddress); // Replace with actual token address
        uint256 totalAmount = amount.mul(recipients.length);

        require(token.balanceOf(msg.sender) >= totalAmount, ""Insufficient balance"");
        require(token.allowance(msg.sender, address(this)) >= totalAmount, ""Allowance too low"");

        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amount);
        }

        return true;
    }
}",2.3687832355499268,bulkTransferTokens,"[{'function': 'bulkTransferTokens', 'complexity': 4}]",5.0,{},45.0,0.6631643150073406,0.2126831129066792,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BulkTokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        token = IERC20(0xYourTokenAddress); // Replace with actual token address
        amount = 1;
    }

    IERC20 public token;
    uint256 public amount;

    function bulkTransferTokens(address[] memory recipients) public returns (bool success) {
        require(recipients.length > 0, ""No recipients provided"");
        require(msg.sender == owner(), ""Caller is not the owner"");

        uint256 totalAmount = amount.mul(recipients.length);

        require(token.balanceOf(msg.sender) >= totalAmount, ""Insufficient balance"");
        require(token.allowance(msg.sender, address(this)) >= totalAmount, ""Allowance too low"");

        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amount);
        }

        return true;
    }
}"
2380,The contract address is always the message sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function transferTokens(address to, uint256 amount) public onlyRole(ADMIN_ROLE) {
        require(balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        _transfer(msg.sender, to, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
        return 0; // Placeholder for actual balance logic
    }

    function _transfer(address from, address to, uint256 amount) internal virtual {}
}",2.236147880554199,transferTokens,"[{'function': 'transferTokens', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.4692274349334429,0.0249561844985001,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function transferTokens(address to, uint256 amount) public onlyRole(ADMIN_ROLE) {
        require(balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        _transfer(msg.sender, to, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
        return 0; // Placeholder for actual balance logic
    }

    function _transfer(address from, address to, uint256 amount) internal virtual {}
}"
4661,"Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenSender {
    address private immutable baseTokenAddress;

    constructor(address _baseToken) {
        baseTokenAddress = _baseToken;
    }

    function sendTokens(address payable _to, uint256 _amount) external onlyOwner {
        IERC20 token = IERC20(baseTokenAddress);
        require(token.transfer(_to, _amount), ""Transfer failed"");
    }
}",1.2694742679595947,sendTokens,"[{'function': 'sendTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""baseTokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8273476478384232,0.2873892099676446,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSender is Ownable {
    address private immutable baseTokenAddress;

    constructor(address _baseToken) Ownable(msg.sender) {
        baseTokenAddress = _baseToken;
    }

    function sendTokens(address payable _to, uint256 _amount) external onlyOwner {
        IERC20 token = IERC20(baseTokenAddress);
        require(token.transfer(_to, _amount), ""Transfer failed"");
    }
}"
3343,Allow pre-approved user to take ownership of a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenOwnerTransfer is Ownable {
    IERC20 public token;
    mapping(address => bool) public preApprovedUsers;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function addPreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = true;
    }

    function removePreApprovedUser(address user) external onlyOwner {
        delete preApprovedUsers[user];
    }

    function transferTokenToUser(address to, uint256 amount) external {
        require(preApprovedUsers[msg.sender], ""You are not pre-approved to take ownership of this token."");
        require(token.balanceOf(address(this)) >= amount, ""Contract does not have enough tokens to transfer."");
        token.transfer(to, amount);
    }
}",2.3162708282470703,transferTokenToUser,"[{'function': 'addPreApprovedUser', 'complexity': 0}, {'function': 'removePreApprovedUser', 'complexity': 0}, {'function': 'transferTokenToUser', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokenToUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preApprovedUsers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You are not pre-approved to take ownership of this token.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Contract does not have enough tokens to transfer.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.499216896659475,0.0052127833685007,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnerTransfer is Ownable {
    IERC20 public token;
    mapping(address => bool) public preApprovedUsers;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        preApprovedUsers[address(0x111)] = true;
        preApprovedUsers[address(0x222)] = true;
        preApprovedUsers[address(0x333)] = true;
    }

    function addPreApprovedUser(address user) external onlyOwner {
        preApprovedUsers[user] = true;
    }

    function removePreApprovedUser(address user) external onlyOwner {
        delete preApprovedUsers[user];
    }

    function transferTokenToUser(address to, uint256 amount) external {
        require(preApprovedUsers[msg.sender], ""You are not pre-approved to take ownership of this token."");
        require(token.balanceOf(address(this)) >= amount, ""Contract does not have enough tokens to transfer."");
        token.transfer(to, amount);
    }
}"
6562,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    event TokensMinted(address indexed to, uint256 value);

    constructor() public {}

    function mintTokens(address _to, uint256 _value) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");

        // Additional logic can be added here
        balanceOf[_to] = balanceOf[_to].add(_value);
        totalSupply = totalSupply.add(_value);

        emit TokensMinted(_to, _value);
    }

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
}",2.1004204750061035,mintTokens,"[{'function': 'mintTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensMinted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.4082791666274012,0.0095101072505658,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    event TokensMinted(address indexed to, uint256 value);

    constructor() Ownable(msg.sender) public {
        balanceOf[owner()] = 1; // Initialize the owner's balance to 1
        totalSupply = 1000000000000000000; // Initialize the total supply to 1
    }

    function mintTokens(address _to, uint256 _value) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");

        // Additional logic can be added here
        balanceOf[_to] = balanceOf[_to].add(_value);
        totalSupply = totalSupply.add(_value);

        emit TokensMinted(_to, _value);
    }

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
}"
52,Function to claim any token stuck on contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ClaimTokens is Ownable {
    using SafeMath for uint256;

    event TokensClaimed(address indexed token, address indexed to, uint256 amount);

    function claimToken(address tokenAddress, address recipient, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(recipient, amount), ""Transfer failed"");
        emit TokensClaimed(tokenAddress, recipient, amount);
    }
}",1.7133910655975342,claimToken,"[{'function': 'claimToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensClaimed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.8219027299775564,0.2059408312253637,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ClaimTokens is Ownable {
    using SafeMath for uint256;

    event TokensClaimed(address indexed token, address indexed to, uint256 amount);

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function claimToken(address tokenAddress, address recipient, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(recipient, amount), ""Transfer failed"");
        emit TokensClaimed(tokenAddress, recipient, amount);
    }
}"
5414,Performs allowance transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract AllowanceTransfer {
    IERC20 public token;
    address owner;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
        owner = msg.sender;
    }

    function transferAllowance(address sender, address recipient, uint256 amount) external {
        require(msg.sender == owner, ""Only owner can perform this action"");
        require(token.transferFrom(sender, recipient, amount), ""Token transfer failed"");
    }
}",1.4992973804473877,transferAllowance,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferAllowance', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owner can perform this action""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6313427731344189,0.101984713789658,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract AllowanceTransfer is Ownable {
    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function transferAllowance(address sender, address recipient, uint256 amount) external {
        require(owner() == msg.sender, ""Only owner can perform this action"");
        require(token.transferFrom(sender, recipient, amount), ""Token transfer failed"");
    }
}"
3148,Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Auction is AccessControl {
    using SafeMath for uint256;

    enum AuctionStage {
        Bidding,
        Finalizing
    }

    address public owner;
    uint256 public biddingEndTime;
    uint256 public finalPrice;
    AuctionStage public stage;

    event AuctionFinalized(uint256 finalPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(uint256 biddingDuration) {
        owner = msg.sender;
        stage = AuctionStage.Bidding;
        biddingEndTime = block.timestamp + biddingDuration;
    }

    function finalizeAuction() external onlyOwner {
        require(stage == AuctionStage.Bidding, ""Auction is not in bidding phase"");
        require(block.timestamp >= biddingEndTime, ""Bidding period has not ended yet"");
        stage = AuctionStage.Finalizing;
        finalPrice = getCurrentPrice(); // Implement the logic to calculate the final price
        emit AuctionFinalized(finalPrice);
    }

    function getCurrentPrice() internal view returns (uint256) {
        // Implement the logic to determine the current price based on bids received
        return 0; // Placeholder, replace with actual calculation
    }
}",3.213371753692627,finalizeAuction,"[{'function': 'finalizeAuction', 'complexity': 2}, {'function': 'getCurrentPrice', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""Bidding""}}, {""type"": ""stringLiteral"", ""value"": ""Auction is not in bidding phase""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""biddingEndTime""}}, {""type"": ""stringLiteral"", ""value"": ""Bidding period has not ended yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""Finalizing""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCurrentPrice""}, ""arguments"": [], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionFinalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalPrice""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.8614697889727895,0.0622510184432996,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    enum AuctionStage {
        Bidding,
        Finalizing
    }

    address public owner = msg.sender;
    uint256 public biddingEndTime;
    uint256 public finalPrice;
    AuctionStage public stage = AuctionStage.Bidding;

    event AuctionFinalized(uint256 finalPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(uint256 biddingDuration) Ownable(msg.sender) {
        biddingEndTime = block.timestamp + biddingDuration;
    }

    function finalizeAuction() external onlyOwner {
        require(stage == AuctionStage.Bidding, ""Auction is not in bidding phase"");
        require(block.timestamp >= biddingEndTime, ""Bidding period has not ended yet"");
        stage = AuctionStage.Finalizing;
        finalPrice = getCurrentPrice(); // Implement the logic to calculate the final price
        emit AuctionFinalized(finalPrice);
    }

    function getCurrentPrice() internal view returns (uint256) {
        // Implement the logic to determine the current price based on bids received
        return 0; // Placeholder, replace with actual calculation
    }
}"
1735,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SecurityGuardDelayedPayment {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public securityGuards;
    uint256 public delaySeconds;

    event PaymentDelaySet(uint256 seconds);
    event PaymentReleased(address indexed to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    modifier onlySecurityGuard() {
        require(securityGuards[msg.sender], ""Only security guards can call this function."");
        _;
    }

    constructor(uint256 _delaySeconds) {
        owner = msg.sender;
        delaySeconds = _delaySeconds;
    }

    function setPaymentDelay(uint256 seconds) public onlyOwner {
        delaySeconds = seconds;
        emit PaymentDelaySet(seconds);
    }

    function releasePayments() public payable onlySecurityGuard {
        require(block.timestamp >= delaySeconds, ""The payment is still delayed."");
        uint256 amount = address(this).balance;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed."");
        emit PaymentReleased(msg.sender, amount);
    }
}",3.054583787918091,releasePayments,"[{'function': 'setPaymentDelay', 'complexity': 0}, {'function': 'releasePayments', 'complexity': 2}]",3.0,{},52.0,0.6888052644359428,0.0356395524077311,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SecurityGuardDelayedPayment is Ownable {;
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public securityGuards;
    uint256 public delaySeconds = 0; // Set to 0 instead of _delaySeconds to avoid zero state

    event PaymentDelaySet(uint256 seconds);
    event PaymentReleased(address indexed to, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    modifier onlySecurityGuard() {
        require(securityGuards[msg.sender], ""Only security guards can call this function."");
        _;
    }

    constructor(uint256 _delaySeconds) Ownable(_delaySeconds > 0 ? msg.sender : address(0)) {
        delaySeconds = _delaySeconds;
    }

    function setPaymentDelay(uint256 seconds) public onlyOwner {
        delaySeconds = seconds;
        emit PaymentDelaySet(seconds);
    }

    function releasePayments() public payable onlySecurityGuard {
        require(block.timestamp >= delaySeconds, ""The payment is still delayed."");
        uint256 amount = address(this).balance;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed."");
        emit PaymentReleased(msg.sender, amount);
    }
}"
170,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint256[] memory prices) external;
}

contract HavvenPriceUpdater is Ownable {
    using SafeMath for uint256;

    address public oracleAddress;

    constructor(address _oracleAddress) {
        require(_oracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _oracleAddress;
    }

    function setOracleAddress(address _newOracleAddress) external onlyOwner {
        require(_newOracleAddress != address(0), ""New Oracle address cannot be zero"");
        oracleAddress = _newOracleAddress;
    }

    function updateHavvenPrices(uint256[] memory prices) external onlyOwner {
        require(oracleAddress != address(0), ""Oracle address must be set"");
        IOracle(oracleAddress).updatePrices(prices);
    }
}",2.257744073867798,setOracleAddress,"[{'function': 'updatePrices', 'complexity': 0}, {'function': 'setOracleAddress', 'complexity': 1}, {'function': 'updateHavvenPrices', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOracleAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOracleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New Oracle address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""oracleAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.4139502358941994,0.0153177770686572,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint256[] memory prices) external;
}

contract HavvenPriceUpdater is Ownable {
    using SafeMath for uint256;

    address public oracleAddress;

    constructor(address _oracleAddress) Ownable(_oracleAddress) {
        require(_oracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _oracleAddress;
    }

    function setOracleAddress(address _newOracleAddress) external onlyOwner {
        require(_newOracleAddress != address(0), ""New Oracle address cannot be zero"");
        oracleAddress = _newOracleAddress;
    }

    function updateHavvenPrices(uint256[] memory prices) external onlyOwner {
        require(oracleAddress != address(0), ""Oracle address must be set"");
        IOracle(oracleAddress).updatePrices(prices);
    }
}"
5043,This function burns all B2BK tokens on the address that caused this function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BurnTokens is Ownable {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function burnTokens(address from) external onlyOwner {
        uint256 balance = token.balanceOf(from);
        require(balance > 0, ""No tokens to burn"");
        require(token.transferFrom(from, address(this), balance), ""Transfer failed"");
        emit TokensBurned(from, balance);
    }

    event TokensBurned(address indexed user, uint256 amount);
}",1.7821547985076904,burnTokens,"[{'function': 'burnTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensBurned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7373770279332891,0.0359355459461638,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BurnTokens is Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function burnTokens(address from) external onlyOwner {
        uint256 balance = token.balanceOf(from);
        require(balance > 0, ""No tokens to burn"");
        require(token.transferFrom(from, address(this), balance), ""Transfer failed"");
        emit TokensBurned(from, balance);
    }

    event TokensBurned(address indexed user, uint256 amount);
}"
3040,This function returns the signature of configure function,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {
    bytes32 public constant CONFIGURE_ROLE = keccak256(""CONFIGURE_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONFIGURE_ROLE, msg.sender);
    }

    function configure(uint256 param1, string memory param2) public onlyRole(CONFIGURE_ROLE) {
        // Function logic here
    }
}",1.288743019104004,configure,"[{'function': 'configure', 'complexity': 0}]",1.0,{},7.0,0.3117761290613554,0.0324871150576476,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl, Ownable {
    bytes32 public constant CONFIGURE_ROLE = keccak256(""CONFIGURE_ROLE"");

    constructor(address admin) AccessControl() Ownable(admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONFIGURE_ROLE, msg.sender);
    }

    function configure(uint256 param1, string memory param2) public onlyRole(CONFIGURE_ROLE) {
        // Function logic here
    }
}"
4025,Converts WT0 to CarbonUSD for the user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IWT0 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface ICarbonUSD {
    function mint(address to, uint256 amount) external;
}

contract WT0toCarbonUSDConverter {
    using SafeMath for uint256;

    IWT0 public wt0Token;
    ICarbonUSD public carbonUsdToken;

    constructor(address _wt0Address, address _carbonUsdAddress) {
        wt0Token = IWT0(_wt0Address);
        carbonUsdToken = ICarbonUSD(_carbonUsdAddress);
    }

    function convertWT0ToCarbonUSD(uint256 amount, address user) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = wt0Token.balanceOf(user);
        require(balanceBefore >= amount, ""Insufficient balance of WT0"");

        bool transferSuccess = wt0Token.transfer(user, amount);
        require(transferSuccess, ""Transfer of WT0 failed"");

        uint256 balanceAfter = wt0Token.balanceOf(user);
        require(balanceAfter == balanceBefore.sub(amount), ""Incorrect balance after transfer"");

        carbonUsdToken.mint(user, amount);
    }
}",3.3959758281707764,convertWT0ToCarbonUSD,"[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 0}, {'function': 'convertWT0ToCarbonUSD', 'complexity': 4}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWT0ToCarbonUSD"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceBefore"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wt0Token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balanceBefore""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance of WT0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wt0Token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Transfer of WT0 failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceAfter"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wt0Token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""balanceAfter""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceBefore""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect balance after transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""carbonUsdToken""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.7331107734571589,0.0286877858201366,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IWT0 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface ICarbonUSD {
    function mint(address to, uint256 amount) external;
}

contract WT0toCarbonUSDConverter is Ownable {
    using SafeMath for uint256;

    IWT0 public wt0Token;
    ICarbonUSD public carbonUsdToken;

    mapping(address => uint256) public balanceOf;

 constructor(address _wt0Address, address _carbonUsdAddress) Ownable(msg.sender) {
        wt0Token = IWT0(_wt0Address);
        carbonUsdToken = ICarbonUSD(_carbonUsdAddress);
    }

    function convertWT0ToCarbonUSD(uint256 amount, address user) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balanceBefore = wt0Token.balanceOf(user);
        require(balanceBefore >= amount, ""Insufficient balance of WT0"");

        bool transferSuccess = wt0Token.transfer(user, amount);
        require(transferSuccess, ""Transfer of WT0 failed"");

        uint256 balanceAfter = wt0Token.balanceOf(user);
        require(balanceAfter == balanceBefore.sub(amount), ""Incorrect balance after transfer"");

        carbonUsdToken.mint(user, amount);
    }
}"
281,Announces intent to cancel tokens using ` slowCancel `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenCanceler is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CANCELER_ROLE = keccak256(""CANCELER_ROLE"");
    mapping(address => bool) public canceledTokens;

    event TokensCanceled(address indexed token, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setCancelerRole(address account) external onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(CANCELER_ROLE, account);
    }

    function cancelTokens(address token, uint256 amount) external onlyRole(CANCELER_ROLE) {
        require(!canceledTokens[token], ""Tokens already canceled"");
        IERC20(token).transfer(msg.sender, amount);
        canceledTokens[token] = true;
        emit TokensCanceled(token, amount);
    }
}",2.447551012039185,cancelTokens,"[{'function': 'setCancelerRole', 'complexity': 0}, {'function': 'cancelTokens', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canceledTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens already canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canceledTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensCanceled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CANCELER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5736219845001178,0.0387433469145128,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenCanceler is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CANCELER_ROLE = keccak256(""CANCELER_ROLE"");
    mapping(address => bool) public canceledTokens;

    event TokensCanceled(address indexed token, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setCancelerRole(address account) external onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(CANCELER_ROLE, account);
    }

    function cancelTokens(address token, uint256 amount) external onlyRole(CANCELER_ROLE) {
        require(!canceledTokens[token], ""Tokens already canceled"");
        IERC20(token).transfer(msg.sender, amount);
        canceledTokens[token] = true;
        emit TokensCanceled(token, amount);
    }
}"
5915,This is public rather than external so we can call super.unpause without using an expensive CALL .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Pausable {
    function unpauseFunction() public override onlyOwner whenPaused {
        super.unpause();
    }
}",0.6926889419555664,unpauseFunction,"[{'function': 'unpauseFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpauseFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.748195987984253,0.0059155185063893,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    constructor() Pausable(), Ownable(msg.sender) {}

    function unpauseFunction() public override onlyOwner whenPaused {
        super.unpause();
    }
}"
1091,"owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    bool public crowdsaleSucceeded;
    mapping(address => uint256) public balances;

    constructor() {
        crowdsaleSucceeded = false;
    }

    function sendEtherToAddress(address to, uint256 value) external onlyOwner {
        require(crowdsaleSucceeded, ""Crowdsale has not succeeded yet."");
        payable(to).transfer(value);
        balances[to] = balances[to].add(value);
    }
}",1.675711154937744,sendEtherToAddress,"[{'function': 'sendEtherToAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendEtherToAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""crowdsaleSucceeded""}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale has not succeeded yet.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.8550621041085634,0.1339490615430709,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    bool public crowdsaleSucceeded;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        crowdsaleSucceeded = false;
    }

    function sendEtherToAddress(address to, uint256 value) external onlyOwner {
        require(crowdsaleSucceeded, ""Crowdsale has not succeeded yet."");
        payable(to).transfer(value);
        balances[to] = balances[to].add(value);
    }
}"
2215,Notifies the controller about an approval allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}","pragma solidity ^0.8.0;

interface IController {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external returns (bytes4);
}

contract MyContract {
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
    }

    function approveAndNotifyController(address to, uint256 tokenId, bytes memory data) external onlyController {
        require(to != address(0), ""Invalid recipient"");
        IERC721(this).approve(to, tokenId);
        emit Approval(msg.sender, to, tokenId);
        if (isContract(to)) {
            IController(to).onERC721Received(msg.sender, msg.sender, tokenId, data);
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",2.5372769832611084,approveAndNotifyController,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'approveAndNotifyController', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndNotifyController"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""onERC721Received""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5615415996839661,0.1688535468469239,"pragma solidity ^0.8.0;

interface IController {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external returns (bytes4);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) Ownable(_controller) {
        controller = _controller;
    }

    function approveAndNotifyController(address to, uint256 tokenId, bytes memory data) external onlyOwner {
        require(to != address(0), ""Invalid recipient"");
        IERC721(this).approve(to, tokenId);
        emit Approval(msg.sender, to, tokenId);
        if (isContract(to)) {
            IController(to).onERC721Received(msg.sender, msg.sender, tokenId, data);
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
5767,Withdraws tokens other than DGZ to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Withdrawal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public beneficiary;

    constructor(address _token, address _beneficiary) {
        require(_token != address(0), ""Invalid token address"");
        require(_beneficiary != address(0), ""Invalid beneficiary address"");
        token = IERC20(_token);
        beneficiary = _beneficiary;
    }

    function withdrawTokens() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to withdraw"");
        bool success = token.transfer(beneficiary, balance);
        require(success, ""Token transfer failed"");
    }
}",2.216571569442749,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to withdraw""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7643735957716872,0.1072741987899604,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Withdrawal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public beneficiary;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _beneficiary) Ownable(msg.sender) {
        require(_token != address(0), ""Invalid token address"");
        require(_beneficiary != address(0), ""Invalid beneficiary address"");
        token = IERC20(_token);
        beneficiary = _beneficiary;
    }

    function withdrawTokens() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to withdraw"");
        bool success = token.transfer(beneficiary, balance);
        require(success, ""Token transfer failed"");
    }
}"
3863,Claim token after token sale based on stake .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenClaim is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => bool) public claimed;
    bytes32 public constant CLAIMER_ROLE = keccak256(""CLAIMER_ROLE"");

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CLAIMER_ROLE, admin);
        token = IERC20(_token);
    }

    function claimTokens() external {
        require(!claimed[msg.sender], ""Tokens already claimed"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to claim"");
        uint256 amount = balance.div(10); // Example: Claim 10% of the total supply
        token.transfer(msg.sender, amount);
        claimed[msg.sender] = true;
    }
}",2.688352584838867,claimTokens,"[{'function': 'claimTokens', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens already claimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available to claim""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",58.0,0.7128353238653679,0.0644837981982129,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenClaim is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => bool) public claimed;
    bytes32 public constant CLAIMER_ROLE = keccak256(""CLAIMER_ROLE"");

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CLAIMER_ROLE, admin);
        token = IERC20(_token);
    }

    function claimTokens() external {
        require(!claimed[msg.sender], ""Tokens already claimed"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available to claim"");
        uint256 amount = balance.div(10); // Example: Claim 10% of the total supply
        token.transfer(msg.sender, amount);
        claimed[msg.sender] = true;
    }
}"
6728,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ForcedTransfer {
    using SafeMath for uint256;
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
    }

    function executeTransfer(address token, address to, uint256 amount) external onlyController {
        require(to != address(0), ""Invalid recipient address."");
        IERC20(token).transfer(to, amount);
    }
}",1.5083560943603516,executeTransfer,"[{'function': 'executeTransfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",55.0,0.6779241011657373,0.060495668771622,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ForcedTransfer is Ownable {
    using SafeMath for uint256;

    address public controller = 0x1111111111111111111111111111111111111111; // Replace with your controller address
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        controller = 0x2222222222222222222222222222222222222222; // Replace with your controller address
        initialized = true;
        initValue = bytes32('initialized');
    }

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    function executeTransfer(address token, address to, uint256 amount) external onlyController {
        require(to != address(0), ""Invalid recipient address."");
        IERC20(token).transfer(to, amount);
    }
}"
691,Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ValidatorRole is AccessControl {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    mapping(address => bool) private validators;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VALIDATOR_ROLE, msg.sender);
    }

    function addValidator(address validator) public onlyRole(VALIDATOR_ROLE) {
        validators[validator] = true;
    }

    function removeValidator(address validator) public onlyRole(VALIDATOR_ROLE) {
        validators[validator] = false;
    }

    function isValidator(address validator) public view returns (bool) {
        return validators[validator];
    }
}

contract AttributeIssuer is ValidatorRole {
    struct Attribute {
        uint256 attributeTypeID;
        bool issued;
    }

    mapping(address => mapping(uint256 => Attribute)) public attributes;

    function issueAttribute(address validator, uint256 attributeTypeID) public onlyRole(VALIDATOR_ROLE) {
        require(validators[validator], ""Validator not authorized"");
        attributes[validator][attributeTypeID].attributeTypeID = attributeTypeID;
        attributes[validator][attributeTypeID].issued = true;
    }

    function isAttributeIssued(address validator, uint256 attributeTypeID) public view returns (bool) {
        return attributes[validator][attributeTypeID].issued;
    }
}",3.3365259170532227,issueAttribute,"[{'function': 'addValidator', 'complexity': 0}, {'function': 'removeValidator', 'complexity': 0}, {'function': 'isValidator', 'complexity': 0}, {'function': 'issueAttribute', 'complexity': 1}, {'function': 'isAttributeIssued', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""issueAttribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, {""type"": ""stringLiteral"", ""value"": ""Validator not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributes""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""attributeTypeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributes""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""issued""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.8532874577622328,0.1970337270187119,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorRole is AccessControl, Ownable {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    mapping(address => bool) private validators;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VALIDATOR_ROLE, msg.sender);
    }

    function addValidator(address validator) public onlyRole(VALIDATOR_ROLE) {
        validators[validator] = true;
    }

    function removeValidator(address validator) public onlyRole(VALIDATOR_ROLE) {
        validators[validator] = false;
    }

    function isValidator(address validator) public view returns (bool) {
        return validators[validator];
    }
}
import ""openzeppelin/SafeMath.sol"";
contract AttributeIssuer is ValidatorRole {
    struct Attribute {
        uint256 attributeTypeID;
        bool issued;
    }

    mapping(address => mapping(uint256 => Attribute)) public attributes;

    constructor() Ownable(msg.sender) {
        // No additional initialization needed for state variables as they are already initialized to safe, non-corner-case values in the parent contract.
    }

    function issueAttribute(address validator, uint256 attributeTypeID) public onlyRole(VALIDATOR_ROLE) {
        require(validators[validator], ""Validator not authorized"");
        attributes[validator][attributeTypeID].attributeTypeID = attributeTypeID;
        attributes[validator][attributeTypeID].issued = true;
    }

    function isAttributeIssued(address validator, uint256 attributeTypeID) public view returns (bool) {
        return attributes[validator][attributeTypeID].issued;
    }
}"
876,Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VaultFinance is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _periodDuration;
    address private _vault;

    constructor(uint256 periodDuration, address vault) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _periodDuration = periodDuration;
        _vault = vault;
    }

    function initializeVaultFinance(uint256 periodDuration, address vault) external {
        require(!hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Sender must not be the default admin"");
        require(!hasRole(ADMIN_ROLE, msg.sender), ""Sender already has ADMIN_ROLE"");
        _setupRole(ADMIN_ROLE, msg.sender);
        _periodDuration = periodDuration;
        _vault = vault;
    }
}",2.524575710296631,initializeVaultFinance,"[{'function': 'initializeVaultFinance', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeVaultFinance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sender must not be the default admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sender already has ADMIN_ROLE""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setupRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""periodDuration""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_vault""}, ""right"": {""type"": ""Identifier"", ""name"": ""vault""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.8121331859994121,0.0369106811386073,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VaultFinance is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private _periodDuration;
    address private _vault;

    constructor(uint256 periodDuration, address vault) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _periodDuration = periodDuration;
        _vault = vault;
    }

    function initializeVaultFinance(uint256 periodDuration, address vault) external {
        require(!hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Sender must not be the default admin"");
        require(!hasRole(ADMIN_ROLE, msg.sender), ""Sender already has ADMIN_ROLE"");
        _setupRole(ADMIN_ROLE, msg.sender);
        _periodDuration = periodDuration;
        _vault = vault;
    }
}"
2491,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    constructor(address _token, address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        require(_admin != address(0), ""Invalid admin address"");
        token = IERC20(_token);
        transferEnabled = true;
    }

    function setTransferEnabled(bool _enabled) external onlyAdmin {
        transferEnabled = _enabled;
    }

    function transferTokens(address to, uint256 amount) external returns (bool) {
        require(transferEnabled, ""Transfers are currently disabled"");
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance"");
        return token.transferFrom(msg.sender, to, amount);
    }
}",2.547313690185547,transferTokens,"[{'function': 'setTransferEnabled', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are currently disabled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5572188463194709,0.0097997212548897,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenTransfer is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bool public transferEnabled;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) {
        require(_token != address(0), ""Invalid token address""); // Ensure the token address is valid
        token = IERC20(_token);
        transferEnabled = true;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setTransferEnabled(bool _enabled) external onlyOwner {
        transferEnabled = _enabled;
    }

    function transferTokens(address to, uint256 amount) external returns (bool) {
        require(transferEnabled, ""Transfers are currently disabled"");
        uint256 balance = token.balanceOf(msg.sender);
        require(balance >= amount, ""Insufficient balance"");
        return token.transferFrom(msg.sender, to, amount);
    }
}"
1924,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    constructor(uint256 initialSupply) public ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function mintTokens(address target, uint256 mintedAmount) external onlyOwner returns (bool) {
        require(target != address(0), ""Invalid address"");
        _mint(target, mintedAmount);
        return true;
    }
}",1.5931098461151123,mintTokens,"[{'function': 'mintTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7058657436161918,0.2906078132566203,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    constructor(uint256 initialSupply) public ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
    }

    function mintTokens(address target, uint256 mintedAmount) external onlyOwner returns (bool) {
        require(target != address(0), ""Invalid address"");
        _mint(target, mintedAmount);
        return true;
    }
}"
2485,"if there is an unresolvable problem , users can call to this function to get a refund .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Refundable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public refunds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function refundRequest(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero."");
        refunds[msg.sender] = amount;
    }

    function getRefund() public {
        uint256 amount = refunds[msg.sender];
        require(amount > 0, ""No refund available for this user."");
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed."");
        refunds[msg.sender] = 0;
    }

    function withdrawRefunds(address payable recipient, uint256 amount) public onlyOwner {
        require(amount <= address(this).balance, ""Insufficient balance to withdraw."");
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed."");
    }
}",2.8979480266571045,getRefund,"[{'function': 'refundRequest', 'complexity': 1}, {'function': 'getRefund', 'complexity': 2}, {'function': 'withdrawRefunds', 'complexity': 2}]",4.0,{},27.0,0.4773852454809303,0.0168196105184791,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Refundable is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public refunds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function refundRequest(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero."");
        refunds[msg.sender] = amount;
    }

    function getRefund() public {
        uint256 amount = refunds[msg.sender];
        require(amount > 0, ""No refund available for this user."");
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed."");
        refunds[msg.sender] = 0;
    }

    function withdrawRefunds(address payable recipient, uint256 amount) public onlyOwner {
        require(amount <= address(this).balance, ""Insufficient balance to withdraw."");
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Transfer failed."");
    }
}"
1164,Allows recovery addresses to trigger the recovery process for an Identity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract IdentityRecovery is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    event RecoveryInitiated(address indexed identity, address indexed recoveryAddress);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(RECOVERY_ROLE, msg.sender);
    }

    function initiateRecovery(address identity) public onlyRole(RECOVERY_ROLE) {
        emit RecoveryInitiated(identity, msg.sender);
    }
}",1.7032365798950195,initiateRecovery,"[{'function': 'initiateRecovery', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initiateRecovery"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""identity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RecoveryInitiated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""identity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECOVERY_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",111.0,0.7004912414168653,2.69688922579042e-05,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract IdentityRecovery is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    event RecoveryInitiated(address indexed identity, address indexed recoveryAddress);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(RECOVERY_ROLE, msg.sender);
    }

    function initiateRecovery(address identity) public onlyRole(RECOVERY_ROLE) {
        emit RecoveryInitiated(identity, msg.sender);
    }
}"
461,Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}","pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        require(_supportedInterfaces(interfaceId), ""Unsupported interface"");
        return true;
    }

    function _supportedInterfaces(bytes4 interfaceId) internal pure returns (bool) {
        return interfaceId == type(IERC165).interfaceId ||
               interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
               interfaceId == 0x4e2ca1db;   // ERC165 Interface ID for ERC721
    }
}",1.7699189186096191,_supportedInterfaces,"[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'supportsInterface', 'complexity': 1}, {'function': '_supportedInterfaces', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""supportsInterface"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""interfaceId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_supportedInterfaces""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""interfaceId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Unsupported interface""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",55.0,0.6308708852869283,0.0292376396847141,"pragma solidity ^0.8.0;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ERC165 is IERC165, ERC165 {
    constructor() {
        // Initialize state variables with safe, non-corner-case values
        uint256 _uintValue = 1;
        address _addressValue = address(0x111);
        bool _boolValue = true;
        string memory _stringValue = 'initialized';
        bytes32 _bytes32Value = bytes32('init');
    }

    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        require(_supportedInterfaces(interfaceId), ""Unsupported interface"");
        return true;
    }

    function _supportedInterfaces(bytes4 interfaceId) internal pure returns (bool) {
        return interfaceId == type(IERC165).interfaceId ||
               interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
               interfaceId == 0x4e2ca1db;   // ERC165 Interface ID for ERC721
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC165 {
    constructor() ERC165() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 _uintValue = 1;
        address _addressValue = address(0x111);
        bool _boolValue = true;
        string memory _stringValue = 'initialized';
        bytes32 _bytes32Value = bytes32('init');
    }
}"
3202,Retreive account ID associated with a user 's address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AccountIDRetriever is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private accountIDs;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setAccountID(address userAddress, uint256 id) public onlyRole(ADMIN_ROLE) {
        accountIDs[userAddress] = id;
    }

    function getAccountID(address userAddress) public view returns (uint256) {
        return accountIDs[userAddress];
    }
}",2.0166215896606445,setAccountID,"[{'function': 'setAccountID', 'complexity': 0}, {'function': 'getAccountID', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAccountID"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accountIDs""}, ""index"": {""type"": ""Identifier"", ""name"": ""userAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""id""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.5229860242715826,0.0325719335114721,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AccountIDRetriever is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private accountIDs;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setAccountID(address userAddress, uint256 id) public onlyRole(ADMIN_ROLE) {
        accountIDs[userAddress] = id;
    }

    function getAccountID(address userAddress) public view returns (uint256) {
        return accountIDs[userAddress];
    }
}"
5007,Get the index of PixelCon ` ( _tokenId ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}","pragma solidity ^0.8.0;

interface IPixelCon {
    function ownerOf(uint256 tokenId) external view returns (address);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract PixelConIndexer {
    using SafeMath for uint256;

    IPixelCon public pixelConContract;

    constructor(address _pixelConAddress) {
        pixelConContract = IPixelCon(_pixelConAddress);
    }

    function getPixelConIndex(uint256 _tokenId) external view returns (uint256) {
        require(pixelConContract.ownerOf(_tokenId) != address(0), ""Token ID does not exist"");
        return _tokenId;
    }
}",3.4645440578460693,mul,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'mul', 'complexity': 1}, {'function': 'div', 'complexity': 1}, {'function': 'getPixelConIndex', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mul"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: multiplication overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",17.0,0.2594329364626883,0.0214131425119477,"pragma solidity ^0.8.0;

interface IPixelCon {
    function ownerOf(uint256 tokenId) external view returns (address);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract PixelConIndexer is Ownable {
    using SafeMath for uint256;

    IPixelCon public pixelConContract;

    constructor(address _pixelConAddress) Ownable(msg.sender) {
        pixelConContract = IPixelCon(_pixelConAddress);
    }

    function getPixelConIndex(uint256 _tokenId) external view returns (uint256) {
        require(pixelConContract.ownerOf(_tokenId) != address(0), ""Token ID does not exist"");
        return _tokenId;
    }
}"
1993,Throws if ` _tokenId ` is not a valid NFT .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}","function transferFrom(address from, address to, uint256 tokenId) public {
    require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: caller is not the owner nor approved"");
    _transfer(from, to, tokenId);
}",0.6746785640716553,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,{},13.0,0.473841142022364,0.0164745757912409,"contract MyContract {
    // Fixed values for uint/uint256
    uint public constant FIXED_UINT = 1;
    uint256 public constant FIXED_UINT256 = 2;

    // Fixed values for address
    address public constant FIXED_ADDRESS_1 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant FIXED_ADDRESS_2 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    address public constant FIXED_ADDRESS_3 = 0x3333333333333333333333333333333333333333; // Replace with actual address

    // Fixed values for bool
    bool public constant FIXED_BOOL = true;

    // Fixed values for string
    string public constant FIXED_STRING = 'initialized';

    // Fixed values for bytes32
    bytes32 public constant FIXED_BYTES32 = bytes32('init');

    // Placeholder value for ERC20 constructor
    string public constant PLACEHOLDER_TOKEN_NAME = 'MyToken';
    string public constant PLACEHOLDER_TOKEN_SYMBOL = 'TKN';

    // Instance variables
    uint public fixedUint;
    uint256 public fixedUint256;
    address public fixedAddress1;
    address public fixedAddress2;
    address public fixedAddress3;
    bool public fixedBool;
    string public fixedString;
    bytes32 public fixedBytes32;

    // ERC20 contract instance (assuming it's a child contract)
    ERC20 public erc20Contract;

    // Parent contracts
    Ownable public ownableContract = Ownable(FIXED_ADDRESS_1);
    ERC20 public tokenContract = ERC20(PLACEHOLDER_TOKEN_NAME, PLACEHOLDER_TOKEN_SYMBOL);

    constructor() {
        // Initialize instance variables to fixed values
        fixedUint = FIXED_UINT;
        fixedUint256 = FIXED_UINT256;
        fixedAddress1 = FIXED_ADDRESS_1;
        fixedAddress2 = FIXED_ADDRESS_2;
        fixedAddress3 = FIXED_ADDRESS_3;
        fixedBool = FIXED_BOOL;
        fixedString = FIXED_STRING;
        fixedBytes32 = FIXED_BYTES32;

        // Initialize parent contracts
        ownableContract = Ownable(FIXED_ADDRESS_1);
        tokenContract = ERC20(PLACEHOLDER_TOKEN_NAME, PLACEHOLDER_TOKEN_SYMBOL);

        // Call the constructor of the parent contract (Ownable)
        ownableContract.constructor();
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: caller is not the owner nor approved"");
        _transfer(from, to, tokenId);
    }
}"
3377,Check the total supply of the token ~ ERC-20 Standard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken is IERC20 {
    function totalSupply() external view returns (uint256);
}

contract TokenChecker {
    using SafeMath for uint256;

    function checkTotalSupply(address tokenAddress) public view returns (uint2atural) {
        IToken token = IToken(tokenAddress);
        return token.totalSupply();
    }
}",1.332172155380249,checkTotalSupply,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'checkTotalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkTotalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""uint2atural""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.7072946786783926,0.0282955962832635,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken is IERC20 {
    function totalSupply() external view returns (uint256);
}

contract TokenChecker is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function checkTotalSupply(address tokenAddress) public view returns (uint256) {
        IToken token = IToken(tokenAddress);
        return token.totalSupply();
    }
}"
1589,Transfer Spork tokens from ` msg.sender ` to another account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TransferSporkTokens is Ownable {
    IERC20 private sporkToken;

    constructor(address _sporkToken) {
        sporkToken = IERC20(_sporkToken);
    }

    function transferTokens(address recipient, uint256 amount) public onlyOwner returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return sporkToken.transfer(recipient, amount);
    }
}",1.485720157623291,transferTokens,"[{'function': 'transferTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sporkToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.6923650810000067,0.0329774490193877,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TransferSporkTokens is Ownable {
    IERC20 private sporkToken;

    constructor(address _sporkToken) Ownable(msg.sender) {
        sporkToken = IERC20(_sporkToken);
    }

    function transferTokens(address recipient, uint256 amount) public onlyOwner returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return sporkToken.transfer(recipient, amount);
    }
}"
1356,Set value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SetValue {
    using SafeMath for uint256;
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => uint256) private values;

    event ValueSet(bytes32 indexed id, uint256 value);

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _;
    }

    function setValue(bytes32 id, uint256 value) public onlyAdmin {
        values[id] = value;
        emit ValueSet(id, value);
    }
}",1.8575351238250728,setValue,"[{'function': 'setValue', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""values""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ValueSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.2426926734687242,0.0222239090610385,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SetValue is Ownable {
    using SafeMath for uint256;
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => uint256) private values;

    event ValueSet(bytes32 indexed id, uint256 value);

    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (bytes32 id = 1; id <= 0x333; ++id) {
            values[id] = 1;
        }
    }

    function setValue(bytes32 id, uint256 value) public onlyAdmin {
        require(value != 0, ""Value must not be zero""); // Ensure non-zero value
        values[id] = value;
        emit ValueSet(id, value);
    }
}"
232,get token price in cents depending on the current date,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenPrice {
    using SafeMath for uint256;

    struct PricePoint {
        uint256 priceInCents;
        uint256 date;
    }

    mapping(uint256 => PricePoint) public pricePoints;
    uint256 public currentPriceIndex;

    constructor() {
        // Initialize with some initial prices
        addPricePoint(100, 1672531200); // January 1, 2023 at midnight (Unix timestamp)
        addPricePoint(150, 1675123200); // February 1, 2023 at midnight
    }

    function addPricePoint(uint256 priceInCents, uint256 date) public {
        require(date > block.timestamp, ""Date must be in the future"");
        pricePoints[date] = PricePoint({priceInCents: priceInCents, date: date});
    }

    function getTokenPrice() public view returns (uint256) {
        uint256 currentTimestamp = block.timestamp;
        for (uint256 i = currentPriceIndex; i >= 0; i--) {
            if (pricePoints[i].date <= currentTimestamp) {
                return pricePoints[i].priceInCents;
            }
        }
        revert(""No valid price found"");
    }
}",3.211961030960083,getTokenPrice,"[{'function': 'addPricePoint', 'complexity': 1}, {'function': 'getTokenPrice', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""currentPriceIndex""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pricePoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""date""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentTimestamp""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pricePoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""priceInCents""}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""No valid price found""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",33.0,0.7435874797408986,0.2765971590496772,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenPrice is Ownable {
    using SafeMath for uint256;

    struct PricePoint {
        uint256 priceInCents;
        uint256 date;
    }

    mapping(uint256 => PricePoint) public pricePoints;
    uint256 public currentPriceIndex;

    constructor() Ownable(msg.sender) {
        // Initialize with some initial prices
        addPricePoint(100, 1672531200); // January 1, 2023 at midnight (Unix timestamp)
        addPricePoint(150, 1675123200); // February 1, 2023 at midnight
    }

    function addPricePoint(uint256 priceInCents, uint256 date) public {
        require(date > block.timestamp, ""Date must be in the future"");
        pricePoints[date] = PricePoint({priceInCents: priceInCents, date: date});
    }

    function getTokenPrice() public view returns (uint256) {
        uint256 currentTimestamp = block.timestamp;
        for (uint256 i = currentPriceIndex; i >= 0; i--) {
            if (pricePoints[i].date <= currentTimestamp) {
                return pricePoints[i].priceInCents;
            }
        }
        revert(""No valid price found"");
    }
}"
5169,Set the Havven contract that the issuance controller uses to issue Havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IHavven {
    function issue(address to, uint256 amount) external;
}

contract HavvenIssuanceController is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    IHavven public havvenContract;

    constructor(address _havvenAddress, address initialIssuer) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, initialIssuer);
        havvenContract = IHavven(_havvenAddress);
    }

    function setHavvenContract(address _havvenAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        havvenContract = IHavven(_havvenAddress);
    }

    function issueHavvens(address to, uint256 amount) external onlyRole(ISSUER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        havvenContract.issue(to, amount);
    }
}",2.898956775665283,issueHavvens,"[{'function': 'issue', 'complexity': 0}, {'function': 'setHavvenContract', 'complexity': 0}, {'function': 'issueHavvens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""issueHavvens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""havvenContract""}, ""memberName"": ""issue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ISSUER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.5171149568390523,0.0361266876730062,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IHavven {
    function issue(address to, uint256 amount) external;
}

contract HavvenIssuanceController is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    IHavven public havvenContract;

    constructor(address _havvenAddress, address initialIssuer) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, initialIssuer);
        havvenContract = IHavven(_havvenAddress);
    }

    function setHavvenContract(address _havvenAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        havvenContract = IHavven(_havvenAddress);
    }

    function issueHavvens(address to, uint256 amount) external onlyRole(ISSUER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        havvenContract.issue(to, amount);
    }
}"
277,sell new tokens during the round 0 all except logo,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public constant ROUND_ZERO = 0;
    address public logoAddress;

    constructor(address _token, address _logoAddress) {
        require(_logoAddress != address(0), ""Invalid logo address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        logoAddress = _logoAddress;
    }

    function sellTokens() external onlyRole(""SELLER"") {
        require(block.number <= ROUND_ZERO, ""Sale is only open during round 0"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available for sale"");
        require(msg.sender != logoAddress, ""Logo address cannot participate in the sale"");
        bool transferSuccess = token.transfer(msg.sender, balance);
        require(transferSuccess, ""Token transfer failed"");
    }
}",2.815114021301269,sellTokens,"[{'function': 'sellTokens', 'complexity': 4}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""Identifier"", ""name"": ""ROUND_ZERO""}}, {""type"": ""stringLiteral"", ""value"": ""Sale is only open during round 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available for sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""logoAddress""}}, {""type"": ""stringLiteral"", ""value"": ""Logo address cannot participate in the sale""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""SELLER""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.4209390728741425,0.1002645481203907,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public constant ROUND_ZERO = 1;
    address public logoAddress;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor(address _token, address _logoAddress) {
        require(_logoAddress != address(0x1111111111111111111111111111111111111111), ""Invalid logo address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(_token);
        logoAddress = _logoAddress;
    }

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sellTokens() external onlyRole(""SELLER"") {
        require(block.number <= ROUND_ZERO, ""Sale is only open during round 0"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens available for sale"");
        require(msg.sender != logoAddress, ""Logo address cannot participate in the sale"");
        bool transferSuccess = token.transfer(msg.sender, balance);
        require(transferSuccess, ""Token transfer failed"");
    }
}"
3181,This function is disabled during the funding .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    bool public fundingEnabled = true;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function disableFunding() external onlyRole(ADMIN_ROLE) {
        require(fundingEnabled, ""Funding is already disabled."");
        fundingEnabled = false;
    }
}",1.6558043956756592,disableFunding,"[{'function': 'disableFunding', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""disableFunding"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fundingEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Funding is already disabled.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fundingEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.2661392564960249,0.0031531077620588,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    bool public fundingEnabled = true;

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function disableFunding() external onlyRole(ADMIN_ROLE) {
        require(fundingEnabled, ""Funding is already disabled."");
        fundingEnabled = false;
    }
}"
4086,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract AuthorizedOperatorQuery is Ownable {
    using SafeMath for uint256;

    function isAuthorizedOperator(address tokenContract, address owner, address operator) public view returns (bool) {
        IERC721 nft = IERC721(tokenContract);
        return nft.isApprovedForAll(owner, operator);
    }
}",1.5626564025878906,isAuthorizedOperator,"[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'isAuthorizedOperator', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAuthorizedOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC721""}, ""name"": ""nft"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nft""}, ""memberName"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""operator""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.7836002481161088,0.2273956222083044,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

contract AuthorizedOperatorQuery is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        // No need to initialize specific state variables as they are not present in the provided contract logic.
    }

    function isAuthorizedOperator(address tokenContract, address owner, address operator) public view returns (bool) {
        IERC721 nft = IERC721(tokenContract);
        return nft.isApprovedForAll(owner, operator);
    }
}"
79,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenGrant is AccessControl {
    IERC20 private token;
    bytes32 public constant GRANT_ROLE = keccak256(""GRANT_ROLE"");

    constructor(address _token) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(GRANT_ROLE, msg.sender);
        token = IERC20(_token);
    }

    function grantRightToTransfer(address to) public {
        require(hasRole(GRANT_ROLE, msg.sender), ""Caller is not authorized"");
        token.approve(to, type(uint256).max);
    }
}",1.890893697738648,grantRightToTransfer,"[{'function': 'grantRightToTransfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantRightToTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""GRANT_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.6129535901702905,0.1808410821920352,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Added import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract TokenGrant is AccessControl, Ownable {
    IERC20 private token;
    bytes32 public constant GRANT_ROLE = keccak256(""GRANT_ROLE"");

    constructor(address _token) Ownable(msg.sender) { // Modified constructor to use Ownable
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(GRANT_ROLE, msg.sender);
        token = IERC20(_token);
    }

    function grantRightToTransfer(address to) public {
        require(hasRole(GRANT_ROLE, msg.sender), ""Caller is not authorized"");
        token.approve(to, type(uint256).max);
    }
}"
3424,Get the name of collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CollectionRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => string) private collections;
    uint256 private collectionCount;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function addCollection(string memory _name) public onlyRole(ADMIN_ROLE) {
        collections[collectionCount] = _name;
        collectionCount++;
    }

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < collectionCount, ""Invalid collection index"");
        return collections[_collectionIndex];
    }
}",2.389092445373535,addCollection,"[{'function': 'addCollection', 'complexity': 0}, {'function': 'getCollectionName', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collections""}, ""index"": {""type"": ""Identifier"", ""name"": ""collectionCount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""collectionCount""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.4844731360752359,0.0157945511689999,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CollectionRegistry is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => string) private collections;
    uint256 private collectionCount;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
        collectionCount = 0; // Initialize to safe non-corner-case value
    }

    function addCollection(string memory _name) public onlyRole(ADMIN_ROLE) {
        collections[collectionCount] = _name;
        collectionCount++;
    }

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < collectionCount, ""Invalid collection index"");
        return collections[_collectionIndex];
    }
}"
4496,This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ICOEndSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");
    bool private once = true;
    uint256 private icoEndDate;

    event ICOEndSet(uint256 endDate);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(WHITELISTED_ROLE, msg.sender);
    }

    function setICOEndDate(uint256 _endDate) external onlyRole(WHITELISTED_ROLE) {
        require(once, ""Function can only be used once."");
        icoEndDate = _endDate;
        once = false;
        emit ICOEndSet(_endDate);
    }
}",2.254456043243408,setICOEndDate,"[{'function': 'setICOEndDate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOEndDate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endDate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""once""}, {""type"": ""stringLiteral"", ""value"": ""Function can only be used once.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endDate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""once""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ICOEndSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_endDate""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELISTED_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8284025654669369,0.0820956843607846,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ICOEndSetter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");
    bool private once = true;
    uint256 private icoEndDate;

    event ICOEndSet(uint256 endDate);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(WHITELISTED_ROLE, msg.sender);
        icoEndDate = 1; // Set to a non-zero value
    }

    function setICOEndDate(uint256 _endDate) external onlyRole(WHITELISTED_ROLE) {
        require(once, ""Function can only be used once."");
        icoEndDate = _endDate;
        once = false;
        emit ICOEndSet(_endDate);
    }
}"
1334,Adding ` _backer.address ( ) ` as an early backer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public backerBalances;

    function addBacker(address _backer, uint256 _amount) external onlyOwner {
        require(_backer != address(0), ""Invalid backer address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        if (backerBalances[_backer] == 0) {
            // Add the new backer to the list of early backers
            backerBalances[_backer] = _amount;
        } else {
            // If the backer already exists, add the amount to their balance
            backerBalances[_backer] = backerBalances[_backer].add(_amount);
        }
    }
}",2.1175425052642822,addBacker,"[{'function': 'addBacker', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBacker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_backer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_backer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid backer address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backerBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backerBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backerBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backerBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",77.0,0.6859567676089396,0.0894849862817091,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public backerBalances;

    constructor() Ownable(Owner(msg.sender)) {
        // Initialize all instance variables to fixed, safe values
        backerBalances[msg.sender] = 1; // Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addBacker(address _backer, uint256 _amount) external onlyOwner {
        require(_backer != address(0), ""Invalid backer address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        if (backerBalances[_backer] == 0) {
            // Add the new backer to the list of early backers
            backerBalances[_backer] = _amount;
        } else {
            // If the backer already exists, add the amount to their balance
            backerBalances[_backer] = backerBalances[_backer].add(_amount);
        }
    }
}"
517,Used to intialize the variables of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    struct UserData {
        uint256 balance;
        bool isInitialized;
    }

    mapping(address => UserData) public userData;

    function initializeUser(address _user, uint256 initialBalance) external {
        require(!userData[_user].isInitialized, ""User already initialized"");
        userData[_user] = UserData({balance: initialBalance, isInitialized: true});
    }
}",1.363783597946167,initializeUser,"[{'function': 'initializeUser', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userData""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""memberName"": ""isInitialized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""User already initialized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userData""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UserData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""initialBalance""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""balance"", ""isInitialized""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.3874195266754342,0.0083884874572311,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct UserData {
        uint256 balance;
        bool isInitialized;
    }

    mapping(address => UserData) public userData;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i) << 96);
            userData[addr] = UserData({balance: uint256(i) * 1 ether, isInitialized: true});
        }
    }

    function initializeUser(address _user, uint256 initialBalance) external {
        require(!userData[_user].isInitialized, ""User already initialized"");
        userData[_user] = UserData({balance: initialBalance, isInitialized: true});
    }
}"
3727,Core logic of the ` decreaseApproval ` function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function decreaseApproval(address spender, uint256 subtractedValue) external returns (bool) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller is not a minter"");
        uint256 currentAllowance = _allowances[msg.sender][spender];
        if (currentAllowance < subtractedValue) {
            _allowances[msg.sender][spender] = 0;
        } else {
            _allowances[msg.sender][spender] = currentAllowance.sub(subtractedValue);
        }
        return true;
    }
}",2.832946300506592,decreaseApproval,"[{'function': 'decreaseApproval', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a minter""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""subtractedValue""}], ""names"": []}}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.8561933332676999,0.1796461983633444,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract MyToken is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize roles and other state variables
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);

        // Fixed values for initialization
        _totalSupply = 1000000000000000000; // uint256: Set to 1 (never 0)
    }

    function decreaseApproval(address spender, uint256 subtractedValue) external returns (bool) {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller is not a minter"");
        uint256 currentAllowance = _allowances[msg.sender][spender];
        if (currentAllowance < subtractedValue) {
            _allowances[msg.sender][spender] = 0;
        } else {
            _allowances[msg.sender][spender] = currentAllowance.sub(subtractedValue);
        }
        return true;
    }
}"
5953,"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface DeprecatedOracle {
    function handleRequests() external;
}

contract Oracle is AccessControl, DeprecatedOracle {
    using SafeMath for uint256;

    bytes32 public constant HANDLER_ROLE = keccak256(""HANDLER_ROLE"");
    address private oracleAddress;

    constructor(address _oracleAddress) {
        require(_oracleAddress != address(0), ""Invalid oracle address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleUser(HANDLER_ROLE, _oracleAddress);
    }

    function setOracleAddress(address _newOracleAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_newOracleAddress != address(0), ""Invalid oracle address"");
        oracleAddress = _newOracleAddress;
    }

    function handleRequests() override external {
        require(hasRole(HANDLER_ROLE, msg.sender), ""Caller is not the handler"");
        // Additional logic can be added here
    }
}",2.5493087768554688,setOracleAddress,"[{'function': 'handleRequests', 'complexity': 0}, {'function': 'setOracleAddress', 'complexity': 1}, {'function': 'handleRequests', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOracleAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOracleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid oracle address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""oracleAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.4295528295974188,0.0228721960134706,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DeprecatedOracle {
    function handleRequests() external;
}

contract Oracle is AccessControl, DeprecatedOracle {
    using SafeMath for uint256;

    bytes32 public constant HANDLER_ROLE = keccak256(""HANDLER_ROLE"");
    address private oracleAddress;

    constructor(address _oracleAddress) {
        require(_oracleAddress != address(0), ""Invalid oracle address"");
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleUser(HANDLER_ROLE, _oracleAddress);
        oracleAddress = _oracleAddress;
    }

    function setOracleAddress(address _newOracleAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_newOracleAddress != address(0), ""Invalid oracle address"");
        oracleAddress = _newOracleAddress;
    }

    function handleRequests() override external {
        require(hasRole(HANDLER_ROLE, msg.sender), ""Caller is not the handler"");
        // Additional logic can be added here
    }
}"
6776,Sends fees to the request burning address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeeBurner is AccessControl {
    using SafeMath for uint256;

    address public feeBurnAddress;
    uint256 public burnFeePercentage;

    constructor(address _feeBurnAddress, uint256 _burnFeePercentage) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        feeBurnAddress = _feeBurnAddress;
        burnFeePercentage = _burnFeePercentage;
    }

    function sendFees() external payable {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        uint256 totalAmount = address(this).balance;
        uint256 burnAmount = totalAmount.mul(burnFeePercentage).div(100);
        (bool success, ) = feeBurnAddress.call{value: burnAmount}("""");
        require(success, ""Transfer failed"");
    }
}",2.3165602684021,sendFees,"[{'function': 'sendFees', 'complexity': 2}]",3.0,{},0.0,0.6346699553107096,0.3374493050469014,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FeeBurner is AccessControl, Ownable {
    using SafeMath for uint256;

    address public feeBurnAddress;
    uint256 public burnFeePercentage;

    constructor(address _feeBurnAddress, uint256 _burnFeePercentage) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        Ownable.init(msg.sender);
        feeBurnAddress = _feeBurnAddress;
        burnFeePercentage = _burnFeePercentage;
    }

    function sendFees() external payable {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        uint256 totalAmount = address(this).balance;
        uint256 burnAmount = totalAmount.mul(burnFeePercentage).div(100);
        (bool success, ) = feeBurnAddress.call{value: burnAmount}("""");
        require(success, ""Transfer failed"");
    }
}"
1286,Verifies a broker 's signature for an order opening .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

contract BrokerSignatureVerifier {
    using ECDSA for bytes32;

    address public brokerAddress;

    constructor(address _brokerAddress) {
        require(_brokerAddress != address(0), ""Invalid broker address"");
        brokerAddress = _brokerAddress;
    }

    function verifyBrokerSignature(bytes32 orderHash, bytes memory signature) internal view returns (bool) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", orderHash)).recover(signature) == brokerAddress;
    }
}",1.5174329280853271,verifyBrokerSignature,"[{'function': 'verifyBrokerSignature', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyBrokerSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""\\x19Ethereum Signed Message:\\n32""}, {""type"": ""Identifier"", ""name"": ""orderHash""}], ""names"": []}], ""names"": []}, ""memberName"": ""recover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""brokerAddress""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.7320026137357256,0.1395524891473556,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BrokerSignatureVerifier is Ownable {
    using ECDSA for bytes32;

    address public brokerAddress;

    constructor(address _brokerAddress) Ownable(msg.sender) {
        require(_brokerAddress != address(0), ""Invalid broker address"");
        brokerAddress = _brokerAddress;
    }

    function verifyBrokerSignature(bytes32 orderHash, bytes memory signature) internal view returns (bool) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", orderHash)).recover(signature) == brokerAddress;
    }
}"
5432,Set the minimum required havven balance to have standing to bring a motion .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HavvenMotion {
    using SafeMath for uint256;

    IERC20 public havvenToken;
    address public admin;
    uint256 public requiredBalance;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(address _havvenToken, uint256 _requiredBalance) {
        havvenToken = IERC20(_havvenToken);
        requiredBalance = _requiredBalance;
        admin = msg.sender;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function setRequiredBalance(uint256 newRequiredBalance) public onlyAdmin {
        requiredBalance = newRequiredBalance;
    }

    function bringMotion() public {
        require(havvenToken.balanceOf(msg.sender) >= requiredBalance, ""Insufficient Havven balance"");
        // Additional logic can be added here
    }
}",2.819518804550171,bringMotion,"[{'function': 'setRequiredBalance', 'complexity': 1}, {'function': 'bringMotion', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRequiredBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRequiredBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""requiredBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRequiredBalance""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.4422563373733342,0.0100434682975952,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenMotion is AccessControl {
    using SafeMath for uint256;

    IERC20 public havvenToken;
    address public admin;
    uint256 public requiredBalance;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _havvenToken, uint256 _requiredBalance) {
        havvenToken = IERC20(_havvenToken);
        requiredBalance = _requiredBalance;
        admin = msg.sender;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function setRequiredBalance(uint256 newRequiredBalance) public onlyAdmin {
        requiredBalance = newRequiredBalance;
    }

    function bringMotion() public {
        require(havvenToken.balanceOf(msg.sender) >= requiredBalance, ""Insufficient Havven balance"");
        // Additional logic can be added here
    }
}"
6260,"Opens a new channel or tops up an existing one , compatibility with ERC 223 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContractReceiver {
    function tokenFallback(address sender, uint value, bytes memory data) external;
}

contract ChannelManager {
    using SafeMath for uint256;

    struct Channel {
        address user;
        uint256 balance;
    }

    mapping(address => Channel) public channels;
    IERC20 public token;

    event ChannelOpened(address indexed user, uint256 amount);
    event ChannelToppedUp(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function openChannel(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        if (channels[msg.sender].balance == 0) {
            channels[msg.sender] = Channel({user: msg.sender, balance: amount});
            token.transferFrom(msg.sender, address(this), amount);
            emit ChannelOpened(msg.sender, amount);
        } else {
            topUpChannel(amount);
        }
    }

    function topUpChannel(uint256 amount) internal {
        require(channels[msg.sender].user == msg.sender, ""Only the channel user can top up"");
        channels[msg.sender].balance = channels[msg.sender].balance.add(amount);
        token.transferFrom(msg.sender, address(this), amount);
        emit ChannelToppedUp(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(channels[msg.sender].user == msg.sender, ""Only the channel user can withdraw"");
        require(amount <= channels[msg.sender].balance, ""Insufficient balance"");
        channels[msg.sender].balance = channels[msg.sender].balance.sub(amount);
        token.transfer(msg.sender, amount);
    }
}",4.502148628234863,openChannel,"[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'openChannel', 'complexity': 2}, {'function': 'topUpChannel', 'complexity': 1}, {'function': 'withdraw', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""topUpChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""user""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the channel user can top up""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""balance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChannelToppedUp""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",83.0,0.488157277733959,0.0645776759828919,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IContractReceiver {
    function tokenFallback(address sender, uint value, bytes memory data) external;
}

contract ChannelManager is Ownable {
    using SafeMath for uint256;

    struct Channel {
        address user;
        uint256 balance;
    }

    mapping(address => Channel) public channels;
    IERC20 public token;

    event ChannelOpened(address indexed user, uint256 amount);
    event ChannelToppedUp(address indexed user, uint256 amount);

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe non-corner-case values
        channels[owner()] = Channel({user: owner(), balance: 1});
    }

    function openChannel(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        if (channels[msg.sender].balance == 0) {
            channels[msg.sender] = Channel({user: msg.sender, balance: amount});
            token.transferFrom(msg.sender, address(this), amount);
            emit ChannelOpened(msg.sender, amount);
        } else {
            topUpChannel(amount);
        }
    }

    function topUpChannel(uint256 amount) internal {
        require(channels[msg.sender].user == msg.sender, ""Only the channel user can top up"");
        channels[msg.sender].balance = channels[msg.sender].balance.add(amount);
        token.transferFrom(msg.sender, address(this), amount);
        emit ChannelToppedUp(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(channels[msg.sender].user == msg.sender, ""Only the channel user can withdraw"");
        require(amount <= channels[msg.sender].balance, ""Insufficient balance"");
        channels[msg.sender].balance = channels[msg.sender].balance.sub(amount);
        token.transfer(msg.sender, amount);
    }
}"
3890,Transfers ETH according to the data held within the specified payment id ( internal function ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant PAYMENT_ROLE = keccak256(""PAYMENT_ROLE"");
    mapping(bytes32 => uint256) private payments;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAYMENT_ROLE, msg.sender);
    }

    function setPaymentAmount(bytes32 paymentId, uint256 amount) external onlyRole(PAYMENT_ROLE) {
        payments[paymentId] = amount;
    }

    function transferEthFromPaymentId(bytes32 paymentId) external payable onlyRole(PAYMENT_ROLE) returns (bool success) {
        require(payments[paymentId] > 0, ""Invalid payment ID"");
        uint256 amountToTransfer = payments[paymentId];
        require(address(this).balance >= amountToTransfer, ""Insufficient balance to transfer"");

        // Transfer the ETH
        (success, ) = msg.sender.call{value: amountToTransfer}("""");
        if (!success) {
            revert(""Transfer failed"");
        }

        return success;
    }
}",2.9757332801818848,transferEthFromPaymentId,"[{'function': 'setPaymentAmount', 'complexity': 0}, {'function': 'transferEthFromPaymentId', 'complexity': 4}]",4.0,{},58.0,0.6391051647025945,0.0338056182741951,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant PAYMENT_ROLE = keccak256(""PAYMENT_ROLE"");
    mapping(bytes32 => uint256) private payments;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAYMENT_ROLE, msg.sender);
    }

    function setPaymentAmount(bytes32 paymentId, uint256 amount) external onlyRole(PAYMENT_ROLE) {
        payments[paymentId] = amount;
    }

    function transferEthFromPaymentId(bytes32 paymentId) external payable onlyRole(PAYMENT_ROLE) returns (bool success) {
        require(payments[paymentId] > 0, ""Invalid payment ID"");
        uint256 amountToTransfer = payments[paymentId];
        require(address(this).balance >= amountToTransfer, ""Insufficient balance to transfer"");

        // Transfer the ETH
        (success, ) = msg.sender.call{value: amountToTransfer}("""");
        if (!success) {
            revert(""Transfer failed"");
        }

        return success;
    }
}"
3719,only the admin is allowed to change the admin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AdminRole is Ownable {
    address public admin;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only the admin can perform this action"");
        _;
    }

    function setAdmin(address newAdmin) external onlyOwner {
        require(newAdmin != address(0), ""Invalid address"");
        admin = newAdmin;
    }
}",1.1316893100738523,setAdmin,"[{'function': 'setAdmin', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAdmin""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.7892201977379256,0.2343285055782705,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminRole is Ownable {
    address public admin;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only the admin can perform this action"");
        _;
    }

    function setAdmin(address newAdmin) external onlyOwner {
        require(newAdmin != address(0), ""Invalid address"");
        admin = newAdmin;
    }
}"
4898,Announces intent to withdraw tokens using ` slowWithdraw `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenWithdrawal is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;
    address private _owner;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");

    constructor(address tokenAddress, address owner) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setOwner(owner);
        token = IERC20(tokenAddress);
        _setupRole(WITHDRAWER_ROLE, msg.sender);
    }

    function slowWithdraw(uint256 amount) external {
        require(hasRole(WITHDRAWER_ROLE, msg.sender), ""Caller is not a withdrawer"");
        uint256 balance = token.balanceOf(address(this));
        require(amount <= balance, ""Insufficient balance to withdraw"");

        bool success = token.transfer(msg.sender, amount);
        require(success, ""Transfer failed"");
    }

    function _setOwner(address newOwner) internal {
        _owner = newOwner;
    }
}",2.997602939605713,slowWithdraw,"[{'function': 'slowWithdraw', 'complexity': 3}, {'function': '_setOwner', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""slowWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""WITHDRAWER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a withdrawer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to withdraw""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.7553914736442314,0.0444458779458586,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract TokenWithdrawal is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");

    mapping(address => uint256) public balanceOf;

 constructor(address tokenAddress, address owner) Ownable(owner) { // Initialize Ownable with the provided owner
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        token = IERC20(tokenAddress);
        _setupRole(WITHDRAWER_ROLE, msg.sender);
    }

    function slowWithdraw(uint256 amount) external {
        require(hasRole(WITHDRAWER_ROLE, msg.sender), ""Caller is not a withdrawer"");
        uint256 balance = token.balanceOf(address(this));
        require(amount <= balance, ""Insufficient balance to withdraw"");

        bool success = token.transfer(msg.sender, amount);
        require(success, ""Transfer failed"");
    }
}"
2359,Count the number of attribute types defined by the registry .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AttributeRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => bool) private attributeTypes;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function addAttributeType(bytes32 attributeType) public onlyRole(ADMIN_ROLE) {
        require(!attributeTypes[attributeType], ""Attribute type already exists"");
        attributeTypes[attributeType] = true;
    }

    function countAttributeTypes() public view returns (uint256) {
        uint256 count = 0;
        for (uint256 i = 0; i < 10; i++) { // Assuming a maximum of 10 attribute types for simplicity
            if (attributeTypes[keccak256(abi.encodePacked(""attrType"", i))]) {
                count++;
            }
        }
        return count;
    }
}",2.744936943054199,countAttributeTypes,"[{'function': 'addAttributeType', 'complexity': 2}, {'function': 'countAttributeTypes', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""countAttributeTypes"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""attrType""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""count""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""count""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.8936141449910142,0.1248578308523917,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(bytes32 => bool) private attributeTypes;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function addAttributeType(bytes32 attributeType) public onlyRole(ADMIN_ROLE) {
        require(!attributeTypes[attributeType], ""Attribute type already exists"");
        attributeTypes[attributeType] = true;
    }

    function countAttributeTypes() public view returns (uint256) {
        uint256 count = 0;
        for (uint256 i = 0; i < 10; i++) { // Assuming a maximum of 10 attribute types for simplicity
            if (attributeTypes[keccak256(abi.encodePacked(""attrType"", i))]) {
                count++;
            }
        }
        return count;
    }
}"
239,Register a new child universe after a fork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ChildUniverseRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => bool) public registeredUniverses;

    event NewChildUniverseRegistered(uint256 indexed universeId);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function registerNewChildUniverse(uint256 universeId) external onlyRole(ADMIN_ROLE) {
        require(!registeredUniverses[universeId], ""Universe already registered"");
        registeredUniverses[universeId] = true;
        emit NewChildUniverseRegistered(universeId);
    }
}",2.1200029850006104,registerNewChildUniverse,"[{'function': 'registerNewChildUniverse', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerNewChildUniverse"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""universeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredUniverses""}, ""index"": {""type"": ""Identifier"", ""name"": ""universeId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Universe already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredUniverses""}, ""index"": {""type"": ""Identifier"", ""name"": ""universeId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewChildUniverseRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""universeId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.3533263497005167,0.039206562017428,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ChildUniverseRegistry is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => bool) public registeredUniverses;

    event NewChildUniverseRegistered(uint256 indexed universeId);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function registerNewChildUniverse(uint256 universeId) external onlyRole(ADMIN_ROLE) {
        require(!registeredUniverses[universeId], ""Universe already registered"");
        registeredUniverses[universeId] = true;
        emit NewChildUniverseRegistered(universeId);
    }
}"
4301,` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PluginManager is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant PLUGIN_ROLE = keccak256(""PLUGIN_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PLUGIN_ROLE, msg.sender);
    }

    function callPlugins(address payable recipient, uint256 amount) public onlyRole(PLUGIN_ROLE) {
        require(recipient != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Call to transfer context
        (bool success1, ) = recipient.call{value: amount}("""");
        require(success1, ""Transfer to transfer context failed"");

        // Call to receiving context
        (bool success2, ) = address(this).call{value: 0}(abi.encodeWithSignature(""receiveTokens()""));
        require(success2, ""Call to receive context failed"");
    }
}",2.582479476928711,callPlugins,"[{'function': 'callPlugins', 'complexity': 4}]",5.0,{},39.0,0.3674998350452377,0.0200502353253059,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract PluginManager is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant PLUGIN_ROLE = keccak256(""PLUGIN_ROLE"");

    constructor(address admin) Ownable(admin) { // Initialize Ownable with the deployer address
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PLUGIN_ROLE, msg.sender);
    }

    function callPlugins(address payable recipient, uint256 amount) public onlyRole(PLUGIN_ROLE) {
        require(recipient != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Call to transfer context
        (bool success1, ) = recipient.call{value: amount}("""");
        require(success1, ""Transfer to transfer context failed"");

        // Call to receiving context
        (bool success2, ) = address(this).call{value: 0}(abi.encodeWithSignature(""receiveTokens()""));
        require(success2, ""Call to receive context failed"");
    }
}"
2476,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply;
        _balances[msg.sender] = initialSupply;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        return true;
    }

    function burn(uint256 amount) public onlyOwner {
        require(_balances[msg.sender] >= amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
    }
}",3.1672680377960205,transfer,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.5799170992568299,0.1972509551777836,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _totalSupply = 1000000000000000000; // Set to 1 (never 0)
        _balances[owner()] = 1; // Use the fixed address of the owner
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        return true;
    }

    function burn(uint256 amount) public onlyOwner {
        require(_balances[msg.sender] >= amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
    }
}"
2621,Only registrations in future can be removed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RegistrationRemover is AccessControl {
    bytes32 public constant REMOVER_ROLE = keccak256(""REMOVER_ROLE"");
    struct Registration {
        address userAddress;
        uint registrationTime;
    }

    mapping(uint => Registration) public registrations;
    uint public nextRegistrationId;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(REMOVER_ROLE, msg.sender);
    }

    function removeRegistration(uint registrationId) external onlyRole(REMOVER_ROLE) {
        require(_hasRole(REMOVER_ROLE, msg.sender), ""Caller is not a remover"");
        delete registrations[registrationId];
    }
}",1.8391966819763184,removeRegistration,"[{'function': 'removeRegistration', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeRegistration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""registrationId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""REMOVER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a remover""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registrations""}, ""index"": {""type"": ""Identifier"", ""name"": ""registrationId""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""REMOVER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.5470201535388974,0.025710986511541,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract RegistrationRemover is AccessControl, Ownable {
    bytes32 public constant REMOVER_ROLE = keccak256(""REMOVER_ROLE"");
    struct Registration {
        address userAddress;
        uint registrationTime;
    }

    mapping(uint => Registration) public registrations;
    uint public nextRegistrationId;

    constructor() AccessControl() Ownable(msg.sender) { // Properly initializing both parent contracts
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(REMOVER_ROLE, msg.sender);
    }

    function removeRegistration(uint registrationId) external onlyRole(REMOVER_ROLE) {
        require(_hasRole(REMOVER_ROLE, msg.sender), ""Caller is not a remover"");
        delete registrations[registrationId];
    }
}"
2632,the goal the campaign must reach in order for it to succeed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Campaign is AccessControl {
    using SafeMath for uint256;

    uint256 public goal;
    bool public succeeded;

    constructor(uint256 _goal) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        goal = _goal;
    }

    function setGoal(uint256 _goal) external onlyRole(DEFAULT_ADMIN_ROLE) {
        goal = _goal;
    }

    function checkSuccess() public view returns (bool) {
        return address(this).balance >= goal;
    }
}",1.6939892768859863,setGoal,"[{'function': 'setGoal', 'complexity': 0}, {'function': 'checkSuccess', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setGoal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_goal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""goal""}, ""right"": {""type"": ""Identifier"", ""name"": ""_goal""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.2716447018401183,0.0437481143122464,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Campaign is Ownable, AccessControl {
    using SafeMath for uint256;

    uint256 public goal = 1;
    bool public succeeded = true;

    constructor(uint256 _goal) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        goal = _goal;
        transferOwnership(msg.sender); // Assuming Ownable should be initialized with the deployer
    }

    function setGoal(uint256 _goal) external onlyRole(DEFAULT_ADMIN_ROLE) {
        goal = _goal;
    }

    function checkSuccess() public view returns (bool) {
        return address(this).balance >= goal;
    }
}"
827,approving image to be taken from specific address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ImageApproval is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant APPROVER_ROLE = keccak256(""APPROVER_ROLE"");
    mapping(address => bool) public approvedImages;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(APPROVER_ROLE, msg.sender);
    }

    function approveImage(address imageAddress) external onlyRole(APPROVER_ROLE) {
        approvedImages[imageAddress] = true;
    }

    function isImageApproved(address imageAddress) external view returns (bool) {
        return approvedImages[imageAddress];
    }
}",1.9506916999816888,approveImage,"[{'function': 'approveImage', 'complexity': 0}, {'function': 'isImageApproved', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveImage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""imageAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedImages""}, ""index"": {""type"": ""Identifier"", ""name"": ""imageAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""APPROVER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.4791144601491136,0.000524747394928,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ImageApproval is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant APPROVER_ROLE = keccak256(""APPROVER_ROLE"");
    mapping(address => bool) public approvedImages;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(APPROVER_ROLE, msg.sender);
    }

    function approveImage(address imageAddress) external onlyRole(APPROVER_ROLE) {
        approvedImages[imageAddress] = true;
    }

    function isImageApproved(address imageAddress) external view returns (bool) {
        return approvedImages[imageAddress];
    }
}"
3458,"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}","pragma solidity ^0.8.0;

interface IState {
    function isSaleActive() external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract MyContract {
    using SafeMath for uint256;

    IState public state;

    modifier onlyWhenSaleActive() {
        require(state.isSaleActive(), ""Sale is not active"");
        _;
    }

    constructor(address _state) {
        state = IState(_state);
    }

    function buyTokens() external payable onlyWhenSaleActive {
        uint256 amount = msg.value;
        // Additional logic for buying tokens with the specified amount
    }
}",2.431718587875366,add,"[{'function': 'isSaleActive', 'complexity': 0}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'buyTokens', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",,0.3341336469838249,0.0199735278294034,"pragma solidity ^0.8.0;

interface IState {
    function isSaleActive() external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    IState public state;

    modifier onlyWhenSaleActive() {
        require(state.isSaleActive(), ""Sale is not active"");
        _;
    }

    constructor(address _state) Ownable(msg.sender) {
        state = IState(_state);
    }

    function buyTokens() external payable onlyWhenSaleActive {
        uint256 amount = msg.value;
        // Additional logic for buying tokens with the specified amount
    }
}"
5648,Creates a checkpoint that can be used to query historical balances / totalSuppy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Checkpoint {
    using SafeMath for uint256;

    struct CheckpointStruct {
        uint256 fromBlock;
        uint256 value;
    }

    mapping(address => CheckpointStruct[]) private checkpoints;

    function createCheckpoint() public returns (bool) {
        require(msg.sender != address(0), ""Invalid sender"");
        // Additional logic can be added here
        return true;
    }
}",1.2753851413726809,createCheckpoint,"[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7251681221608753,0.1415657744124123,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Checkpoint is Ownable {
    using SafeMath for uint256;

    struct CheckpointStruct {
        uint256 fromBlock;
        uint256 value;
    }

    mapping(address => CheckpointStruct[]) private checkpoints;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function createCheckpoint() public returns (bool) {
        require(msg.sender != address(0), ""Invalid sender"");
        // Additional logic can be added here
        return true;
    }
}"
5200,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenTransfer {
    function sendToken(address tokenAddress, address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0, ""Value must be greater than zero"");

        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(_from) >= _value, ""Insufficient balance"");
        require(token.transferFrom(_from, _to, _value), ""Token transfer failed"");

        return true;
    }
}",1.728783130645752,sendToken,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'sendToken', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",59.0,0.7427840023893333,0.2681241572489344,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendToken(address tokenAddress, address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0, ""Value must be greater than zero"");

        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(_from) >= _value, ""Insufficient balance"");
        require(token.transferFrom(_from, _to, _value), ""Token transfer failed"");

        return true;
    }
}"
5602,Allows the owner to destroy the contract and return the tokens to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DestroyContract is Ownable {
    using SafeMath for uint256;

    function destroyAndReturnTokens(address tokenAddress) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
    }
}",1.4848098754882812,destroyAndReturnTokens,"[{'function': 'destroyAndReturnTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyAndReturnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.8057323552308769,0.4690095451109716,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DestroyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function destroyAndReturnTokens(address tokenAddress) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
    }
}"
1932,Called to obtain the loyalty reward balance of any given member,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoyaltyRewards is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private memberBalances;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function getLoyaltyRewardBalance(address member) public view returns (uint256) {
        require(hasRole(ADMIN_ROLE, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have the necessary role to query balances"");
        return memberBalances[member];
    }
}",2.0684497356414795,getLoyaltyRewardBalance,"[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoyaltyRewardBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Caller does not have the necessary role to query balances""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memberBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""member""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",34.0,0.8834641127260081,0.1114052613507808,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract LoyaltyRewards is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private memberBalances;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function getLoyaltyRewardBalance(address member) public view returns (uint256) {
        require(hasRole(ADMIN_ROLE, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have the necessary role to query balances"");
        return memberBalances[member];
    }
}"
4568,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSender {
    using SafeMath for uint256;

    function sendTokens(address _to, uint256 _amount) public {
        IERC20 token = IERC20(msg.sender);
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}",1.6180505752563477,sendTokens,"[{'function': 'sendTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.7907385337685969,0.6401773127248016,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSender is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are not defined in this contract
    }

    function sendTokens(address _to, uint256 _amount) public {
        IERC20 token = IERC20(msg.sender);
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}"
5799,Set the contract address of the rent auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RentAuction is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    address private contractAddress;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function setContractAddress(address _contractAddress) public onlyRole(ADMIN_ROLE) {
        contractAddress = _contractAddress;
    }
}",1.454310178756714,setContractAddress,"[{'function': 'setContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contractAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7382102264954671,0.0178965413626649,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RentAuction is AccessControl, Ownable {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    address private contractAddress;

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, admin);
        transferOwnership(admin);
    }

    function setContractAddress(address _contractAddress) public onlyRole(ADMIN_ROLE) {
        contractAddress = _contractAddress;
    }
}"
694,Withdraw any accumulated fees to the specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeeWithdrawal is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");
    uint256 public accumulatedFees;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WITHDRAWER_ROLE, msg.sender);
    }

    function withdrawFees(address payable recipient) external onlyRole(WITHDRAWER_ROLE) {
        uint256 fees = accumulatedFees;
        require(fees > 0, ""No fees to withdraw"");

        accumulatedFees = 0;
        (bool success, ) = recipient.call{value: fees}("""");
        require(success, ""Transfer failed"");
    }

    function addFees(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        accumulatedFees += amount;
    }
}",2.477726697921753,withdrawFees,"[{'function': 'withdrawFees', 'complexity': 2}, {'function': 'addFees', 'complexity': 0}]",3.0,{},18.0,0.6761807476329014,0.0348599833962719,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FeeWithdrawal is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");
    uint256 public accumulatedFees;

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(WITHDRAWER_ROLE, admin);
        transferOwnership(admin);
    }

    function withdrawFees(address payable recipient) external onlyRole(WITHDRAWER_ROLE) {
        uint256 fees = accumulatedFees;
        require(fees > 0, ""No fees to withdraw"");

        accumulatedFees = 0;
        (bool success, ) = recipient.call{value: fees}("""");
        require(success, ""Transfer failed"");
    }

    function addFees(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        accumulatedFees += amount;
    }
}"
6751,Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract MyToken is IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    function approve(address spender, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _allowances[msg.sender][spender] = amount;
        return true;
    }
}",2.4538345336914062,approve,"[{'function': 'approve', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.5621473000127192,0.0273087975669832,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken is IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 constructor() {
        // Initialize state variables with safe, non-corner-case values
        _totalSupply = 1000 * 10**18; // Example total supply
        _balances[msg.sender] = _totalSupply;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _allowances[msg.sender][spender] = amount;
        return true;
    }
}"
2680,Assigns bonus tokens to the specific contributor .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ContributorBonus is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CONTRIBUTOR_ROLE = keccak256(""CONTRIBUTOR_ROLE"");
    mapping(address => uint256) public contributions;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONTRIBUTOR_ROLE, msg.sender);
    }

    function assignBonusTokens(address contributor, uint256 amount) external onlyRole(CONTRIBUTOR_ROLE) {
        contributions[contributor] = contributions[contributor].add(amount);
    }
}",1.798832654953003,assignBonusTokens,"[{'function': 'assignBonusTokens', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonusTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CONTRIBUTOR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.7150357233325616,0.0317524457450926,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ContributorBonus is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant CONTRIBUTOR_ROLE = keccak256(""CONTRIBUTOR_ROLE"");
    mapping(address => uint256) public contributions;

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONTRIBUTOR_ROLE, msg.sender);
    }

    function assignBonusTokens(address contributor, uint256 amount) external onlyRole(CONTRIBUTOR_ROLE) {
        contributions[contributor] = contributions[contributor].add(amount);
    }
}"
3939,"Change the address of the registryAdmin , who has the privilege to create new accounts","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Registry is AccessControl {
    bytes32 public constant REGISTRY_ADMIN = keccak256(""REGISTRY_ADMIN"");
    address private _registryAdmin;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRegistryAdmin(_msgSender());
    }

    function setRegistryAdmin(address newRegistryAdmin) public onlyRole(REGISTRY_ADMIN) {
        require(newRegistryAdmin != address(0), ""Invalid address"");
        _setRegistryAdmin(newRegistryAdmin);
    }

    function _setRegistryAdmin(address newRegistryAdmin) internal {
        _registryAdmin = newRegistryAdmin;
        grantRole(REGISTRY_ADMIN, newRegistryAdmin);
    }
}",1.847917079925537,setRegistryAdmin,"[{'function': 'setRegistryAdmin', 'complexity': 1}, {'function': '_setRegistryAdmin', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newRegistryAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newRegistryAdmin""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setRegistryAdmin""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRegistryAdmin""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""REGISTRY_ADMIN""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9376243916414796,0.0988151148296687,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Registry is AccessControl, Context {
    bytes32 public constant REGISTRY_ADMIN = keccak256(""REGISTRY_ADMIN"");
    address private _registryAdmin;

    constructor(address initialRegistryAdmin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRegistryAdmin(initialRegistryAdmin);
    }

    function setRegistryAdmin(address newRegistryAdmin) public onlyRole(REGISTRY_ADMIN) {
        require(newRegistryAdmin != address(0), ""Invalid address"");
        _setRegistryAdmin(newRegistryAdmin);
    }

    function _setRegistryAdmin(address newRegistryAdmin) internal {
        _registryAdmin = newRegistryAdmin;
        grantRole(REGISTRY_ADMIN, newRegistryAdmin);
    }
}"
3322,"Returns the contribution to be used as part of the transaction , and any refund value if expected .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContribution {
    function getContribution(address user) external view returns (uint256 contribution, uint256 refund);
}

contract TransactionHandler {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public approvedUsers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyApprovedUser() {
        require(approvedUsers[msg.sender], ""Only approved users can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addApprovedUser(address user) public onlyOwner {
        approvedUsers[user] = true;
    }

    function removeApprovedUser(address user) public onlyOwner {
        require(approvedUsers[user], ""User is not an approved user"");
        delete approvedUsers[user];
    }

    function getTransactionDetails(address user, IContribution contributionContract) public view returns (uint256 contribution, uint256 refund) {
        require(approvedUsers[user] || msg.sender == owner, ""User is not an approved user or the contract owner"");
        return contributionContract.getContribution(user);
    }
}",3.03196668624878,removeApprovedUser,"[{'function': 'getContribution', 'complexity': 0}, {'function': 'addApprovedUser', 'complexity': 0}, {'function': 'removeApprovedUser', 'complexity': 1}, {'function': 'getTransactionDetails', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeApprovedUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, {""type"": ""stringLiteral"", ""value"": ""User is not an approved user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.2497182286363621,0.0019024025103697,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable contract

interface IContribution {
    function getContribution(address user) external view returns (uint256 contribution, uint256 refund);
}

contract TransactionHandler is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedUsers;

    modifier onlyApprovedUser() {
        require(approvedUsers[msg.sender], ""Only approved users can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender;
    }

    function addApprovedUser(address user) public onlyOwner {
        approvedUsers[user] = true;
    }

    function removeApprovedUser(address user) public onlyOwner {
        require(approvedUsers[user], ""User is not an approved user"");
        delete approvedUsers[user];
    }

    function getTransactionDetails(address user, IContribution contributionContract) public view onlyApprovedUser returns (uint256 contribution, uint256 refund) {
        return contributionContract.getContribution(user);
    }
}"
3650,Method for setting a registered issuer firm authority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract IssuerAuthority is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public registeredIssuers;

    event IssuerRegistered(address indexed issuer);
    event IssuerUnregistered(address indexed issuer);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setIssuerAuthority(address issuer) public onlyRole(ISSUER_ROLE) {
        require(!isIssuer(issuer), ""Issuer already registered"");
        registeredIssuers[issuer] = true;
        emit IssuerRegistered(issuer);
    }

    function removeIssuerAuthority(address issuer) public onlyRole(ISSUER_ROLE) {
        require(isIssuer(issuer), ""Issuer not registered"");
        registeredIssuers[issuer] = false;
        emit IssuerUnregistered(issuer);
    }

    function isIssuer(address issuer) public view returns (bool) {
        return registeredIssuers[issuer];
    }
}",2.8332302570343018,setIssuerAuthority,"[{'function': 'setIssuerAuthority', 'complexity': 2}, {'function': 'removeIssuerAuthority', 'complexity': 1}, {'function': 'isIssuer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIssuerAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isIssuer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuer""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Issuer already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredIssuers""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IssuerRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ISSUER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.697449539502027,0.009658665066196,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract IssuerAuthority is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public registeredIssuers;

    event IssuerRegistered(address indexed issuer);
    event IssuerUnregistered(address indexed issuer);

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setIssuerAuthority(address issuer) public onlyRole(ISSUER_ROLE) {
        require(!isIssuer(issuer), ""Issuer already registered"");
        registeredIssuers[issuer] = true;
        emit IssuerRegistered(issuer);
    }

    function removeIssuerAuthority(address issuer) public onlyRole(ISSUER_ROLE) {
        require(isIssuer(issuer), ""Issuer not registered"");
        registeredIssuers[issuer] = false;
        emit IssuerUnregistered(issuer);
    }

    function isIssuer(address issuer) public view returns (bool) {
        return registeredIssuers[issuer];
    }
}"
4267,"Returns holder id for the specified address , creates it if needed .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HolderRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant HOLDER_ROLE = keccak256(""HOLDER_ROLE"");
    mapping(address => uint256) private holderIds;
    uint256 private nextHolderId;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(HOLDER_ROLE, msg.sender);
        nextHolderId = 1;
    }

    function getHolderId(address holderAddress) public returns (uint256) {
        if (holderIds[holderAddress] == 0) {
            holderIds[holderAddress] = nextHolderId;
            _setupRole(HOLDER_ROLE, holderAddress);
            nextHolderId = nextHolderId.add(1);
        }
        return holderIds[holderAddress];
    }
}",2.321643352508545,getHolderId,"[{'function': 'getHolderId', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHolderId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""nextHolderId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setupRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""HOLDER_ROLE""}, {""type"": ""Identifier"", ""name"": ""holderAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextHolderId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nextHolderId""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",114.0,0.6479699509007242,0.01811147836347,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HolderRegistry is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant HOLDER_ROLE = keccak256(""HOLDER_ROLE"");
    mapping(address => uint256) private holderIds;
    uint256 private nextHolderId;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(HOLDER_ROLE, msg.sender);
        nextHolderId = 1;
    }

    function getHolderId(address holderAddress) public returns (uint256) {
        if (holderIds[holderAddress] == 0) {
            holderIds[holderAddress] = nextHolderId;
            _setupRole(HOLDER_ROLE, holderAddress);
            nextHolderId = nextHolderId.add(1);
        }
        return holderIds[holderAddress];
    }
}"
5707,` onlyOwner ` An efficient way to cancel multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CancelPayments is Ownable {
    mapping(address => uint256) public payments;

    function cancelPayment(address payable recipient, uint256 amount) external onlyOwner {
        require(payments[recipient] >= amount, ""Insufficient balance to cancel"");
        if (amount > 0) {
            payments[recipient] -= amount;
            recipient.transfer(amount);
        }
    }
}",1.186403751373291,cancelPayment,"[{'function': 'cancelPayment', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to cancel""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.6797053197723817,0.0834058286896906,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CancelPayments is Ownable {
    mapping(address => uint256) public payments;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        payments[address(0x111)] = 1;
        payments[address(0x222)] = 1;
        payments[address(0x333)] = 1;
    }

    function cancelPayment(address payable recipient, uint256 amount) external onlyOwner {
        require(payments[recipient] >= amount, ""Insufficient balance to cancel"");
        if (amount > 0) {
            payments[recipient] -= amount;
            recipient.transfer(amount);
        }
    }
}"
32,Allows the owner of this contract to set the currentPrice for each token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenPricing is Ownable {
    uint256 public currentPrice;

    function setCurrentPrice(uint256 _newPrice) external onlyOwner {
        require(_newPrice > 0, ""Price must be greater than zero"");
        currentPrice = _newPrice;
    }
}",0.963282823562622,setCurrentPrice,"[{'function': 'setCurrentPrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newPrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8836946637504124,0.1241303298313274,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenPricing is Ownable {
    uint256 public currentPrice;

    constructor() Ownable(msg.sender) {
        currentPrice = 1; // Set to a non-zero value
    }

    function setCurrentPrice(uint256 _newPrice) external onlyOwner {
        require(_newPrice > 0, ""Price must be greater than zero"");
        currentPrice = _newPrice;
    }
}"
2463,Gets a given contract address by bytes32 in order to save gas,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ContractAddressSaver is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SAVED_CONTRACT_ROLE = keccak256(""SAVED_CONTRACT_ROLE"");
    mapping(bytes32 => address) private savedContracts;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SAVED_CONTRACT_ROLE, msg.sender);
    }

    function saveContractAddress(bytes32 contractId, address contractAddress) public onlyRole(SAVED_CONTRACT_ROLE) {
        savedContracts[contractId] = contractAddress;
    }

    function getSavedContractAddress(bytes32 contractId) public view returns (address) {
        return savedContracts[contractId];
    }
}",2.174936294555664,saveContractAddress,"[{'function': 'saveContractAddress', 'complexity': 0}, {'function': 'getSavedContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""saveContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""contractId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""savedContracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""contractId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""SAVED_CONTRACT_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",62.0,0.5232346491720687,0.0001357032967616,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ContractAddressSaver is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SAVED_CONTRACT_ROLE = keccak256(""SAVED_CONTRACT_ROLE"");
    mapping(bytes32 => address) private savedContracts;

    constructor() Ownable() { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SAVED_CONTRACT_ROLE, msg.sender);
    }

    function saveContractAddress(bytes32 contractId, address contractAddress) public onlyRole(SAVED_CONTRACT_ROLE) {
        savedContracts[contractId] = contractAddress;
    }

    function getSavedContractAddress(bytes32 contractId) public view returns (address) {
        return savedContracts[contractId];
    }
}"
1777,"Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract StakingContract {
    using SafeMath for uint256;

    struct Stake {
        uint256 amount;
        bool isLocked;
    }

    mapping(uint256 => Stake) public stakes;

    function setStake(uint256 ID, uint256 stake) external {
        require(stake > 0, ""Stake must be greater than zero"");
        stakes[ID] = Stake({amount: stake, isLocked: true});
    }
}",1.41424560546875,setStake,"[{'function': 'setStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""stake""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Stake must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stake""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""stake""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""amount"", ""isLocked""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.6766770422209246,0.1519596335066871,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Stake {
        uint256 amount;
        bool isLocked;
    }

    mapping(uint256 => Stake) public stakes;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                stakes[i] = Stake({amount: 1, isLocked: true});
            } else if (i == 2) {
                // Placeholder for address initialization
                // Assuming the pattern continues as per the requirement
                stakes[i] = Stake({amount: 1, isLocked: true});
            } else if (i == 3) {
                // Placeholder for address initialization
                // Assuming the pattern continues as per the requirement
                stakes[i] = Stake({amount: 1, isLocked: true});
            }
        }
    }

    function setStake(uint256 ID, uint256 stake) external {
        require(stake > 0, ""Stake must be greater than zero"");
        stakes[ID] = Stake({amount: stake, isLocked: true});
    }
}"
2431,"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}","pragma solidity ^0.8.0;

interface TokenController {
    function proxyPayment(address user) external payable returns (bool);
}

contract MyToken {
    address public owner;
    TokenController public tokenController;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenController) {
        owner = msg.sender;
        tokenController = TokenController(_tokenController);
    }

    fallback() external payable {
        if (owner != address(0)) {
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        }
    }
}",1.5970604419708252,,"[{'function': 'proxyPayment', 'complexity': 0}]",0.0,{},20.0,0.1874240226054952,0.0,"pragma solidity ^0.8.0;

interface TokenController {
    function proxyPayment(address user) external payable returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is TokenController {
    address public owner;
    TokenController public tokenController;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenController) {
        owner = msg.sender;
        tokenController = TokenController(_tokenController);
    }

    fallback() external payable override {
        if (owner != address(0)) {
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        }
    }
}"
1613,Calculate the halving hash rate of a miner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Miner {
    using SafeMath for uint256;

    struct MinerInfo {
        uint256 hashRate;
        uint256 lastHalvingTimestamp;
    }

    mapping(address => MinerInfo) public minerInfos;

    function calculateHalvingHashRate(uint256 initialHashRate, uint256 halvingInterval, uint256 currentTime) public pure returns (uint256) {
        require(initialHashRate > 0, ""Initial hash rate must be greater than zero"");
        require(halvingInterval > 0, ""Halving interval must be greater than zero"");

        if (currentTime < block.timestamp) {
            return initialHashRate >> ((block.timestamp - minerInfos[msg.sender].lastHalvingTimestamp) / halvingInterval);
        } else {
            return initialHashRate;
        }
    }
}",2.163867712020874,calculateHalvingHashRate,"[{'function': 'calculateHalvingHashRate', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateHalvingHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialHashRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halvingInterval"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""initialHashRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Initial hash rate must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""halvingInterval""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Halving interval must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""initialHashRate""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""minerInfos""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""lastHalvingTimestamp""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""halvingInterval""}}], ""isArray"": False}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""initialHashRate""}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",25.0,0.323306534659647,0.0304712438506483,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Miner is Ownable {
    using SafeMath for uint256;

    struct MinerInfo {
        uint256 hashRate;
        uint256 lastHalvingTimestamp;
    }

    mapping(address => MinerInfo) public minerInfos;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        minerInfos[msg.sender].hashRate = 1;
        minerInfos[msg.sender].lastHalvingTimestamp = block.timestamp;
    }

    function calculateHalvingHashRate(uint256 initialHashRate, uint256 halvingInterval, uint256 currentTime) public pure returns (uint256) {
        require(initialHashRate > 0, ""Initial hash rate must be greater than zero"");
        require(halvingInterval > 0, ""Halving interval must be greater than zero"");

        if (currentTime < block.timestamp) {
            return initialHashRate >> ((block.timestamp - minerInfos[msg.sender].lastHalvingTimestamp) / halvingInterval);
        } else {
            return initialHashRate;
        }
    }
}"
2278,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract TokenLocker {
    using SafeMath for uint256;

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function increaseAllowance(address token, address spender, uint256 addedValue) external returns (bool) {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        IERC20 tokenContract = IERC20(token);
        uint256 currentAllowance = tokenContract.allowance(owner, spender);
        uint256 newAllowance = currentAllowance.add(addedValue);
        return tokenContract.approve(spender, newAllowance);
    }
}",3.035285472869873,increaseAllowance,"[{'function': 'approve', 'complexity': 0}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'increaseAllowance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addedValue""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",99.0,0.6305311643287635,0.0583639499280815,"pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b > a, ""SafeMath: addition overflow"");
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenLocker is Ownable {
    using SafeMath for uint256;

    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function increaseAllowance(address token, address spender, uint256 addedValue) external returns (bool) {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        IERC20 tokenContract = IERC20(token);
        uint256 currentAllowance = tokenContract.allowance(owner, spender);
        uint256 newAllowance = currentAllowance.add(addedValue);
        return tokenContract.approve(spender, newAllowance);
    }
}"
4847,Function that is called when transaction target is contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public authorizedAddresses;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedAddresses[msg.sender], ""Not authorized"");
        _;
    }

    constructor() {
        owner = msg.sender;
        authorizedAddresses[msg.sender] = true;
    }

    function addAuthorizedAddress(address addr) public onlyOwner {
        authorizedAddresses[addr] = true;
    }

    function removeAuthorizedAddress(address addr) public onlyOwner {
        require(addr != owner, ""Cannot remove the contract owner"");
        delete authorizedAddresses[addr];
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        owner = newOwner;
    }

    function transactionTargetIsContract() internal view returns (bool) {
        return msg.sender == address(this);
    }
}",2.6566452980041504,removeAuthorizedAddress,"[{'function': 'addAuthorizedAddress', 'complexity': 0}, {'function': 'removeAuthorizedAddress', 'complexity': 1}, {'function': 'transferOwnership', 'complexity': 1}, {'function': 'transactionTargetIsContract', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAuthorizedAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""addr""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot remove the contract owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",61.0,0.3585993344674583,0.0058114410255553,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public authorizedAddresses;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedAddresses[msg.sender], ""Not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        authorizedAddresses[owner] = true;
    }

    function addAuthorizedAddress(address addr) public onlyOwner {
        authorizedAddresses[addr] = true;
    }

    function removeAuthorizedAddress(address addr) public onlyOwner {
        require(addr != owner, ""Cannot remove the contract owner"");
        delete authorizedAddresses[addr];
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Invalid address"");
        owner = newOwner;
    }

    function transactionTargetIsContract() internal view returns (bool) {
        return msg.sender == address(this);
    }
}"
1565,Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    string public name = ""SampleToken"";
    string public symbol = ""STK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Minted(address indexed tokenHolder, uint256 amount);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function mint(address _tokenHolder, uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        _totalSupply = _totalSupply.add(_amount);
        balances[_tokenHolder] = balances[_tokenHolder].add(_amount);
        emit Minted(_tokenHolder, _amount);
    }
}",2.5412118434906006,mint,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenHolder""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenHolder""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Minted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.8418036578127646,0.2235550668505662,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    string public name = ""SampleToken"";
    string public symbol = ""STK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply = 1000000000000000000;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Minted(address indexed tokenHolder, uint256 amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1000000000000000000;
        balances[owner()] = 1;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function mint(address _tokenHolder, uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        _totalSupply = _totalSupply.add(_amount);
        balances[_tokenHolder] = balances[_tokenHolder].add(_amount);
        emit Minted(_tokenHolder, _amount);
    }
}"
5534,Returns the timestamp at which the question will be/was finalized,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract QuestionFinalization {
    using SafeMath for uint256;

    struct Question {
        bool exists;
        uint256 timestamp;
    }

    mapping(uint256 => Question) public questions;

    function getQuestionTimestamp(uint256 questionId) public view returns (uint256) {
        require(questions[questionId].exists, ""Question does not exist"");
        return questions[questionId].timestamp;
    }
}",1.3145473003387451,getQuestionTimestamp,"[{'function': 'getQuestionTimestamp', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getQuestionTimestamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""questionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""questionId""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Question does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""questionId""}}, ""memberName"": ""timestamp""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.6591612739696954,0.1741467509997117,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract QuestionFinalization is Ownable {
    using SafeMath for uint256;

    struct Question {
        bool exists;
        uint256 timestamp;
    }

    mapping(uint256 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            questions[i] = Question({exists: true, timestamp: uint256(addr)});
        }
    }

    function getQuestionTimestamp(uint256 questionId) public view returns (uint256) {
        require(questions[questionId].exists, ""Question does not exist"");
        return questions[questionId].timestamp;
    }
}"
2081,Become owner of a deed for which you are currently approved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DeedApproval is Ownable {
    struct Approval {
        address approver;
        bool approved;
    }

    mapping(uint256 => Approval[]) public approvals;

    function becomeOwnerOfDeed(uint256 deedId) external onlyOwner {
        require(approvals[deedId].length > 0, ""No approval found for this deed"");

        bool isApproved = false;
        uint256 i;
        for (i = 0; i < approvals[deedId].length; i++) {
            if (approvals[deedId][i].approver == msg.sender) {
                require(!isApproved, ""Already approved"");
                isApproved = true;
            }
        }

        require(isApproved, ""Not approved to become owner of this deed"");

        // Transfer ownership or perform other necessary actions here
    }
}",2.206027030944824,becomeOwnerOfDeed,"[{'function': 'becomeOwnerOfDeed', 'complexity': 7}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""becomeOwnerOfDeed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No approval found for this deed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isApproved"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""approver""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isApproved""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Already approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isApproved""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isApproved""}, {""type"": ""stringLiteral"", ""value"": ""Not approved to become owner of this deed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.8178619249011957,0.0360254644237769,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DeedApproval is Ownable {
    struct Approval {
        address approver;
        bool approved;
    }

    mapping(uint256 => Approval[]) public approvals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function becomeOwnerOfDeed(uint256 deedId) external onlyOwner {
        require(approvals[deedId].length > 0, ""No approval found for this deed"");

        bool isApproved = false;
        uint256 i;
        for (i = 0; i < approvals[deedId].length; i++) {
            if (approvals[deedId][i].approver == msg.sender) {
                require(!isApproved, ""Already approved"");
                isApproved = true;
            }
        }

        require(isApproved, ""Not approved to become owner of this deed"");

        // Transfer ownership or perform other necessary actions here
    }
}"
790,Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IRenExBrokerVerifier {
    function setRenExBrokerVerifier(address newAddress) external;
}

contract RenExBrokerVerifierUpdater is Ownable {
    address public renExBrokerVerifier;

    constructor(address _renExBrokerVerifier) {
        renExBrokerVerifier = _renExBrokerVerifier;
    }

    function updateRenExBrokerVerifier(address newAddress) external onlyOwner {
        require(newAddress != address(0), ""Invalid address"");
        IRenExBrokerVerifier(renExBrokerVerifier).setRenExBrokerVerifier(newAddress);
        renExBrokerVerifier = newAddress;
    }
}",1.5988562107086182,updateRenExBrokerVerifier,"[{'function': 'setRenExBrokerVerifier', 'complexity': -2}, {'function': 'updateRenExBrokerVerifier', 'complexity': 1}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateRenExBrokerVerifier"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IRenExBrokerVerifier""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""renExBrokerVerifier""}], ""names"": []}, ""memberName"": ""setRenExBrokerVerifier""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""renExBrokerVerifier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7980514316973886,0.0934899846258443,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IRenExBrokerVerifier {
    function setRenExBrokerVerifier(address newAddress) external;
}
import ""openzeppelin/SafeMath.sol"";
contract RenExBrokerVerifierUpdater is Ownable {
    address public renExBrokerVerifier;

    constructor(address _renExBrokerVerifier) Ownable() {
        renExBrokerVerifier = _renExBrokerVerifier;
    }

    function updateRenExBrokerVerifier(address newAddress) external onlyOwner {
        require(newAddress != address(0), ""Invalid address"");
        IRenExBrokerVerifier(renExBrokerVerifier).setRenExBrokerVerifier(newAddress);
        renExBrokerVerifier = newAddress;
    }
}"
1335,Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OwnerWithdrawal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function withdrawExcessFunds() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No excess funds to withdraw"");
        bool success = token.transfer(owner(), balance);
        require(success, ""Transfer failed"");
    }
}",1.826768159866333,withdrawExcessFunds,"[{'function': 'withdrawExcessFunds', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No excess funds to withdraw""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.8697702663328603,0.1822485002713807,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OwnerWithdrawal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function withdrawExcessFunds() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No excess funds to withdraw"");
        bool success = token.transfer(owner(), balance);
        require(success, ""Transfer failed"");
    }
}"
3433,Permit ` msg.sender ` to set its NeuroChain Address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract NeuroChainAddressSetter is Ownable {
    mapping(address => address) public neuroChainAddresses;

    function setNeuroChainAddress(address _neuroChainAddress) external {
        require(_neuroChainAddress != address(0), ""Invalid address"");
        neuroChainAddresses[msg.sender] = _neuroChainAddress;
    }
}",1.0529937744140625,setNeuroChainAddress,"[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_neuroChainAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_neuroChainAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""neuroChainAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_neuroChainAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.9237386666725668,0.2050346600214682,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeuroChainAddressSetter is Ownable {
    mapping(address => address) public neuroChainAddresses;

    constructor() Ownable(msg.sender) {
        // No need to initialize mappings or other state variables as they are set in the function call above
    }

    function setNeuroChainAddress(address _neuroChainAddress) external {
        require(_neuroChainAddress != address(0), ""Invalid address"");
        neuroChainAddresses[msg.sender] = _neuroChainAddress;
    }
}"
465,Get the token balance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBalanceGetter is AccessControl {
    IERC20 private immutable token;

    constructor(address _token, address admin) {
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
    }

    function getTokenBalance(address account) public view returns (uint256) {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        return token.balanceOf(account);
    }
}",1.5740413665771484,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.7799413766465539,0.2079146503603159,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Corrected import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract TokenBalanceGetter is AccessControl, Ownable {
    IERC20 private immutable token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address admin) Ownable(admin) { // Correctly initialized Ownable
        token = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
    }

    function getTokenBalance(address account) public view returns (uint256) {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        return token.balanceOf(account);
    }
}"
5228,A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IPledge {
    function getDelegateLevel(address delegate) external view returns (uint256);
}

contract PledgeGetter {
    using SafeMath for uint256;

    struct DelegationChain {
        address delegate;
        uint256 level;
    }

    IPledge public pledgeContract;

    constructor(address _pledgeAddress) {
        pledgeContract = IPledge(_pledgeAddress);
    }

    function getDelegateLevel(address delegate) external view returns (uint256) {
        uint256 level = 0;
        address currentDelegate = delegate;

        while (currentDelegate != address(0)) {
            uint256 currentLevel = pledgeContract.getDelegateLevel(currentDelegate);
            require(currentLevel > 0, ""Invalid delegation chain"");
            level = level.add(currentLevel);
            currentDelegate = getPreviousDelegate(currentDelegate);
        }

        return level;
    }

    function getPreviousDelegate(address delegate) internal view returns (address) {
        // Implement logic to retrieve the previous delegate in the chain
        // This is a placeholder for actual implementation details
        return address(0);
    }
}",2.76858901977539,getDelegateLevel,"[{'function': 'getDelegateLevel', 'complexity': 0}, {'function': 'getDelegateLevel', 'complexity': 2}, {'function': 'getPreviousDelegate', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDelegateLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""delegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""level"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentDelegate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""delegate""}}, {""type"": ""WhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentDelegate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentLevel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledgeContract""}, ""memberName"": ""getDelegateLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentDelegate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""currentLevel""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid delegation chain""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""level""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""level""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentLevel""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentDelegate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPreviousDelegate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentDelegate""}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""level""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",35.0,0.7404237345023733,0.0651441488277972,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IPledge {
    function getDelegateLevel(address delegate) external view returns (uint256);
}

contract PledgeGetter is Ownable {
    using SafeMath for uint256;

    struct DelegationChain {
        address delegate;
        uint256 level;
    }

    IPledge public pledgeContract;

    constructor(address _pledgeAddress) Ownable(msg.sender) {
        require(_pledgeAddress != address(0), ""Invalid pledge contract address"");
        pledgeContract = IPledge(_pledgeAddress);
    }

    function getDelegateLevel(address delegate) external view returns (uint256) {
        uint256 level = 0;
        address currentDelegate = delegate;

        while (currentDelegate != address(0)) {
            uint256 currentLevel = pledgeContract.getDelegateLevel(currentDelegate);
            require(currentLevel > 0, ""Invalid delegation chain"");
            level = level.add(currentLevel);
            currentDelegate = getPreviousDelegate(currentDelegate);
        }

        return level;
    }

    function getPreviousDelegate(address delegate) internal view returns (address) {
        // Implement logic to retrieve the previous delegate in the chain
        // This is a placeholder for actual implementation details
        return address(0);
    }
}"
3288,Distirbutes a different quantity of tokens to all the specified addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenDistributor {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function distributeTokens(uint256[] memory amounts, address[] memory recipients) external {
        require(amounts.length == recipients.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
        }
    }
}",1.7433068752288818,distributeTokens,"[{'function': 'distributeTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.6514471712490669,0.0609080236529944,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDistributor is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function distributeTokens(uint256[] memory amounts, address[] memory recipients) external {
        require(amounts.length == recipients.length, ""Length mismatch"");
        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(msg.sender, recipients[i], amounts[i]);
        }
    }
}"
110,This method should be called by the owner before the contribution period starts This initializes most of the parameters,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ContributionInitializer is Ownable {
    using SafeMath for uint256;

    struct InitializationParams {
        address tokenAddress;
        uint256 minContribution;
        uint256 maxContribution;
        uint256 hardCap;
        uint256 softCap;
        uint256 startTime;
        uint256 endTime;
    }

    InitializationParams public params;

    function initialize(
        address _tokenAddress,
        uint256 _minContribution,
        uint256 _maxContribution,
        uint256 _hardCap,
        uint256 _softCap,
        uint256 _startTime,
        uint256 _endTime
    ) external onlyOwner {
        require(_startTime > block.timestamp && _endTime > _startTime, ""Invalid time parameters"");
        require(_minContribution <= _maxContribution, ""Min contribution must be less than or equal to max contribution"");
        require(_hardCap >= _softCap, ""Hard cap must be greater than or equal to soft cap"");

        params = InitializationParams({
            tokenAddress: _tokenAddress,
            minContribution: _minContribution,
            maxContribution: _maxContribution,
            hardCap: _hardCap,
            softCap: _softCap,
            startTime: _startTime,
            endTime: _endTime
        });
    }
}",3.3698854446411133,initialize,"[{'function': 'initialize', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minContribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxContribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_hardCap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_softCap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid time parameters""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_minContribution""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxContribution""}}, {""type"": ""stringLiteral"", ""value"": ""Min contribution must be less than or equal to max contribution""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_hardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""_softCap""}}, {""type"": ""stringLiteral"", ""value"": ""Hard cap must be greater than or equal to soft cap""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""params""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InitializationParams""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}, {""type"": ""Identifier"", ""name"": ""_minContribution""}, {""type"": ""Identifier"", ""name"": ""_maxContribution""}, {""type"": ""Identifier"", ""name"": ""_hardCap""}, {""type"": ""Identifier"", ""name"": ""_softCap""}, {""type"": ""Identifier"", ""name"": ""_startTime""}, {""type"": ""Identifier"", ""name"": ""_endTime""}], ""names"": [""tokenAddress"", ""minContribution"", ""maxContribution"", ""hardCap"", ""softCap"", ""startTime"", ""endTime""]}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",136.0,0.6799606869155737,0.049469780291553,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ContributionInitializer is Ownable {
    using SafeMath for uint256;

    struct InitializationParams {
        address tokenAddress;
        uint256 minContribution;
        uint256 maxContribution;
        uint256 hardCap;
        uint256 softCap;
        uint256 startTime;
        uint256 endTime;
    }

    InitializationParams public params;

    constructor() Ownable(0x1111111111111111111111111111111111111111 , 1) {
        params = InitializationParams({
            tokenAddress: address(0x1111111111111111111111111111111111111111),
            minContribution: 1,
            maxContribution: 1,
            hardCap: 1,
            softCap: 1,
            startTime: block.timestamp + 1,
            endTime: block.timestamp + 100
        });
    }

    function initialize(
        address _tokenAddress,
        uint256 _minContribution,
        uint256 _maxContribution,
        uint256 _hardCap,
        uint256 _softCap,
        uint256 _startTime,
        uint256 _endTime
    ) external onlyOwner {
        require(_startTime > block.timestamp && _endTime > _startTime, ""Invalid time parameters"");
        require(_minContribution <= _maxContribution, ""Min contribution must be less than or equal to max contribution"");
        require(_hardCap >= _softCap, ""Hard cap must be greater than or equal to soft cap"");

        params = InitializationParams({
            tokenAddress: _tokenAddress,
            minContribution: _minContribution,
            maxContribution: _maxContribution,
            hardCap: _hardCap,
            softCap: _softCap,
            startTime: _startTime,
            endTime: _endTime
        });
    }
}"
2093,Get all details of PixelCon # ` ( _tokenIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}","pragma solidity ^0.8.0;

interface IPixelCon {
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

contract PixelConDetailsGetter {
    address private immutable pixelConAddress;

    constructor(address _pixelConAddress) {
        require(_pixelConAddress != address(0), ""Invalid contract address"");
        pixelConAddress = _pixelConAddress;
    }

    function getPixelConDetails(uint256 _tokenIndex) public view returns (string memory) {
        IPixelCon pixelConContract = IPixelCon(pixelConAddress);
        return pixelConContract.tokenURI(_tokenIndex);
    }
}",1.46840500831604,getPixelConDetails,"[{'function': 'tokenURI', 'complexity': 0}, {'function': 'getPixelConDetails', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPixelConDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IPixelCon""}, ""name"": ""pixelConContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IPixelCon""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pixelConAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelConContract""}, ""memberName"": ""tokenURI""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenIndex""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.7370241877846866,0.0435307101515318,"pragma solidity ^0.8.0;

interface IPixelCon {
    function tokenURI(uint256 tokenId) external view returns (string memory);
}
import ""openzeppelin/SafeMath.sol"";
contract PixelConDetailsGetter is Ownable {
    address private immutable pixelConAddress;

    constructor(address _pixelConAddress) Ownable(_pixelConAddress) {
        require(_pixelConAddress != address(0), ""Invalid contract address"");
        pixelConAddress = _pixelConAddress;
    }

    function getPixelConDetails(uint256 _tokenIndex) public view returns (string memory) {
        IPixelCon pixelConContract = IPixelCon(pixelConAddress);
        return pixelConContract.tokenURI(_tokenIndex);
    }
}"
2971,Get the approved address for a single NFT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SingleNFT is Ownable {
    IERC721 public nftContract;
    uint256 private tokenId;

    constructor(address _nftAddress, uint256 _tokenId) {
        nftContract = IERC721(_nftAddress);
        tokenId = _tokenId;
    }

    function getApprovedAddress() public view returns (address) {
        return nftContract.getApproved(tokenId);
    }
}",1.5403223037719729,getApprovedAddress,"[{'function': 'getApprovedAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApprovedAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nftContract""}, ""memberName"": ""getApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.7070169784000807,0.0526326442708959,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SingleNFT is Ownable {
    IERC721 public nftContract;
    uint256 private tokenId;

    constructor(address _nftAddress, uint256 _tokenId) Ownable(msg.sender) {
        nftContract = IERC721(_nftAddress);
        tokenId = _tokenId;
    }

    function getApprovedAddress() public view returns (address) {
        return nftContract.getApproved(tokenId);
    }
}"
2241,Gets absolute issued hardcap volume which means it will be greater than softcap value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}","pragma solidity ^0.8.0;

interface ITokenSale {
    function getHardCap() external view returns (uint256);
    function getSoftCap() external view returns (uint256);
}

contract TokenSaleChecker {
    using SafeMath for uint256;

    function isHardCapExceeded(address tokenSaleAddress) public view returns (bool) {
        ITokenSale tokenSale = ITokenSale(tokenSaleAddress);
        uint256 hardCap = tokenSale.getHardCap();
        uint256 softCap = tokenSale.getSoftCap();
        return hardCap > softCap;
    }
}",1.424018621444702,isHardCapExceeded,"[{'function': 'getSoftCap', 'complexity': 0}, {'function': 'isHardCapExceeded', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isHardCapExceeded"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenSaleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ITokenSale""}, ""name"": ""tokenSale"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITokenSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenSaleAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hardCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenSale""}, ""memberName"": ""getHardCap""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""softCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenSale""}, ""memberName"": ""getSoftCap""}, ""arguments"": [], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""hardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",21.0,0.6919041712658661,0.1279578256865712,"pragma solidity ^0.8.0;

interface ITokenSale {
    function getHardCap() external view returns (uint256);
    function getSoftCap() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSaleChecker is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isHardCapExceeded(address tokenSaleAddress) public view returns (bool) {
        ITokenSale tokenSale = ITokenSale(tokenSaleAddress);
        uint256 hardCap = tokenSale.getHardCap();
        uint256 softCap = tokenSale.getSoftCap();
        return hardCap > softCap;
    }
}"
4491,Exchange ETH to SNX while insisting on a particular set of rates .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}","pragma solidity ^0.8.0;

interface IExchange {
    function exchangeETHForSNX(uint256 amountOutMin, address[] calldata path) external payable returns (uint256);
}

contract Exchange {
    using SafeMath for uint256;

    IExchange public exchange;
    uint256 public rate;

    constructor(address _exchange, uint256 _rate) {
        exchange = IExchange(_exchange);
        rate = _rate;
    }

    function exchangeETHForSNX() external payable {
        require(msg.value > 0, ""Insufficient ETH amount"");
        uint256 amountOutMin = msg.value.mul(rate);
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = SNX;
        exchange.exchangeETHForSNX{value: msg.value}(amountOutMin, path);
    }
}",2.0557637214660645,exchangeETHForSNX,"[{'function': 'exchangeETHForSNX', 'complexity': 0}, {'function': 'exchangeETHForSNX', 'complexity': 1}]",2.0,{},36.0,0.6650118756828444,0.0372836011920248,"pragma solidity ^0.8.0;

interface IExchange {
    function exchangeETHForSNX(uint256 amountOutMin, address[] calldata path) external payable returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Exchange is Ownable {
    using SafeMath for uint256;

    IExchange public exchange;
    uint256 public rate;

    constructor(address _exchange, uint256 _rate) Ownable(msg.sender) {
        exchange = IExchange(_exchange);
        rate = _rate;
    }

    function exchangeETHForSNX() external payable {
        require(msg.value > 0, ""Insufficient ETH amount"");
        uint256 amountOutMin = msg.value.mul(rate);
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = SNX;
        exchange.exchangeETHForSNX{value: msg.value}(amountOutMin, path);
    }
}"
4173,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract ETHBalances {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function getUserBalances(address user) external view returns (uint256 supplyBalance, uint256 borrowBalance) {
        uint256 supplyBalanceRaw = token.balanceOf(user);
        uint256 borrowBalanceRaw = 0; // Assume no borrowing functionality for simplicity

        supplyBalance = supplyBalanceRaw.div(1e18);
        borrowBalance = borrowBalanceRaw.div(1e18);
    }
}",3.788264751434326,getUserBalances,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'mul', 'complexity': 1}, {'function': 'div', 'complexity': 1}, {'function': 'getUserBalances', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mul"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: multiplication overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",24.0,0.6854481124586276,0.0384506342507836,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ETHBalances is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function getUserBalances(address user) external view returns (uint256 supplyBalance, uint256 borrowBalance) {
        uint256 supplyBalanceRaw = token.balanceOf(user);
        uint256 borrowBalanceRaw = 0; // Assume no borrowing functionality for simplicity

        supplyBalance = supplyBalanceRaw.div(1e18);
        borrowBalance = borrowBalanceRaw.div(1e18);
    }
}"
4418,Create a new payment channel between two parties,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentChannel is Ownable {
    using SafeMath for uint256;

    struct Channel {
        address payable sender;
        address payable receiver;
        uint256 balance;
        bool open;
        mapping(address => uint256) approvals;
        uint256 approvalCount;
    }

    mapping(bytes32 => Channel) public channels;

    event Funded(bytes32 indexed channelId, address sender, uint256 amount);
    event Closed(bytes32 indexed channelId, address receiver, uint256 amount);
    event Withdrawn(bytes32 indexed channelId, address to, uint256 amount);
    event Approved(bytes32 indexed channelId, address approver);

    function createChannel(bytes32 channelId, address payable sender, address payable receiver) public {
        require(channels[channelId].open == false, ""Channel already exists"");
        channels[channelId] = Channel({sender: sender, receiver: receiver, balance: 0, open: true});
    }

    function fundChannel(bytes32 channelId, uint256 amount) public payable {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender == channels[channelId].sender || msg.sender == channels[channelId].receiver, ""Not a party to the channel"");
        channels[channelId].balance += amount;
        emit Funded(channelId, msg.sender, amount);
    }

    function closeChannel(bytes32 channelId) public {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender == channels[channelId].receiver || msg.sender == owner(), ""Not authorized to close the channel"");
        uint256 amount = channels[channelId].balance;
        if (msg.sender == channels[channelId].receiver) {
            require(channels[channelId].approvals[msg.sender] > 0, ""Receiver must approve before closing"");
        } else {
            require(channels[channelId].approvalCount >= 1, ""At least one party must approve before closing"");
        }
        channels[channelId].open = false;
        if (address(this).balance >= amount) {
            (bool success, ) = channels[channelId].receiver.call{value: amount}("""");
            require(success, ""Transfer failed"");
        }
        emit Closed(channelId, channels[channelId].receiver, amount);
    }

    function withdrawFromChannel(bytes32 channelId) public {
        require(channels[channelId].open == false, ""Channel is still open"");
        require(msg.sender == channels[channelId].sender || msg.sender == channels[channelId].receiver, ""Not a party to the channel"");
        uint256 amount = channels[channelId].balance;
        if (msg.sender == channels[channelId].sender) {
            require(channels[channelId].approvals[msg.sender] > 0, ""Sender must approve before withdrawing"");
        } else {
            require(channels[channelId].approvalCount >= 1, ""At least one party must approve before withdrawing"");
        }
        channels[channelId].balance = 0;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Withdrawn(channelId, msg.sender, amount);
    }

    function approveChannel(bytes32 channelId) public {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender != channels[channelId].sender && msg.sender != channels[channelId].receiver, ""Sender or receiver cannot approve"");
        if (channels[channelId].approvals[msg.sender] == 0) {
            channels[channelId].approvalCount++;
        }
        channels[channelId].approvals[msg.sender] = 1;
        emit Approved(channelId, msg.sender);
    }
}",8.628052949905396,closeChannel,"[{'function': 'createChannel', 'complexity': 1}, {'function': 'fundChannel', 'complexity': 3}, {'function': 'closeChannel', 'complexity': 10}, {'function': 'withdrawFromChannel', 'complexity': 9}, {'function': 'approveChannel', 'complexity': 4}]",12.0,{},114.0,0.5461392622632993,0.0214536467617627,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentChannel is Ownable {
    using SafeMath for uint256;

    struct Channel {
        address payable sender;
        address payable receiver;
        uint256 balance;
        bool open;
        mapping(address => uint256) approvals;
        uint256 approvalCount;
    }

    mapping(bytes32 => Channel) public channels;

    event Funded(bytes32 indexed channelId, address sender, uint256 amount);
    event Closed(bytes32 indexed channelId, address receiver, uint256 amount);
    event Withdrawn(bytes32 indexed channelId, address to, uint256 amount);
    event Approved(bytes32 indexed channelId, address approver);

    constructor() Ownable(msg.sender) {
        channels[bytes32('init')] = Channel({sender: 0x1111111111111111111111111111111111111111, receiver: 0x2222222222222222222222222222222222222222, balance: 1, open: true});
    }

    function createChannel(bytes32 channelId, address payable sender, address payable receiver) public {
        require(channels[channelId].open == false, ""Channel already exists"");
        channels[channelId] = Channel({sender: sender, receiver: receiver, balance: 0, open: true});
    }

    function fundChannel(bytes32 channelId, uint256 amount) public payable {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender == channels[channelId].sender || msg.sender == channels[channelId].receiver, ""Not a party to the channel"");
        channels[channelId].balance += amount;
        emit Funded(channelId, msg.sender, amount);
    }

    function closeChannel(bytes32 channelId) public {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender == channels[channelId].receiver || msg.sender == owner(), ""Not authorized to close the channel"");
        uint256 amount = channels[channelId].balance;
        if (msg.sender == channels[channelId].receiver) {
            require(channels[channelId].approvals[msg.sender] > 0, ""Receiver must approve before closing"");
        } else {
            require(channels[channelId].approvalCount >= 1, ""At least one party must approve before closing"");
        }
        channels[channelId].open = false;
        if (address(this).balance >= amount) {
            (bool success, ) = channels[channelId].receiver.call{value: amount}("""");
            require(success, ""Transfer failed"");
        }
        emit Closed(channelId, channels[channelId].receiver, amount);
    }

    function withdrawFromChannel(bytes32 channelId) public {
        require(channels[channelId].open == false, ""Channel is still open"");
        require(msg.sender == channels[channelId].sender || msg.sender == channels[channelId].receiver, ""Not a party to the channel"");
        uint256 amount = channels[channelId].balance;
        if (msg.sender == channels[channelId].sender) {
            require(channels[channelId].approvals[msg.sender] > 0, ""Sender must approve before withdrawing"");
        } else {
            require(channels[channelId].approvalCount >= 1, ""At least one party must approve before withdrawing"");
        }
        channels[channelId].balance = 0;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");
        emit Withdrawn(channelId, msg.sender, amount);
    }

    function approveChannel(bytes32 channelId) public {
        require(channels[channelId].open == true, ""Channel does not exist"");
        require(msg.sender != channels[channelId].sender && msg.sender != channels[channelId].receiver, ""Sender or receiver cannot approve"");
        if (channels[channelId].approvals[msg.sender] == 0) {
            channels[channelId].approvalCount++;
        }
        channels[channelId].approvals[msg.sender] = 1;
        emit Approved(channelId, msg.sender);
    }
}"
6848,from ` _from ` will be sended ` _value ` tokens to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    function transferTokens(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_value > 0, ""Value must be greater than zero"");
        IERC20 token = IERC20(0xYourTokenAddress); // Replace with actual token contract address
        bool transferSuccess = token.transferFrom(_from, _to, _value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}",1.5965290069580078,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,{},79.0,0.8185115509865453,0.4083017288661291,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    // Fixed, safe values for instance variables
    uint256 public constant DEFAULT_VALUE = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        _value = DEFAULT_VALUE;
        _tokenAddress = DEFAULT_ADDRESS;
        _transferSuccess = DEFAULT_BOOL;
    }

    uint256 private _value;
    address public constant _tokenAddress;
    bool public constant _transferSuccess;

    function transferTokens(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_value > 0, ""Value must be greater than zero"");
        IERC20 token = IERC20(DEFAULT_ADDRESS); // Replace with actual token contract address
        bool transferSuccess = token.transferFrom(_from, _to, _value);
        require(transferSuccess, ""Token transfer failed"");
        _transferSuccess = true;
        return true;
    }
}"
967,Sets the message sender as the winner if they have completed the hunt,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract HuntWinnerSetter is Ownable {
    string public currentMessage;
    uint256 public completionTime;

    function setHuntWinner(string memory message, uint256 time) external onlyOwner {
        require(time <= block.timestamp, ""Completion time must be in the future"");
        currentMessage = message;
        completionTime = time;
    }
}",1.1130425930023191,setHuntWinner,"[{'function': 'setHuntWinner', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHuntWinner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""message"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""time"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""time""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Completion time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentMessage""}, ""right"": {""type"": ""Identifier"", ""name"": ""message""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""completionTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""time""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",59.0,0.5292664092742161,0.0030194376408351,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HuntWinnerSetter is Ownable {
    string public currentMessage;
    uint256 public completionTime;

    constructor(string memory message, uint256 time) Ownable(msg.sender) {
        require(time > block.timestamp, ""Completion time must be in the future"");
        currentMessage = message;
        completionTime = time;
    }

    function setHuntWinner(string memory message, uint256 time) external onlyOwner {
        require(time <= block.timestamp, ""Completion time must be in the future"");
        currentMessage = message;
        completionTime = time;
    }
}"
5478,Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken is IERC20 {
    function mint(address to, uint256 amount) external;
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public _buyExchangeRate;
    uint256 public _sellExchangeRate;

    constructor(address _tokenAddress, uint256 buyRate, uint256 sellRate) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
        _buyExchangeRate = buyRate;
        _sellExchangeRate = sellRate;
    }

    function buyTokens() public payable {
        uint256 amount = msg.value.mul(_buyExchangeRate);
        require(amount > 0, ""Insufficient funds sent"");
        token.mint(msg.sender, amount);
    }

    function sellTokens(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 ethAmount = amount.div(_sellExchangeRate);
        require(ethAmount <= address(this).balance, ""Insufficient balance to fulfill the sale"");
        token.transferFrom(msg.sender, address(this), amount);
        payable(msg.sender).transfer(ethAmount);
    }
}",3.4330921173095703,sellTokens,"[{'function': 'mint', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sellExchangeRate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""ethAmount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to fulfill the sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.5027518794663155,0.0099993773696564,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken is IERC20 {
    function mint(address to, uint256 amount) external;
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public _buyExchangeRate;
    uint256 public _sellExchangeRate;

    constructor(address _tokenAddress, uint256 buyRate, uint256 sellRate) Ownable() {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
        _buyExchangeRate = buyRate;
        _sellExchangeRate = sellRate;
    }

    function buyTokens() public payable {
        uint256 amount = msg.value.mul(_buyExchangeRate);
        require(amount > 0, ""Insufficient funds sent"");
        token.mint(msg.sender, amount);
    }

    function sellTokens(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 ethAmount = amount.div(_sellExchangeRate);
        require(ethAmount <= address(this).balance, ""Insufficient balance to fulfill the sale"");
        token.transferFrom(msg.sender, address(this), amount);
        payable(msg.sender).transfer(ethAmount);
    }
}"
1010,Fills a offer that has been previously made using ` makeOffer ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Marketplace is AccessControl {
    using SafeMath for uint256;

    enum OfferStatus { Pending, Filled }

    struct Offer {
        address seller;
        uint256 price;
        OfferStatus status;
    }

    mapping(uint256 => Offer) public offers;
    uint256 public offerCount;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function makeOffer(uint256 price) external {
        require(price > 0, ""Price must be greater than zero"");
        offers[offerCount] = Offer({seller: msg.sender, price: price, status: OfferStatus.Pending});
        offerCount++;
    }

    function fillOffer(uint256 index) external {
        require(_exists(index), ""Offer does not exist"");
        require(offers[index].status == OfferStatus.Pending, ""Offer is already filled or invalid"");
        require(msg.sender != offers[index].seller, ""Seller cannot fill their own offer"");

        offers[index].status = OfferStatus.Filled;
        // Transfer funds from buyer to seller
        (bool success, ) = payable(offers[index].seller).call{value: offers[index].price}("""");
        require(success, ""Transfer failed"");
    }

    function _exists(uint256 index) internal view returns (bool) {
        return index < offerCount && offers[index].status != OfferStatus.Filled;
    }
}",3.608719348907471,fillOffer,"[{'function': 'makeOffer', 'complexity': 1}, {'function': 'fillOffer', 'complexity': 4}, {'function': '_exists', 'complexity': 0}]",6.0,{},73.0,0.7534281595205786,0.0284059949815589,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Marketplace is Ownable {
    using SafeMath for uint256;

    enum OfferStatus { Pending, Filled }

    struct Offer {
        address seller;
        uint256 price;
        OfferStatus status;
    }

    mapping(uint256 => Offer) public offers;
    uint256 public offerCount;

    constructor() Ownable() {
        // Initialize state variables with safe, non-corner-case values
        offerCount = 1;
    }

    function makeOffer(uint256 price) external {
        require(price > 0, ""Price must be greater than zero"");
        offers[offerCount] = Offer({seller: msg.sender, price: price, status: OfferStatus.Pending});
        offerCount++;
    }

    function fillOffer(uint256 index) external {
        require(_exists(index), ""Offer does not exist"");
        require(offers[index].status == OfferStatus.Pending, ""Offer is already filled or invalid"");
        require(msg.sender != offers[index].seller, ""Seller cannot fill their own offer"");

        offers[index].status = OfferStatus.Filled;
        // Transfer funds from buyer to seller
        (bool success, ) = payable(offers[index].seller).call{value: offers[index].price}("""");
        require(success, ""Transfer failed"");
    }

    function _exists(uint256 index) internal view returns (bool) {
        return index < offerCount && offers[index].status != OfferStatus.Filled;
    }
}"
1790,Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISynthetix {
    function updateSynthetixExchangeRate(uint256 newRate) external;
}

contract SynthetixDrawingRights is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPDATE_RIGHTS = keccak256(""UPDATE_RIGHTS"");
    ISynthetix public synthetix;

    constructor(address _synthetix) {
        require(_synthetix != address(0), ""Invalid Synthetix address"");
        synthetix = ISynthetix(_synthetix);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(UPDATE_RIGHTS, msg.sender);
    }

    function updateExchangeRate(uint256 newRate) external onlyRole(UPDATE_RIGHTS) {
        synthetix.updateSynthetixExchangeRate(newRate);
    }
}",2.402179479598999,updateExchangeRate,"[{'function': 'updateSynthetixExchangeRate', 'complexity': 0}, {'function': 'updateExchangeRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateExchangeRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetix""}, ""memberName"": ""updateSynthetixExchangeRate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRate""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPDATE_RIGHTS""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",72.0,0.6625067934913701,0.0039195987810005,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynthetix {
    function updateSynthetixExchangeRate(uint256 newRate) external;
}

contract SynthetixDrawingRights is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPDATE_RIGHTS = keccak256(""UPDATE_RIGHTS"");
    ISynthetix public synthetix;

    constructor(address _synthetix) {
        require(_synthetix != address(0), ""Invalid Synthetix address"");
        synthetix = ISynthetix(_synthetix);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(UPDATE_RIGHTS, msg.sender);
    }

    function updateExchangeRate(uint256 newRate) external onlyRole(UPDATE_RIGHTS) {
        synthetix.updateSynthetixExchangeRate(newRate);
    }
}"
3704,Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    IERC20 public token;
    address payable public owner;
    uint256 public rate = 1000; // Rate of tokens per ether (1 ETH = 1000 tokens)

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
        owner = payable(msg.sender);
    }

    function buyTokens() public payable {
        require(msg.value > 0, ""Minimum contribution is zero ether"");
        uint256 tokensToBuy = msg.value.mul(rate);
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");
        token.transfer(msg.sender, tokensToBuy);
    }
}",2.19105076789856,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum contribution is zero ether""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",,0.6873973666197929,0.2301149533483296,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address payable public owner;
    uint256 public rate = 1000; // Rate of tokens per ether (1 ETH = 1000 tokens)

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        token = IERC20(""MyToken""); // Use a placeholder value for ERC20 mapping(address => uint256) public balanceOf;

 constructor
        owner = payable(0x1111111111111111111111111111111111111111); // Fixed address
        rate = 1000; // Set to fixed value
    }

    function buyTokens() public payable {
        require(msg.value > 0, ""Minimum contribution is zero ether"");
        uint256 tokensToBuy = msg.value.mul(rate);
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");
        token.transfer(msg.sender, tokensToBuy);
    }
}"
2468,"Decentralizes the contract , this operation can not be undone","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DecentralizedContract is Ownable {
    bool public decentralized = false;

    function decentralize() external onlyOwner {
        require(!decentralized, ""Contract is already decentralized"");
        decentralized = true;
    }
}",0.8378276824951172,decentralize,"[{'function': 'decentralize', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""decentralize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""decentralized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract is already decentralized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""decentralized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.5881901448432433,0.0814364770841942,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DecentralizedContract is Ownable {
    bool public decentralized = false;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        decentralized = true; // Set to true immediately upon deployment
    }

    function decentralize() external onlyOwner {
        require(!decentralized, ""Contract is already decentralized"");
        decentralized = true;
    }
}"
97,This is public rather than external so it can be called by derived contracts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function performOperation(uint256 a, uint256 b) public pure returns (uint256) {
        require(a > 0 && b > 0, ""Inputs must be greater than zero"");
        return a.mul(b);
    }
}",1.06471848487854,performOperation,"[{'function': 'performOperation', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""performOperation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Inputs must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",20.0,0.196592340376493,0.0125347246907176,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function performOperation(uint256 a, uint256 b) public pure returns (uint256) {
        require(a > 0 && b > 0, ""Inputs must be greater than zero"");
        return a.mul(b);
    }
}"
5181,Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ThirdPartyOwnerChecker is Ownable {
    mapping(address => bool) public thirdPartyOwners;

    function addThirdPartyOwner(address _address) external onlyOwner {
        require(_address != owner(), ""Address cannot be the origin owner"");
        thirdPartyOwners[_address] = true;
    }

    function removeThirdPartyOwner(address _address) external onlyOwner {
        require(_address != owner(), ""Address cannot be the origin owner"");
        delete thirdPartyOwners[_address];
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return thirdPartyOwners[_address];
    }
}",1.6733670234680176,addThirdPartyOwner,"[{'function': 'addThirdPartyOwner', 'complexity': 1}, {'function': 'removeThirdPartyOwner', 'complexity': 1}, {'function': 'isThirdPartyOwner', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addThirdPartyOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address cannot be the origin owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""thirdPartyOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7106822360247832,0.0986563751769119,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ThirdPartyOwnerChecker is Ownable {
    mapping(address => bool) public thirdPartyOwners;
    address public constant DEFAULT_OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bytes32 public constant DEFAULT_INIT_VALUE = bytes32('init');

    constructor() Ownable(DEFAULT_OWNER) {
        thirdPartyOwners[DEFAULT_OWNER] = true;
    }

    function addThirdPartyOwner(address _address) external onlyOwner {
        require(_address != owner(), ""Address cannot be the origin owner"");
        thirdPartyOwners[_address] = true;
    }

    function removeThirdPartyOwner(address _address) external onlyOwner {
        require(_address != owner(), ""Address cannot be the origin owner"");
        delete thirdPartyOwners[_address];
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return thirdPartyOwners[_address];
    }
}"
4562,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Dividend {
    using SafeMath for uint256;

    address[] public excludedAddresses;
    mapping(address => bool) private isExcluded;
    uint256 public totalDividends;

    constructor(address[] memory _excludedAddresses) {
        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            isExcluded[_excludedAddresses[i]] = true;
        }
    }

    function createDividend(uint256 amount) public onlyOwner {
        require(!isContract(msg.sender), ""Ownable: caller is a contract"");
        totalDividends += amount;
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",2.1078481674194336,isContract,"[{'function': 'createDividend', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",187.0,0.2690397852123531,1.2264433015021532e-05,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Dividend is Ownable {
    using SafeMath for uint256;

    address[] public excludedAddresses;
    mapping(address => bool) private isExcluded;
    uint256 public totalDividends;

    constructor(address[] memory _excludedAddresses) Ownable(msg.sender) {
        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            isExcluded[_excludedAddresses[i]] = true;
        }
    }

    function createDividend(uint256 amount) public onlyOwner {
        require(!isContract(msg.sender), ""Ownable: caller is a contract"");
        totalDividends += amount;
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
6025,Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDeposit is Ownable {
    IERC20 public token;
    mapping(address => uint256) public deposits;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function depositTokens(uint256 amount) external onlyOwner {
        require(token.transferFrom(msg.sender, address(this), amount), ""Token transfer failed"");
        deposits[msg.sender] += amount;
    }
}",1.56144118309021,depositTokens,"[{'function': 'depositTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.7504210562855906,0.0451332899366428,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDeposit is Ownable {
    IERC20 public token;
    mapping(address => uint256) public deposits;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables to safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function depositTokens(uint256 amount) external onlyOwner {
        require(token.transferFrom(msg.sender, address(this), amount), ""Token transfer failed"");
        deposits[msg.sender] += amount;
    }
}"
521,set the ticker registration fee in POLY tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TickerRegistration is AccessControl {
    using SafeMath for uint256;

    IERC20 public polyToken;
    uint256 public registrationFee;
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor(address _polyToken, uint256 initialFee) {
        polyToken = IERC20(_polyToken);
        registrationFee = initialFee;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setRegistrationFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {
        registrationFee = newFee;
    }
}",2.1709041595458984,setRegistrationFee,"[{'function': 'setRegistrationFee', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegistrationFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""newFee""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.7443043117274512,0.0218507314787355,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TickerRegistration is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 public polyToken;
    uint256 public registrationFee;
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor(address _polyToken, uint256 initialFee) Ownable(msg.sender) {
        polyToken = IERC20(_polyToken);
        registrationFee = initialFee;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setRegistrationFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {
        registrationFee = newFee;
    }
}"
2313,Set both ico min at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ICO is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct ICOConfig {
        uint256 minContribution;
    }

    mapping(address => ICOConfig) public icoConfigs;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function setICOMin(address[] memory users, uint256 minContribution) public onlyRole(ADMIN_ROLE) {
        require(users.length > 0, ""At least one user must be specified"");
        for (uint256 i = 0; i < users.length; i++) {
            icoConfigs[users[i]] = ICOConfig({minContribution: minContribution});
        }
    }
}",2.5034899711608887,setICOMin,"[{'function': 'setICOMin', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOMin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""users"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minContribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""users""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""At least one user must be specified""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""users""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""icoConfigs""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ICOConfig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""minContribution""}], ""names"": [""minContribution""]}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.6332819941148372,0.0553106039492109,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ICO is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct ICOConfig {
        uint256 minContribution;
    }

    mapping(address => ICOConfig) public icoConfigs;

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function setICOMin(address[] memory users, uint256 minContribution) public onlyRole(ADMIN_ROLE) {
        require(users.length > 0, ""At least one user must be specified"");
        for (uint256 i = 0; i < users.length; i++) {
            icoConfigs[users[i]] = ICOConfig({minContribution: minContribution});
        }
    }
}"
1838,Keep a US Citizen 's tokens for one year .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract USCitizenTokenLock {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public lockEndTime;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function lockTokensForOneYear(uint256 amount, address beneficiary) external {
        require(beneficiary != address(0), ""Invalid beneficiary address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 duration = 365 days; // Assuming a year is 365 days for simplicity
        lockEndTime[beneficiary] = block.timestamp.add(duration);

        require(token.transferFrom(msg.sender, address(this), amount), ""Token transfer failed"");
    }

    function releaseTokens(address beneficiary) external {
        require(block.timestamp >= lockEndTime[beneficiary], ""Lock period not over yet"");
        uint256 amount = token.balanceOf(address(this));
        require(token.transfer(beneficiary, amount), ""Token transfer failed"");
    }
}",2.8786773681640625,lockTokensForOneYear,"[{'function': 'lockTokensForOneYear', 'complexity': 3}, {'function': 'releaseTokens', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""lockTokensForOneYear"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid beneficiary address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""duration"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockEndTime""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""duration""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5814581622450273,0.1871167615842218,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract USCitizenTokenLock is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public lockEndTime;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function lockTokensForOneYear(uint256 amount, address beneficiary) external {
        require(beneficiary != address(0), ""Invalid beneficiary address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 duration = 365 days; // Assuming a year is 365 days for simplicity
        lockEndTime[beneficiary] = block.timestamp.add(duration);

        require(token.transferFrom(msg.sender, address(this), amount), ""Token transfer failed"");
    }

    function releaseTokens(address beneficiary) external {
        require(block.timestamp >= lockEndTime[beneficiary], ""Lock period not over yet"");
        uint256 amount = token.balanceOf(address(this));
        require(token.transfer(beneficiary, amount), ""Token transfer failed"");
    }
}"
6404,Adds multiple addresses to the administrator list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AdminListAdder is AccessControl {
    mapping(address => bool) public administrators;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addAdministrators(address[] memory addresses) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        for (uint256 i = 0; i < addresses.length; i++) {
            administrators[addresses[i]] = true;
        }
    }
}",1.422398805618286,addAdministrators,"[{'function': 'addAdministrators', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAdministrators"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""administrators""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.7136505487873464,0.1040104908581871,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminListAdder is AccessControl, Ownable {
    mapping(address => bool) public administrators;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addAdministrators(address[] memory addresses) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        for (uint256 i = 0; i < addresses.length; i++) {
            administrators[addresses[i]] = true;
        }
    }
}"
892,Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CarbonDollar is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");
    IERC20 public stablecoin;
    uint256 public defaultFee;

    constructor(address _stablecoin, uint256 _defaultFee) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);
        stablecoin = IERC20(_stablecoin);
        defaultFee = _defaultFee;
    }

    function setDefaultFee(uint256 newFee) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        defaultFee = newFee;
    }

    function burnCarbonDollar(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 fee = amount.mul(defaultFee).div(100);
        uint256 netBurnAmount = amount.sub(fee);
        stablecoin.transferFrom(msg.sender, address(this), fee);
        stablecoin.burn(netBurnAmount);
    }
}",3.2731621265411377,burnCarbonDollar,"[{'function': 'setDefaultFee', 'complexity': 1}, {'function': 'burnCarbonDollar', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnCarbonDollar"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""defaultFee""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""netBurnAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stablecoin""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stablecoin""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""netBurnAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.4354928376177682,0.0291929647997162,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CarbonDollar is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BURNER_ROLE = keccak256(""BURNER_ROLE"");
    IERC20 public stablecoin;
    uint256 public defaultFee;

    constructor(address _stablecoin, uint256 _defaultFee) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);
        stablecoin = IERC20(_stablecoin);
        defaultFee = _defaultFee;
    }

    function setDefaultFee(uint256 newFee) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        defaultFee = newFee;
    }

    function burnCarbonDollar(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 fee = amount.mul(defaultFee).div(100);
        uint256 netBurnAmount = amount.sub(fee);
        stablecoin.transferFrom(msg.sender, address(this), fee);
        stablecoin.burn(netBurnAmount);
    }
}"
3332,"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}","pragma solidity ^0.8.0;

interface IDataOrder {
    function getDataResponses() external view returns (address[] memory);
}

contract DataOrderManager {
    address[] private openDataOrders;

    function getAllOpenDataOrders() public view returns (address[] memory) {
        return openDataOrders;
    }

    function updateOpenDataOrders(address[] memory newOrders) internal {
        openDataOrders = newOrders;
    }
}

contract DataOrderRegistry is IDataOrder, DataOrderManager {
    mapping(address => bool) private dataOrderExists;

    event DataOrderAdded(address indexed orderAddress);
    event DataOrderRemoved(address indexed orderAddress);

    function addDataOrder(address orderAddress) public {
        require(!dataOrderExists[orderAddress], ""Data order already exists"");
        dataOrderExists[orderAddress] = true;
        openDataOrders.push(orderAddress);
        emit DataOrderAdded(orderAddress);
    }

    function removeDataOrder(address orderAddress) public {
        require(dataOrderExists[orderAddress], ""Data order does not exist"");
        dataOrderExists[orderAddress] = false;
        for (uint i = 0; i < openDataOrders.length; i++) {
            if (openDataOrders[i] == orderAddress) {
                openDataOrders[i] = openDataOrders[openDataOrders.length - 1];
                openDataOrders.pop();
                break;
            }
        }
        emit DataOrderRemoved(orderAddress);
    }

    function getDataResponses() external view override returns (address[] memory) {
        return openDataOrders;
    }
}",3.4433038234710693,removeDataOrder,"[{'function': 'getDataResponses', 'complexity': 0}, {'function': 'getAllOpenDataOrders', 'complexity': 0}, {'function': 'updateOpenDataOrders', 'complexity': 0}, {'function': 'addDataOrder', 'complexity': 2}, {'function': 'removeDataOrder', 'complexity': 5}, {'function': 'getDataResponses', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addDataOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""orderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dataOrderExists""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Data order already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dataOrderExists""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""openDataOrders""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderAddress""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DataOrderAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.579578992996747,0.1159036067152758,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IDataOrder {
    function getDataResponses() external view returns (address[] memory);
}
import ""openzeppelin/SafeMath.sol"";
contract DataOrderManager is Ownable {
    address[] private openDataOrders;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getAllOpenDataOrders() public view returns (address[] memory) {
        return openDataOrders;
    }

    function updateOpenDataOrders(address[] memory newOrders) internal {
        openDataOrders = newOrders;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract DataOrderRegistry is IDataOrder, DataOrderManager, Ownable {
    mapping(address => bool) private dataOrderExists;

    event DataOrderAdded(address indexed orderAddress);
    event DataOrderRemoved(address indexed orderAddress);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addDataOrder(address orderAddress) public {
        require(!dataOrderExists[orderAddress], ""Data order already exists"");
        dataOrderExists[orderAddress] = true;
        openDataOrders.push(orderAddress);
        emit DataOrderAdded(orderAddress);
    }

    function removeDataOrder(address orderAddress) public {
        require(dataOrderExists[orderAddress], ""Data order does not exist"");
        dataOrderExists[orderAddress] = false;
        for (uint i = 0; i < openDataOrders.length; i++) {
            if (openDataOrders[i] == orderAddress) {
                openDataOrders[i] = openDataOrders[openDataOrders.length - 1];
                openDataOrders.pop();
                break;
            }
        }
        emit DataOrderRemoved(orderAddress);
    }

    function getDataResponses() external view override returns (address[] memory) {
        return openDataOrders;
    }
}"
2110,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanPayer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    address payable public converterRamp;

    constructor(address _converterRamp) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
        converterRamp = payable(_converterRamp);
    }

    function setNewConverterRamp(address payable newConverterRamp) public onlyRole(ADMIN_ROLE) {
        converterRamp = newConverterRamp;
    }
}",1.9449350833892824,setNewConverterRamp,"[{'function': 'setNewConverterRamp', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""newConverterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""newConverterRamp""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8169414107969204,0.0265837302662102,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract LoanPayer is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    address payable public converterRamp;

    constructor(address _converterRamp) Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _grantRole(ADMIN_ROLE, msg.sender);
        converterRamp = payable(_converterRamp);
    }

    function setNewConverterRamp(address payable newConverterRamp) public onlyRole(ADMIN_ROLE) {
        converterRamp = newConverterRamp;
    }
}"
1438,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract IncreaseAllowance is Ownable {
    using SafeMath for uint256;

    function increaseAllowance(address tokenAddress, address spender, uint256 addedValue) public onlyOwner returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 currentAllowance = token.allowance(_msgSender(), spender);
        require(currentAllowance <= type(uint256).max - addedValue, ""SafeMath: addition overflow"");

        return token.approve(spender, currentAllowance.add(addedValue));
    }
}",1.9225561618804927,increaseAllowance,"[{'function': 'increaseAllowance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}, ""right"": {""type"": ""Identifier"", ""name"": ""addedValue""}}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addedValue""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.6476549614375692,0.0434043684663986,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract IncreaseAllowance is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function increaseAllowance(address tokenAddress, address spender, uint256 addedValue) public onlyOwner returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 currentAllowance = token.allowance(_msgSender(), spender);
        require(currentAllowance <= type(uint256).max - addedValue, ""SafeMath: addition overflow"");

        return token.approve(spender, currentAllowance.add(addedValue));
    }
}"
2532,Remove an address owned by a holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract OwnedHolder {
    mapping(address => bool) private holders;
    uint256 public totalHolders;

    constructor() {
        totalHolders = 0;
    }

    function addHolder(address holder) external onlyOwner {
        if (!holders[holder]) {
            holders[holder] = true;
            totalHolders++;
        }
    }

    function removeHolder(address holder) external onlyOwner {
        require(holders[holder], ""Holder does not exist"");
        holders[holder] = false;
        totalHolders--;
    }
}",1.5250554084777832,addHolder,"[{'function': 'addHolder', 'complexity': 2}, {'function': 'removeHolder', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}, {""type"": ""stringLiteral"", ""value"": ""Holder does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""totalHolders""}, ""isPrefix"": False}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",74.0,0.65738446878439,0.0017615073952615,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OwnedHolder is Ownable {
    mapping(address => bool) private holders;
    uint256 public totalHolders;

    constructor() Ownable(msg.sender) {
        totalHolders = 1; // Set to 1 (never 0)
    }

    function addHolder(address holder) external onlyOwner {
        if (!holders[holder]) {
            holders[holder] = true;
            totalHolders++;
        }
    }

    function removeHolder(address holder) external onlyOwner {
        require(holders[holder], ""Holder does not exist"");
        holders[holder] = false;
        totalHolders--;
    }
}"
339,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CardInfo is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => Card) private cards;

    struct Card {
        uint256 cardId;
        string name;
        uint256 balance;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addCard(uint256 cardId, string memory name) public onlyRole(ADMIN_ROLE) {
        require(!hasCard(cardId), ""Card already exists"");
        cards[cardId] = Card(cardId, name, 0);
    }

    function getCardInfo(uint256 cardId) public view returns (uint256, string memory, uint256) {
        require(hasCard(cardId), ""Card does not exist"");
        Card storage card = cards[cardId];
        return (card.cardId, card.name, card.balance);
    }

    function hasCard(uint256 cardId) public view returns (bool) {
        return cards[cardId].cardId != 0;
    }
}",3.155796527862549,getCardInfo,"[{'function': 'addCard', 'complexity': 2}, {'function': 'getCardInfo', 'complexity': 1}, {'function': 'hasCard', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCardInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasCard""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cardId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Card does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""cardId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""cardId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""balance""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.7025856704984622,0.181612924409587,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CardInfo is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(uint256 => Card) private cards;

    struct Card {
        uint256 cardId;
        string name;
        uint256 balance;
    }

    constructor() Ownable() AccessControl() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        cards[1] = Card(1, 'Card 1', 0);
        cards[2] = Card(2, 'Card 2', 0);
        cards[3] = Card(3, 'Card 3', 0);
    }

    function addCard(uint256 cardId, string memory name) public onlyRole(ADMIN_ROLE) {
        require(!hasCard(cardId), ""Card already exists"");
        cards[cardId] = Card(cardId, name, 0);
    }

    function getCardInfo(uint256 cardId) public view returns (uint256, string memory, uint256) {
        require(hasCard(cardId), ""Card does not exist"");
        Card storage card = cards[cardId];
        return (card.cardId, card.name, card.balance);
    }

    function hasCard(uint256 cardId) public view returns (bool) {
        return cards[cardId].cardId != 0;
    }
}"
4993,"Reclaim an expired , non-empty swap into a multisig","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SwapReclaim is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RECLAIMER_ROLE = keccak256(""RECLAIMER_ROLE"");
    address public immutable multisigWallet;

    constructor(address _multisigWallet, address admin) {
        require(_multisigWallet != address(0), ""Invalid multisig wallet address"");
        multisigWallet = _multisigWallet;
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(RECLAIMER_ROLE, admin);
    }

    function reclaimSwap(uint256 amount) external onlyRole(RECLAIMER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = multisigWallet.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",2.280989646911621,reclaimSwap,"[{'function': 'reclaimSwap', 'complexity': 2}]",3.0,{},78.0,0.7085863175112423,0.0618533271858153,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SwapReclaim is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RECLAIMER_ROLE = keccak256(""RECLAIMER_ROLE"");
    address public immutable multisigWallet;

    constructor(address _multisigWallet, address admin) {
        require(_multisigWallet != address(0), ""Invalid multisig wallet address"");
        multisigWallet = _multisigWallet;
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(RECLAIMER_ROLE, admin);
    }

    function reclaimSwap(uint256 amount) external onlyRole(RECLAIMER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = multisigWallet.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}"
5531,Revoke vote for transaction Can be called only by authorized user,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TransactionVoting is Ownable {
    struct Vote {
        bool approved;
        address voter;
    }

    mapping(uint256 => Vote) public votes;
    uint256 public voteCount;

    modifier onlyAuthorized() {
        require(isAuthorized(msg.sender), ""Only authorized users can call this function"");
        _;
    }

    function isAuthorized(address user) internal view returns (bool) {
        // Implement your authorization logic here, e.g., check if the user is in a whitelist
        return owner() == user; // For simplicity, we assume only the contract owner can revoke votes
    }

    function revokeVote(uint256 transactionId) public onlyAuthorized {
        require(votes[transactionId].voter != address(0), ""No vote found for this transaction"");
        delete votes[transactionId];
        voteCount--;
    }
}",2.1815075874328613,revokeVote,"[{'function': 'isAuthorized', 'complexity': 0}, {'function': 'revokeVote', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeVote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transactionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votes""}, ""index"": {""type"": ""Identifier"", ""name"": ""transactionId""}}, ""memberName"": ""voter""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""No vote found for this transaction""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votes""}, ""index"": {""type"": ""Identifier"", ""name"": ""transactionId""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""voteCount""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.5389839434915966,0.0245777741108497,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TransactionVoting is Ownable {
    struct Vote {
        bool approved;
        address voter;
    }

    mapping(uint256 => Vote) public votes;
    uint256 public voteCount;

    modifier onlyAuthorized() {
        require(isAuthorized(msg.sender), ""Only authorized users can call this function"");
        _;
    }

    function isAuthorized(address user) internal view returns (bool) {
        // Implement your authorization logic here, e.g., check if the user is in a whitelist
        return owner() == user; // For simplicity, we assume only the contract owner can revoke votes
    }

    function revokeVote(uint256 transactionId) public onlyAuthorized {
        require(votes[transactionId].voter != address(0), ""No vote found for this transaction"");
        delete votes[transactionId];
        voteCount--;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        voteCount = 1; // Start with at least one vote
    }
}"
6063,A user has redeemed a top-up voucher for phone credit .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}","pragma solidity ^0.8.0;

interface ITopUpVoucher {
    function redeem(address user, uint256 amount) external returns (bool);
}

contract TopUpRedemption {
    address public owner;
    mapping(address => bool) public approvedUsers;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    modifier onlyApprovedUser() {
        require(approvedUsers[msg.sender], ""Not an approved user"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addApprovedUser(address user) public onlyOwner {
        approvedUsers[user] = true;
    }

    function redeemVoucher(ITopUpVoucher topUpVoucher, address user, uint256 amount) public onlyApprovedUser returns (bool) {
        return topUpVoucher.redeem(user, amount);
    }
}",2.145822286605835,addApprovedUser,"[{'function': 'redeem', 'complexity': 0}, {'function': 'addApprovedUser', 'complexity': 0}, {'function': 'redeemVoucher', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addApprovedUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.3607493900429078,0.0064120540610253,"pragma solidity ^0.8.0;

interface ITopUpVoucher {
    function redeem(address user, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TopUpRedemption is Ownable {
    mapping(address => bool) public approvedUsers;

    modifier onlyApprovedUser() {
        require(approvedUsers[msg.sender], ""Not an approved user"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize any other state variables as they are initialized in the parent contract
    }

    function addApprovedUser(address user) public onlyOwner {
        approvedUsers[user] = true;
    }

    function redeemVoucher(ITopUpVoucher topUpVoucher, address user, uint256 amount) public onlyApprovedUser returns (bool) {
        return topUpVoucher.redeem(user, amount);
    }
}"
6774,"Move to ceiling , used as a failsafe","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CeilingFunction {
    using SafeMath for uint256;

    function moveToCeiling(uint256 value, uint256 ceiling) internal pure returns (uint256) {
        require(value <= type(uint256).max, ""Value exceeds maximum uint256 size"");
        require(ceiling > 0, ""Ceiling must be greater than zero"");

        if (value % ceiling == 0) {
            return value;
        } else {
            return value.add(ceiling).sub(1).div(ceiling).mul(ceiling);
        }
    }
}",1.5791301727294922,moveToCeiling,"[{'function': 'moveToCeiling', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ceiling"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Value exceeds maximum uint256 size""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""ceiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ceiling must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""%"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""ceiling""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""value""}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""value""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ceiling""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ceiling""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ceiling""}], ""names"": []}]}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",40.0,0.6903315234576493,0.0206067237539311,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CeilingFunction is Ownable {
    using SafeMath for uint256;

    function moveToCeiling(uint256 value, uint256 ceiling) internal pure returns (uint256) {
        require(value <= type(uint256).max, ""Value exceeds maximum uint256 size"");
        require(ceiling > 0, ""Ceiling must be greater than zero"");

        if (value % ceiling == 0) {
            return value;
        } else {
            return value.add(ceiling).sub(1).div(ceiling).mul(ceiling);
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1493,A function which allows only the owner to change the address of totlePrimary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TotlePrimaryUpdater is Ownable {
    address public totlePrimary;

    function setTotlePrimary(address newAddress) external onlyOwner {
        require(newAddress != address(0), ""Invalid address"");
        totlePrimary = newAddress;
    }
}",0.9100706577301024,setTotlePrimary,"[{'function': 'setTotlePrimary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotlePrimary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8870600052786858,0.3525678415060714,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TotlePrimaryUpdater is Ownable {
    address public totlePrimary;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        totlePrimary = 0x1111111111111111111111111111111111111111; // Replace with actual address
    }

    function setTotlePrimary(address newAddress) external onlyOwner {
        require(newAddress != address(0), ""Invalid address"");
        totlePrimary = newAddress;
    }
}"
6875,Allow the token holder to upgrade some of their tokens to the new contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface NewContract {
    function upgradeTokens(uint256 amount) external;
}

contract TokenUpgrade is ReentrancyGuard, Ownable {
    IERC20 public token;
    NewContract public newContract;

    constructor(address _token, address _newContract) {
        token = IERC20(_token);
        newContract = NewContract(_newContract);
    }

    function upgradeTokens(uint256 amount) external nonReentrant notZero(amount) {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        require(token.allowance(msg.sender, address(this)) >= amount, ""Allowance too low"");

        token.transferFrom(msg.sender, address(this), amount);
        newContract.upgradeTokens(amount);
    }

    modifier notZero(uint256 amount) {
        require(amount > 0, ""Amount must be greater than zero"");
        _;
    }
}",2.708197832107544,upgradeTokens,"[{'function': 'upgradeTokens', 'complexity': 0}, {'function': 'upgradeTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgradeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance too low""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newContract""}, ""memberName"": ""upgradeTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""notZero"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.6270624837955096,0.0870065792242629,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface NewContract {
    function upgradeTokens(uint256 amount) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenUpgrade is ReentrancyGuard, Ownable {
    IERC20 public token;
    NewContract public newContract;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _newContract) Ownable(msg.sender) {
        token = IERC20(_token);
        newContract = NewContract(_newContract);
    }

    function upgradeTokens(uint256 amount) external nonReentrant notZero(amount) {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        require(token.allowance(msg.sender, address(this)) >= amount, ""Allowance too low"");

        token.transferFrom(msg.sender, address(this), amount);
        newContract.upgradeTokens(amount);
    }

    modifier notZero(uint256 amount) {
        require(amount > 0, ""Amount must be greater than zero"");
        _;
    }
}"
1111,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GasAmountCover {
    using SafeMath for uint256;

    function coverEthForGas(uint256 gasPriceLimit, uint256 providedGas) public payable returns (uint256) {
        require(gasPriceLimit >= tx.gasprice, ""Gas price exceeds the specified limit"");
        return msg.value.sub(providedGas * tx.gasprice);
    }
}",1.189112424850464,coverEthForGas,"[{'function': 'coverEthForGas', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""coverEthForGas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gasPriceLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""providedGas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""gasPriceLimit""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""gasprice""}}, {""type"": ""stringLiteral"", ""value"": ""Gas price exceeds the specified limit""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""providedGas""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""gasprice""}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",20.0,0.2700579622639864,0.0197443211573033,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GasAmountCover is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        gasPriceLimit = 1;
        providedGas = 1;
    }

    uint256 public constant INITIAL_GAS_PRICE_LIMIT = 1;
    uint256 public constant INITIAL_PROVIDED_GAS = 1;

    uint256 public gasPriceLimit = INITIAL_GAS_PRICE_LIMIT;
    uint256 public providedGas = INITIAL_PROVIDED_GAS;

    function coverEthForGas(uint256 gasPriceLimit, uint256 providedGas) public payable returns (uint256) {
        require(gasPriceLimit >= tx.gasprice, ""Gas price exceeds the specified limit"");
        return msg.value.sub(providedGas * tx.gasprice);
    }
}"
312,Obtain the index of the next schedule entry that will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    struct VestingEntry {
        uint256 vestingTime;
        uint256 amount;
    }

    mapping(address => VestingEntry[]) private vestingEntries;

    function getNextVestingIndex(address user) public view returns (uint256 index, uint256 time, uint256 amount) {
        require(vestingEntries[user].length > 0, ""No vesting entries found for this user"");

        uint256 currentTime = block.timestamp;
        for (uint256 i = 0; i < vestingEntries[user].length; i++) {
            if (vestingEntries[user][i].vestingTime > currentTime) {
                return (i, vestingEntries[user][i].vestingTime, vestingEntries[user][i].amount);
            }
        }
        revert(""No more vesting entries found"");
    }
}",2.3544363975524902,getNextVestingIndex,"[{'function': 'getNextVestingIndex', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""time"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No vesting entries found for this user""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""vestingTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""i""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""vestingTime""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}], ""isArray"": False}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""No more vesting entries found""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.758642590521271,0.1801728698980874,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    struct VestingEntry {
        uint256 vestingTime;
        uint256 amount;
    }

    mapping(address => VestingEntry[]) private vestingEntries;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        vestingEntries[msg.sender] = [VestingEntry(0, 1)];
    }

    function getNextVestingIndex(address user) public view returns (uint256 index, uint256 time, uint256 amount) {
        require(vestingEntries[user].length > 0, ""No vesting entries found for this user"");

        uint256 currentTime = block.timestamp;
        for (uint256 i = 0; i < vestingEntries[user].length; i++) {
            if (vestingEntries[user][i].vestingTime > currentTime) {
                return (i, vestingEntries[user][i].vestingTime, vestingEntries[user][i].amount);
            }
        }
        revert(""No more vesting entries found"");
    }
}"
3060,Transfers tokens held by timelock to all beneficiaries .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface ITimelock {
    function release(address beneficiary) external;
}

contract TokenTimelock is Ownable {
    IERC20 private immutable token;
    address[] public beneficiaries;

    constructor(IERC20 _token, address[] memory _beneficiaries) {
        require(_beneficiaries.length > 0, ""At least one beneficiary must be specified"");
        token = _token;
        beneficiaries = _beneficiaries;
    }

    function releaseTokens() external onlyOwner {
        for (uint256 i = 0; i < beneficiaries.length; i++) {
            token.transfer(beneficiaries[i], token.balanceOf(address(this)));
        }
    }
}",1.989236116409301,releaseTokens,"[{'function': 'release', 'complexity': 0}, {'function': 'releaseTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",74.0,0.7522395031956095,0.0213789552480944,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ITimelock {
    function release(address beneficiary) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTimelock is Ownable {
    IERC20 private immutable token;
    address[] public beneficiaries;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, address[] memory _beneficiaries) Ownable() {
        require(_beneficiaries.length > 0, ""At least one beneficiary must be specified"");
        token = _token;
        beneficiaries = _beneficiaries;
    }

    function releaseTokens() external onlyOwner {
        for (uint256 i = 0; i < beneficiaries.length; i++) {
            token.transfer(beneficiaries[i], token.balanceOf(address(this)));
        }
    }
}"
6528,Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CommissionTracker {
    using SafeMath for uint256;

    uint256 public totalCommissionPaid;

    function getTotalCommissionPaid() external view returns (uint256) {
        return totalCommissionPaid;
    }
}",0.9155371189117432,getTotalCommissionPaid,"[{'function': 'getTotalCommissionPaid', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalCommissionPaid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalCommissionPaid""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.6399476214110008,0.0946430081610004,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CommissionTracker is Ownable {
    using SafeMath for uint256;

    uint256 public totalCommissionPaid = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTotalCommissionPaid() external view returns (uint256) {
        return totalCommissionPaid;
    }
}"
1094,finds total amount of neumarks issued for given amount of Euro,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IExchangeRate {
    function getEuroToNeuMark(uint256 euroAmount) external view returns (uint256);
}

contract NeuMarkIssuer {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getTotalNeuMarksIssuedForEuro(uint256 euroAmount) external view returns (uint256) {
        uint256 neumarkAmount = exchangeRateContract.getEuroToNeuMark(euroAmount);
        return neumarkAmount;
    }
}",1.7585813999176023,getTotalNeuMarksIssuedForEuro,"[{'function': 'getEuroToNeuMark', 'complexity': 0}, {'function': 'getTotalNeuMarksIssuedForEuro', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalNeuMarksIssuedForEuro"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""neumarkAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeRateContract""}, ""memberName"": ""getEuroToNeuMark""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""euroAmount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""neumarkAmount""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",72.0,0.6702631373154851,0.0012744796118593,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IExchangeRate {
    function getEuroToNeuMark(uint256 euroAmount) external view returns (uint256);
}

contract NeuMarkIssuer is Ownable {;
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) Ownable(msg.sender) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getTotalNeuMarksIssuedForEuro(uint256 euroAmount) external view returns (uint256) {
        uint256 neumarkAmount = exchangeRateContract.getEuroToNeuMark(euroAmount);
        return neumarkAmount;
    }
}"
2019,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSender {
    using SafeMath for uint256;

    function sendTokens(address _to, uint256 _amount) public {
        IERC20 token = IERC20(msg.sender);
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_to != address(0), ""Invalid recipient address"");

        bool success = token.transferFrom(msg.sender, _to, _amount);
        require(success, ""Token transfer failed"");
    }
}",1.6138479709625244,sendTokens,"[{'function': 'sendTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.6541838202826071,0.0184034842500721,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSender is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendTokens(address _to, uint256 _amount) public {
        IERC20 token = IERC20(_to); // Corrected to use the recipient address as the contract address
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_to != address(0), ""Invalid recipient address"");

        bool success = token.transferFrom(msg.sender, _to, _amount);
        require(success, ""Token transfer failed"");
    }
}"
5946,"Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}","pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(_newOwnerCandidate == msg.sender, ""Ownable: caller is not the new owner candidate"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function transferOwnership(address newOwner) external onlyNewOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function acceptOwnership() external {
        require(_newOwnerCandidate == msg.sender, ""Ownable: caller is not the new owner candidate"");
        emit OwnershipTransferred(_owner, _newOwnerCandidate);
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0);
    }
}",2.218658924102783,acceptOwnership,"[{'function': 'transferOwnership', 'complexity': 1}, {'function': 'acceptOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Ownable: caller is not the new owner candidate""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.8861458576086481,0.2912140633466234,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(_newOwnerCandidate == msg.sender, ""Ownable: caller is not the new owner candidate"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
    }

    function transferOwnership(address newOwner) external onlyNewOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function acceptOwnership() external {
        require(_newOwnerCandidate == msg.sender, ""Ownable: caller is not the new owner candidate"");
        emit OwnershipTransferred(_owner, _newOwnerCandidate);
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0);
    }
}"
4342,The owner will call this method to extract the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ExtractTokens is Ownable {
    function extractTokens(address tokenAddress, uint256 amount) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(msg.sender, amount), ""Token transfer failed"");
    }
}",1.124037504196167,extractTokens,"[{'function': 'extractTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""extractTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",120.0,0.6272891695542349,0.0006877756641707,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExtractTokens is Ownable {
    constructor(address tokenAddress, uint256 amount) Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        address owner = msg.sender;
        bytes32 initBytes = bytes32('init');
        string memory initializedString = 'initialized';

        // No need to initialize tokenAddress and amount as they are passed as arguments
    }

    function extractTokens(address tokenAddress, uint256 amount) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(msg.sender, amount), ""Token transfer failed"");
    }
}"
1358,Internal - Checks if the entered ticker is registered and has not expired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract StockRegistry {
    using SafeMath for uint256;

    struct Stock {
        string ticker;
        bool isRegistered;
        uint256 expirationDate;
    }

    mapping(string => Stock) public stocks;

    function registerStock(string memory _ticker, uint256 _expirationDate) internal {
        require(!stocks[_ticker].isRegistered, ""Ticker already registered"");
        require(_expirationDate > block.timestamp, ""Expiration date must be in the future"");

        stocks[_ticker] = Stock({
            ticker: _ticker,
            isRegistered: true,
            expirationDate: _expirationDate
        });
    }
}",1.758197784423828,registerStock,"[{'function': 'registerStock', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerStock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expirationDate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""memberName"": ""isRegistered""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Ticker already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expirationDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiration date must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stock""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_ticker""}, {""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""_expirationDate""}], ""names"": [""ticker"", ""isRegistered"", ""expirationDate""]}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.357833161519419,0.0488992893536711,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract StockRegistry is Ownable {
    using SafeMath for uint256;

    struct Stock {
        string ticker;
        bool isRegistered;
        uint256 expirationDate;
    }

    mapping(string => Stock) public stocks;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function registerStock(string memory _ticker, uint256 _expirationDate) internal {
        require(!stocks[_ticker].isRegistered, ""Ticker already registered"");
        require(_expirationDate > block.timestamp, ""Expiration date must be in the future"");

        stocks[_ticker] = Stock({
            ticker: _ticker,
            isRegistered: true,
            expirationDate: _expirationDate
        });
    }
}"
5732,Withdraws deposited tokens on behalf of users Allowed only for oracle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Withdrawal is Ownable {
    IERC20 public token;

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only oracle allowed"");
        _;
    }

    constructor(address _token) {
        token = IERC20(_token);
    }

    function withdrawTokens(uint256 amount, address user) external onlyOracle {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient balance"");

        bool success = token.transfer(user, amount);
        require(success, ""Transfer failed"");
    }
}",1.983944177627564,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.7003011368016029,0.0563054755773261,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Withdrawal is Ownable {
    IERC20 public token;

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only oracle allowed"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function withdrawTokens(uint256 amount, address user) external onlyOracle {
        require(amount > 0, ""Amount must be greater than zero"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient balance"");

        bool success = token.transfer(user, amount);
        require(success, ""Transfer failed"");
    }
}"
5527,"Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}","pragma solidity ^0.8.0;

interface IVestedToken {
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}

contract VestedTokenClaim {
    using SafeMath for uint256;

    IVestedToken public vestedToken;
    address public owner;
    uint256 public grantDuration;
    uint256 public cliffDuration;
    mapping(address => uint256) public grants;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _vestedToken, uint256 _grantDuration, uint256 _cliffDuration) {
        vestedToken = IVestedToken(_vestedToken);
        grantDuration = _grantDuration;
        cliffDuration = _cliffDuration;
        owner = msg.sender;
    }

    function claim() external returns (uint256, uint256) {
        require(block.timestamp >= cliffDuration, ""Clawback: Cliff not reached"");
        uint256 totalGrant = grants[msg.sender];
        require(totalGrant > 0, ""No grant available for this recipient"");

        uint256 vestedMonths = (block.timestamp - cliffDuration) / 30 days;
        if (vestedMonths >= grantDuration / 30 days) {
            vestedMonths = grantDuration / 30 days;
        }

        uint256 unclaimedTokens = totalGrant * vestedMonths / (grantDuration / 30 days);
        uint256 availableTokens = totalGrant - unclaimedTokens;

        if (availableTokens > 0) {
            require(vestedToken.balanceOf(address(this)) >= availableTokens, ""Insufficient tokens in contract"");
            vestedToken.transfer(msg.sender, availableTokens);
        }

        return (vestedMonths, availableTokens);
    }
}",5.078569173812866,claim,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'add', 'complexity': 1}, {'function': 'claim', 'complexity': 5}]",10.0,"{""type"": ""FunctionDefinition"", ""name"": ""claim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cliffDuration""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback: Cliff not reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalGrant"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""grants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""totalGrant""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No grant available for this recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""vestedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cliffDuration""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""vestedMonths""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""grantDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vestedMonths""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""grantDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unclaimedTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalGrant""}, ""right"": {""type"": ""Identifier"", ""name"": ""vestedMonths""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""grantDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""availableTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""totalGrant""}, ""right"": {""type"": ""Identifier"", ""name"": ""unclaimedTokens""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vestedToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""availableTokens""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vestedToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""availableTokens""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""vestedMonths""}, {""type"": ""Identifier"", ""name"": ""availableTokens""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7709804858272862,0.0380398125649848,"pragma solidity ^0.8.0;

interface IVestedToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract VestedTokenClaim is Ownable {
    using SafeMath for uint256;

    IVestedToken public vestedToken;
    address public owner;
    uint256 public grantDuration;
    uint256 public cliffDuration;
    mapping(address => uint256) public grants;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _vestedToken, uint256 _grantDuration, uint256 _cliffDuration) Ownable(_vestedToken) {
        vestedToken = IVestedToken(_vestedToken);
        grantDuration = _grantDuration;
        cliffDuration = _cliffDuration;
        owner = msg.sender;
    }

    function claim() external returns (uint256, uint256) {
        require(block.timestamp >= cliffDuration, ""Clawback: Cliff not reached"");
        uint256 totalGrant = grants[msg.sender];
        require(totalGrant > 0, ""No grant available for this recipient"");

        uint256 vestedMonths = (block.timestamp - cliffDuration) / 30 days;
        if (vestedMonths >= grantDuration / 30 days) {
            vestedMonths = grantDuration / 30 days;
        }

        uint256 unclaimedTokens = totalGrant * vestedMonths / (grantDuration / 30 days);
        uint256 availableTokens = totalGrant - unclaimedTokens;

        if (availableTokens > 0) {
            require(vestedToken.balanceOf(address(this)) >= availableTokens, ""Insufficient tokens in contract"");
            vestedToken.transfer(msg.sender, availableTokens);
        }

        return (vestedMonths, availableTokens);
    }
}"
1662,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract ETHBalances {
    using SafeMath for uint256;

    address public userAddress;

    constructor(address _userAddress) {
        userAddress = _userAddress;
    }

    function getUserETHValues() external view returns (uint256 supplyBalance, uint256 borrowBalance) {
        IERC20 tokenContract = IERC20(/* Replace with the actual token contract address */);

        uint256 supplyBalanceRaw = tokenContract.balanceOf(userAddress);
        uint256 borrowBalanceRaw = /* Calculate the borrow balance */;

        supplyBalance = supplyBalanceRaw;
        borrowBalance = borrowBalanceRaw;
    }
}",1.9715995788574217,getUserETHValues,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getUserETHValues', 'complexity': 0}]",1.0,{},102.0,0.6345824124851689,0.0001590107203973,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract ETHBalances is Ownable {
    using SafeMath for uint256;

    address public userAddress;

    mapping(address => uint256) public balanceOf;

 constructor(address _userAddress) Ownable() {
        userAddress = _userAddress;
    }

    function getUserETHValues() external view returns (uint256 supplyBalance, uint256 borrowBalance) {
        IERC20 tokenContract = IERC20(_userAddress); // Replace with the actual token contract address

        uint256 supplyBalanceRaw = tokenContract.balanceOf(userAddress);
        uint256 borrowBalanceRaw = /* Calculate the borrow balance */;

        supplyBalance = supplyBalanceRaw;
        borrowBalance = borrowBalanceRaw;
    }
}"
6249,Set the threshold for a payment to be sent directly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentThreshold {
    using SafeMath for uint256;

    address public owner;
    uint256 public paymentThreshold;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 initialThreshold) {
        owner = msg.sender;
        paymentThreshold = initialThreshold;
    }

    function setPaymentThreshold(uint256 newThreshold) public onlyOwner {
        require(newThreshold > 0, ""Threshold must be greater than zero."");
        paymentThreshold = newThreshold;
    }
}",1.642352819442749,setPaymentThreshold,"[{'function': 'setPaymentThreshold', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPaymentThreshold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newThreshold"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newThreshold""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Threshold must be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentThreshold""}, ""right"": {""type"": ""Identifier"", ""name"": ""newThreshold""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8018819999969633,0.0201907485099452,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentThreshold is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public paymentThreshold = 1;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 initialThreshold) Ownable(msg.sender) {
        paymentThreshold = initialThreshold;
    }

    function setPaymentThreshold(uint256 newThreshold) public onlyOwner {
        require(newThreshold > 0, ""Threshold must be greater than zero."");
        paymentThreshold = newThreshold;
    }
}"
153,A getter to find if a specified Project has been canceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ProjectManagement is AccessControl {
    struct Project {
        bool canceled;
    }

    mapping(uint256 => Project) public projects;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function getProjectCanceledStatus(uint256 projectId) public view returns (bool) {
        require(_exists(projectId), ""Project does not exist"");
        return projects[projectId].canceled;
    }

    function _exists(uint256 projectId) internal view returns (bool) {
        return projectId < 100 && projectId >= 0; // Assuming a maximum of 100 projects for simplicity
    }
}",1.7878212928771973,getProjectCanceledStatus,"[{'function': 'getProjectCanceledStatus', 'complexity': 1}, {'function': '_exists', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProjectCanceledStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""projectId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""projectId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Project does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""projects""}, ""index"": {""type"": ""Identifier"", ""name"": ""projectId""}}, ""memberName"": ""canceled""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.8140181039723123,0.1223178926202697,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for Ownable usage
import ""openzeppelin/SafeMath.sol"";
contract ProjectManagement is AccessControl, Ownable {
    struct Project {
        bool canceled;
    }

    mapping(uint256 => Project) public projects;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        // Initialize state variables with safe non-corner-case values
        for (uint256 i = 0; i < 100; i++) {
            projects[i] = Project({canceled: false});
        }
    }

    function getProjectCanceledStatus(uint256 projectId) public view returns (bool) {
        require(_exists(projectId), ""Project does not exist"");
        return projects[projectId].canceled;
    }

    function _exists(uint256 projectId) internal view returns (bool) {
        return projectId < 100 && projectId >= 0; // Assuming a maximum of 100 projects for simplicity
    }
}"
223,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CardInfo {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 cardNumber;
        uint256 balance;
    }

    mapping(uint256 => Card) public cards;

    function getCardInfo(uint256 _cardNumber) public view returns (string memory, uint256, uint256) {
        require(_cardNumber > 0 && _cardNumber <= totalCards, ""Invalid card number"");
        Card storage card = cards[_cardNumber];
        return (card.name, card.cardNumber, card.balance);
    }

    function addCard(uint256 _cardNumber, string memory _name) public {
        require(_cardNumber > 0 && _cardNumber <= totalCards, ""Invalid card number"");
        cards[_cardNumber] = Card({
            name: _name,
            cardNumber: _cardNumber,
            balance: 0
        });
    }

    uint256 public totalCards;

    constructor(uint256 _totalCards) {
        totalCards = _totalCards;
    }
}",2.657484531402588,addCard,"[{'function': 'getCardInfo', 'complexity': 2}, {'function': 'addCard', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCardInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_cardNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_cardNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_cardNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCards""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid card number""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_cardNumber""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""cardNumber""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""balance""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",56.0,0.5094282647343956,0.0209971032341252,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CardInfo is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 cardNumber;
        uint256 balance;
    }

    mapping(uint256 => Card) public cards;

    function getCardInfo(uint256 _cardNumber) public view returns (string memory, uint256, uint256) {
        require(_cardNumber > 0 && _cardNumber <= totalCards, ""Invalid card number"");
        Card storage card = cards[_cardNumber];
        return (card.name, card.cardNumber, card.balance);
    }

    function addCard(uint256 _cardNumber, string memory _name) public {
        require(_cardNumber > 0 && _cardNumber <= totalCards, ""Invalid card number"");
        cards[_cardNumber] = Card({
            name: _name,
            cardNumber: _cardNumber,
            balance: 0
        });
    }

    uint256 public totalCards;

    constructor(uint256 _totalCards) Ownable(msg.sender) {
        totalCards = _totalCards;
    }
}"
1195,"The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ClawbackContract is Ownable {
    using SafeMath for uint256;

    struct UserBalance {
        uint256 balance;
        bool claimed;
    }

    mapping(address => UserBalance) public userBalances;
    uint256 public clawbackDate;

    event Clawback(address indexed user, uint256 amount);

    constructor(uint256 _clawbackDate) {
        require(_clawbackDate > block.timestamp, ""Clawback date must be in the future"");
        clawbackDate = _clawbackDate;
    }

    function claimCredits() external {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet started"");
        uint256 balance = userBalances[msg.sender].balance;
        require(balance > 0, ""User has no credits to claim"");
        require(!userBalances[msg.sender].claimed, ""Credits have already been claimed"");

        userBalances[msg.sender].claimed = true;
        (bool success, ) = msg.sender.call{value: balance}("""");
        require(success, ""Transfer failed"");

        emit Clawback(msg.sender, balance);
    }

    function clawback() external onlyOwner {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet started"");
        for (address user = address(0); user <= owner(); user++) {
            if (!userBalances[user].claimed) {
                uint256 balance = userBalances[user].balance;
                userBalances[user].claimed = true;
                (bool success, ) = user.call{value: balance}("""");
                require(success, ""Transfer failed"");
                emit Clawback(user, balance);
            }
        }
    }

    function addCredits(address user, uint256 amount) external onlyOwner {
        userBalances[user].balance += amount;
    }
}",4.573543071746826,claimCredits,"[{'function': 'claimCredits', 'complexity': 5}, {'function': 'clawback', 'complexity': 6}, {'function': 'addCredits', 'complexity': 0}]",5.0,{},37.0,0.7525560115979361,0.1277920129945365,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ClawbackContract is Ownable {
    using SafeMath for uint256;

    struct UserBalance {
        uint256 balance;
        bool claimed;
    }

    mapping(address => UserBalance) public userBalances;
    uint256 public clawbackDate;

    event Clawback(address indexed user, uint256 amount);

    constructor() Ownable(msg.sender) {
        require(block.timestamp + 1 > block.timestamp, ""Clawback date must be in the future"");
        clawbackDate = block.timestamp + 1; // Set to a fixed value for testing purposes
    }

    function claimCredits() external {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet started"");
        uint256 balance = userBalances[msg.sender].balance;
        require(balance > 0, ""User has no credits to claim"");
        require(!userBalances[msg.sender].claimed, ""Credits have already been claimed"");

        userBalances[msg.sender].claimed = true;
        (bool success, ) = msg.sender.call{value: balance}("""");
        require(success, ""Transfer failed"");

        emit Clawback(msg.sender, balance);
    }

    function clawback() external onlyOwner {
        require(block.timestamp >= clawbackDate, ""Clawback period has not yet started"");
        for (address user = address(0); user <= owner(); user++) {
            if (!userBalances[user].claimed) {
                uint256 balance = userBalances[user].balance;
                userBalances[user].claimed = true;
                (bool success, ) = user.call{value: balance}("""");
                require(success, ""Transfer failed"");
                emit Clawback(user, balance);
            }
        }
    }

    function addCredits(address user, uint256 amount) external onlyOwner {
        userBalances[user].balance += amount;
    }
}"
3570,Pauses the whitelist if there is any issue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract WhitelistManager is Ownable, Pausable {
    mapping(address => bool) public whitelistedAddresses;

    function addToWhitelist(address _address) external onlyOwner {
        require(!whitelistedAddresses[_address], ""Address already whitelisted"");
        whitelistedAddresses[_address] = true;
    }

    function removeFromWhitelist(address _address) external onlyOwner {
        require(whitelistedAddresses[_address], ""Address not whitelisted"");
        whitelistedAddresses[_address] = false;
    }

    function pauseWhitelist() external onlyOwner whenNotPaused {
        _pause();
    }

    function unpauseWhitelist() external onlyOwner whenPaused {
        _unpause();
    }
}",2.0129287242889404,addToWhitelist,"[{'function': 'addToWhitelist', 'complexity': 2}, {'function': 'removeFromWhitelist', 'complexity': 1}, {'function': 'pauseWhitelist', 'complexity': 0}, {'function': 'unpauseWhitelist', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelistedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Address already whitelisted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelistedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.5464946978571384,0.0323072592816023,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WhitelistManager is Ownable, Pausable {
    mapping(address => bool) public whitelistedAddresses;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            whitelistedAddresses[addr] = true;
        }
    }

    function addToWhitelist(address _address) external onlyOwner {
        require(!whitelistedAddresses[_address], ""Address already whitelisted"");
        whitelistedAddresses[_address] = true;
    }

    function removeFromWhitelist(address _address) external onlyOwner {
        require(whitelistedAddresses[_address], ""Address not whitelisted"");
        whitelistedAddresses[_address] = false;
    }

    function pauseWhitelist() external onlyOwner whenNotPaused {
        _pause();
    }

    function unpauseWhitelist() external onlyOwner whenPaused {
        _unpause();
    }
}"
5480,Allows transfer token ownership back to distribution contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDistribution is Ownable {
    address public distributionContract;

    constructor(address _distributionContract) {
        require(_distributionContract != address(0), ""Invalid distribution contract"");
        distributionContract = _distributionContract;
    }

    function transferOwnershipToDistribution() external onlyOwner {
        require(msg.sender == owner(), ""Only the owner can transfer ownership back to the distribution contract"");
        (bool success, ) = distributionContract.call{value: address(this).balance}("""");
        require(success, ""Transfer failed"");
        selfdestruct(payable(distributionContract));
    }
}",1.535550594329834,transferOwnershipToDistribution,"[{'function': 'transferOwnershipToDistribution', 'complexity': 2}]",3.0,{},19.0,0.5831158761138417,0.249737169014991,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDistribution is Ownable {
    address public distributionContract;

    constructor(address _distributionContract) Ownable(_distributionContract) {
        require(_distributionContract != address(0), ""Invalid distribution contract"");
        distributionContract = _distributionContract;
    }

    function transferOwnershipToDistribution() external onlyOwner {
        require(msg.sender == owner(), ""Only the owner can transfer ownership back to the distribution contract"");
        (bool success, ) = distributionContract.call{value: address(this).balance}("""");
        require(success, ""Transfer failed"");
        selfdestruct(payable(distributionContract));
    }
}"
3477,"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Loan is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant LOAN_CREATOR = keccak256(""LOAN_CREATOR"");
    struct LoanMetadata {
        string name;
        address creator;
        uint256 amount;
        uint256 interestRate;
        uint256 duration;
    }

    mapping(uint256 => LoanMetadata) public loanMetadata;
    uint256 public loanCount;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setLoanMetadata(string memory name, address creator, uint256 amount, uint256 interestRate, uint256 duration) external onlyRole(LOAN_CREATOR) {
        loanMetadata[loanCount] = LoanMetadata({
            name: name,
            creator: creator,
            amount: amount,
            interestRate: interestRate,
            duration: duration
        });
        loanCount++;
    }

    function getLoanMetadata(uint256 index) external view returns (string memory, address, uint256, uint256, uint256) {
        LoanMetadata storage loan = loanMetadata[index];
        return (loan.name, loan.creator, loan.amount, loan.interestRate, loan.duration);
    }
}",3.2847816944122314,setLoanMetadata,"[{'function': 'setLoanMetadata', 'complexity': 0}, {'function': 'getLoanMetadata', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLoanMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""duration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loanMetadata""}, ""index"": {""type"": ""Identifier"", ""name"": ""loanCount""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LoanMetadata""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""interestRate""}, {""type"": ""Identifier"", ""name"": ""duration""}], ""names"": [""name"", ""creator"", ""amount"", ""interestRate"", ""duration""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""loanCount""}, ""isPrefix"": False}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""LOAN_CREATOR""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.6105471296066001,0.0250737635683339,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Loan is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant LOAN_CREATOR = keccak256(""LOAN_CREATOR"");
    struct LoanMetadata {
        string name;
        address creator;
        uint256 amount;
        uint256 interestRate;
        uint256 duration;
    }

    mapping(uint256 => LoanMetadata) public loanMetadata;
    uint256 public loanCount;

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setLoanMetadata(string memory name, address creator, uint256 amount, uint256 interestRate, uint256 duration) external onlyRole(LOAN_CREATOR) {
        loanMetadata[loanCount] = LoanMetadata({
            name: name,
            creator: creator,
            amount: amount,
            interestRate: interestRate,
            duration: duration
        });
        loanCount++;
    }

    function getLoanMetadata(uint256 index) external view returns (string memory, address, uint256, uint256, uint256) {
        LoanMetadata storage loan = loanMetadata[index];
        return (loan.name, loan.creator, loan.amount, loan.interestRate, loan.duration);
    }
}"
1259,Claims the ownership of a given token ID,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ClaimToken is Ownable {
    IERC721 public tokenContract;
    uint256 public tokenId;

    constructor(address _tokenAddress, uint256 _tokenId) {
        tokenContract = IERC721(_tokenAddress);
        tokenId = _tokenId;
    }

    function claimToken() external onlyOwner {
        require(tokenContract.ownerOf(tokenId) != msg.sender, ""You already own this token"");
        tokenContract.transferFrom(owner(), msg.sender, tokenId);
    }
}",1.6844596862792969,claimToken,"[{'function': 'claimToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You already own this token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.6382036388600135,0.1566129712261721,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ClaimToken is Ownable {
    IERC721 public tokenContract;
    uint256 public tokenId;

    constructor(address _tokenAddress, uint256 _tokenId) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        tokenContract = IERC721(_tokenAddress);
        tokenId = _tokenId;
    }

    function claimToken() external onlyOwner {
        require(tokenContract.ownerOf(tokenId) != msg.sender, ""You already own this token"");
        tokenContract.transferFrom(owner(), msg.sender, tokenId);
    }
}"
6427,We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 input1, uint256 input2) public onlyRole(ADMIN_ROLE) returns (uint256) {
        return input1.add(input2);
    }
}",1.6996662616729736,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""input1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""input2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""input1""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""input2""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.3514010436037535,0.0025150514344549,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function myFunction(uint256 input1, uint256 input2) public onlyRole(ADMIN_ROLE) returns (uint256) {
        return input1.add(input2);
    }
}"
5406,Returns all rewards charged for the given canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IRewardManager {
    function getRewardsForCanvas(uint256 canvasId) external view returns (uint256);
}

contract RewardManager is AccessControl, IRewardManager {
    using SafeMath for uint256;

    bytes32 public constant REWARD_MANAGER_ROLE = keccak256(""REWARD_MANAGER_ROLE"");
    mapping(uint256 => uint256) private rewardsForCanvas;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(REWARD_MANAGER_ROLE, msg.sender);
    }

    function setRewardsForCanvas(uint256 canvasId, uint256 rewards) external onlyRole(REWARD_MANAGER_ROLE) {
        rewardsForCanvas[canvasId] = rewards;
    }

    function getRewardsForCanvas(uint256 canvasId) external view override returns (uint256) {
        return rewardsForCanvas[canvasId];
    }
}",2.6019389629364014,setRewardsForCanvas,"[{'function': 'getRewardsForCanvas', 'complexity': 0}, {'function': 'setRewardsForCanvas', 'complexity': 0}, {'function': 'getRewardsForCanvas', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRewardsForCanvas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rewards"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewardsForCanvas""}, ""index"": {""type"": ""Identifier"", ""name"": ""canvasId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""rewards""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""REWARD_MANAGER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.6873119589942481,0.0096395408400301,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRewardManager {
    function getRewardsForCanvas(uint256 canvasId) external view returns (uint256);
}

contract RewardManager is AccessControl, IRewardManager {
    using SafeMath for uint256;

    bytes32 public constant REWARD_MANAGER_ROLE = keccak256(""REWARD_MANAGER_ROLE"");
    mapping(uint256 => uint256) private rewardsForCanvas;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(REWARD_MANAGER_ROLE, msg.sender);
    }

    function setRewardsForCanvas(uint256 canvasId, uint256 rewards) external onlyRole(REWARD_MANAGER_ROLE) {
        rewardsForCanvas[canvasId] = rewards;
    }

    function getRewardsForCanvas(uint256 canvasId) external view override returns (uint256) {
        return rewardsForCanvas[canvasId];
    }
}"
6503,The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RewardCalculator {
    using SafeMath for uint256;

    struct Commitment {
        uint256 value;
    }

    function calculateReward(uint256 numberOfBlocks, uint256 commitmentValue, uint256 effectiveStake) public pure returns (uint256) {
        require(numberOfBlocks > 0, ""Number of blocks must be greater than zero"");
        require(commitmentValue > 0, ""Commitment value must be greater than zero"");
        require(effectiveStake > 0, ""Effective stake must be greater than zero"");

        uint256 effectiveBlockReward = (block.reward - block.prevRevenue) / numberOfBlocks;
        uint256 averageEffectiveStake = effectiveStake; // Assuming linear approximation for simplicity

        return numberOfBlocks.mul(effectiveBlockReward).mul(commitmentValue).div(averageEffectiveStake);
    }
}",2.211253881454468,calculateReward,"[{'function': 'calculateReward', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfBlocks"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""commitmentValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Number of blocks must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""commitmentValue""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Commitment value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""effectiveStake""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Effective stake must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""reward""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""prevRevenue""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""averageEffectiveStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""effectiveStake""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""commitmentValue""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""averageEffectiveStake""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",47.0,0.6674719118568936,0.1918156800489841,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract RewardCalculator is Ownable {
    using SafeMath for uint256;

    struct Commitment {
        uint256 value;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        numberOfBlocks = 1;
        commitmentValue = 1;
        effectiveStake = 1;
    }

    uint256 public numberOfBlocks;
    uint256 public commitmentValue;
    uint256 public effectiveStake;

    function calculateReward(uint256 _numberOfBlocks, uint256 _commitmentValue, uint256 _effectiveStake) public pure returns (uint256) {
        require(_numberOfBlocks > 0, ""Number of blocks must be greater than zero"");
        require(_commitmentValue > 0, ""Commitment value must be greater than zero"");
        require(_effectiveStake > 0, ""Effective stake must be greater than zero"");

        uint256 effectiveBlockReward = (block.reward - block.prevRevenue) / _numberOfBlocks;
        uint256 averageEffectiveStake = _effectiveStake; // Assuming linear approximation for simplicity

        return _numberOfBlocks.mul(effectiveBlockReward).mul(_commitmentValue).div(averageEffectiveStake);
    }
}"
2533,Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract KYCCompliantContract is ReentrancyGuard, AccessControl {
    bytes32 public constant KYCER_ROLE = keccak256(""KYCER_ROLE"");
    uint256 public constant MIN_ETH_REQUIRED = 10 ether;

    mapping(address => bool) public kycCompleted;

    event RefundInitiated(address indexed user, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(KYCER_ROLE, msg.sender);
    }

    function processRefund(uint256 amount) external nonReentrant {
        require(!kycCompleted[msg.sender], ""KYC already completed"");
        require(amount <= address(this).balance, ""Contract does not have enough balance"");
        require(amount >= MIN_ETH_REQUIRED, ""Amount sent is less than required minimum"");

        kycCompleted[msg.sender] = true;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Refund transfer failed"");

        emit RefundInitiated(msg.sender, amount);
    }

    function completeKYC(address user) external onlyRole(KYCER_ROLE) {
        kycCompleted[user] = true;
    }
}",3.2051072120666504,processRefund,"[{'function': 'processRefund', 'complexity': 5}, {'function': 'completeKYC', 'complexity': 0}]",7.0,{},44.0,0.6258808759278314,0.0305266566441151,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract KYCCompliantContract is ReentrancyGuard, AccessControl, Ownable {
    bytes32 public constant KYCER_ROLE = keccak256(""KYCER_ROLE"");
    uint256 public constant MIN_ETH_REQUIRED = 10 ether;

    mapping(address => bool) public kycCompleted;

    event RefundInitiated(address indexed user, uint256 amount);

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(KYCER_ROLE, msg.sender);
    }

    function processRefund(uint256 amount) external nonReentrant {
        require(!kycCompleted[msg.sender], ""KYC already completed"");
        require(amount <= address(this).balance, ""Contract does not have enough balance"");
        require(amount >= MIN_ETH_REQUIRED, ""Amount sent is less than required minimum"");

        kycCompleted[msg.sender] = true;
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Refund transfer failed"");

        emit RefundInitiated(msg.sender, amount);
    }

    function completeKYC(address user) external onlyRole(KYCER_ROLE) {
        kycCompleted[user] = true;
    }
}"
5759,Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

contract TokenAllowanceChecker {
    function checkAllowance(address _owner, address _spender, address tokenAddress) public view returns (uint256) {
        IERC20 token = IERC2序(tokenAddress);
        return token.allowance(_owner, _spender);
    }
}",1.0921752452850342,checkAllowance,"[{'function': 'allowance', 'complexity': 0}, {'function': 'checkAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC2""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.7755108902835829,0.2884875003490582,"pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenAllowanceChecker is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkAllowance(address _owner, address _spender, address tokenAddress) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.allowance(_owner, _spender);
    }
}"
4344,shuts the CDP and returns all the value in the form of Dai .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CDPInterface {
    function closeCDP() external;
    function getDaiBalance() external view returns (uint256);
}

contract CDPCloser is AccessControl {
    using SafeMath for uint256;

    IERC20 public daiToken;
    CDPInterface public cdp;

    constructor(address _daiToken, address _cdp) {
        require(_daiToken != address(0), ""Invalid DAI token address"");
        require(_cdp != address(0), ""Invalid CDP address"");

        daiToken = IERC20(_daiToken);
        cdp = CDPInterface(_cdp);

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function closeAndWithdrawCDP() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 daiBalance = cdp.getDaiBalance();
        require(daiBalance > 0, ""No DAI balance in the CDP"");

        cdp.closeCDP();
        bool success = daiToken.transfer(msg.sender, daiBalance);
        require(success, ""Transfer failed"");
    }
}",3.1382923126220703,closeAndWithdrawCDP,"[{'function': 'getDaiBalance', 'complexity': 0}, {'function': 'closeAndWithdrawCDP', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""closeAndWithdrawCDP"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""daiBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cdp""}, ""memberName"": ""getDaiBalance""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""daiBalance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No DAI balance in the CDP""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cdp""}, ""memberName"": ""closeCDP""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""daiBalance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",67.0,0.5990926118543067,0.026164022863573,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CDPInterface {
    function closeCDP() external;
    function getDaiBalance() external view returns (uint256);
}

contract CDPCloser is AccessControl {
    using SafeMath for uint256;

    IERC20 public daiToken;
    CDPInterface public cdp;

    constructor(address _daiToken, address _cdp) {
        require(_daiToken != address(0), ""Invalid DAI token address"");
        require(_cdp != address(0), ""Invalid CDP address"");

        daiToken = IERC20(_daiToken);
        cdp = CDPInterface(_cdp);

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function closeAndWithdrawCDP() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 daiBalance = cdp.getDaiBalance();
        require(daiBalance > 0, ""No DAI balance in the CDP"");

        cdp.closeCDP();
        bool success = daiToken.transfer(msg.sender, daiBalance);
        require(success, ""Transfer failed"");
    }
}"
6386,Internal - Removes the owner of a ticker,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RemoveOwner {
    struct Ticker {
        address owner;
    }

    mapping(string => Ticker) public tickers;

    function removeOwner(string memory ticker) internal {
        require(tickers[ticker].owner != address(0), ""Ticker does not exist"");
        require(msg.sender == tickers[ticker].owner, ""Only the owner can remove themselves as the owner"");
        tickers[ticker].owner = address(0);
    }
}",1.336538553237915,removeOwner,"[{'function': 'removeOwner', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Ticker does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}, ""memberName"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can remove themselves as the owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.8192230347006958,0.0160489527413715,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RemoveOwner is Ownable {
    struct Ticker {
        address owner;
    }

    mapping(string => Ticker) public tickers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
                tickers['TICKER'].owner = addr;
            } else if (i == 2) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
                tickers['TICKER'].owner = addr;
            } else if (i == 3) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
                tickers['TICKER'].owner = addr;
            }
        }
    }

    function removeOwner(string memory ticker) internal {
        require(tickers[ticker].owner != address(0), ""Ticker does not exist"");
        require(msg.sender == tickers[ticker].owner, ""Only the owner can remove themselves as the owner"");
        tickers[ticker].owner = address(0);
    }
}"
5781,Get the allowance of an specified address to use another address balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract AllowanceChecker {
    using SafeMath for uint256;

    function getAllowance(address tokenAddress, address owner, address spender) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.allowance(owner, spender);
    }
}",1.984778881072998,sub,"[{'function': 'allowance', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'getAllowance', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sub"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: subtraction overflow""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",8.0,0.420953395439126,0.0428145879084094,"pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract AllowanceChecker is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getAllowance(address tokenAddress, address owner, address spender) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.allowance(owner, spender);
    }
}"
5300,Last callback used to accept the ERC721 parcel tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}","pragma solidity ^0.8.0;

interface IERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;
}

contract ParcelAcceptance {
    address public owner;
    mapping(uint256 => bool) public acceptedTokens;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function acceptParcelToken(uint256 tokenId, address parcelTokenAddress) public onlyOwner {
        require(!acceptedTokens[tokenId], ""This parcel token has already been accepted"");
        IERC721(parcelTokenAddress).transferFrom(address(this), owner, tokenId);
        acceptedTokens[tokenId] = true;
    }
}",1.8778076171875,acceptParcelToken,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'acceptParcelToken', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptParcelToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""parcelTokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""acceptedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""This parcel token has already been accepted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""parcelTokenAddress""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""acceptedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5335164599076203,0.0199812650099478,"pragma solidity ^0.8.0;

interface IERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;
}
import ""openzeppelin/SafeMath.sol"";
contract ParcelAcceptance is Ownable {
    mapping(uint256 => bool) public acceptedTokens;

    constructor() Ownable(msg.sender) {
        // No need to initialize owner as it will be set in the base constructor
    }

    function acceptParcelToken(uint256 tokenId, address parcelTokenAddress) public onlyOwner {
        require(!acceptedTokens[tokenId], ""This parcel token has already been accepted"");
        IERC721(parcelTokenAddress).transferFrom(address(this), owner(), tokenId);
        acceptedTokens[tokenId] = true;
    }
}"
6110,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint256[] memory prices) external;
}

contract HavvenPriceUpdater is Ownable {
    using SafeMath for uint256;

    address public oracleAddress;

    constructor(address _oracleAddress) {
        require(_oracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _oracleAddress;
    }

    function setOracleAddress(address _newOracleAddress) external onlyOwner {
        require(_newOracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _newOracleAddress;
    }

    function updatePrices(uint256[] memory prices) external onlyOwner {
        IOracle(oracleAddress).updatePrices(prices);
    }
}",2.0668728351593018,setOracleAddress,"[{'function': 'updatePrices', 'complexity': 0}, {'function': 'setOracleAddress', 'complexity': 1}, {'function': 'updatePrices', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOracleAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOracleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Oracle address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""oracleAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOracleAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.3993845718366821,0.0153634587691902,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint256[] memory prices) external;
}

contract HavvenPriceUpdater is Ownable {
    using SafeMath for uint256;

    address public oracleAddress;

    constructor(address _oracleAddress) Ownable(_oracleAddress) {
        require(_oracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _oracleAddress;
    }

    function setOracleAddress(address _newOracleAddress) external onlyOwner {
        require(_newOracleAddress != address(0), ""Oracle address cannot be zero"");
        oracleAddress = _newOracleAddress;
    }

    function updatePrices(uint256[] memory prices) external onlyOwner {
        IOracle(oracleAddress).updatePrices(prices);
    }
}"
1872,selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}","pragma solidity ^0.8.0;

contract Escrow {
    address public immutable escrowModerator;
    address public immutable beneficiary;

    constructor(address _escrowModerator, address _beneficiary) {
        require(_escrowModerator != address(0), ""Escrow moderator must be a valid address"");
        require(_beneficiary != address(0), ""Beneficiary must be a valid address"");
        escrowModerator = _escrowModerator;
        beneficiary = _beneficiary;
    }

    function selfDestruct() public {
        uint256 balance = address(this).balance;
        (bool success, ) = payable(escrowModerator).call{value: balance}("""");
        require(success, ""Transfer to escrow moderator failed"");
        if (!success) {
            (success, ) = payable(beneficiary).call{value: balance}("""");
            require(success, ""Transfer to beneficiary failed"");
        }
    }
}",2.0758934020996094,selfDestruct,"[{'function': 'selfDestruct', 'complexity': 4}]",4.0,{},22.0,0.7121025099190103,0.1312019727962944,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    address public immutable escrowModerator;
    address public immutable beneficiary;

    constructor(address _escrowModerator, address _beneficiary) Ownable() {
        require(_escrowModerator != address(0), ""Escrow moderator must be a valid address"");
        require(_beneficiary != address(0), ""Beneficiary must be a valid address"");
        escrowModerator = _escrowModerator;
        beneficiary = _beneficiary;
    }

    function selfDestruct() public {
        uint256 balance = address(this).balance;
        (bool success, ) = payable(escrowModerator).call{value: balance}("""");
        require(success, ""Transfer to escrow moderator failed"");
        if (!success) {
            (success, ) = payable(beneficiary).call{value: balance}("""");
            require(success, ""Transfer to beneficiary failed"");
        }
    }
}"
4928,Sets the contract which implements a specific interface for an address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}","pragma solidity ^0.8.0;

interface SpecificInterface {
    function someFunction() external view returns (bool);
}

contract SetContract {
    address public specificAddress;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setSpecificAddress(address _specificAddress) public onlyOwner {
        require(_specificAddress != address(0), ""Invalid address"");
        specificAddress = _specificAddress;

        SpecificInterface specificContract = SpecificInterface(_specificAddress);
        bool isValid = specificContract.someFunction();
        require(isValid, ""The provided address does not implement the specific interface"");
    }
}",1.7276630401611328,setSpecificAddress,"[{'function': 'someFunction', 'complexity': 0}, {'function': 'setSpecificAddress', 'complexity': 2}]",15.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSpecificAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_specificAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_specificAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""specificAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_specificAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SpecificInterface""}, ""name"": ""specificContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SpecificInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_specificAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isValid"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""specificContract""}, ""memberName"": ""someFunction""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isValid""}, {""type"": ""stringLiteral"", ""value"": ""The provided address does not implement the specific interface""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.5823925002315374,0.0714340586413043,"pragma solidity ^0.8.0;

interface SpecificInterface {
    function someFunction() external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract SetContract is Ownable {
    address public specificAddress;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is handled in the base class constructor
    }

    function setSpecificAddress(address _specificAddress) public onlyOwner {
        require(_specificAddress != address(0), ""Invalid address"");
        specificAddress = _specificAddress;

        SpecificInterface specificContract = SpecificInterface(_specificAddress);
        bool isValid = specificContract.someFunction();
        require(isValid, ""The provided address does not implement the specific interface"");
    }
}"
1268,"This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PledgeContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private hPledge2idx;
    address[] private pledges;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function createOrFindPledge(address pledgeAddress) public {
        require(!isPledgeCreated(pledgeAddress), ""Pledge already exists"");
        pledges.push(pledgeAddress);
        hPledge2idx[pledgeAddress] = pledges.length - 1;
    }

    function isPledgeCreated(address pledgeAddress) public view returns (bool) {
        return hPledge2idx[pledgeAddress] != 0 || pledges.length > 0;
    }
}",2.4701316356658936,createOrFindPledge,"[{'function': 'createOrFindPledge', 'complexity': 2}, {'function': 'isPledgeCreated', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createOrFindPledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""pledgeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isPledgeCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pledgeAddress""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Pledge already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pledgeAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""pledgeAddress""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",55.0,0.7251121622206628,0.0037565081581717,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PledgeContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => uint256) private hPledge2idx;
    address[] private pledges;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function createOrFindPledge(address pledgeAddress) public {
        require(!isPledgeCreated(pledgeAddress), ""Pledge already exists"");
        pledges.push(pledgeAddress);
        hPledge2idx[pledgeAddress] = pledges.length - 1;
    }

    function isPledgeCreated(address pledgeAddress) public view returns (bool) {
        return hPledge2idx[pledgeAddress] != 0 || pledges.length > 0;
    }
}"
6042,Returns all the relevant information about a specific library .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ILibrary {
    function getInfo() external view returns (uint256, string memory, address);
}

contract LibraryQuery is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant QUERY_ROLE = keccak256(""QUERY_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(QUERY_ROLE, msg.sender);
    }

    function getLibraryInfo(address libraryAddress) public view returns (uint256, string memory, address) {
        require(hasRole(QUERY_ROLE, msg.sender), ""Caller is not authorized"");
        ILibrary libraryContract = ILibrary(libraryAddress);
        return libraryContract.getInfo();
    }
}",2.0843865871429443,getLibraryInfo,"[{'function': 'getInfo', 'complexity': 0}, {'function': 'getLibraryInfo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLibraryInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""libraryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""QUERY_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not authorized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ILibrary""}, ""name"": ""libraryContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ILibrary""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""libraryAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""libraryContract""}, ""memberName"": ""getInfo""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",42.0,0.6763902827855419,0.1142320414167923,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

interface ILibrary {
    function getInfo() external view returns (uint256, string memory, address);
}

contract LibraryQuery is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant QUERY_ROLE = keccak256(""QUERY_ROLE"");

    constructor() Ownable(msg.sender) { // Initialize Ownable in the constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(QUERY_ROLE, msg.sender);
    }

    function getLibraryInfo(address libraryAddress) public view returns (uint256, string memory, address) {
        require(hasRole(QUERY_ROLE, msg.sender), ""Caller is not authorized"");
        ILibrary libraryContract = ILibrary(libraryAddress);
        return libraryContract.getInfo();
    }
}"
1213,Get the token balance for a specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenBalanceGetter {
    using SafeMath for uint256;

    function getTokenBalance(address tokenAddress, address account) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(account);
    }
}",1.1862285137176514,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",10.0,0.7976532560814623,0.1546540124980857,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenBalanceGetter is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenBalance(address tokenAddress, address account) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(account);
    }
}"
6726,transfers tokens in ERC20 compatible way using signature to recover token sender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public authorizedSigners;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedSigners[msg.sender], ""Only authorized signers can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addAuthorizedSigner(address signer) public onlyOwner {
        authorizedSigners[signer] = true;
    }

    function removeAuthorizedSigner(address signer) public onlyOwner {
        require(signer != owner, ""Cannot remove the owner"");
        delete authorizedSigners[signer];
    }

    function transferTokens(
        address tokenAddress,
        address recipient,
        uint256 amount,
        bytes memory signature
    ) public onlyAuthorized {
        require(amount > 0, ""Amount must be greater than zero"");

        // Recover the signer's address from the signature
        address recoveredSigner = recoverSigner(tokenAddress, recipient, amount, signature);

        // Transfer tokens to the recipient
        IERC20 token = IERC20(tokenAddress);
        require(token.transferFrom(recoveredSigner, recipient, amount), ""Token transfer failed"");
    }

    function recoverSigner(
        address tokenAddress,
        address recipient,
        uint256 amount,
        bytes memory signature
    ) internal view returns (address) {
        // Construct the message to be signed
        bytes32 message = keccak256(abi.encodePacked(tokenAddress, recipient, amount));

        // Recover the signer's address from the signature
        return recoverAddressFromSignature(message, signature);
    }

    function recoverAddressFromSignature(bytes32 message, bytes memory signature) internal pure returns (address) {
        require(signature.length == 65, ""Invalid signature length"");

        // Recover the signer's address from the signed message
        return ecrecover(message, uint8(signature[64]), bytes32(signature[0:32]), bytes32(signature[32:64]));
    }
}",5.31264328956604,transferTokens,"[{'function': 'addAuthorizedSigner', 'complexity': 0}, {'function': 'removeAuthorizedSigner', 'complexity': 1}, {'function': 'transferTokens', 'complexity': 0}, {'function': 'recoverSigner', 'complexity': 0}, {'function': 'recoverAddressFromSignature', 'complexity': 1}]",3.0,{},29.0,0.617201909630492,0.0232918575800312,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public authorizedSigners;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedSigners[msg.sender], ""Only authorized signers can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addAuthorizedSigner(address signer) public onlyOwner {
        authorizedSigners[signer] = true;
    }

    function removeAuthorizedSigner(address signer) public onlyOwner {
        require(signer != owner, ""Cannot remove the owner"");
        delete authorizedSigners[signer];
    }

    function transferTokens(
        address tokenAddress,
        address recipient,
        uint256 amount,
        bytes memory signature
    ) public onlyAuthorized {
        require(amount > 0, ""Amount must be greater than zero"");

        // Recover the signer's address from the signature
        address recoveredSigner = recoverSigner(tokenAddress, recipient, amount, signature);

        // Transfer tokens to the recipient
        IERC20 token = IERC20(tokenAddress);
        require(token.transferFrom(recoveredSigner, recipient, amount), ""Token transfer failed"");
    }

    function recoverSigner(
        address tokenAddress,
        address recipient,
        uint256 amount,
        bytes memory signature
    ) internal view returns (address) {
        // Construct the message to be signed
        bytes32 message = keccak256(abi.encodePacked(tokenAddress, recipient, amount));

        // Recover the signer's address from the signed message
        return recoverAddressFromSignature(message, signature);
    }

    function recoverAddressFromSignature(bytes32 message, bytes memory signature) internal pure returns (address) {
        require(signature.length == 65, ""Invalid signature length"");

        // Recover the signer's address from the signed message
        return ecrecover(message, uint8(signature[64]), bytes32(signature[0:32]), bytes32(signature[32:64]));
    }
}"
6123,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenApproval {
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function approveToken(address _spender, uint256 _amount) external {
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool approved = token.approve(_spender, _amount);
        require(approved, ""Approval failed"");
    }
}",1.5319232940673828,approveToken,"[{'function': 'approveToken', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""approved""}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7661716486460092,0.1929211673727235,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function approveToken(address _spender, uint256 _amount) external {
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool approved = token.approve(_spender, _amount);
        require(approved, ""Approval failed"");
    }
}"
240,Used to check if an address is a delegate or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract DelegateChecker is AccessControl {
    bytes32 public constant DELEGATE_ROLE = keccak256(""DELEGATE_ROLE"");

    function isDelegate(address addr) external view returns (bool) {
        return hasRole(DELEGATE_ROLE, addr);
    }
}",0.968611478805542,isDelegate,"[{'function': 'isDelegate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isDelegate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DELEGATE_ROLE""}, {""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.7529678244377138,0.3578835436145691,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DelegateChecker is AccessControl, Ownable {
    bytes32 public constant DELEGATE_ROLE = keccak256(""DELEGATE_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(DELEGATE_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function isDelegate(address addr) external view returns (bool) {
        return hasRole(DELEGATE_ROLE, addr);
    }
}"
3785,Clear collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ClearCollection is AccessControl {
    using SafeMath for uint256;

    struct Collection {
        address owner;
        string name;
        // Add other collection details here
    }

    mapping(uint256 => Collection) public collections;
    uint256 public totalCollections;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function clearCollection(uint256 _collectionIndex) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_collectionIndex < totalCollections, ""Invalid collection index"");

        // Transfer ownership to the contract owner (or a designated address)
        collections[_collectionIndex].owner = msg.sender;

        // Emit an event or perform other necessary actions to clear the collection
        emit CollectionCleared(_collectionIndex);
    }

    event CollectionCleared(uint256 indexed collectionIndex);
}",2.344839096069336,clearCollection,"[{'function': 'clearCollection', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""clearCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCollections""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collection index""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collections""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CollectionCleared""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.8381687341011743,0.1017173694505057,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ClearCollection is AccessControl, Ownable {
    using SafeMath for uint256;

    struct Collection {
        address owner;
        string name;
        // Add other collection details here
    }

    mapping(uint256 => Collection) public collections;
    uint256 public totalCollections;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function clearCollection(uint256 _collectionIndex) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_collectionIndex < totalCollections, ""Invalid collection index"");

        // Transfer ownership to the contract owner (or a designated address)
        collections[_collectionIndex].owner = msg.sender;

        // Emit an event or perform other necessary actions to clear the collection
        emit CollectionCleared(_collectionIndex);
    }

    event CollectionCleared(uint256 indexed collectionIndex);
}"
3163,` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Campaign is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant PAYER_ROLE = keccak256(""PAYER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAYER_ROLE, msg.sender);
    }

    function proxyPayment() external payable {
        require(hasRole(PAYER_ROLE, msg.sender), ""Caller does not have PAYER_ROLE"");
    }
}",1.5843660831451416,proxyPayment,"[{'function': 'proxyPayment', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""PAYER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller does not have PAYER_ROLE""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",12.0,0.7039984693108851,0.06586656967644,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Campaign is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant PAYER_ROLE = keccak256(""PAYER_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAYER_ROLE, msg.sender);
    }

    function proxyPayment() external payable {
        require(hasRole(PAYER_ROLE, msg.sender), ""Caller does not have PAYER_ROLE"");
    }
}"
4854,A constant getter that returns the total number of pledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PledgeTracker {
    using SafeMath for uint256;

    mapping(address => uint256) public pledges;
    uint256 public totalPledges;

    function getTotalPledges() external view returns (uint2atural) {
        return totalPledges;
    }
}",1.014777421951294,getTotalPledges,"[{'function': 'getTotalPledges', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalPledges"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""uint2atural""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalPledges""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",5.0,0.8065722159411751,0.1073382554549285,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PledgeTracker is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public pledges;
    uint256 public totalPledges = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the constructor, no need to explicitly initialize them here.
    }

    function getTotalPledges() external view returns (uint256) {
        return totalPledges;
    }
}"
6206,Returns owner of a given Asset ( Token ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IAsset {
    function ownerOf(uint256 tokenId) external view returns (address);
}

contract AssetOwnerGetter is Ownable {
    mapping(uint256 => address) private assetOwners;

    function setAssetOwner(uint256 tokenId, address owner) public onlyOwner {
        assetOwners[tokenId] = owner;
    }

    function getAssetOwner(uint256 tokenId) public view returns (address) {
        return assetOwners[tokenId];
    }
}",1.4279124736785889,setAssetOwner,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'setAssetOwner', 'complexity': 0}, {'function': 'getAssetOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAssetOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7134280641485857,0.0895079401175506,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IAsset {
    function ownerOf(uint256 tokenId) external view returns (address);
}
import ""openzeppelin/SafeMath.sol"";
contract AssetOwnerGetter is Ownable {
    mapping(uint256 => address) private assetOwners;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized by the parent contract and interface
    }

    function setAssetOwner(uint256 tokenId, address owner) public onlyOwner {
        assetOwners[tokenId] = owner;
    }

    function getAssetOwner(uint256 tokenId) public view returns (address) {
        return assetOwners[tokenId];
    }
}"
780,Checks if two strings are equal or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/Strings.sol"";

contract StringEqualityChecker {
    using Strings for string;

    function areStringsEqual(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",0.9917609691619872,areStringsEqual,"[{'function': 'areStringsEqual', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""areStringsEqual"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""a"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""b"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""a""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",2.0,0.9022974933555472,0.5800815463973866,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StringEqualityChecker is Ownable {
    using Strings for string;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function areStringsEqual(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}"
6276,"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","pragma solidity ^0.8.0;

interface IController {
    function proxyPayment(address _token, address _user) external payable returns (bool);
}

contract TokenSale {
    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function fallback() external payable {
        require(controller != address(0), ""Controller not set"");
        IController(controller).proxyPayment{value: msg.value}(address(0), msg.sender);
    }
}",1.3163843154907229,fallback,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'fallback', 'complexity': 1}]",2.0,{},0.0,0.3617539228837474,0.015207675084487,"pragma solidity ^0.8.0;

interface IController {
    function proxyPayment(address _token, address _user) external payable returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    address public controller;

    constructor(address _controller) Ownable(msg.sender) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function fallback() external payable {
        require(controller != address(0), ""Controller not set"");
        IController(controller).proxyPayment{value: msg.value}(address(0), msg.sender);
    }
}"
321,Function used by the main partner to set the start time of the funding,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FundingContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant SET_START_TIME_ROLE = keccak256(""SET_START_TIME_ROLE"");
    uint256 private startTime;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setStartTime(uint256 _startTime) public onlyRole(SET_START_TIME_ROLE) {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        startTime = _startTime;
    }
}",1.7205395698547363,setStartTime,"[{'function': 'setStartTime', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""SET_START_TIME_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.7738597886372649,0.4240398004140948,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FundingContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant SET_START_TIME_ROLE = keccak256(""SET_START_TIME_ROLE"");
    uint256 private startTime;

    constructor(address admin) AccessControl() Ownable(admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        startTime = 1; // Set to a non-zero value
    }

    function setStartTime(uint256 _startTime) public onlyRole(SET_START_TIME_ROLE) {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        startTime = _startTime;
    }
}"
2712,Only owner is allowed to perform this operation .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    function onlyOwnerFunction(uint256 _input) public onlyOwner {
        require(_input > 0, ""Input must be greater than zero"");
        // Additional logic can be added here
    }
}",0.8385756015777588,onlyOwnerFunction,"[{'function': 'onlyOwnerFunction', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""onlyOwnerFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_input"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_input""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Input must be greater than zero""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.4833908254505202,0.025503575857644,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // Initialize state variables in the constructor
    uint256 public constant _uintConstant = 1;
    address public constant _addressConstant = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _boolConstant = true;
    string public constant _stringConstant = 'initialized';
    bytes32 public constant _bytes32Constant = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize state variables in the constructor
        uint256 public uintVariable = _uintConstant;
        address public addressVariable = _addressConstant;
        bool public boolVariable = _boolConstant;
        string public stringVariable = _stringConstant;
        bytes32 public bytes32Variable = _bytes32Constant;

        // Call parent contract's constructor
        super();
    }

    function onlyOwnerFunction(uint256 _input) public onlyOwner {
        require(_input > 0, ""Input must be greater than zero"");
        // Additional logic can be added here
    }
}"
3285,Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetApproval is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event ApprovalForAllSet(address indexed operator, bool approved);

    function setApprovalForAll(address operator, bool approved) external onlyOwner {
        require(operator != address(0), ""Invalid operator address"");
        approvedOperators[operator] = approved;
        emit ApprovalForAllSet(operator, approved);
    }
}",1.4916858673095703,setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid operator address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAllSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.9313590403236436,0.133071328698252,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetApproval is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event ApprovalForAllSet(address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address operator, bool approved) external onlyOwner {
        require(operator != address(0), ""Invalid operator address"");
        approvedOperators[operator] = approved;
        emit ApprovalForAllSet(operator, approved);
    }
}"
382,"Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RentArea is AccessControl {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint256 pricePerBlock;
        bool rented;
    }

    mapping(uint256 => Rental) public rentals;
    uint256 private rentalIdCounter;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 pricePerBlock) public payable {
        require(pricePerBlock > 0, ""Price per block must be greater than zero"");
        require(toX >= fromX && toY >= fromY, ""Invalid coordinates"");

        uint256 areaSize = (toX - fromX + 1) * (toY - fromY + 1);
        uint256 totalPrice = areaSize.mul(pricePerBlock);

        require(msg.value >= totalPrice, ""Insufficient funds sent"");

        rentalIdCounter++;
        rentals[rentalIdCounter] = Rental({renter: msg.sender, pricePerBlock: pricePerBlock, rented: true});
    }
}",3.05819034576416,rentArea,"[{'function': 'rentArea', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""rentArea"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""pricePerBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""pricePerBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price per block must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""toX""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromX""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""toY""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromY""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid coordinates""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""areaSize"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toX""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromX""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toY""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromY""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""areaSize""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pricePerBlock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""rentalIdCounter""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rentals""}, ""index"": {""type"": ""Identifier"", ""name"": ""rentalIdCounter""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Rental""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""pricePerBlock""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""renter"", ""pricePerBlock"", ""rented""]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",42.0,0.5338465515694071,0.1877593649557075,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RentArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint256 pricePerBlock;
        bool rented;
    }

    mapping(uint256 => Rental) public rentals;
    uint256 private rentalIdCounter;

    constructor() Ownable(msg.sender) {
        rentalIdCounter = 1; // Initialize to 1 instead of 0
    }

    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 pricePerBlock) public payable {
        require(pricePerBlock > 0, ""Price per block must be greater than zero"");
        require(toX >= fromX && toY >= fromY, ""Invalid coordinates"");

        uint256 areaSize = (toX - fromX + 1) * (toY - fromY + 1);
        uint256 totalPrice = areaSize.mul(pricePerBlock);

        require(msg.value >= totalPrice, ""Insufficient funds sent"");

        rentalIdCounter++; // Increment after use
        rentals[rentalIdCounter] = Rental({renter: msg.sender, pricePerBlock: pricePerBlock, rented: true});
    }
}"
1424,Allows the owner to revoke the vesting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IVesting {
    function revokeVesting(address beneficiary) external;
}

contract Vesting is Ownable, IVesting {
    mapping(address => uint256) public vestingAmounts;
    mapping(address => bool) public revoked;

    event RevokeVesting(address indexed beneficiary, uint256 amount);

    function revokeVesting(address beneficiary) external override onlyOwner {
        require(!revoked[beneficiary], ""Vesting already revoked"");
        uint256 amount = vestingAmounts[beneficiary];
        vestingAmounts[beneficiary] = 0;
        revoked[beneficiary] = true;
        emit RevokeVesting(beneficiary, amount);
    }
}",1.7749207019805908,revokeVesting,"[{'function': 'revokeVesting', 'complexity': 0}, {'function': 'revokeVesting', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeVesting"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Vesting already revoked""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RevokeVesting""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6751009207573114,0.0815467876149291,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IVesting {
    function revokeVesting(address beneficiary) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable(Ownable(msg.sender)) {
    mapping(address => uint256) public vestingAmounts;
    mapping(address => bool) public revoked;

    event RevokeVesting(address indexed beneficiary, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        vestingAmounts[msg.sender] = 1; // Set to a non-zero value
        revoked[msg.sender] = true;
    }

    function revokeVesting(address beneficiary) external override onlyOwner {
        require(!revoked[beneficiary], ""Vesting already revoked"");
        uint256 amount = vestingAmounts[beneficiary];
        vestingAmounts[beneficiary] = 0;
        revoked[beneficiary] = true;
        emit RevokeVesting(beneficiary, amount);
    }
}"
4864,Function to send multiple token transfers in one tx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MultiTokenTransfer {
    using SafeMath for uint256;

    function multiTransfer(address[] memory recipients, uint256[] memory amounts, address tokenAddress) public {
        IERC20 token = IERC20(tokenAddress);
        require(recipients.length == amounts.length, ""Recipients and amounts must be of the same length"");

        for (uint256 i = 0; i < recipients.length; i++) {
            uint256 amount = amounts[i];
            require(amount > 0, ""Amount must be greater than zero"");
            token.transferFrom(msg.sender, recipients[i], amount);
        }
    }
}",1.9426908493041992,multiTransfer,"[{'function': 'multiTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and amounts must be of the same length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.7497668948456621,0.2478476508483765,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MultiTokenTransfer is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function multiTransfer(address[] memory recipients, uint256[] memory amounts, address tokenAddress) public {
        IERC20 token = IERC20(tokenAddress);
        require(recipients.length == amounts.length, ""Recipients and amounts must be of the same length"");

        for (uint256 i = 0; i < recipients.length; i++) {
            uint256 amount = amounts[i];
            require(amount > 0, ""Amount must be greater than zero"");
            token.transferFrom(msg.sender, recipients[i], amount);
        }
    }
}"
5466,The user sends Ether to the pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Pool {
    using SafeMath for uint256;
    address public owner;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function sendEtherToPool(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        balances[msg.sender] = balances[msg.sender].add(amount);
    }
}",1.6141142845153809,sendEtherToPool,"[{'function': 'sendEtherToPool', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendEtherToPool"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",17.0,0.5095252118860943,0.1187170429008822,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Pool is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balances[owner()] = 1;
    }

    function sendEtherToPool(uint256 amount) public payable {
        require(amount > 0, ""Amount must be greater than zero"");
        balances[msg.sender] = balances[msg.sender].add(amount);
    }
}"
906,Create group Can be called only by contract owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract GroupManagement is Ownable {
    struct Group {
        uint256 id;
        string name;
        address[] members;
    }

    mapping(uint256 => Group) public groups;
    uint256 public nextGroupId = 1;

    function createGroup(string memory _name, address[] memory _members) public onlyOwner {
        require(_members.length > 0, ""At least one member must be specified"");

        Group storage newGroup = groups[nextGroupId];
        newGroup.id = nextGroupId;
        newGroup.name = _name;
        newGroup.members = _members;

        nextGroupId++;
    }
}",1.7069833278656006,createGroup,"[{'function': 'createGroup', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_members"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_members""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""At least one member must be specified""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Group""}, ""name"": ""newGroup"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groups""}, ""index"": {""type"": ""Identifier"", ""name"": ""nextGroupId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newGroup""}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""nextGroupId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newGroup""}, ""memberName"": ""name""}, ""right"": {""type"": ""Identifier"", ""name"": ""_name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newGroup""}, ""memberName"": ""members""}, ""right"": {""type"": ""Identifier"", ""name"": ""_members""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""nextGroupId""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.6594716050191755,0.0230600394599165,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GroupManagement is Ownable {
    struct Group {
        uint256 id;
        string name;
        address[] members;
    }

    mapping(uint256 => Group) public groups;
    uint256 public nextGroupId = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 0; i < 3; i++) {
            groups[i + 1] = Group({id: i + 1, name: ""initialized"", members: new address[](0)});
        }
    }

    function createGroup(string memory _name, address[] memory _members) public onlyOwner {
        require(_members.length > 0, ""At least one member must be specified"");

        Group storage newGroup = groups[nextGroupId];
        newGroup.id = nextGroupId;
        newGroup.name = _name;
        newGroup.members = _members;

        nextGroupId++;
    }
}"
1722,Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;
    IERC20 public token;
    uint256 public newTokenSaleHardCap = 1000 * 10**8; // 1000 tokens with 8 decimals
    mapping(address => uint256) public purchasedTokens;
    uint256 public totalPurchased;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint256 tokensToBuy = msg.value; // Assuming exchange rate is 1 XCR per token for simplicity
        require(totalPurchased.add(tokensToBuy) <= newTokenSaleHardCap, ""Purchase exceeds hard cap"");

        totalPurchased += tokensToBuy;
        purchasedTokens[msg.sender] += tokensToBuy;
        token.transfer(msg.sender, tokensToBuy);
    }
}",2.621289014816284,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalPurchased""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""newTokenSaleHardCap""}}, {""type"": ""stringLiteral"", ""value"": ""Purchase exceeds hard cap""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalPurchased""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchasedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",39.0,0.5741593812497104,0.0047104901973513,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;
    IERC20 public token;
    uint256 public newTokenSaleHardCap = 1000 * 10**8; // 1000 tokens with 8 decimals
    mapping(address => uint256) public purchasedTokens;
    uint256 public totalPurchased;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint256 tokensToBuy = msg.value; // Assuming exchange rate is 1 XCR per token for simplicity
        require(totalPurchased.add(tokensToBuy) <= newTokenSaleHardCap, ""Purchase exceeds hard cap"");

        totalPurchased += tokensToBuy;
        purchasedTokens[msg.sender] += tokensToBuy;
        token.transfer(msg.sender, tokensToBuy);
    }
}"
3988,Pause sale just in case we have some troubles Note that time marks are not updated,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PausableSale is Ownable {
    bool public paused = false;

    function pauseSale() external onlyOwner {
        paused = true;
    }

    function resumeSale() external onlyOwner {
        paused = false;
    }
}",0.8711788654327393,pauseSale,"[{'function': 'pauseSale', 'complexity': 0}, {'function': 'resumeSale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8160286138852458,0.0446510695659661,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PausableSale is Ownable {
    bool public paused = false;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        paused = false;
    }

    function pauseSale() external onlyOwner {
        paused = true;
    }

    function resumeSale() external onlyOwner {
        paused = false;
    }
}"
4761,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ResourcePriceUpdater {
    using SafeMath for uint256;

    uint256 public price;
    uint256 public remainingResources;

    constructor(uint256 initialPrice, uint256 initialRemainingResources) {
        price = initialPrice;
        remainingResources = initialRemainingResources;
    }

    function updatePrice() internal {
        if (remainingResources > 0) {
            price = price.div(remainingResources);
        } else {
            revert(""No resources left"");
        }
    }

    function setRemainingResources(uint256 newRemainingResources) public {
        remainingResources = newRemainingResources;
        updatePrice();
    }
}",1.7877752780914309,updatePrice,"[{'function': 'updatePrice', 'complexity': 1}, {'function': 'setRemainingResources', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRemainingResources"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRemainingResources"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""remainingResources""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRemainingResources""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrice""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.7397958155653496,0.1329943557030586,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public price;
    uint256 public remainingResources;

    constructor(uint256 initialPrice, uint256 initialRemainingResources) Ownable() {
        require(initialPrice > 0, ""Price must be greater than zero"");
        require(initialRemainingResources > 0, ""Remaining resources must be greater than zero"");

        price = initialPrice;
        remainingResources = initialRemainingResources;
    }

    function updatePrice() internal {
        if (remainingResources > 0) {
            price = price.div(remainingResources);
        } else {
            revert(""No resources left"");
        }
    }

    function setRemainingResources(uint256 newRemainingResources) public onlyOwner {
        remainingResources = newRemainingResources;
        updatePrice();
    }
}"
609,Checks that a given kitten is able to breed ( i.e .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract KittenBreeding is Ownable {
    using SafeMath for uint256;

    struct Kitten {
        bool isReadyToBreed;
        uint256 breedingCooldown;
    }

    mapping(uint256 => Kitten) public kittens;

    function setKittenReadiness(uint256 kittenId, bool readyToBreed, uint256 cooldownPeriod) external onlyOwner {
        require(cooldownPeriod > 0, ""Cooldown period must be greater than zero"");
        kittens[kittenId] = Kitten({isReadyToBreed: readyToBreed, breedingCooldown: block.timestamp + cooldownPeriod});
    }

    function canKittenBreed(uint256 kittenId) public view returns (bool) {
        require(_exists(kittenId), ""Kitten does not exist"");
        return kittens[kittenId].isReadyToBreed && block.timestamp >= kittens[kittenId].breedingCooldown;
    }

    function _exists(uint256 kittenId) internal view returns (bool) {
        return kittens[kittenId].breedingCooldown != 0;
    }
}",2.8742470741271973,setKittenReadiness,"[{'function': 'setKittenReadiness', 'complexity': 1}, {'function': 'canKittenBreed', 'complexity': 1}, {'function': '_exists', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""setKittenReadiness"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""kittenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""readyToBreed"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cooldownPeriod"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""cooldownPeriod""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Cooldown period must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""kittens""}, ""index"": {""type"": ""Identifier"", ""name"": ""kittenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Kitten""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""readyToBreed""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cooldownPeriod""}}], ""names"": [""isReadyToBreed"", ""breedingCooldown""]}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.614811721455604,0.045717258736071,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract KittenBreeding is Ownable {
    using SafeMath for uint256;

    struct Kitten {
        bool isReadyToBreed;
        uint256 breedingCooldown;
    }

    mapping(uint256 => Kitten) public kittens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            kittens[i] = Kitten({isReadyToBreed: true, breedingCooldown: block.timestamp + 1 days});
        }
    }

    function setKittenReadiness(uint256 kittenId, bool readyToBreed, uint256 cooldownPeriod) external onlyOwner {
        require(cooldownPeriod > 0, ""Cooldown period must be greater than zero"");
        kittens[kittenId] = Kitten({isReadyToBreed: readyToBreed, breedingCooldown: block.timestamp + cooldownPeriod});
    }

    function canKittenBreed(uint256 kittenId) public view returns (bool) {
        require(_exists(kittenId), ""Kitten does not exist"");
        return kittens[kittenId].isReadyToBreed && block.timestamp >= kittens[kittenId].breedingCooldown;
    }

    function _exists(uint256 kittenId) internal view returns (bool) {
        return kittens[kittenId].breedingCooldown != 0;
    }
}"
4790,Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenApproval {
    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function approveToken(address spender, uint256 amount) public returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return token.approve(spender, amount);
    }
}",1.2638492584228516,approveToken,"[{'function': 'approveToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8138272519492427,0.3445261402978937,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function approveToken(address spender, uint256 amount) public returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return token.approve(spender, amount);
    }
}"
4695,A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PrivateSale is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public maxFundingAmount;
    uint256 public totalFunded;

    event Funded(address indexed participant, uint256 amount);
    event RejectedContribution(address indexed participant);

    constructor(uint256 _maxFundingAmount) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        maxFundingAmount = _maxFundingAmount;
    }

    function fund() external payable {
        require(!isMaxFunded(), ""Private Sale has reached its maximum funding amount"");
        totalFunded += msg.value;
        emit Funded(msg.sender, msg.value);
    }

    function rejectContribution(address participant) external onlyRole(ADMIN_ROLE) {
        require(!isMaxFunded(), ""Private Sale has reached its maximum funding amount"");
        uint256 contribution = 0; // Assuming you need to store the rejected contribution amount for some reason
        if (contribution > 0) {
            payable(participant).transfer(contribution);
        }
        emit RejectedContribution(participant);
    }

    function isMaxFunded() public view returns (bool) {
        return totalFunded >= maxFundingAmount;
    }
}",3.479184150695801,rejectContribution,"[{'function': 'fund', 'complexity': 2}, {'function': 'rejectContribution', 'complexity': 3}, {'function': 'isMaxFunded', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""rejectContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""participant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isMaxFunded""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Private Sale has reached its maximum funding amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contribution"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""contribution""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""participant""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contribution""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RejectedContribution""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""participant""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.501398201545019,0.0352406012282986,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable contract

contract PrivateSale is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public maxFundingAmount;
    uint256 public totalFunded;

    event Funded(address indexed participant, uint256 amount);
    event RejectedContribution(address indexed participant);

    constructor(uint256 _maxFundingAmount) Ownable(msg.sender) { // Correctly invoking the Ownable constructor
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
        maxFundingAmount = _maxFundingAmount;
    }

    function fund() external payable {
        require(!isMaxFunded(), ""Private Sale has reached its maximum funding amount"");
        totalFunded += msg.value;
        emit Funded(msg.sender, msg.value);
    }

    function rejectContribution(address participant) external onlyRole(ADMIN_ROLE) {
        require(!isMaxFunded(), ""Private Sale has reached its maximum funding amount"");
        uint256 contribution = 0; // Assuming you need to store the rejected contribution amount for some reason
        if (contribution > 0) {
            payable(participant).transfer(contribution);
        }
        emit RejectedContribution(participant);
    }

    function isMaxFunded() public view returns (bool) {
        return totalFunded >= maxFundingAmount;
    }
}"
2989,Get a description of the validator at account ` validator ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ValidatorContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VALIDATOR_ROLE, msg.sender);
    }

    function getValidatorDescription(address validator) public view returns (string memory) {
        require(hasRole(VALIDATOR_ROLE, validator), ""Caller is not a validator"");
        // Additional logic can be added here to fetch the description of the validator at account `validator`.
        return """"; // Placeholder for actual implementation.
    }
}",1.9043757915496824,getValidatorDescription,"[{'function': 'getValidatorDescription', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorDescription"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""validator""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a validator""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": """"}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.827035191996456,0.129188779743488,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract ValidatorContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VALIDATOR_ROLE, msg.sender);
    }

    function getValidatorDescription(address validator) public view returns (string memory) {
        require(hasRole(VALIDATOR_ROLE, validator), ""Caller is not a validator"");
        // Additional logic can be added here to fetch the description of the validator at account `validator`.
        return """"; // Placeholder for actual implementation.
    }
}"
4597,Returns how many pixels has been already set .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PixelArt is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public totalPixelsSet;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setPixel(uint256 x, uint256 y) external onlyRole(ADMIN_ROLE) {
        // Additional logic can be added here
        totalPixelsSet = totalPixelsSet.add(1);
    }
}",1.7728891372680664,setPixel,"[{'function': 'setPixel', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPixel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalPixelsSet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalPixelsSet""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.2889637500455976,0.018061933874476,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract PixelArt is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 public totalPixelsSet;

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(ADMIN_ROLE, admin);
        transferOwnership(admin); // Transfer ownership to the admin
    }

    function setPixel(uint256 x, uint256 y) external onlyRole(ADMIN_ROLE) {
        totalPixelsSet = totalPixelsSet.add(1);
    }
}"
1962,Get value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

contract ValueStorage {
    using SafeMath for uint256;
    mapping(bytes32 => uint256) private values;

    function getValueForUint(bytes32 idKey, uint256 defaultValue) public view returns (uint256) {
        if (values[idKey] == 0) {
            return defaultValue;
        } else {
            return values[idKey];
        }
    }
}",1.2245826721191406,getValueForUint,"[{'function': 'getValueForUint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValueForUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""idKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""defaultValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""values""}, ""index"": {""type"": ""Identifier"", ""name"": ""idKey""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""defaultValue""}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""values""}, ""index"": {""type"": ""Identifier"", ""name"": ""idKey""}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.6541626107957441,0.2061927630692647,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ValueStorage is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => uint256) private values;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        values[bytes32('init')] = 1; // uint256: Set to 1 (never 0)
    }

    function getValueForUint(bytes32 idKey, uint256 defaultValue) public view returns (uint256) {
        if (values[idKey] == 0) {
            return defaultValue;
        } else {
            return values[idKey];
        }
    }
}"
629,"Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Vesting {
    using SafeMath for uint256;

    struct Grant {
        uint256 start;
        uint256 duration;
        uint256 cliff;
        uint256 tokens;
        bool claimed;
    }

    mapping(uint256 => Grant) public grants;
    uint256 public totalGrants;

    function claimTokens(uint256 _grantId) external returns (uint256 vested, uint256 unclaimed) {
        require(_grantId < totalGrants, ""Invalid grant ID"");
        Grant storage grant = grants[_grantId];
        require(!grant.claimed, ""Tokens already claimed"");
        require(block.timestamp >= grant.start.add(grant.cliff), ""Clawback period not reached"");

        uint256 timeSinceStart = block.timestamp.sub(grant.start);
        if (timeSinceStart < grant.duration) {
            vested = grant.tokens.mul(timeSinceStart).div(grant.duration);
            unclaimed = grant.tokens.sub(vested);
        } else {
            vested = grant.tokens;
            unclaimed = 0;
            grant.claimed = true;
        }
    }
}",2.881169319152832,claimTokens,"[{'function': 'claimTokens', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_grantId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""vested"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unclaimed"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_grantId""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalGrants""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid grant ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""grants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_grantId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens already claimed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""start""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""cliff""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Clawback period not reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSinceStart"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""start""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSinceStart""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""duration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vested""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""tokens""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""timeSinceStart""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""duration""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""unclaimed""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""tokens""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vested""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vested""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""tokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""unclaimed""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.7776396896520882,0.102132123011607,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Vesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 start;
        uint256 duration;
        uint256 cliff;
        uint256 tokens;
        bool claimed;
    }

    mapping(uint256 => Grant) public grants;
    uint256 public totalGrants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalGrants = 3; // Example value, adjust as needed

        for (uint256 i = 0; i < totalGrants; i++) {
            grants[i] = Grant({
                start: block.timestamp, // Example value, adjust as needed
                duration: 1 years, // Example value, adjust as needed
                cliff: 1 weeks, // Example value, adjust as needed
                tokens: 1000 * (10 ** uint256(decimals())), // Example value, adjust as needed
                claimed: false
            });
        }
    }

    function claimTokens(uint256 _grantId) external returns (uint256 vested, uint256 unclaimed) {
        require(_grantId < totalGrants, ""Invalid grant ID"");
        Grant storage grant = grants[_grantId];
        require(!grant.claimed, ""Tokens already claimed"");
        require(block.timestamp >= grant.start.add(grant.cliff), ""Clawback period not reached"");

        uint256 timeSinceStart = block.timestamp.sub(grant.start);
        if (timeSinceStart < grant.duration) {
            vested = grant.tokens.mul(timeSinceStart).div(grant.duration);
            unclaimed = grant.tokens.sub(vested);
        } else {
            vested = grant.tokens;
            unclaimed = 0;
            grant.claimed = true;
        }
    }
}"
4567,Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    struct Module {
        bool registered;
        address moduleAddress;
    }

    mapping(address => Module) public modules;

    function registerModule(address _moduleAddress) external onlyOwner {
        require(!modules[_moduleAddress].registered, ""Module already registered"");
        modules[_moduleAddress] = Module({registered: true, moduleAddress: _moduleAddress});
    }
}",1.448132038116455,registerModule,"[{'function': 'registerModule', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""memberName"": ""registered""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Module""}, ""arguments"": [{""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""_moduleAddress""}], ""names"": [""registered"", ""moduleAddress""]}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.7757789474403776,0.0003484074569814,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    struct Module {
        bool registered;
        address moduleAddress;
    }

    mapping(address => Module) public modules;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function registerModule(address _moduleAddress) external onlyOwner {
        require(!modules[_moduleAddress].registered, ""Module already registered"");
        modules[_moduleAddress] = Module({registered: true, moduleAddress: _moduleAddress});
    }
}"
2433,Total hash rate of a miner in a halving,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MinerHashRate {
    using SafeMath for uint256;

    struct Miner {
        uint256 hashRate;
        uint256 totalHashRate;
    }

    mapping(address => Miner) public miners;

    function updateMinerHashRate(uint256 newHashRate, address minerAddress) public {
        require(miners[minerAddress].hashRate != 0, ""Miner does not exist"");
        uint256 currentTotalHashRate = miners[minerAddress].totalHashRate;
        uint256 halvedHashRate = newHashRate.div(2);
        miners[minerAddress].hashRate = halvedHashRate;
        miners[minerAddress].totalHashRate = currentTotalHashRate.add(halvedHashRate);
    }
}",2.0038015842437744,updateMinerHashRate,"[{'function': 'updateMinerHashRate', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateMinerHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newHashRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""minerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""minerAddress""}}, ""memberName"": ""hashRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Miner does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTotalHashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""minerAddress""}}, ""memberName"": ""totalHashRate""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halvedHashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newHashRate""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""minerAddress""}}, ""memberName"": ""hashRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""halvedHashRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""minerAddress""}}, ""memberName"": ""totalHashRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTotalHashRate""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""halvedHashRate""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.715676287713939,0.0311134348040368,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MinerHashRate is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 hashRate;
        uint256 totalHashRate;
    }

    mapping(address => Miner) public miners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            miners[addr] = Miner({hashRate: 1, totalHashRate: 1});
        }
    }

    function updateMinerHashRate(uint256 newHashRate, address minerAddress) public {
        require(miners[minerAddress].hashRate != 0, ""Miner does not exist"");
        uint256 currentTotalHashRate = miners[minerAddress].totalHashRate;
        uint256 halvedHashRate = newHashRate.div(2);
        miners[minerAddress].hashRate = halvedHashRate;
        miners[minerAddress].totalHashRate = currentTotalHashRate.add(halvedHashRate);
    }
}"
915,"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}","pragma solidity ^0.8.0;

interface ICampaign {
    function getTotalValue() external view returns (uint256);
}

contract CampaignBudgetChecker {
    uint256 public constant MAX_CAMPAIGN_ID = 100; // Example max campaign ID, adjust as needed
    mapping(uint256 => ICampaign) public campaigns;

    constructor() {
        for (uint256 i = 1; i <= MAX_CAMPAIGN_ID; i++) {
            campaigns[i] = new MockCampaign(); // Replace with actual campaign contract addresses or mocks
        }
    }

    function getAvailableBudget(uint256 campaignId) public view returns (uint256) {
        require(campaignId > 0 && campaignId <= MAX_CAMPAIGN_ID, ""Invalid campaign ID"");
        return campaigns[campaignId].getTotalValue();
    }
}

contract MockCampaign is ICampaign {
    uint256 private totalValue;

    function setTotalValue(uint256 value) external {
        totalValue = value;
    }

    function getTotalValue() public override view returns (uint256) {
        return totalValue;
    }
}",2.609405040740967,getAvailableBudget,"[{'function': 'getTotalValue', 'complexity': 0}, {'function': 'getAvailableBudget', 'complexity': 2}, {'function': 'setTotalValue', 'complexity': 0}, {'function': 'getTotalValue', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAvailableBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""campaignId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignId""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_CAMPAIGN_ID""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid campaign ID""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""getTotalValue""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.5349241480263902,0.0158361051856454,"pragma solidity ^0.8.0;

interface ICampaign {
    function getTotalValue() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract CampaignBudgetChecker is Ownable {
    uint256 public constant MAX_CAMPAIGN_ID = 100; // Example max campaign ID, adjust as needed
    mapping(uint256 => ICampaign) public campaigns;

    constructor() Ownable(msg.sender) {
        for (uint256 i = 1; i <= MAX_CAMPAIGN_ID; i++) {
            campaigns[i] = new MockCampaign(); // Replace with actual campaign contract addresses or mocks
        }
    }

    function getAvailableBudget(uint256 campaignId) public view returns (uint256) {
        require(campaignId > 0 && campaignId <= MAX_CAMPAIGN_ID, ""Invalid campaign ID"");
        return campaigns[campaignId].getTotalValue();
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MockCampaign is ICampaign {
    uint256 private totalValue;

    function setTotalValue(uint256 value) external {
        totalValue = value;
    }

    function getTotalValue() public override view returns (uint256) {
        return totalValue;
    }
}"
2907,Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

interface IIcoContract {
    function setIcoAddress(address icoAddress) external;
}

contract IcoSetter is AccessControl {
    address public icoContractAddress;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    modifier onlyIcoContract() {
        require(msg.sender == icoContractAddress, ""Caller is not the ICO contract"");
        _;
    }

    function setIcoContractAddress(address newIcoContract) external onlyRole(DEFAULT_ADMIN_ROLE) {
        icoContractAddress = newIcoContract;
    }

    function setIcoAddressViaIcoContract() external onlyIcoContract {
        // Additional logic can be added here
    }
}",1.8893086910247805,setIcoContractAddress,"[{'function': 'setIcoAddress', 'complexity': 0}, {'function': 'setIcoContractAddress', 'complexity': 0}, {'function': 'setIcoAddressViaIcoContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newIcoContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""newIcoContract""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8061314926168265,0.2014941615706457,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

interface IIcoContract {
    function setIcoAddress(address icoAddress) external;
}
import ""openzeppelin/SafeMath.sol"";
contract IcoSetter is AccessControl, SafeERC20(""MyToken"") {
    address public icoContractAddress;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        icoContractAddress = 0x1111111111111111111111111111111111111111; // Replace with the actual ICO contract address
        _init();
    }

    modifier onlyIcoContract() {
        require(msg.sender == icoContractAddress, ""Caller is not the ICO contract"");
        _;
    }

    function setIcoContractAddress(address newIcoContract) external onlyRole(DEFAULT_ADMIN_ROLE) {
        icoContractAddress = newIcoContract;
    }

    function setIcoAddressViaIcoContract() external onlyIcoContract {
        // Additional logic can be added here
    }
}
import ""openzeppelin/SafeMath.sol"";
contract IcoSetterOwnable is AccessControl {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
5542,Enables the owner of a parcel to update the data field,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ParcelDataUpdater is Ownable {
    struct Parcel {
        string data;
    }

    mapping(address => Parcel) public parcels;

    function updateParcelData(address parcelAddress, string memory newData) public onlyOwner {
        require(parcels[parcelAddress].data != newData, ""New data is the same as the current data"");
        parcels[parcelAddress].data = newData;
    }
}",1.2363409996032717,updateParcelData,"[{'function': 'updateParcelData', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateParcelData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""parcelAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""newData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""parcels""}, ""index"": {""type"": ""Identifier"", ""name"": ""parcelAddress""}}, ""memberName"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""newData""}}, {""type"": ""stringLiteral"", ""value"": ""New data is the same as the current data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""parcels""}, ""index"": {""type"": ""Identifier"", ""name"": ""parcelAddress""}}, ""memberName"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""newData""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.5987231383927839,0.0240245972424045,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ParcelDataUpdater is Ownable {
    struct Parcel {
        string data;
    }

    mapping(address => Parcel) public parcels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            parcels[addr] = Parcel({data: ""initialized""});
        }
    }

    function updateParcelData(address parcelAddress, string memory newData) public onlyOwner {
        require(parcels[parcelAddress].data != newData, ""New data is the same as the current data"");
        parcels[parcelAddress].data = newData;
    }
}"
6660,"Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Deed is Ownable {
    mapping(address => bool) public approvedTakers;

    function setApprovedTaker(address _taker, bool _approved) public onlyOwner {
        require(_taker != address(0), ""Invalid taker address"");
        approvedTakers[_taker] = _approved;
    }
}",1.043001651763916,setApprovedTaker,"[{'function': 'setApprovedTaker', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovedTaker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_taker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_taker""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid taker address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTakers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_taker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.5720592068619546,0.018061933874476,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Deed is Ownable {
    mapping(address => bool) public approvedTakers;
    address public constant DEFAULT_TAKER = 0x1111111111111111111111111111111111111111; // Replace with actual default taker address
    bytes32 public constant DEFAULT_APPROVED = bytes32('init');

    constructor() Ownable(0x2222222222222222222222222222222222222222) { // Replace with actual owner address
        _setApproved(DEFAULT_TAKER, true);
    }

    function setApprovedTaker(address _taker, bool _approved) public onlyOwner {
        require(_taker != address(0), ""Invalid taker address"");
        approvedTakers[_taker] = _approved;
    }

    function _setApproved(address _taker, bool _approved) internal {
        approvedTakers[_taker] = _approved;
    }
}"
2749,"Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BudgetSetter is AccessControl {
    using SafeMath for uint256;

    IERC20 private _token;
    mapping(string => uint256) public budget;

    constructor(address tokenAddress, string memory symbol, uint256 amount) {
        require(tokenAddress != address(0), ""Invalid token address"");
        _token = IERC20(tokenAddress);
        setBudget(symbol, amount);
    }

    function setBudget(string memory symbol, uint256 amount) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_token.balanceOf(address(this)).sub(_token.allowance(address(this), address(this))) >= amount, ""Insufficient token allowance"");
        budget[symbol] = amount;
    }
}",2.288771629333496,setBudget,"[{'function': 'setBudget', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""budget""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.8285097789310623,0.0740467572974137,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is used for access control or ownership

contract BudgetSetter is AccessControl, Ownable {
    using SafeMath for uint256;

    IERC20 private _token;
    mapping(string => uint256) public budget;

    mapping(address => uint256) public balanceOf;

 constructor(address tokenAddress, string memory symbol, uint256 amount) Ownable(msg.sender) {
        require(tokenAddress != address(0), ""Invalid token address"");
        _token = IERC20(tokenAddress);
        setBudget(symbol, amount);
    }

    function setBudget(string memory symbol, uint256 amount) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_token.balanceOf(address(this)).sub(_token.allowance(address(this), address(this))) >= amount, ""Insufficient token allowance"");
        budget[symbol] = amount;
    }
}"
5294,"Only to be used when this contract is significantly broken , and an upgrade is required .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract UpgradeableContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant UPGRADER_ROLE = keccak256(""UPGRADER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(UPGRADER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function upgradeContract(address newImplementation) external onlyRole(UPGRADER_ROLE) {
        require(newImplementation != address(0), ""Invalid contract address"");
        (bool success, ) = newImplementation.delegatecall(abi.encodeWithSignature(""initialize()""));
        require(success, ""Initialization failed"");
    }
}",1.9480786323547363,upgradeContract,"[{'function': 'upgradeContract', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgradeContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newImplementation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contract address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newImplementation""}, ""memberName"": ""delegatecall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""initialize()""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Initialization failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""UPGRADER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.7078267709227638,0.0286865465202653,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract UpgradeableContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant UPGRADER_ROLE = keccak256(""UPGRADER_ROLE"");

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setRoleAdmin(UPGRADER_ROLE, DEFAULT_ADMIN_ROLE);
        transferOwnership(admin);
    }

    function upgradeContract(address newImplementation) external onlyRole(UPGRADER_ROLE) {
        require(newImplementation != address(0), ""Invalid contract address"");
        (bool success, ) = newImplementation.delegatecall(abi.encodeWithSignature(""initialize()""));
        require(success, ""Initialization failed"");
    }
}"
598,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    function sendTokens(address tokenAddress, address to, uint256 value) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= value, ""Insufficient balance"");
        bool transferSuccess = token.transferFrom(msg.sender, to, value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}",1.515505075454712,sendTokens,"[{'function': 'sendTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transferSuccess""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.6160794558121204,0.0390540931301241,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    // Fixed, safe values for uint and address
    uint256 public constant DEFAULT_VALUE = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address

    // Safe initialization of bool and string variables
    bool public initialized = true;
    string public constant INITIALIZED_STRING = 'initialized';

    // Bytes32 initialization using a fixed value
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables with safe values
        uint256 _defaultValue = DEFAULT_VALUE;
        address _defaultAddress = DEFAULT_ADDRESS;

        bool _initialized = true;
        string _initializedString = INITIALIZED_STRING;
        bytes32 _initBytes32 = INIT_BYTES32;

        // Call parent contract's mapping(address => uint256) public balanceOf;

 constructor
        super();
    }

    function sendTokens(address tokenAddress, address to, uint256 value) public onlyOwner returns (bool success) {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(msg.sender) >= value, ""Insufficient balance"");
        bool transferSuccess = token.transferFrom(msg.sender, to, value);
        require(transferSuccess, ""Token transfer failed"");
        return true;
    }
}"
2600,This function will set the conversion rate .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ConversionRateSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private conversionRate;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        conversionRate = 100; // Default conversion rate
    }

    function setConversionRate(uint256 newRate) public onlyRole(ADMIN_ROLE) {
        require(newRate > 0, ""Conversion rate must be greater than zero"");
        conversionRate = newRate;
    }
}",1.928802251815796,setConversionRate,"[{'function': 'setConversionRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConversionRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Conversion rate must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""conversionRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.7118072518490939,0.0174487678906813,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ConversionRateSetter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    uint256 private conversionRate;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        conversionRate = 100; // Default conversion rate
    }

    function setConversionRate(uint256 newRate) public onlyRole(ADMIN_ROLE) {
        require(newRate > 0, ""Conversion rate must be greater than zero"");
        conversionRate = newRate;
    }
}"
2777,Calls approve on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenApprover {
    using SafeMath for uint256;

    function approveToken(address tokenAddress, address spender, uint256 amount) public {
        IERC20 token = IERC20(tokenAddress);
        bool success = token.approve(spender, amount);
        require(success, ""Approve failed"");
    }
}",1.3077750205993652,approveToken,"[{'function': 'approveToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Approve failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.4289108731413295,0.0054212097864555,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApprover is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set in the parent constructor and modifiers
    }

    function approveToken(address tokenAddress, address spender, uint256 amount) public {
        IERC20 token = IERC20(tokenAddress);
        bool success = token.approve(spender, amount);
        require(success, ""Approve failed"");
    }
}"
2639,"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SynthIssuance {
    using SafeMath for uint256;

    // State variable to store the total SNX owned by this account
    uint256 private totalSNX;

    function setTotalSNX(uint256 amount) internal {
        totalSNX = amount;
    }

    function getTotalSNX() public view returns (uint256) {
        return totalSNX;
    }
}",1.2887721061706543,setTotalSNX,"[{'function': 'setTotalSNX', 'complexity': 0}, {'function': 'getTotalSNX', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotalSNX"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSNX""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.338065521727352,0.0016170778187978,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SynthIssuance is Ownable {
    using SafeMath for uint256;

    // State variable to store the total SNX owned by this account
    uint256 private totalSNX;

    constructor() Ownable(msg.sender) {
        totalSNX = 1;
    }

    function setTotalSNX(uint256 amount) internal {
        totalSNX = amount;
    }

    function getTotalSNX() public view returns (uint256) {
        return totalSNX;
    }
}"
4569,Returns all the relevant information about a specific whale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract WhaleInfo {
    using SafeMath for uint256;

    struct Whale {
        string name;
        uint256 balance;
        uint256 totalTransactions;
    }

    mapping(address => Whale) public whales;

    function getWhaleInfo(address whaleAddress) public view returns (string memory, uint256, uint256) {
        require(whales[whaleAddress].balance > 0, ""Whale not found"");
        return (whales[whaleAddress].name, whales[whaleAddress].balance, whales[whaleAddress].totalTransactions);
    }
}",1.6099741458892822,getWhaleInfo,"[{'function': 'getWhaleInfo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhaleInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""whaleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""whaleAddress""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Whale not found""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""whaleAddress""}}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""whaleAddress""}}, ""memberName"": ""balance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""whaleAddress""}}, ""memberName"": ""totalTransactions""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.7545012404037132,0.1295343869085936,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract WhaleInfo is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
        uint256 balance;
        uint256 totalTransactions;
    }

    mapping(address => Whale) public whales;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        whales[msg.sender] = Whale(""Unknown"", 1, 0);
    }

    function getWhaleInfo(address whaleAddress) public view returns (string memory, uint256, uint256) {
        require(whales[whaleAddress].balance > 0, ""Whale not found"");
        return (whales[whaleAddress].name, whales[whaleAddress].balance, whales[whaleAddress].totalTransactions);
    }
}"
3314,deliberately authorized the sender of the message via some mechanism,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AuthorizedSender is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant AUTHORIZED_ROLE = keccak256(""AUTHORIZED_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(AUTHORIZED_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(AUTHORIZED_ROLE, msg.sender);
    }

    function authorizeSender(address sender) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(AUTHORIZED_ROLE, sender);
    }

    modifier onlyAuthorized() {
        require(hasRole(AUTHORIZED_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    function performAction() public onlyAuthorized {
        // Function logic goes here
    }
}",2.21870493888855,authorizeSender,"[{'function': 'authorizeSender', 'complexity': 0}, {'function': 'performAction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeSender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""AUTHORIZED_ROLE""}, {""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.3250987942381181,0.0002617845961531,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AuthorizedSender is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant AUTHORIZED_ROLE = keccak256(""AUTHORIZED_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(AUTHORIZED_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(AUTHORIZED_ROLE, msg.sender);
    }

    function authorizeSender(address sender) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(AUTHORIZED_ROLE, sender);
    }

    modifier onlyAuthorized() {
        require(hasRole(AUTHORIZED_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    function performAction() public onlyAuthorized {
        // Function logic goes here
    }
}"
3619,Get the tags related to the module factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}","pragma solidity ^0.8.0;

interface IModuleFactory {
    function getTags() external view returns (string[] memory);
}

contract ModuleCaller {
    address public immutable moduleFactoryAddress;

    constructor(address _moduleFactoryAddress) {
        moduleFactoryAddress = _moduleFactoryAddress;
    }

    function getModuleTags() public view returns (string[] memory) {
        IModuleFactory moduleFactory = IModuleFactory(moduleFactoryAddress);
        return moduleFactory.getTags();
    }
}",1.1392815113067627,getModuleTags,"[{'function': 'getTags', 'complexity': 0}, {'function': 'getModuleTags', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getModuleTags"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IModuleFactory""}, ""name"": ""moduleFactory"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""moduleFactoryAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""getTags""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.7126127059202034,0.2147288484485343,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IModuleFactory {
    function getTags() external view returns (string[] memory);
}
import ""openzeppelin/SafeMath.sol"";
contract ModuleCaller is Ownable {
    address public immutable moduleFactoryAddress;

    constructor(address _moduleFactoryAddress) Ownable(msg.sender) {
        moduleFactoryAddress = _moduleFactoryAddress;
    }

    function getModuleTags() public view returns (string[] memory) {
        IModuleFactory moduleFactory = IModuleFactory(moduleFactoryAddress);
        return moduleFactory.getTags();
    }
}"
3235,Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}","pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract MyContract {
    address public targetAddress;

    constructor(address _targetAddress) {
        require(_targetAddress != address(0), ""Invalid target address"");
        targetAddress = _targetAddress;
    }

    function invokeOnERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4) {
        require(isContract(targetAddress), ""Target address is not a contract"");
        return IERC721Receiver(targetAddress).onERC721Received(operator, from, tokenId, data);
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",2.2263669967651367,isContract,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'invokeOnERC721Received', 'complexity': 1}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",24.0,0.3986485511324248,0.0396853412126827,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable, IERC721Receiver {
    address public targetAddress;

    constructor(address _targetAddress) Ownable(_msgSender()) {
        require(_targetAddress != address(0), ""Invalid target address"");
        targetAddress = _targetAddress;
    }

    function invokeOnERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public override returns (bytes4) {
        require(isContract(targetAddress), ""Target address is not a contract"");
        return IERC721Receiver(targetAddress).onERC721Received(operator, from, tokenId, data);
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
4896,Set whether prices can be changed manually .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract PriceSetter is AccessControl {
    bytes32 public constant PRICE_SETTER_ROLE = keccak256(""PRICE_SETTER_ROLE"");
    bool public canChangePricesManually;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PRICE_SETTER_ROLE, msg.sender);
        canChangePricesManually = false;
    }

    function setCanChangePricesManually(bool _canChange) public {
        require(hasRole(PRICE_SETTER_ROLE, msg.sender), ""Caller is not a price setter"");
        canChangePricesManually = _canChange;
    }
}",1.7307724952697754,setCanChangePricesManually,"[{'function': 'setCanChangePricesManually', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCanChangePricesManually"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_canChange"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""PRICE_SETTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a price setter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canChangePricesManually""}, ""right"": {""type"": ""Identifier"", ""name"": ""_canChange""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.7104150599046725,0.0187198008699162,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceSetter is AccessControl, Ownable {
    bytes32 public constant PRICE_SETTER_ROLE = keccak256(""PRICE_SETTER_ROLE"");
    bool public canChangePricesManually;

    constructor(address admin) AccessControl() Ownable(admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PRICE_SETTER_ROLE, msg.sender);
        canChangePricesManually = false;
    }

    function setCanChangePricesManually(bool _canChange) public {
        require(hasRole(PRICE_SETTER_ROLE, msg.sender), ""Caller is not a price setter"");
        canChangePricesManually = _canChange;
    }
}"
5609,Updates registration status for multiple addresses for participation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RegistrationStatusUpdater is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => bool) private registeredAddresses;

    event AddressRegistered(address indexed addr);
    event AddressUnregistered(address indexed addr);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function registerAddresses(address[] memory addrs) public onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (!registeredAddresses[addrs[i]]) {
                registeredAddresses[addrs[i]] = true;
                emit AddressRegistered(addrs[i]);
            }
        }
    }

    function unregisterAddresses(address[] memory addrs) public onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (registeredAddresses[addrs[i]]) {
                registeredAddresses[addrs[i]] = false;
                emit AddressUnregistered(addrs[i]);
            }
        }
    }
}",3.231130123138428,registerAddresses,"[{'function': 'registerAddresses', 'complexity': 4}, {'function': 'unregisterAddresses', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerAddresses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredAddresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredAddresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddressRegistered""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.6604207807683646,0.229034577591395,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RegistrationStatusUpdater is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => bool) private registeredAddresses;

    event AddressRegistered(address indexed addr);
    event AddressUnregistered(address indexed addr);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        grantRole(ADMIN_ROLE, msg.sender);
    }

    function registerAddresses(address[] memory addrs) public onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (!registeredAddresses[addrs[i]]) {
                registeredAddresses[addrs[i]] = true;
                emit AddressRegistered(addrs[i]);
            }
        }
    }

    function unregisterAddresses(address[] memory addrs) public onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (registeredAddresses[addrs[i]]) {
                registeredAddresses[addrs[i]] = false;
                emit AddressUnregistered(addrs[i]);
            }
        }
    }
}"
3896,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DestroyBeneficiary is Ownable {
    mapping(address => bool) public beneficiaries;

    function addBeneficiary(address _beneficiary) external onlyOwner {
        require(!beneficiaries[_beneficiary], ""Beneficiary already exists"");
        beneficiaries[_beneficiary] = true;
    }

    function removeBeneficiary(address _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        beneficiaries[_beneficiary] = false;
    }

    function destroyBeneficiary(address payable _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        selfdestruct(_beneficiary);
    }
}",1.8336403369903564,addBeneficiary,"[{'function': 'addBeneficiary', 'complexity': 2}, {'function': 'removeBeneficiary', 'complexity': 1}, {'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",69.0,0.7469885370231203,0.0085935258326756,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DestroyBeneficiary is Ownable {
    mapping(address => bool) public beneficiaries;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        bytes32 placeholder = bytes32('init');
        string memory initializedString = 'initialized';

        // No need to initialize the mapping as it starts with false values by default
    }

    function addBeneficiary(address _beneficiary) external onlyOwner {
        require(!beneficiaries[_beneficiary], ""Beneficiary already exists"");
        beneficiaries[_beneficiary] = true;
    }

    function removeBeneficiary(address _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        beneficiaries[_beneficiary] = false;
    }

    function destroyBeneficiary(address payable _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        selfdestruct(_beneficiary);
    }
}"
2053,Create ` msg.value ` ETH worth of GMT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GMTContract {
    using SafeMath for uint256;
    address public owner;
    mapping(address => uint256) public balances;

    constructor() {
        owner = msg.sender;
    }

    function createGMT(uint256 value) external payable {
        require(msg.value == value, ""Incorrect amount of ETH sent"");
        balances[owner] += value;
    }
}",1.2164669036865234,createGMT,"[{'function': 'createGMT', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGMT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect amount of ETH sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",73.0,0.5329461002028817,0.008370710643559,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GMTContract is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    function createGMT(uint256 value) external payable {
        require(msg.value == value, ""Incorrect amount of ETH sent"");
        balances[owner] += value;
    }
}"
306,How many HEAL tokens do this contract have,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBalance {
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function totalSupply() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}",1.029550075531006,totalSupply,"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.6133694927870236,0.5208534475787221,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    IERC20 public token;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function totalSupply() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}"
3644,"Pledges fees to the token holders , later to be claimed by burning","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PledgeFees {
    using SafeMath for uint256;

    IERC20 public token;
    address public owner;
    mapping(address => bool) public isClaimed;

    constructor(address _token) {
        token = IERC20(_token);
        owner = msg.sender;
    }

    function pledgeFees() external {
        require(msg.sender == owner, ""Only the contract owner can pledge fees"");
        uint256 balance = token.balanceOf(address(this));
        for (uint256 i = 0; i < balance; i++) {
            address holder = token.ownerOf(i);
            if (!isClaimed[holder]) {
                isClaimed[holder] = true;
                token.transfer(holder, 1); // Adjust the amount to be transferred per pledge
            }
        }
    }
}",2.347027540206909,pledgeFees,"[{'function': 'pledgeFees', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can pledge fees""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isClaimed""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isClaimed""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""holder""}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.7656053704797814,0.0330837274101644,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PledgeFees is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => bool) public isClaimed;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function pledgeFees() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        for (uint256 i = 0; i < balance; i++) {
            address holder = token.ownerOf(i);
            if (!isClaimed[holder]) {
                isClaimed[holder] = true;
                token.transfer(holder, 1); // Adjust the amount to be transferred per pledge
            }
        }
    }
}"
6330,Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetValuation {
    using SafeMath for uint256;

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function calculateValuation(uint256 assetAmount, uint256 exchangeRate) public pure returns (uint256) {
        return assetAmount.mul(exchangeRate);
    }
}",1.4402532577514648,calculateValuation,"[{'function': 'calculateValuation', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateValuation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""exchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assetAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""exchangeRate""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",30.0,0.1742993195544468,0.0237187427397564,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetValuation is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    function calculateValuation(uint256 assetAmount, uint256 exchangeRate) public pure returns (uint256) {
        return assetAmount.mul(exchangeRate);
    }
}"
5296,"Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}","pragma solidity ^0.8.0;

contract LinkedList {
    struct Node {
        uint256 data;
        Node next;
        Node prev;
    }

    Node head;

    function removeNode(uint256 _data) public {
        require(head != address(0), ""List is empty"");

        Node memory current = head;
        while (current != address(0)) {
            if (current.data == _data) {
                if (current.prev != address(0)) {
                    current.prev.next = current.next;
                } else {
                    head = current.next;
                }
                if (current.next != address(0)) {
                    current.next.prev = current.prev;
                }
                return;
            }
            current = current.next;
        }
        revert(""Node not found"");
    }
}",1.9099845886230469,removeNode,"[{'function': 'removeNode', 'complexity': 10}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeNode"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_data"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""head""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""List is empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""current"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""head""}}, {""type"": ""WhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""current""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""_data""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""prev""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""prev""}, ""memberName"": ""next""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""head""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}, ""memberName"": ""prev""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""prev""}}}]}, ""FalseBody"": None}, None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""current""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""current""}, ""memberName"": ""next""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Node not found""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.6972673068410937,0.0934535870321407,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LinkedList is Ownable {
    struct Node {
        uint256 data;
        Node next;
        Node prev;
    }

    Node head;

    constructor() Ownable(msg.sender) {
        // Initialize the head node with safe values
        head = Node({data: 1, next: address(0), prev: address(0)});
    }

    function removeNode(uint256 _data) public {
        require(head != address(0), ""List is empty"");

        Node memory current = head;
        while (current != address(0)) {
            if (current.data == _data) {
                if (current.prev != address(0)) {
                    current.prev.next = current.next;
                } else {
                    head = current.next;
                }
                if (current.next != address(0)) {
                    current.next.prev = current.prev;
                }
                return;
            }
            current = current.next;
        }
        revert(""Node not found"");
    }
}"
1009,Function that registers new synth as they are isseud .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SynthIssuance is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public issuedSynths;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, msg.sender);
    }

    function registerNewSynth(address synthAddress) external onlyRole(ISSUER_ROLE) {
        require(!issuedSynths[synthAddress], ""Synth already issued"");
        issuedSynths[synthAddress] = true;
    }
}",1.8964202404022217,registerNewSynth,"[{'function': 'registerNewSynth', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerNewSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""synthAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""issuedSynths""}, ""index"": {""type"": ""Identifier"", ""name"": ""synthAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Synth already issued""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""issuedSynths""}, ""index"": {""type"": ""Identifier"", ""name"": ""synthAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ISSUER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",86.0,0.6005792831777361,0.0003736687582978,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract SynthIssuance is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public issuedSynths;

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, msg.sender);
    }

    function registerNewSynth(address synthAddress) external onlyRole(ISSUER_ROLE) {
        require(!issuedSynths[synthAddress], ""Synth already issued"");
        issuedSynths[synthAddress] = true;
    }
}"
5740,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor(address _tokenAddress, uint256 _newBuyPrice, uint256 _newSellPrice) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() external payable {
        uint256 amount = msg.value.div(newBuyPrice);
        require(token.balanceOf(address(this)) >= amount, ""Insufficient tokens available"");
        require(token.transfer(msg.sender, amount), ""Token transfer failed"");
    }

    function sellTokens(uint256 _amount) external {
        uint256 ethAmount = _amount.mul(newSellPrice);
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance to sell tokens"");
        require(token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");
        payable(msg.sender).transfer(ethAmount);
    }

    function setNewBuyPrice(uint256 _newBuyPrice) external onlyOwner {
        newBuyPrice = _newBuyPrice;
    }

    function setNewSellPrice(uint256 _newSellPrice) external onlyOwner {
        newSellPrice = _newSellPrice;
    }
}",4.330322980880737,sellTokens,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 2}, {'function': 'sellTokens', 'complexity': 2}, {'function': 'setNewBuyPrice', 'complexity': 0}, {'function': 'setNewSellPrice', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newSellPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to sell tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.4475712026912464,0.009893615743446,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IToken public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress, uint256 _newBuyPrice, uint256 _newSellPrice) Ownable() {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() external payable {
        uint256 amount = msg.value.div(newBuyPrice);
        require(token.balanceOf(address(this)) >= amount, ""Insufficient tokens available"");
        require(token.transfer(msg.sender, amount), ""Token transfer failed"");
    }

    function sellTokens(uint256 _amount) external {
        uint256 ethAmount = _amount.mul(newSellPrice);
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance to sell tokens"");
        require(token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");
        payable(msg.sender).transfer(ethAmount);
    }

    function setNewBuyPrice(uint256 _newBuyPrice) external onlyOwner {
        newBuyPrice = _newBuyPrice;
    }

    function setNewSellPrice(uint256 _newSellPrice) external onlyOwner {
        newSellPrice = _newSellPrice;
    }
}"
4219,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","pragma solidity ^0.8.0;

interface IController {
    function isAdmin(address) external view returns (bool);
}

contract Contribution {
    uint256 public endTime;
    address public controller;

    constructor(uint256 _endTime, address _controller) {
        require(_endTime > block.timestamp, ""End time must be in the future"");
        endTime = _endTime;
        controller = _controller;
    }

    modifier onlyAdminOrAfterEnd() {
        require(IController(_controller).isAdmin(msg.sender) || block.timestamp >= endTime, ""Only admin or after end time"");
        _;
    }

    function withdraw() external onlyAdminOrAfterEnd {
        // Withdraw logic here
    }
}",1.7083492279052734,withdraw,"[{'function': 'isAdmin', 'complexity': 0}, {'function': 'withdraw', 'complexity': 0}]",1.0,{},100.0,0.4011334939731908,4.005190952911351e-06,"pragma solidity ^0.8.0;

interface IController {
    function isAdmin(address) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract Contribution is Ownable {
    uint256 public endTime;
    address public controller;

    constructor(uint256 _endTime, address _controller) Ownable(msg.sender) {
        require(_endTime > block.timestamp, ""End time must be in the future"");
        endTime = _endTime;
        controller = _controller;
    }

    modifier onlyAdminOrAfterEnd() {
        require(IController(_controller).isAdmin(msg.sender) || block.timestamp >= endTime, ""Only admin or after end time"");
        _;
    }

    function withdraw() external onlyAdminOrAfterEnd {
        // Withdraw logic here
    }
}"
6178,Checks whether the contract operations is paused or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}","pragma solidity ^0.8.0;

interface Pausable {
    function paused() external view returns (bool);
}

contract ContractAccessControl {
    address public owner;
    bool private paused = false;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract operations are currently paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    function checkIfPaused(address contractAddress) external view returns (bool) {
        Pausable pausableContract = Pausable(contractAddress);
        return pausableContract.paused();
    }
}",2.012613296508789,checkIfPaused,"[{'function': 'paused', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'checkIfPaused', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkIfPaused"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pausable""}, ""name"": ""pausableContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pausable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pausableContract""}, ""memberName"": ""paused""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.5732065130164185,0.1989591391878165,"pragma solidity ^0.8.0;

interface Pausable {
    function paused() external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ContractAccessControl is Ownable {
    bool private paused = false;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract operations are currently paused"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the base class constructor
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    function checkIfPaused(address contractAddress) external view returns (bool) {
        Pausable pausableContract = Pausable(contractAddress);
        return pausableContract.paused();
    }
}"
1600,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanConverter {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public approvedRampContracts;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyApprovedRamp() {
        require(approvedRampContracts[msg.sender], ""The caller is not an approved ramp contract"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setNewConverterRamp(address newRamp) public onlyOwner {
        require(newRamp != address(0), ""Invalid address"");
        approvedRampContracts[newRamp] = true;
    }
}",1.930392265319824,setNewConverterRamp,"[{'function': 'setNewConverterRamp', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newRamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedRampContracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""newRamp""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8133798803851807,0.0394640208935507,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing the Ownable contract

contract LoanConverter is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public approvedRampContracts;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier onlyApprovedRamp() {
        require(approvedRampContracts[msg.sender], ""The caller is not an approved ramp contract"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setNewConverterRamp(address newRamp) public onlyOwner {
        require(newRamp != address(0), ""Invalid address"");
        approvedRampContracts[newRamp] = true;
    }
}"
4079,Get the token spender allowance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenAllowance {
    using SafeMath for uint256;

    function getTokenAllowance(address tokenAddress, address account, address spender) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.allowance(account, spender);
    }
}",1.249647617340088,getTokenAllowance,"[{'function': 'getTokenAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",17.0,0.8498238683812476,0.2074013651776517,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenAllowance is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function getTokenAllowance(address tokenAddress, address account, address spender) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.allowance(account, spender);
    }
}"
5836,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenMinter {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function mintTokens(address to, uint256 amount) external returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return token.transfer(to, amount);
    }
}",1.4795758724212646,mintTokens,"[{'function': 'mintTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.5898737872446521,0.01785373810379,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenMinter is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function mintTokens(address to, uint256 amount) external returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        return token.transfer(to, amount);
    }
}"
6399,Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IERC1967 {
    function setInterfaceImplementer(address account, bytes4 interfaceHash, address implementer) external;
}

abstract contract ManagerRole is Ownable {
    mapping(address => bool) public managers;

    modifier onlyManager() {
        require(managers[msg.sender], ""Only manager can call this function"");
        _;
    }

    function addManager(address manager) external onlyOwner {
        managers[manager] = true;
    }

    function removeManager(address manager) external onlyOwner {
        require(managers[manager], ""Manager does not exist"");
        managers[manager] = false;
    }
}

contract InterfaceImplementerSetter is ManagerRole {
    IERC1967 public erc1967;

    function setInterfaceImplementer(address account, bytes4 interfaceHash, address implementer) external onlyManager {
        require(address(erc1967) != address(0), ""ERC1967 contract not set"");
        erc1967.setInterfaceImplementer(account, interfaceHash, implementer);
    }

    function setERC1967Contract(address _erc1967) external onlyOwner {
        require(_erc1967 != address(0), ""Invalid contract address"");
        erc1967 = IERC1967(_erc1967);
    }
}",3.1995983123779297,removeManager,"[{'function': 'setInterfaceImplementer', 'complexity': 0}, {'function': 'addManager', 'complexity': 0}, {'function': 'removeManager', 'complexity': 1}, {'function': 'setInterfaceImplementer', 'complexity': 1}, {'function': 'setERC1967Contract', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""manager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""manager""}}, {""type"": ""stringLiteral"", ""value"": ""Manager does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""manager""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.6774134893027306,0.0268056438618414,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC1967 {
    function setInterfaceImplementer(address account, bytes4 interfaceHash, address implementer) external;
}
import ""openzeppelin/SafeMath.sol"";
contract ManagerRole is Ownable {
    mapping(address => bool) public managers;

    modifier onlyManager() {
        require(managers[msg.sender], ""Only manager can call this function"");
        _;
    }

    function addManager(address manager) external onlyOwner {
        managers[manager] = true;
    }

    function removeManager(address manager) external onlyOwner {
        require(managers[manager], ""Manager does not exist"");
        managers[manager] = false;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract InterfaceImplementerSetter is ManagerRole {
    IERC1967 public erc1967;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setInterfaceImplementer(address account, bytes4 interfaceHash, address implementer) external onlyManager {
        require(address(erc1967) != address(0), ""ERC1967 contract not set"");
        erc1967.setInterfaceImplementer(account, interfaceHash, implementer);
    }

    function setERC1967Contract(address _erc1967) external onlyOwner {
        require(_erc1967 != address(0), ""Invalid contract address"");
        erc1967 = IERC1967(_erc1967);
    }
}"
5804,Returns current sell offer for the canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}","pragma solidity ^0.8.0;

interface ICanvasMarketplace {
    function getSellOffer(uint256 tokenId) external view returns (uint256);
}

contract CanvasBuyer {
    address private constant MARKETPLACE_ADDRESS = 0xYourMarketplaceAddress;

    function buyCanvas(uint256 tokenId) public payable {
        ICanvasMarketplace marketplace = ICanvasMarketplace(MARKETPLACE_ADDRESS);
        uint256 sellOffer = marketplace.getSellOffer(tokenId);

        require(msg.value >= sellOffer, ""Insufficient funds to buy the canvas."");

        (bool success, ) = MARKETPLACE_ADDRESS.call{value: sellOffer}(abi.encodeWithSignature(""buyCanvas(uint256)"", tokenId));
        require(success, ""Transaction failed."");
    }
}",1.80841875076294,buyCanvas,"[{'function': 'getSellOffer', 'complexity': 0}, {'function': 'buyCanvas', 'complexity': 2}]",3.0,{},29.0,0.589842029600666,0.0207041484550099,"pragma solidity ^0.8.0;

interface ICanvasMarketplace {
    function getSellOffer(uint256 tokenId) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract CanvasBuyer is Ownable {
    address private constant MARKETPLACE_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with your marketplace address
    uint256 public constant DEFAULT_SELL_OFFER = 1;
    bool public initialized = true;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buyCanvas(uint256 tokenId) public payable {
        ICanvasMarketplace marketplace = ICanvasMarketplace(MARKETPLACE_ADDRESS);
        uint256 sellOffer = marketplace.getSellOffer(tokenId);

        require(msg.value >= sellOffer, ""Insufficient funds to buy the canvas."");

        (bool success, ) = MARKETPLACE_ADDRESS.call{value: sellOffer}(abi.encodeWithSignature(""buyCanvas(uint256)"", tokenId));
        require(success, ""Transaction failed."");
    }
}"
1832,Generates ` amount ` tokens that are assigned to ` owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenAssignment is Ownable {
    IERC20 private token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function generateTokens(uint256 amount, address owner) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(owner != address(0), ""Invalid recipient address"");

        bool success = token.transfer(owner, amount);
        require(success, ""Token transfer failed"");
    }
}",1.6018764972686768,generateTokens,"[{'function': 'generateTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""generateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.7719772714921781,0.0135968551208325,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenAssignment is Ownable {
    IERC20 private token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function generateTokens(uint256 amount, address owner) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(owner != address(0), ""Invalid recipient address"");

        bool success = token.transfer(owner, amount);
        require(success, ""Token transfer failed"");
    }
}"
107,Allows the owner to register and the details for a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenRegistration is Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint8 decimals;
        uint256 totalSupply;
    }

    mapping(address => bool) public registeredTokens;
    mapping(address => TokenDetails) public tokenDetails;

    function registerToken(address _tokenAddress, string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public onlyOwner {
        require(!registeredTokens[_tokenAddress], ""Token already registered"");
        require(_totalSupply > 0, ""Total supply must be greater than zero"");

        TokenDetails storage token = tokenDetails[_tokenAddress];
        token.name = _name;
        token.symbol = _symbol;
        token.decimals = _decimals;
        token.totalSupply = _totalSupply;

        registeredTokens[_tokenAddress] = true;
    }
}",2.43569564819336,registerToken,"[{'function': 'registerToken', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_decimals"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_totalSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Total supply must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenDetails""}, ""name"": ""token"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenDetails""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""name""}, ""right"": {""type"": ""Identifier"", ""name"": ""_name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""symbol""}, ""right"": {""type"": ""Identifier"", ""name"": ""_symbol""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""right"": {""type"": ""Identifier"", ""name"": ""_decimals""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.8248678999334321,0.1186467919411579,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenRegistration is Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint8 decimals;
        uint256 totalSupply;
    }

    mapping(address => bool) public registeredTokens;
    mapping(address => TokenDetails) public tokenDetails;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            registeredTokens[addr] = false;
            tokenDetails[addr].name = 'initialized';
            tokenDetails[addr].symbol = 'initialized';
            tokenDetails[addr].decimals = 18; // Default value for decimals
            tokenDetails[addr].totalSupply = 1 * 10**uint256(18); // Example total supply
        }
    }

    function registerToken(address _tokenAddress, string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public onlyOwner {
        require(!registeredTokens[_tokenAddress], ""Token already registered"");
        require(_totalSupply > 0, ""Total supply must be greater than zero"");

        TokenDetails storage token = tokenDetails[_tokenAddress];
        token.name = _name;
        token.symbol = _symbol;
        token.decimals = _decimals;
        token.totalSupply = _totalSupply;

        registeredTokens[_tokenAddress] = true;
    }
}"
2044,Mint ` _amount ` tokens that are assigned to ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private _balances;
    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    function mint(address _owner, uint256 _amount) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        _balances[_owner] = _balances[_owner].add(_amount);
    }
}",1.5891315937042236,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.7792954398505493,0.0434579125779292,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private _balances;
    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        _balances[msg.sender] = 1000; // Set initial balance for the owner
    }

    function mint(address _owner, uint256 _amount) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        _balances[_owner] = _balances[_owner].add(_amount);
    }
}"
2892,Makes an offer which can be filled by other users .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OfferContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OFFER_ROLE = keccak256(""OFFER_ROLE"");
    mapping(uint256 => Offer) public offers;
    uint256 public offerCounter;

    struct Offer {
        address creator;
        uint256 amount;
        bool filled;
    }

    event OfferCreated(uint256 indexed id, address indexed creator, uint256 amount);
    event OfferFilled(uint256 indexed id, address indexed filler, uint256 amount);

    modifier onlyOfferCreator(uint256 _id) {
        require(offers[_id].creator == msg.sender, ""Only the creator can fill this offer"");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OFFER_ROLE, msg.sender);
    }

    function createOffer(uint256 _amount) public {
        offerCounter++;
        offers[offerCounter] = Offer({creator: msg.sender, amount: _amount, filled: false});
        emit OfferCreated(offerCounter, msg.sender, _amount);
    }

    function fillOffer(uint256 _id) public {
        require(!offers[_id].filled, ""This offer has already been filled"");
        require(_hasRole(OFFER_ROLE, msg.sender), ""Caller is not an offer creator"");
        offers[_id].filled = true;
        (bool success, ) = offers[_id].creator.call{value: offers[_id].amount}("""");
        require(success, ""Transfer failed"");
        emit OfferFilled(_id, msg.sender, offers[_id].amount);
    }
}",4.147941589355469,fillOffer,"[{'function': 'createOffer', 'complexity': 0}, {'function': 'fillOffer', 'complexity': 4}]",4.0,{},134.0,0.6726068302583704,0.0340874514427525,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract OfferContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant OFFER_ROLE = keccak256(""OFFER_ROLE"");
    mapping(uint256 => Offer) public offers;
    uint256 public offerCounter;

    struct Offer {
        address creator;
        uint256 amount;
        bool filled;
    }

    event OfferCreated(uint256 indexed id, address indexed creator, uint256 amount);
    event OfferFilled(uint256 indexed id, address indexed filler, uint256 amount);

    modifier onlyOfferCreator(uint256 _id) {
        require(offers[_id].creator == msg.sender, ""Only the creator can fill this offer"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OFFER_ROLE, msg.sender);
    }

    function createOffer(uint256 _amount) public {
        offerCounter++;
        offers[offerCounter] = Offer({creator: msg.sender, amount: _amount, filled: false});
        emit OfferCreated(offerCounter, msg.sender, _amount);
    }

    function fillOffer(uint256 _id) public {
        require(!offers[_id].filled, ""This offer has already been filled"");
        require(_hasRole(OFFER_ROLE, msg.sender), ""Caller is not an offer creator"");
        offers[_id].filled = true;
        (bool success, ) = offers[_id].creator.call{value: offers[_id].amount}("""");
        require(success, ""Transfer failed"");
        emit OfferFilled(_id, msg.sender, offers[_id].amount);
    }
}"
5927,A getter to find the level of authority a specific Project has using a self-referential loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}","pragma solidity ^0.8.0;

interface IProject {
    function getLevelOfAuthority(address user) external view returns (uint256);
}

contract AuthorityFinder {
    address public projectAddress;

    constructor(address _projectAddress) {
        projectAddress = _projectAddress;
    }

    function findLevelOfAuthority() public view returns (uint256) {
        IProject project = IProject(projectAddress);
        return project.getLevelOfAuthority(msg.sender);
    }
}",1.1793029308319092,findLevelOfAuthority,"[{'function': 'getLevelOfAuthority', 'complexity': 0}, {'function': 'findLevelOfAuthority', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""findLevelOfAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IProject""}, ""name"": ""project"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IProject""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""projectAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""project""}, ""memberName"": ""getLevelOfAuthority""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.6214900812875004,0.0280354037486408,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IProject {
    function getLevelOfAuthority(address user) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract AuthorityFinder is Ownable, IProject {
    address public projectAddress;

    constructor(address _projectAddress) Ownable(msg.sender) {
        projectAddress = _projectAddress;
    }

    function findLevelOfAuthority() public view override returns (uint256) {
        IProject project = IProject(projectAddress);
        return project.getLevelOfAuthority(msg.sender);
    }
}"
3990,Notifies the controller about a token transfer allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}","pragma solidity ^0.8.0;

interface IController {
    function notifyTokenTransfer(address sender, address recipient, uint256 amount) external;
}

contract TokenTransferNotifier {
    address public immutable controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function transferToken(address token, address to, uint256 amount) external {
        require(to != address(0), ""Invalid recipient address"");
        require(IERC20(token).transferFrom(msg.sender, to, amount), ""Transfer failed"");
        IController(controller).notifyTokenTransfer(msg.sender, to, amount);
    }
}",1.5949485301971436,transferToken,"[{'function': 'notifyTokenTransfer', 'complexity': -2}, {'function': 'transferToken', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""notifyTokenTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.6609889788775385,0.013020730574087,"pragma solidity ^0.8.0;

interface IController {
    function notifyTokenTransfer(address sender, address recipient, uint256 amount) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransferNotifier is Ownable {
    address public immutable controller;

    constructor(address _controller) Ownable(msg.sender) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function transferToken(address token, address to, uint256 amount) external {
        require(to != address(0), ""Invalid recipient address"");
        require(IERC20(token).transferFrom(msg.sender, to, amount), ""Transfer failed"");
        IController(controller).notifyTokenTransfer(msg.sender, to, amount);
    }
}"
5074,` onlyOwner ` Cancel a payment all together,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentCancellation is Ownable {
    mapping(address => uint256) public payments;

    function cancelPayment(address payee) external onlyOwner {
        require(payments[payee] > 0, ""No payment to cancel"");
        payments[payee] = 0;
    }
}",0.9737997055053712,cancelPayment,"[{'function': 'cancelPayment', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""payee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No payment to cancel""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7560555070963613,0.0226982954892162,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentCancellation is Ownable {
    mapping(address => uint256) public payments;
    address public constant PAYEE_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant IS_PAID = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(PAYEE_ADDRESS, INIT_BYTES32) {
        payments[PAYEE_ADDRESS] = 1; // Initialize payment amount to a fixed value
    }

    function cancelPayment(address payee) external onlyOwner {
        require(payments[payee] > 0, ""No payment to cancel"");
        payments[payee] = 0;
    }
}"
1247,Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl, IERC777Recipient {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        require(hasRole(OPERATOR_ROLE, operator), ""Caller is not an operator"");
        // Additional logic can be added here
    }
}",2.273554563522339,tokensReceived,"[{'function': 'tokensReceived', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokensReceived"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""operator""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an operator""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",,0.7046259790189795,0.0162878025267217,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract MyContract is AccessControl, IERC777Recipient, Ownable {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(OPERATOR_ROLE, msg.sender);
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        require(hasRole(OPERATOR_ROLE, operator), ""Caller is not an operator"");
        // Additional logic can be added here
    }
}"
5500,Approves another address to claim for the ownership of any tokens owned by this account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenApproval is Ownable {
    using SafeMath for uint256;

    function approveForClaim(address tokenAddress, address spender) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        uint256 allowance = token.allowance(owner(), spender);
        require(allowance < token.totalSupply(), ""Allowance exceeds total supply"");
        token.approve(spender, type(uint256).max);
    }
}",1.7165920734405518,approveForClaim,"[{'function': 'approveForClaim', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveForClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Allowance exceeds total supply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.6807905104146074,0.1294577685471297,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenApproval is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveForClaim(address tokenAddress, address spender) public onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        uint256 allowance = token.allowance(owner(), spender);
        require(allowance < token.totalSupply(), ""Allowance exceeds total supply"");
        token.approve(spender, type(uint256).max);
    }
}"
4001,Function calls other functions to calculate tokenamount to send to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenDistribution {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function calculateTokenAmount(address beneficiary) public view returns (uint256) {
        // Example logic to calculate token amount
        uint256 balance = balances[beneficiary];
        return balance.mul(10).div(100); // 10% of the balance
    }

    function sendTokensToBeneficiary(address beneficiary, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        balances[beneficiary] = balances[beneficiary].add(amount);
    }
}",2.2761905193328857,calculateTokenAmount,"[{'function': 'calculateTokenAmount', 'complexity': 0}, {'function': 'sendTokensToBeneficiary', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokenAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",56.0,0.6280446068403333,0.0057746199861152,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDistribution is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent contract's constructor
    }

    function calculateTokenAmount(address beneficiary) public view returns (uint256) {
        uint256 balance = balances[beneficiary];
        return balance.mul(10).div(100); // 10% of the balance
    }

    function sendTokensToBeneficiary(address beneficiary, uint256 amount) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        balances[beneficiary] = balances[beneficiary].add(amount);
    }
}"
267,Redeem required amount of tokens for the real asset,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenRedemption is ReentrancyGuard {
    IToken public token;
    address public owner;

    constructor(address _tokenAddress) {
        token = IToken(_tokenAddress);
        owner = msg.sender;
    }

    function redeemTokens(uint256 amount, address recipient) external nonReentrant {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool success = token.transfer(recipient, amount);
        require(success, ""Token transfer failed"");
    }
}",2.030924797058105,redeemTokens,"[{'function': 'transfer', 'complexity': 0}, {'function': 'redeemTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeemTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6419805738480009,0.0333056132816407,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenRedemption is ReentrancyGuard, Ownable {
    IToken public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IToken(_tokenAddress);
    }

    function redeemTokens(uint256 amount, address recipient) external nonReentrant {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance"");
        bool success = token.transfer(recipient, amount);
        require(success, ""Token transfer failed"");
    }
}"
1315,Burns ` _amount ` tokens from ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenBurner is Ownable {
    IERC20 private token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function burnTokens(address _owner, uint256 _amount) public onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(_owner) >= _amount, ""Insufficient balance"");

        token.transferFrom(_owner, address(this), _amount);
        token.burn(_amount);
    }
}",1.680840015411377,burnTokens,"[{'function': 'burnTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.7794601159911589,0.2454220287871353,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBurner is Ownable {
    IERC20 private token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function burnTokens(address _owner, uint256 _amount) public onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(_owner) >= _amount, ""Insufficient balance"");

        token.transferFrom(_owner, address(this), _amount);
        token.burn(_amount);
    }
}"
4051,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract AuthorizedOperatorQuery is AccessControl {
    using SafeMath for uint256;

    IERC721 public nftContract;
    address private _owner;

    constructor(address nftAddress, address owner) {
        nftContract = IERC721(nftAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _owner = owner;
    }

    function isAuthorizedOperator(address account, address operator) public view returns (bool) {
        return nftContract.isApprovedForAll(account, operator);
    }
}",2.6345155239105225,sub,"[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'isAuthorizedOperator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sub"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: subtraction overflow""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",8.0,0.2985770583551934,0.0212432412991732,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract AuthorizedOperatorQuery is AccessControl {
    using SafeMath for uint256;

    IERC721 public nftContract;
    address private _owner;

    constructor(address nftAddress, address owner) {
        nftContract = IERC721(nftAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, owner);
        _owner = owner;
    }

    function isAuthorizedOperator(address account, address operator) public view returns (bool) {
        return nftContract.isApprovedForAll(account, operator);
    }
}"
5314,Modifies the list of overrides for non-accredited limits in USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OverrideLimits is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => bool) public nonAccreditedLimitOverrides;

    event LimitOverrideSet(address indexed account, bool isOverridden);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function setNonAccreditedLimitOverride(address account, bool overrideEnabled) public onlyRole(ADMIN_ROLE) {
        nonAccreditedLimitOverrides[account] = overrideEnabled;
        emit LimitOverrideSet(account, overrideEnabled);
    }
}",2.0193192958831787,setNonAccreditedLimitOverride,"[{'function': 'setNonAccreditedLimitOverride', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNonAccreditedLimitOverride"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""overrideEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonAccreditedLimitOverrides""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""Identifier"", ""name"": ""overrideEnabled""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LimitOverrideSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""overrideEnabled""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.6921763592693807,0.0161940849358322,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract OverrideLimits is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
    mapping(address => bool) public nonAccreditedLimitOverrides;

    event LimitOverrideSet(address indexed account, bool isOverridden);

    constructor() Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function setNonAccreditedLimitOverride(address account, bool overrideEnabled) public onlyRole(ADMIN_ROLE) {
        nonAccreditedLimitOverrides[account] = overrideEnabled;
        emit LimitOverrideSet(account, overrideEnabled);
    }
}"
2308,Return the boolean ( true/false ) registration status for an issuer firm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract IssuerRegistration is AccessControl {
    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) private registeredIssuers;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function registerIssuer(address issuer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!isRegistered(issuer), ""Issuer already registered"");
        _grantRole(ISSUER_ROLE, issuer);
        registeredIssuers[issuer] = true;
    }

    function isRegistered(address issuer) public view returns (bool) {
        return registeredIssuers[issuer];
    }
}",1.815354585647583,registerIssuer,"[{'function': 'registerIssuer', 'complexity': 2}, {'function': 'isRegistered', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerIssuer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuer""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Issuer already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ISSUER_ROLE""}, {""type"": ""Identifier"", ""name"": ""issuer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredIssuers""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.5433651738249445,0.0275125220868678,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuerRegistration is AccessControl, Ownable {
    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) private registeredIssuers;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function registerIssuer(address issuer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!isRegistered(issuer), ""Issuer already registered"");
        _grantRole(ISSUER_ROLE, issuer);
        registeredIssuers[issuer] = true;
    }

    function isRegistered(address issuer) public view returns (bool) {
        return registeredIssuers[issuer];
    }
}"
1642,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract TokenApproval {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function approveSpender(address _spender, uint256 _amount) external returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        return IERC20(msg.sender).approve(_spender, _amount);
    }
}",1.606621026992798,approveSpender,"[{'function': 'approve', 'complexity': 0}, {'function': 'approveSpender', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.8412843472553219,0.1065338296644879,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function approveSpender(address _spender, uint256 _amount) external returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        return IERC20(msg.sender).approve(_spender, _amount);
    }
}"
3698,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenRecovery {
    address public immutable controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function recoverTokens(address tokenAddress, uint256 amount) external {
        require(msg.sender == controller, ""Only the controller can call this function"");
        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient token balance"");
        bool success = token.transfer(controller, amount);
        require(success, ""Token transfer failed"");
    }
}",1.9863612651824951,recoverTokens,"[{'function': 'transfer', 'complexity': 0}, {'function': 'recoverTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, {""type"": ""stringLiteral"", ""value"": ""Only the controller can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.6218607391659288,0.226630724893932,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenRecovery is Ownable {
    address public immutable controller;

    mapping(address => uint256) public balanceOf;

 constructor(address _controller) Ownable() {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function recoverTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient token balance"");
        bool success = token.transfer(controller, amount);
        require(success, ""Token transfer failed"");
    }
}"
6060,Set current ICO prices in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}","pragma solidity ^0.8.0;

interface IMetaDollar {
    function setPriceInWei(uint256 _price) external;
}

contract ICO {
    address public owner;
    uint256 public priceInWei;
    bool public isActive = true;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setPriceInWei(uint256 _price) external onlyOwner {
        require(isActive, ""ICO is not active"");
        priceInWei = _price;
    }
}",1.566126585006714,setPriceInWei,"[{'function': 'setPriceInWei', 'complexity': 0}, {'function': 'setPriceInWei', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceInWei"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isActive""}, {""type"": ""stringLiteral"", ""value"": ""ICO is not active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.5937025009468999,0.0339162513055787,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ICO {
    address public owner;
    uint256 public priceInWei = 1;
    bool public isActive = true;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setPriceInWei(uint256 _price) external onlyOwner {
        require(isActive, ""ICO is not active"");
        priceInWei = _price;
    }
}"
6552,upper bound of series of snapshotIds for which there 's a value in series,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SnapshotSeries {
    using SafeMath for uint256;

    struct Snapshot {
        uint256 value;
        uint256 timestamp;
    }

    mapping(uint256 => Snapshot) public snapshots;
    uint256 private latestSnapshotId = 0;

    function addSnapshot(uint256 _value, uint256 _timestamp) internal {
        require(_timestamp > block.timestamp, ""Timestamp must be in the future"");
        latestSnapshotId++;
        snapshots[latestSnapshotId] = Snapshot({value: _value, timestamp: _timestamp});
    }

    function getUpperBound() public view returns (uint256) {
        return latestSnapshotId;
    }
}",1.8245158195495603,addSnapshot,"[{'function': 'addSnapshot', 'complexity': 1}, {'function': 'getUpperBound', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSnapshot"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""latestSnapshotId""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""snapshots""}, ""index"": {""type"": ""Identifier"", ""name"": ""latestSnapshotId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Snapshot""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_timestamp""}], ""names"": [""value"", ""timestamp""]}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.561732142975944,0.013136602547521,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SnapshotSeries is Ownable {
    using SafeMath for uint256;

    struct Snapshot {
        uint256 value;
        uint256 timestamp;
    }

    mapping(uint256 => Snapshot) public snapshots;
    uint256 private latestSnapshotId = 0;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        latestSnapshotId = 1;
        snapshots[latestSnapshotId] = Snapshot({value: 1, timestamp: block.timestamp});
    }

    function addSnapshot(uint256 _value, uint256 _timestamp) internal {
        require(_timestamp > block.timestamp, ""Timestamp must be in the future"");
        latestSnapshotId++;
        snapshots[latestSnapshotId] = Snapshot({value: _value, timestamp: _timestamp});
    }

    function getUpperBound() public view returns (uint256) {
        return latestSnapshotId;
    }
}"
2199,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MintableToken is IERC20, Ownable {
    string public name = ""Mintable Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor(uint256 initialSupply) {
        _totalSupply = initialSupply * 10 ** decimals;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address target, uint256 mintedAmount) external onlyOwner {
        _totalSupply += mintedAmount * 10 ** decimals;
        _balances[target] += mintedAmount * 10 ** decimals;
        emit Transfer(address(0), target, mintedAmount * 10 ** decimals);
    }
}",5.8371217250823975,transferFrom,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}, {'function': 'mint', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.4760203633320161,0.0114770808167612,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MintableToken is IERC20, Ownable {
    string public name = ""Mintable Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) Ownable(msg.sender) {
        _totalSupply = initialSupply * 10 ** decimals;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[msg.sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        require(_allowances[sender][msg.sender] >= amount, ""ERC20: transfer amount exceeds allowance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        _allowances[sender][msg.sender] -= amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function mint(address target, uint256 mintedAmount) external onlyOwner {
        _totalSupply += mintedAmount * 10 ** decimals;
        _balances[target] += mintedAmount * 10 ** decimals;
        emit Transfer(address(0), target, mintedAmount * 10 ** decimals);
    }
}"
1644,Trim the realitio question content to the part before the initial delimiter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RealitioQuestion is AccessControl {
    using SafeMath for uint256;

    bytes public questionContent;
    address payable public oracleAddress;
    mapping(address => bool) public voters;
    uint256 public totalVotes;

    constructor(bytes memory _questionContent, address payable _oracleAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        questionContent = _questionContent;
        oracleAddress = _oracleAddress;
    }

    function vote() external payable {
        require(!voters[msg.sender], ""Already voted"");
        require(msg.value > 0, ""Must send some ether to vote"");

        voters[msg.sender] = true;
        totalVotes = totalVotes.add(1);
    }
}",2.120363473892212,vote,"[{'function': 'vote', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Already voted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Must send some ether to vote""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVotes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalVotes""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",34.0,0.2149487505022922,0.0299543023493194,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract RealitioQuestion is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes public questionContent;
    address payable public oracleAddress;
    mapping(address => bool) public voters;
    uint256 public totalVotes;

    constructor(bytes memory _questionContent, address payable _oracleAddress) Ownable(msg.sender) { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        questionContent = _questionContent;
        oracleAddress = _oracleAddress;
    }

    function vote() external payable {
        require(!voters[msg.sender], ""Already voted"");
        require(msg.value > 0, ""Must send some ether to vote"");

        voters[msg.sender] = true;
        totalVotes = totalVotes.add(1);
    }
}"
2321,Function to send tokens or refund after the closing time of the funding proposals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FundingProposal {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public closingTime;
    mapping(address => bool) public hasClaimed;

    constructor(IERC20 _token, uint256 _closingTime) {
        token = _token;
        closingTime = _closingTime;
    }

    function claimTokens() external {
        require(block.timestamp >= closingTime, ""Funding proposals are still open."");
        require(!hasClaimed[msg.sender], ""You have already claimed your tokens."");

        uint256 balance = token.balanceOf(address(this));
        uint256 amount = balance.div(10); // Example: 10% of the total tokens are distributed

        require(amount > 0, ""No tokens available for claim."");

        token.transfer(msg.sender, amount);
        hasClaimed[msg.sender] = true;
    }
}",2.541757106781006,claimTokens,"[{'function': 'claimTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""closingTime""}}, {""type"": ""stringLiteral"", ""value"": ""Funding proposals are still open.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasClaimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""You have already claimed your tokens.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available for claim.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasClaimed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.4323991387859123,0.1179931101000819,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FundingProposal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public closingTime;
    mapping(address => bool) public hasClaimed;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, uint256 _closingTime) Ownable(msg.sender) {
        token = _token;
        closingTime = _closingTime;
    }

    function claimTokens() external {
        require(block.timestamp >= closingTime, ""Funding proposals are still open."");
        require(!hasClaimed[msg.sender], ""You have already claimed your tokens."");

        uint256 balance = token.balanceOf(address(this));
        uint256 amount = balance.div(10); // Example: 10% of the total tokens are distributed

        require(amount > 0, ""No tokens available for claim."");

        token.transfer(msg.sender, amount);
        hasClaimed[msg.sender] = true;
    }
}"
5497,Returns asset balance for a particular holder id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetBalance is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant HOLDER_ROLE = keccak256(""HOLDER_ROLE"");
    mapping(uint256 => uint256) private balances;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(HOLDER_ROLE, msg.sender);
    }

    function setBalance(uint256 holderId, uint256 amount) public {
        require(hasRole(HOLDER_ROLE, msg.sender), ""Caller is not a holder"");
        balances[holderId] = amount;
    }

    function getBalance(uint256 holderId) public view returns (uint256) {
        return balances[holderId];
    }
}",2.170625925064087,setBalance,"[{'function': 'setBalance', 'complexity': 1}, {'function': 'getBalance', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""HOLDER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a holder""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.6234195009278647,0.0185802213236069,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetBalance is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant HOLDER_ROLE = keccak256(""HOLDER_ROLE"");
    mapping(uint256 => uint256) private balances;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(HOLDER_ROLE, msg.sender);
        // Initialize state variables with safe non-zero values
        for (uint256 i = 1; i <= 3; i++) {
            balances[i] = 1;
        }
    }

    function setBalance(uint256 holderId, uint256 amount) public {
        require(hasRole(HOLDER_ROLE, msg.sender), ""Caller is not a holder"");
        balances[holderId] = amount;
    }

    function getBalance(uint256 holderId) public view returns (uint256) {
        return balances[holderId];
    }
}"
124,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenGrant is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    mapping(address => bool) public allowedTransferrers;

    event TransferrerGranted(address indexed transferrer);
    event TransferrerRevoked(address indexed transferrer);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function grantTransferrer(address _transferrer) public onlyOwner {
        allowedTransferrers[_transferrer] = true;
        emit TransferrerGranted(_transferrer);
    }

    function revokeTransferrer(address _transferrer) public onlyOwner {
        allowedTransferrers[_transferrer] = false;
        emit TransferrerRevoked(_transferrer);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(allowedTransferrers[msg.sender], ""Transfer not allowed"");
        return token.transferFrom(sender, recipient, amount);
    }

    function takeOwnership(uint256 amount) public {
        token.transfer(msg.sender, amount);
    }
}",3.0181233882904053,grantTransferrer,"[{'function': 'grantTransferrer', 'complexity': 0}, {'function': 'revokeTransferrer', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}, {'function': 'takeOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantTransferrer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_transferrer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowedTransferrers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_transferrer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferrerGranted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_transferrer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.4947129896357368,0.0365123585782038,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenGrant is Ownable {
    using SafeMath for uint256;
    IERC20 public token;

    mapping(address => bool) public allowedTransferrers;

    event TransferrerGranted(address indexed transferrer);
    event TransferrerRevoked(address indexed transferrer);

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        allowedTransferrers[_tokenAddress] = true; // Assuming the owner should be able to transfer tokens by default for simplicity
    }

    function grantTransferrer(address _transferrer) public onlyOwner {
        allowedTransferrers[_transferrer] = true;
        emit TransferrerGranted(_transferrer);
    }

    function revokeTransferrer(address _transferrer) public onlyOwner {
        allowedTransferrers[_transferrer] = false;
        emit TransferrerRevoked(_transferrer);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(allowedTransferrers[msg.sender], ""Transfer not allowed"");
        return token.transferFrom(sender, recipient, amount);
    }

    function takeOwnership(uint256 amount) public {
        token.transfer(msg.sender, amount);
    }
}"
467,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DestroyBeneficiary is Ownable {
    mapping(address => bool) public beneficiaries;

    function addBeneficiary(address _beneficiary) public onlyOwner {
        beneficiaries[_beneficiary] = true;
    }

    function removeBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        delete beneficiaries[_beneficiary];
    }

    function destroyBeneficiary(address payable _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        selfdestruct(_beneficiary);
    }
}",1.58406662940979,removeBeneficiary,"[{'function': 'addBeneficiary', 'complexity': 0}, {'function': 'removeBeneficiary', 'complexity': 1}, {'function': 'destroyBeneficiary', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.8156632398348138,0.0607856973194974,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DestroyBeneficiary is Ownable {
    mapping(address => bool) public beneficiaries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addBeneficiary(address _beneficiary) public onlyOwner {
        beneficiaries[_beneficiary] = true;
    }

    function removeBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        delete beneficiaries[_beneficiary];
    }

    function destroyBeneficiary(address payable _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        selfdestruct(_beneficiary);
    }
}"
3604,Adds a co-owner for an asset with provided symbol .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetManagement is Ownable {
    using SafeMath for uint256;

    struct Asset {
        string symbol;
        address[] coOwners;
    }

    mapping(string => Asset) public assets;

    function addCoOwner(string memory assetSymbol, address coOwner) public onlyOwner {
        require(assets[assetSymbol].coOwners.length < 5, ""Maximum number of co-owners reached""); // Assuming a maximum of 5 co-owners per asset
        Asset storage asset = assets[assetSymbol];
        for (uint256 i = 0; i < asset.coOwners.length; i++) {
            require(asset.coOwners[i] != coOwner, ""Co-owner already exists"");
        }
        asset.coOwners.push(coOwner);
    }
}",2.1616852283477783,addCoOwner,"[{'function': 'addCoOwner', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addCoOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""assetSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""coOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""assetSymbol""}}, ""memberName"": ""coOwners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Maximum number of co-owners reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Asset""}, ""name"": ""asset"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""assetSymbol""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""asset""}, ""memberName"": ""coOwners""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""asset""}, ""memberName"": ""coOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""coOwner""}}, {""type"": ""stringLiteral"", ""value"": ""Co-owner already exists""}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""asset""}, ""memberName"": ""coOwners""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""coOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.5605295885383338,0.0265898238185243,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetManagement is Ownable {
    using SafeMath for uint256;

    struct Asset {
        string symbol;
        address[] coOwners;
    }

    mapping(string => Asset) public assets;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address fixedAddress = address(uint160(i + 1));
            assets[bytes32('asset')] = Asset({symbol: 'A', coOwners: [fixedAddress]});
        }
    }

    function addCoOwner(string memory assetSymbol, address coOwner) public onlyOwner {
        require(assets[assetSymbol].coOwners.length < 5, ""Maximum number of co-owners reached""); // Assuming a maximum of 5 co-owners per asset
        Asset storage asset = assets[assetSymbol];
        for (uint256 i = 0; i < asset.coOwners.length; i++) {
            require(asset.coOwners[i] != coOwner, ""Co-owner already exists"");
        }
        asset.coOwners.push(coOwner);
    }
}"
5691,allows participants in the Atonomi network to claim their rewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RewardClaim is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CLAIMER_ROLE = keccak256(""CLAIMER_ROLE"");
    mapping(address => bool) public claimed;
    uint256 public totalRewards;

    event RewardClaimed(address indexed user, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CLAIMER_ROLE, msg.sender);
    }

    function claimRewards(uint256 amount) external {
        require(!claimed[msg.sender], ""Already claimed"");
        require(hasRole(CLAIMER_ROLE, msg.sender), ""Caller is not a claimee"");
        require(amount <= totalRewards, ""Insufficient rewards"");

        // Subtract the claimed amount from total rewards
        totalRewards = totalRewards.sub(amount);
        claimed[msg.sender] = true;

        // Transfer the reward to the user
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");

        emit RewardClaimed(msg.sender, amount);
    }

    function addRewards(uint256 amount) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        totalRewards = totalRewards.add(amount);
    }
}",3.48400354385376,claimRewards,"[{'function': 'claimRewards', 'complexity': 5}, {'function': 'addRewards', 'complexity': 1}]",5.0,{},51.0,0.4910542349763406,0.1488511666110359,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RewardClaim is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant CLAIMER_ROLE = keccak256(""CLAIMER_ROLE"");
    mapping(address => bool) public claimed;
    uint256 public totalRewards;

    event RewardClaimed(address indexed user, uint256 amount);

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CLAIMER_ROLE, msg.sender);
        totalRewards = 1; // Initialize to a safe non-zero value
    }

    function claimRewards(uint256 amount) external {
        require(!claimed[msg.sender], ""Already claimed"");
        require(hasRole(CLAIMER_ROLE, msg.sender), ""Caller is not a claimee"");
        require(amount <= totalRewards, ""Insufficient rewards"");

        // Subtract the claimed amount from total rewards
        totalRewards = totalRewards.sub(amount);
        claimed[msg.sender] = true;

        // Transfer the reward to the user
        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Transfer failed"");

        emit RewardClaimed(msg.sender, amount);
    }

    function addRewards(uint256 amount) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        totalRewards = totalRewards.add(amount);
    }
}"
2271,Deposit Ether where the contribution is credited to the address specified in the parameter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DepositContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public contributions;

    function depositEther(address payable recipient) public payable {
        require(msg.value > 0, ""Contribution must be greater than zero"");
        contributions[recipient] = contributions[recipient].add(msg.value);
        (bool success, ) = recipient.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }
}",1.5452966690063477,depositEther,"[{'function': 'depositEther', 'complexity': 2}]",3.0,{},41.0,0.6295788091674974,0.1106212078984218,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DepositContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public contributions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function depositEther(address payable recipient) public payable {
        require(msg.value > 0, ""Contribution must be greater than zero"");
        contributions[recipient] = contributions[recipient].add(msg.value);
        (bool success, ) = recipient.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }
}"
2948,The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Auction is AccessControl {
    using SafeMath for uint256;

    struct AuctionItem {
        address payable seller;
        uint256 startingPrice;
        uint256 highestBid;
        address highestBidder;
        bool ended;
        uint256 endTime;
        string tokenId;
    }

    mapping(string => AuctionItem) public auctionItems;
    bytes32 public constant AUCTION_MANAGER = keccak256(""AUCTION_MANAGER"");

    event AuctionCreated(string tokenId, uint256 startingPrice);
    event BidPlaced(string tokenId, address bidder, uint256 amount);
    event AuctionEnded(string tokenId, address winner, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function createAuction(
        string memory tokenId,
        uint256 startingPrice,
        uint256 duration
    ) public {
        require(auctionItems[tokenId].seller == address(0), ""Auction already exists"");
        auctionItems[tokenId] = AuctionItem({
            seller: payable(msg.sender),
            startingPrice: startingPrice,
            highestBid: 0,
            highestBidder: address(0),
            ended: false,
            endTime: block.timestamp + duration,
            tokenId: tokenId
        });
        emit AuctionCreated(tokenId, startingPrice);
    }

    function placeBid(string memory tokenId) public payable {
        AuctionItem storage auction = auctionItems[tokenId];
        require(!auction.ended, ""Auction already ended"");
        require(block.timestamp < auction.endTime, ""Auction expired"");
        uint256 bidAmount = msg.value;
        if (bidAmount <= auction.highestBid) {
            revert(""There already is a higher or equal bid"");
        }
        if (auction.highestBid != 0) {
            payable(auction.highestBidder).transfer(auction.highestBid);
        }
        auction.highestBid = bidAmount;
        auction.highestBidder = msg.sender;
        emit BidPlaced(tokenId, msg.sender, bidAmount);
    }

    function endAuction(string memory tokenId) public {
        AuctionItem storage auction = auctionItems[tokenId];
        require(!auction.ended, ""Auction already ended"");
        require(block.timestamp >= auction.endTime, ""Auction not yet expired"");
        auction.ended = true;
        if (auction.highestBid != 0) {
            payable(auction.seller).transfer(auction.highestBid);
            emit AuctionEnded(tokenId, auction.highestBidder, auction.highestBid);
        } else {
            // Return the highest bid to the bidder if no higher bids were placed
            payable(auction.highestBidder).transfer(auction.highestBid);
        }
    }
}",6.593413591384888,createAuction,"[{'function': 'createAuction', 'complexity': 0}, {'function': 'placeBid', 'complexity': 5}, {'function': 'endAuction', 'complexity': 4}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""placeBid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""tokenId"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AuctionItem""}, ""name"": ""auction"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""auctionItems""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""ended""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Auction already ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""endTime""}}, {""type"": ""stringLiteral"", ""value"": ""Auction expired""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""bidAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""bidAmount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBid""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""There already is a higher or equal bid""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBid""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBidder""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBid""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBid""}, ""right"": {""type"": ""Identifier"", ""name"": ""bidAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""auction""}, ""memberName"": ""highestBidder""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidPlaced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""bidAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",42.0,0.5328258175185371,0.0104709511715479,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    struct AuctionItem {
        address payable seller;
        uint256 startingPrice;
        uint256 highestBid;
        address highestBidder;
        bool ended;
        uint256 endTime;
        string tokenId;
    }

    mapping(string => AuctionItem) public auctionItems;
    bytes32 public constant AUCTION_MANAGER = keccak256(""AUCTION_MANAGER"");

    event AuctionCreated(string tokenId, uint256 startingPrice);
    event BidPlaced(string tokenId, address bidder, uint256 amount);
    event AuctionEnded(string tokenId, address winner, uint256 amount);

    constructor() Ownable() {
        // Initialization of state variables as per the rules provided
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function createAuction(
        string memory tokenId,
        uint256 startingPrice,
        uint256 duration
    ) public {
        require(auctionItems[tokenId].seller == address(0), ""Auction already exists"");
        auctionItems[tokenId] = AuctionItem({
            seller: payable(msg.sender),
            startingPrice: startingPrice,
            highestBid: 0,
            highestBidder: address(0),
            ended: false,
            endTime: block.timestamp + duration,
            tokenId: tokenId
        });
        emit AuctionCreated(tokenId, startingPrice);
    }

    function placeBid(string memory tokenId) public payable {
        AuctionItem storage auction = auctionItems[tokenId];
        require(!auction.ended, ""Auction already ended"");
        require(block.timestamp < auction.endTime, ""Auction expired"");
        uint256 bidAmount = msg.value;
        if (bidAmount <= auction.highestBid) {
            revert(""There already is a higher or equal bid"");
        }
        if (auction.highestBid != 0) {
            payable(auction.highestBidder).transfer(auction.highestBid);
        }
        auction.highestBid = bidAmount;
        auction.highestBidder = msg.sender;
        emit BidPlaced(tokenId, msg.sender, bidAmount);
    }

    function endAuction(string memory tokenId) public {
        AuctionItem storage auction = auctionItems[tokenId];
        require(!auction.ended, ""Auction already ended"");
        require(block.timestamp >= auction.endTime, ""Auction not yet expired"");
        auction.ended = true;
        if (auction.highestBid != 0) {
            payable(auction.seller).transfer(auction.highestBid);
            emit AuctionEnded(tokenId, auction.highestBidder, auction.highestBid);
        } else {
            // Return the highest bid to the bidder if no higher bids were placed
            payable(auction.highestBidder).transfer(auction.highestBid);
        }
    }
}"
4839,"Returns the loan metadata , hashed with keccak256 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanMetadata {
    using SafeMath for uint256;
    using Strings for string;

    struct Loan {
        address borrower;
        uint256 amount;
        uint256 interestRate;
        uint256 duration;
        bool isPaid;
    }

    mapping(uint256 => Loan) public loans;
    uint256 public loanCount;

    function getLoanMetadata(uint256 _loanId) public view returns (bytes32) {
        require(_loanId < loanCount, ""Loan does not exist"");
        Loan storage loan = loans[_loanId];
        return keccak256(abi.encodePacked(
            loan.borrower,
            loan.amount,
            loan.interestRate,
            loan.duration,
            loan.isPaid
        ));
    }
}",2.259138345718384,getLoanMetadata,"[{'function': 'getLoanMetadata', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoanMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_loanId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_loanId""}, ""right"": {""type"": ""Identifier"", ""name"": ""loanCount""}}, {""type"": ""stringLiteral"", ""value"": ""Loan does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""_loanId""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""borrower""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""interestRate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""duration""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""isPaid""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.7260236451719634,0.3298038418567384,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/utils/Strings.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract LoanMetadata is Ownable {
    using SafeMath for uint256;
    using Strings for string;

    struct Loan {
        address borrower;
        uint256 amount;
        uint256 interestRate;
        uint256 duration;
        bool isPaid;
    }

    mapping(uint256 => Loan) public loans;
    uint256 public loanCount;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        loanCount = 1; // Set to a fixed value (never 0)
        loans[1] = Loan(address(0x1111111111111111111111111111111111111111), 1, 1, 1, false);
        loans[2] = Loan(address(0x2222222222222222222222222222222222222222), 2, 2, 2, false);
        loans[3] = Loan(address(0x3333333333333333333333333333333333333333), 3, 3, 3, false);

        // Initialize ERC20 contract (assuming it's not present in the original code)
        string public tokenName = ""MyToken"";
        string public tokenSymbol = ""TKN"";

        // Initialize Ownable contract
        super(msg.sender);
    }

    function getLoanMetadata(uint256 _loanId) public view returns (bytes32) {
        require(_loanId < loanCount, ""Loan does not exist"");
        Loan storage loan = loans[_loanId];
        return keccak256(abi.encodePacked(
            loan.borrower,
            loan.amount,
            loan.interestRate,
            loan.duration,
            loan.isPaid
        ));
    }
}"
1398,Performs transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}","pragma solidity ^0.8.0;

interface IPlatform {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TransferCaller {
    address private immutable platformAddress;

    constructor(address _platformAddress) {
        require(_platformAddress != address(0), ""Invalid platform address"");
        platformAddress = _platformAddress;
    }

    function transferFromPlatform(address sender, uint256 amount) external returns (bool) {
        IPlatform(platformAddress).transfer(sender, amount);
        return true;
    }
}",1.2833821773529053,transferFromPlatform,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transferFromPlatform', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromPlatform"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IPlatform""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""platformAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.595950061764688,0.018461832632109,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IPlatform {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TransferCaller is Ownable {
    address private immutable platformAddress;

    constructor(address _platformAddress) Ownable() {
        require(_platformAddress != address(0), ""Invalid platform address"");
        platformAddress = _platformAddress;
    }

    function transferFromPlatform(address sender, uint256 amount) external returns (bool) {
        IPlatform(platformAddress).transfer(sender, amount);
        return true;
    }
}"
883,Buy from multiple sellers at once to fill a single large order .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Seller {
    function fulfillOrder(address buyer, uint256 amount) external returns (bool);
}

contract MultiSellerBuyer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BUYER_ROLE = keccak256(""BUYER_ROLE"");
    mapping(address => bool) public sellersFulfilled;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BUYER_ROLE, msg.sender);
    }

    function buyFromSellers(address[] memory sellerAddresses, uint256[] memory amounts) public payable {
        require(sellerAddresses.length == amounts.length, ""Length mismatch between seller addresses and amounts"");
        for (uint256 i = 0; i < sellerAddresses.length; i++) {
            Seller seller = Seller(sellerAddresses[i]);
            require(seller.fulfillOrder(msg.sender, amounts[i]), ""Seller failed to fulfill order"");
            sellersFulfilled[sellerAddresses[i]] = true;
        }
    }
}",2.759880781173706,buyFromSellers,"[{'function': 'fulfillOrder', 'complexity': 0}, {'function': 'buyFromSellers', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyFromSellers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""sellerAddresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellerAddresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length mismatch between seller addresses and amounts""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellerAddresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Seller""}, ""name"": ""seller"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Seller""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellerAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""seller""}, ""memberName"": ""fulfillOrder""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Seller failed to fulfill order""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellersFulfilled""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellerAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",41.0,0.6139452935591306,0.0731814832274457,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Seller {
    function fulfillOrder(address buyer, uint256 amount) external returns (bool);
}

contract MultiSellerBuyer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant BUYER_ROLE = keccak256(""BUYER_ROLE"");
    mapping(address => bool) public sellersFulfilled;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(BUYER_ROLE, msg.sender);
    }

    function buyFromSellers(address[] memory sellerAddresses, uint256[] memory amounts) public payable {
        require(sellerAddresses.length == amounts.length, ""Length mismatch between seller addresses and amounts"");
        for (uint256 i = 0; i < sellerAddresses.length; i++) {
            Seller seller = Seller(sellerAddresses[i]);
            require(seller.fulfillOrder(msg.sender, amounts[i]), ""Seller failed to fulfill order"");
            sellersFulfilled[sellerAddresses[i]] = true;
        }
    }
}"
2617,Set current mtdAmount price in wei for one token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenPriceSetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    uint256 private _currentMtdAmount;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function setCurrentMtdAmount(uint256 amount) public onlyRole(MINTER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        _currentMtdAmount = amount;
    }

    function getCurrentMtdAmount() public view returns (uint256) {
        return _currentMtdAmount;
    }
}",2.120840787887573,setCurrentMtdAmount,"[{'function': 'setCurrentMtdAmount', 'complexity': 1}, {'function': 'getCurrentMtdAmount', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentMtdAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_currentMtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.7958517126288013,0.2018274005857749,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenPriceSetter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    uint256 private _currentMtdAmount;

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        _setupRole(MINTER_ROLE, admin);
        transferOwnership(admin);
    }

    function setCurrentMtdAmount(uint256 amount) public onlyRole(MINTER_ROLE) {
        require(amount > 0, ""Amount must be greater than zero"");
        _currentMtdAmount = amount;
    }

    function getCurrentMtdAmount() public view returns (uint256) {
        return _currentMtdAmount;
    }
}"
191,"Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;
    uint256 public periodDuration;

    function setPeriodDuration(uint256 _periodDuration) external {
        require(_periodDuration > 0, ""Period duration must be greater than zero"");
        periodDuration = _transformTime(_periodDuration);
    }

    function _transformTime(uint256 _time) internal pure returns (uint256) {
        // Example transformation: double the time for demonstration purposes
        return _time.mul(2);
    }
}",1.4838314056396484,setPeriodDuration,"[{'function': 'setPeriodDuration', 'complexity': 1}, {'function': '_transformTime', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPeriodDuration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Period duration must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""periodDuration""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transformTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.8699043095108494,0.1797404915208156,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    uint256 public periodDuration;

    constructor() Ownable(msg.sender) {
        periodDuration = 1; // Set to 1 as per initialization rules
    }

    function setPeriodDuration(uint256 _periodDuration) external {
        require(_periodDuration > 0, ""Period duration must be greater than zero"");
        periodDuration = _transformTime(_periodDuration);
    }

    function _transformTime(uint256 _time) internal pure returns (uint256) {
        // Example transformation: double the time for demonstration purposes
        return _time.mul(2);
    }
}"
243,Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BidResetter is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant RESETTER_ROLE = keccak256(""RESETTER_ROLE"");
    bool public resetRequested;

    event ResetRequested(address indexed user);
    event ResetConfirmed();

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(RESETTER_ROLE, msg.sender);
    }

    function requestReset() external {
        require(!resetRequested, ""Reset already requested"");
        resetRequested = true;
        emit ResetRequested(msg.sender);
    }

    function confirmReset() external onlyRole(RESETTER_ROLE) {
        require(resetRequested, ""No reset request found"");
        // Additional logic to reset the bid decryption/appending process can be added here
        resetRequested = false;
        emit ResetConfirmed();
    }
}",2.372321844100952,confirmReset,"[{'function': 'requestReset', 'complexity': 2}, {'function': 'confirmReset', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""requestReset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""resetRequested""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Reset already requested""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""resetRequested""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ResetRequested""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",67.0,0.5279890525023999,0.0114609089592762,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BidResetter is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant RESETTER_ROLE = keccak256(""RESETTER_ROLE"");
    bool public resetRequested;

    event ResetRequested(address indexed user);
    event ResetConfirmed();

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(RESETTER_ROLE, msg.sender);
    }

    function requestReset() external {
        require(!resetRequested, ""Reset already requested"");
        resetRequested = true;
        emit ResetRequested(msg.sender);
    }

    function confirmReset() external onlyRole(RESETTER_ROLE) {
        require(resetRequested, ""No reset request found"");
        // Additional logic to reset the bid decryption/appending process can be added here
        resetRequested = false;
        emit ResetConfirmed();
    }
}"
6808,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor(address _token, uint256 _newBuyPrice, uint256 _newSellPrice) {
        token = IERC20(_token);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() public payable {
        require(msg.value == newBuyPrice, ""Incorrect amount of ETH sent"");
        uint256 tokensToSend = token.balanceOf(address(this)).sub(token.totalSupply());
        require(tokensToSend > 0, ""Not enough tokens to sell"");
        bool success = token.transfer(msg.sender, tokensToSend);
        require(success, ""Token transfer failed"");
    }

    function sellTokens(uint256 amount) public {
        uint256 ethToReceive = amount.mul(newSellPrice).div(1 ether);
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance of tokens to sell"");
        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Token transfer failed"");
        payable(msg.sender).transfer(ethToReceive);
    }
}",3.5619561672210693,buyTokens,"[{'function': 'buyTokens', 'complexity': 3}, {'function': 'sellTokens', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect amount of ETH sent""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToSend"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensToSend""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens to sell""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToSend""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",39.0,0.5038210426963965,0.0099993773696564,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(address _token, uint256 _newBuyPrice, uint256 _newSellPrice) Ownable(msg.sender) {
        token = IERC20(_token);
        newBuyPrice = _newBuyPrice;
        newSellPrice = _newSellPrice;
    }

    function buyTokens() public payable {
        require(msg.value == newBuyPrice, ""Incorrect amount of ETH sent"");
        uint256 tokensToSend = token.balanceOf(address(this)).sub(token.totalSupply());
        require(tokensToSend > 0, ""Not enough tokens to sell"");
        bool success = token.transfer(msg.sender, tokensToSend);
        require(success, ""Token transfer failed"");
    }

    function sellTokens(uint256 amount) public {
        uint256 ethToReceive = amount.mul(newSellPrice).div(1 ether);
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient balance of tokens to sell"");
        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Token transfer failed"");
        payable(msg.sender).transfer(ethToReceive);
    }
}"
4005,Buy quantity of tokens depending on the amount of sent ethers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}

contract TokenSale {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate = 1000; // 1 ETH = 1000 tokens
    address payable public owner;

    constructor(address _token) {
        token = IERC20(_token);
        owner = payable(msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint256 tokensToBuy = msg.value.mul(rate);
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens available for sale"");
        token.transfer(msg.sender, tokensToBuy);
    }
}",3.019926786422729,buyTokens,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'add', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'buyTokens', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens available for sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",47.0,0.7037472247668856,0.0461428790317023,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate = 1000; // 1 ETH = 1000 tokens
    address payable public owner;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
        owner = payable(msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint256 tokensToBuy = msg.value.mul(rate);
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens available for sale"");
        token.transfer(msg.sender, tokensToBuy);
    }
}"
5639,Transfers asset balance from the caller to specified receiver .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AssetTransfer is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant TRANSFER_ROLE = keccak256(""TRANSFER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRANSFER_ROLE, msg.sender);
    }

    function transferAsset(address receiver, uint256 amount) public {
        require(hasRole(TRANSFER_ROLE, msg.sender), ""Caller does not have TRANSFER_ROLE"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Transfer the asset balance from caller to receiver
        (bool success, ) = receiver.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}",2.140730857849121,transferAsset,"[{'function': 'transferAsset', 'complexity': 3}]",5.0,{},16.0,0.5916311841790843,0.0330963367028476,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";

contract AssetTransfer is Ownable, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant TRANSFER_ROLE = keccak256(""TRANSFER_ROLE"");

    constructor() Ownable() AccessControl() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(TRANSFER_ROLE, msg.sender);
    }

    function transferAsset(address receiver, uint256 amount) public {
        require(hasRole(TRANSFER_ROLE, msg.sender), ""Caller does not have TRANSFER_ROLE"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Transfer the asset balance from caller to receiver
        (bool success, ) = receiver.call{value: amount}("""");
        require(success, ""Transfer failed"");
    }
}"
971,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenApproval {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_value >= 0, ""Value must be greater than or equal to 0"");
        return token.approve(_spender, _value);
    }
}",1.5954723358154297,approveSpender,"[{'function': 'approveSpender', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than or equal to 0""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8536341144521454,0.2952925422521023,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApproval is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_value >= 0, ""Value must be greater than or equal to 0"");
        return token.approve(_spender, _value);
    }
}"
2396,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract TokenSale {
    IERC20 public token;
    address payable public owner;
    uint256 public pricePerToken;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress, uint256 _pricePerToken) {
        token = IERC20(_tokenAddress);
        pricePerToken = _pricePerToken;
        owner = payable(msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value >= pricePerToken, ""Insufficient funds sent"");
        uint256 amount = msg.value / pricePerToken;
        token.approve(address(this), amount * 1 ether); // Assuming the ERC20 contract uses a standard unit of 18 decimals
    }
}",2.213815689086914,buyTokens,"[{'function': 'approve', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""pricePerToken""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds sent""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""pricePerToken""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",97.0,0.6157924295491488,0.0054567342720699,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    IERC20 public token;
    address payable public owner;
    uint256 public pricePerToken;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress, uint256 _pricePerToken) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        pricePerToken = _pricePerToken;
        owner = payable(msg.sender);
    }

    function buyTokens() external payable {
        require(msg.value >= pricePerToken, ""Insufficient funds sent"");
        uint256 amount = msg.value / pricePerToken;
        token.approve(address(this), amount * 1 ether); // Assuming the ERC20 contract uses a standard unit of 18 decimals
    }
}"
2112,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenRecovery is Ownable {
    function recoverTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(owner(), amount), ""Token transfer failed"");
    }
}",1.1170556545257568,recoverTokens,"[{'function': 'recoverTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.6998431976766002,0.1072010329170778,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRecovery is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function recoverTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(owner(), amount), ""Token transfer failed"");
    }
}"
5098,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMyToken {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

contract TokenTransfer {
    using SafeMath for uint256;

    function sendTokens(address _token, address _from, address _to, uint256 _value) public returns (bool) {
        IERC20 token = IERC20(_token);
        require(token.allowance(_from, msg.sender) >= _value, ""Not approved to transfer tokens"");
        require(token.balanceOf(_from) >= _value, ""Insufficient balance"");
        return token.transferFrom(_from, _to, _value);
    }
}",1.9722144603729248,sendTokens,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Not approved to transfer tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",84.0,0.7344851172342085,0.1613975353159209,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IMyToken {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendTokens(address _token, address _from, address _to, uint256 _value) public returns (bool) {
        IERC20 token = IERC20(_token);
        require(token.allowance(_from, msg.sender) >= _value, ""Not approved to transfer tokens"");
        require(token.balanceOf(_from) >= _value, ""Insufficient balance"");
        return token.transferFrom(_from, _to, _value);
    }
}"
3297,Used by a staker to withdraw their initial stake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract StakingContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");
    mapping(address => uint256) public stakes;

    event StakeWithdrawn(address indexed user, uint256 amount);

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WITHDRAWER_ROLE, msg.sender);
    }

    function withdrawStake(uint256 amount) external {
        require(stakes[msg.sender] >= amount, ""Insufficient stake"");
        stakes[msg.sender] = stakes[msg.sender].sub(amount);
        payable(msg.sender).transfer(amount);
        emit StakeWithdrawn(msg.sender, amount);
    }
}",2.254873275756836,withdrawStake,"[{'function': 'withdrawStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient stake""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""StakeWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.7109468687216716,0.0348747823820285,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract StakingContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant WITHDRAWER_ROLE = keccak256(""WITHDRAWER_ROLE"");
    mapping(address => uint256) public stakes;

    event StakeWithdrawn(address indexed user, uint256 amount);

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(WITHDRAWER_ROLE, msg.sender);
        // Initialize state variables with safe, non-corner-case values
        stakes[msg.sender] = 1; // Set initial stake to 1 (never 0)
    }

    function withdrawStake(uint256 amount) external {
        require(stakes[msg.sender] >= amount, ""Insufficient stake"");
        stakes[msg.sender] = stakes[msg.sender].sub(amount);
        payable(msg.sender).transfer(amount);
        emit StakeWithdrawn(msg.sender, amount);
    }
}"
1877,A function which allows the caller to approve the max amount of any given token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/SafeMath.sol"";

contract TokenApprover {
    using SafeMath for uint256;

    function approveMax(address tokenAddress) public returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 maxAllowance = type(uint256).max;
        return token.approve(msg.sender, maxAllowance);
    }
}",1.3157055377960205,approveMax,"[{'function': 'approveMax', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveMax"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maxAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""maxAllowance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.7134920580378589,0.0698394521696201,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApprover is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveMax(address tokenAddress) public returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 maxAllowance = type(uint256).max;
        return token.approve(msg.sender, maxAllowance);
    }
}"
