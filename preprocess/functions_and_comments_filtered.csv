ID,Function,Comment
1,"function sendEther ( address to , uint value ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( address ( 0 ) != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }",Send ` value ` of ether to address ` to `
2,function isReadyToMate ( uint256 _ponyId ) public view returns ( bool ) { require ( _ponyId > 0 ) ; Pony storage pon = ponies [ _ponyId ] ; return _isReadyToMate ( pon ) ; },Checks that a given pony is able to breed ( i.e .
3,"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }",Returns the amount which _spender is still allowed to withdraw from _owner
4,function isValidator ( ) external view returns ( bool ) { uint256 totalValidators = _jurisdiction . countValidators ( ) ; for ( uint256 i = 0 ; i < totalValidators ; i ++ ) { address validator = _jurisdiction . getValidator ( i ) ; if ( validator == address ( this ) ) { return true ; } } return false ; },Check if contract is assigned as a validator on the jurisdiction .
5,"function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( msg . value == 0 , ""Basic jurisdictions do not support payments when assigning attributes"" ) ; require ( canValidate ( msg . sender , attributeTypeID ) , ""only approved validators may assign attributes of this type"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . validator == address ( 0 ) , ""duplicate attributes are not supported, remove existing attribute first"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , validator : msg . sender , value : value } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; }",Issue an attribute of the type with ID ` attributeTypeID ` and a value of ` value ` to ` account ` if ` message.caller.address ( ) ` is approved validator .
7,"function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . token , msg . sender , balance , block . number ) ; } return success ; }",Caller makes a deposit into their channel balance .
8,"function lockAndDistributeTokens ( address _tokenHolder , uint256 _amount , uint256 _percentageToLock , uint256 _unlockTime ) public onlyOwner { requireMultiple ( _amount ) ; require ( _percentageToLock <= 100 && _percentageToLock > 0 , ""You can only lock a percentage between 0 and 100."" ) ; require ( mLockedBalances [ _tokenHolder ] . amount == 0 , ""You can only lock one amount of tokens for a given address. It is currently indicating that there are already locked tokens for this address."" ) ; uint256 amountToLock = _amount . mul ( _percentageToLock ) . div ( 100 ) ; mBalances [ msg . sender ] = mBalances [ msg . sender ] . sub ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; mLockedBalances [ _tokenHolder ] = lockedTokens ( { amount : amountToLock , timeLockedUntil : _unlockTime } ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , """" , true ) ; emit LockedTokens ( _tokenHolder , amountToLock , _unlockTime ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }",locks a percentage of tokens for a specified time period and then grants ownership to the specified owner
10,"function revoke ( ERC20 token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
13,"function approve ( address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; address owner = _ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( msg . sender == owner || _isApprovedForAll ( owner , msg . sender ) ) ; _tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }",Change or reaffirm the approved address for an NFT
15,function isDeregistered ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt <= currentEpoch . blocknumber ; },Returns if a darknode is in the deregistered state .
18,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
22,"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",send ` _value ` token to ` _to `
23,"function updateGiver ( uint64 idGiver , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage giver = findAdmin ( idGiver ) ; require ( giver . adminType == PledgeAdminType . Giver ) ; require ( giver . addr == msg . sender ) ; giver . addr = newAddr ; giver . name = newName ; giver . url = newUrl ; giver . commitTime = newCommitTime ; GiverUpdated ( idGiver ) ; }","Updates a Giver 's info to change the address , name , url , or commitTime , it can not be used to change a plugin , and it must be called by the current address of the Giver"
25,"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; require ( token . transfer ( msg . sender , reward ) ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; }",claim the tokens owed for the msg.sender in the provided challenge
26,function claimProfitEquivalent ( ) public { uint256 toPay ; for ( uint k = 0 ; k <= yearsPast . length - 1 ; k ++ ) { toPay += snapShot [ yearsPast [ k ] ] [ msg . sender ] ; snapShot [ yearsPast [ k ] ] [ msg . sender ] = 0 ; } msg . sender . transfer ( toPay ) ; peLastPeriod -= toPay ; },Allow user to claim his PE on his Ethereum Address .
28,function getTime ( ) internal view returns ( uint256 ) { return now ; },This function is overrided by the test Mocks .
29,"function QToken ( address target , uint256 qAmount ) onlyOwner public { balanceOf [ target ] += qAmount ; totalSupply += qAmount ; emit Transfer ( 0 , this , qAmount ) ; emit Transfer ( this , target , qAmount ) ; }",Create ` qAmount ` tokens and send it to ` target `
30,function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; },Called in order to get the number of members on the platform
31,"function unlockMiner ( ) public locked onlyOwner { require ( block . timestamp >= minerRelaseTime ) ; require ( minerLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= minerLockedAmount ) ; token . transfer ( minerLockAddress , minerLockedAmount ) ; minerLockedAmount = 0 ; }",Transfers tokens held by timelock to miner .
32,function setCurrentPrice ( uint256 newPrice ) public onlyOwner { currentPrice = newPrice ; },Allows the owner of this contract to set the currentPrice for each token
33,"function finalize ( bool _forceRefund ) onlyOwner public returns ( bool ) { if ( isFinalized ) { error ( 'finalize: ICO is already finalized.' ) ; return false ; } if ( weisRaised >= weisSoftCap && ! _forceRefund ) { if ( ! SCRefundVault . close ( ) ) { error ( 'finalize: SCRefundVault.close() failed' ) ; return false ; } } else { if ( ! SCRefundVault . enableRefunds ( ) ) { error ( 'finalize: SCRefundVault.enableRefunds() failed' ) ; return false ; } if ( _forceRefund ) { emit ForceRefund ( ) ; } } uint256 balanceAmount = SCTokens . balanceOf ( this ) ; if ( ! SCTokens . transfer ( address ( SCEscrow ) , balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } if ( ! SCEscrow . deposit ( balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } isFinalized = true ; emit Finalized ( ) ; return true ; }","Must be called by owner before or after ICO ends , to check whether soft cap is reached and transfer collected funds"
34,"function registerDeed ( string propertyAddress , string document ) public { require ( __isSenderInRole ( ROLE_DEED_REGISTRANT ) ) ; uint256 documentHash = uint256 ( keccak256 ( document ) ) ; require ( documentRegistry [ documentHash ] == 0 ) ; require ( document . contains ( propertyAddress ) ) ; documentRegistry [ documentHash ] = now ; uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; if ( addressRegistry [ propertyAddressHash ] . length == 0 ) { knownPropertyAddresses . push ( propertyAddress ) ; } addressRegistry [ propertyAddressHash ] . push ( document ) ; emit DeedRegistered ( propertyAddress , document ) ; }","A ` document ` may not necessarily represent a document itself , it can also be its metadata or just a hash"
35,function calculateCurrentBlock ( uint256 _stakeNumber ) internal view returns ( uint256 currentBlock ) { currentBlock = block . number ; if ( currentBlock >= stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ) { currentBlock = stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ; } },This is a helper function used to calculate how many blocks to mint coins for
36,function SetContractorManager ( address _contractorManager ) ;,Function used by the creator to set the contractor manager smart contract
37,"function isSigned ( address _address , bytes32 messageHash , uint8 v , bytes32 r , bytes32 s ) public pure returns ( bool ) { return _isSigned ( _address , messageHash , v , r , s ) || _isSignedPrefixed ( _address , messageHash , v , r , s ) ; }",Determines whether the passed signature of ` messageHash ` was made by the private key of ` _address ` .
38,"function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || dllMap [ msg . sender ] . contains ( _prevPollID ) ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , ""numTokens"" , _numTokens ) ; store . setAttribute ( UUID , ""commitHash"" , uint ( _secretHash ) ) ; pollMap [ _pollID ] . didCommit [ msg . sender ] = true ; _VoteCommitted ( _pollID , _numTokens , msg . sender ) ; }",Commits vote using hash of choice and secret salt to conceal vote until reveal
39,"function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , _excluded , _name ) ; }","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses"
40,function totalSupply ( ) public view returns ( uint ) { return rabbits . length - 1 ; },Returns the total number of rabbits currently in existence .
41,"function staticChecks ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) public view whenNotPaused { bool previousBuyOccured = false ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; if ( thisTrade . isSell ) { if ( previousBuyOccured ) { errorReporter . revertTx ( ""A buy has occured before this sell"" ) ; } if ( ! Utils . tokenAllowanceAndBalanceSet ( msg . sender , thisTrade . tokenAddress , thisTrade . tokenAmount , tokenTransferProxy ) ) { if ( ! thisTrade . optionalTrade ) { errorReporter . revertTx ( ""Taker has not sent allowance/balance on a non-optional trade"" ) ; } tradeFlags [ i ] . ignoreTrade = true ; continue ; } } else { previousBuyOccured = true ; } for ( uint256 j ; j < thisTrade . orders . length ; j ++ ) { Order memory thisOrder = thisTrade . orders [ j ] ; if ( ! handlerWhitelistMap [ thisOrder . exchangeHandler ] ) { tradeFlags [ i ] . ignoreOrder [ j ] = true ; continue ; } } } }",Performs static checks on the rebalance payload before execution
43,"function onTransfer ( address _from , address _to , uint _amount ) public initialized returns ( bool ) { return false ; }",Notifies the controller about a token transfer allowing the controller to react if desired
44,"function transferToAddress ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToAddress ( to , value , data ) ; }",Override the functions to not allow token transfers until the end of the ICO
45,function setOracleURL ( string _oracleURL ) onlyOwner public { oracleURL = _oracleURL ; },Allows owner to set URL used in Oraclize queries
47,"function removeAttribute ( uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , ""only jurisdiction or issuing validator may remove a restricted attribute"" ) ; require ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . setPersonally ) { refundAddress = msg . sender ; } else { address operator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ msg . sender ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , msg . sender , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( refundAddress . send ( stake ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake ) ; } } }",Remove an attribute of the type with ID ` attributeTypeID ` from account of ` msg.sender ` .
52,"function claimTokens ( token _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }",Function to claim any token stuck on contract
53,function getCurrencySymbol ( ) external view returns ( bytes32 ) { return currencySymbol ; },Returns symbol of oracle currency ( 0x0 for ETH )
57,"function batchReclaimExpiredSwaps ( bytes32 msigId , bytes32 [ ] swapIds ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) reclaimExpiredSwaps ( msigId , swapIds [ i ] ) ; }","Reclaim all the expired , non-empty swaps into a multisig"
61,function setupEventsHistory ( address _eventsHistory ) external auth returns ( uint ) { require ( _eventsHistory != 0x0 ) ; _setEventsHistory ( _eventsHistory ) ; return OK ; },Sets up events history address Allowed only for authorized roles .
63,"function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }",Issue nomins against the sender 's havvens .
66,function _forwardFunds ( ) internal { },Stops the crowdsale contract from sending ethers .
67,"function setAllowedTransferTo ( address to , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferToPrivate ( to , allowed ) ; }",enables or disables address to be receipient of EUR-T
69,function motionVoting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] < now && now < motionStartTime [ motionID ] + votingPeriod ; },"There is a motion in progress on the specified account , and votes are being accepted in that motion ."
71,"function tokenURI ( uint256 _tokenId ) external view returns ( string ret ) { string memory tokenIdAsString = uintToString ( uint ( _tokenId ) ) ; ret = string ( abi . encodePacked ( _tokenURI , tokenIdAsString , ""/"" ) ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
72,"function purchase ( uint256 _nftId ) external payable mustBeValidToken ( _nftId ) mustBeOwnedByThisContract ( _nftId ) { require ( msg . value == SALE_PRICE ) ; _transfer ( _nftId , msg . sender ) ; }","The price is always 0.5 ether , and you can buy any available square Be sure you are calling this from a regular account ( not a smart contract ) or if you are calling from a smart contract , make sure it can use ERC-721 non-fungible tokens"
73,"function send ( address _to , uint256 _amount , bytes _data ) public { doSend ( msg . sender , msg . sender , _to , _amount , _data , """" , true ) ; }",Send ` _amount ` of tokens to address ` _to ` passing ` _data ` to the recipient
75,"function batchTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; transferFrom ( _from , _to , _id ) ; } }",Batch TransferFrom with the same to & from address
79,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; memeIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
80,function balanceOf ( address _owner ) constant returns ( uint256 balance ) ;,Get the account balance of another account with address _owner
81,function pickUniquePacks ( uint [ ] assetIds ) public view returns ( uint [ ] ) { require ( assetIds . length > 0 ) ; uint [ ] memory packs = new uint [ ] ( assetIds . length ) ; uint packsCount = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { Asset memory asset = assets [ assetIds [ i ] ] ; bool exists = false ; for ( uint j = 0 ; j < packsCount ; j ++ ) { if ( asset . packId == packs [ j ] ) { exists = true ; } } if ( ! exists ) { packs [ packsCount ] = asset . packId ; packsCount ++ ; } } uint [ ] memory finalPacks = new uint [ ] ( packsCount ) ; for ( i = 0 ; i < packsCount ; i ++ ) { finalPacks [ i ] = packs [ i ] ; } return finalPacks ; },method that gets all unique packs from array of assets
83,"function init ( ChronoBankPlatform _chronoBankPlatform , string _symbol , string _name ) public returns ( bool ) { if ( address ( chronoBankPlatform ) != 0x0 ) { return false ; } chronoBankPlatform = _chronoBankPlatform ; symbol = _symbol ; smbl = stringToBytes32 ( _symbol ) ; name = _name ; return true ; }","Sets platform address , assigns symbol and name ."
84,"function finalize ( ) public onlyController { assert ( token . totalSupply ( ) >= distributionCap ( ) ) ; doMint ( reserveWallet , totalReserve ) ; finalizedBlock = getBlockNumber ( ) ; token . finalize ( ) ; token . changeController ( controller ) ; Finalized ( ) ; }",This method can be called the distribution cap is reached only
85,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { testmonedarecipiente spender = testmonedarecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
86,function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner external { maxSecurityGuardDelay = _maxSecurityGuardDelay ; },` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment
87,"function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }",Allows someone buy obtain an GoldenGoose asset token
88,function setTransfersEnabled ( bool enable ) onlyOwner public { transfersEnabled = enable ; },Use for disable transfers before exchange to main BOB tokens
89,"function getInfo ( string _zitetag ) external view returns ( string ) { bytes32 hash = keccak256 ( abi . encodePacked ( 'zitetag.' , _zitetag ) ) ; string memory info = zer0netDb . getString ( hash ) ; return ( info ) ; }",Retrieves the registration info for the given zitetag .
90,"function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner returns ( bool ) { require ( registry [ _moduleFactory ] != 0 , ""Module factory should have been already registered"" ) ; verified [ _moduleFactory ] = _verified ; emit LogModuleVerified ( _moduleFactory , _verified ) ; return true ; }",( The only exception to this is that the author of the module is the owner of the ST )
91,"function updateContract ( string _contractName , address _newAddress ) external ;",Update an existing contract ( changing the address )
93,function roundMoneyUpToWholeFinney ( uint _valueWei ) constant internal returns ( uint valueFinney ) { return ( 1 finney + _valueWei - 1 wei ) / 1 finney ; },Convert ` _valueWei ` into a whole number of finney .
94,"function approveSynthesizing ( address _address , uint256 _yangId ) external whenNotPaused { require ( _owns ( msg . sender , _yangId ) ) ; synthesizeAllowedToAddress [ _yangId ] = _address ; }",Grants approval to another user to synthesize with one of your Kydys .
95,"function moveTokens ( address _to , bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveTokensToAddress ( _uuid , _to , _tokensCount ) ; }",Function for transfering tokens from account to specified address .
96,function setLiquidPledging ( address _newLiquidPledging ) public onlyOwner { require ( address ( liquidPledging ) == 0x0 ) ; liquidPledging = LiquidPledging ( _newLiquidPledging ) ; },"` onlyOwner ` used to attach a specific liquidPledging instance to this LPvault ; keep in mind that once a liquidPledging contract is attached it can not be undone , this vault will be forever connected"
97,function unpause ( ) public onlyManager { paused = false ; },This is public rather than external so it can be called by derived contracts .
98,function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { },"Returns the questions 's content hash , identifying the question content"
99,"function unlock ( ) external onlyOwner vaultLocked { require ( unlockedAt == 0 , ""Must not be unlocked yet"" ) ; require ( block . timestamp >= lockedAt . add ( vestingPeriod ) , ""Lock up must be over"" ) ; unlockedAt = block . timestamp ; emit Unlocked ( ) ; }","Unlock the vault , allowing the tokens to be distributed to their beneficiaries ."
100,"function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( address [ ] ) ;",Returns the list of available Module factory addresses of a particular type for a given token .
101,function getMinerBlock ( ) public constant returns ( uint256 ) { return getBlockOf ( msg . sender ) ; },Return the block in which the miner is
102,"function claimTokensByMerkleProof ( bytes32 [ ] _proof , bytes32 _operationId , uint _position , uint _amount ) external whenNotPaused returns ( uint ) { bytes32 leaf = _calculateMerkleLeaf ( _operationId , _position , msg . sender , _amount ) ; require ( completedAirdrops [ _operationId ] == false , ""AIRDROP_ALREADY_CLAIMED"" ) ; require ( checkMerkleProof ( merkleRoot , _proof , _position , leaf ) , ""AIRDROP_INVALID_PROOF"" ) ; require ( token . transfer ( msg . sender , _amount ) , ""AIRDROP_TRANSFER_FAILURE"" ) ; completedAirdrops [ _operationId ] = true ; emit LogAirdropClaimed ( msg . sender , _operationId , _amount ) ; return OK ; }",Claim tokens held by airdrop contract based on proof provided by sender ` msg.sender ` based on position ` _position ` in airdrop list .
103,"function transferExternalToken ( address _kAddr , address _to , uint _amount ) public returns ( bool ) ;",Salvage ` _amount ` tokens at ` _kaddr ` and send them to ` _to `
104,"function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) { uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; airdrop . uniqueAirdrop [ msg . sender ] = _smartContract ; idCounter = airdrop . id + 1 ; } else revert ( 'Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop' ) ; }",Adds a new airdrop to the smart contract and starts the count down until it is distributed
107,"function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner ;",Allows the owner to register and the details for a token .
110,"function initialize ( address _snt , address _sntController , uint256 _startBlock , uint256 _endBlock , address _dynamicCeiling , address _destEthDevs , address _destTokensReserve , address _destTokensSgt , address _destTokensDevs , address _sgt , uint256 _maxSGTSupply ) public onlyOwner { require ( address ( SNT ) == 0x0 ) ; SNT = MiniMeToken ( _snt ) ; require ( SNT . totalSupply ( ) == 0 ) ; require ( SNT . controller ( ) == address ( this ) ) ; require ( SNT . decimals ( ) == 18 ) ; require ( _sntController != 0x0 ) ; sntController = _sntController ; require ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _dynamicCeiling != 0x0 ) ; dynamicCeiling = DynamicCeiling ( _dynamicCeiling ) ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensSgt != 0x0 ) ; destTokensSgt = _destTokensSgt ; require ( _destTokensDevs != 0x0 ) ; destTokensDevs = _destTokensDevs ; require ( _sgt != 0x0 ) ; SGT = MiniMeToken ( _sgt ) ; require ( _maxSGTSupply >= MiniMeToken ( SGT ) . totalSupply ( ) ) ; maxSGTSupply = _maxSGTSupply ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters
111,"function mint ( address _to , uint _amount ) public onlyForeignBridge returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _to ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _to ] , previousBalanceTo + _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( 0x0 , _to , _amount ) ; return true ; }",Mints ` _amount ` tokens that are assigned to ` _owner `
112,function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; UpgradedController ( _newControllerAddress ) ; },` onlyOwner ` can upgrade the controller contract
113,"function initialize ( address _token , address _destTokensReserve , address _destTokensTeam , address _destTokensBounties , address _destTokensAirdrop , address _destTokensAdvisors , address _destTokensEarlyInvestors ) public onlyOwner { require ( address ( token ) == 0x0 ) ; token = MiniMeToken ( _token ) ; require ( token . totalSupply ( ) == 0 ) ; require ( token . controller ( ) == address ( this ) ) ; require ( token . decimals ( ) == 8 ) ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensBounties != 0x0 ) ; destTokensBounties = _destTokensBounties ; require ( _destTokensAirdrop != 0x0 ) ; destTokensAirdrop = _destTokensAirdrop ; require ( _destTokensAdvisors != 0x0 ) ; destTokensAdvisors = _destTokensAdvisors ; require ( _destTokensEarlyInvestors != 0x0 ) ; destTokensEarlyInvestors = _destTokensEarlyInvestors ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters
114,"function initiateCreateSale ( uint256 _tokenId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration ) external { require ( _tokenId != 0 ) ; address owner = ownerOf ( _tokenId ) ; require ( owner == msg . sender ) ; require ( _startingPrice == _startingPrice ) ; require ( _endingPrice == _endingPrice ) ; require ( _duration == _duration ) ; require ( checkIsAttached ( _tokenId ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenId ) ; saleManagerAddress . createSale ( _tokenId , _startingPrice , _endingPrice , _duration , msg . sender ) ; }",Helps a wallet to create a sale using our Sale Contract
115,function checkMonthlyLimit ( address _owner ) external constant returns ( uint256 remaining ) { return monthlyLimit [ _owner ] ; },Check how much Casino withdrawal balance remains for address
116,"function addValidator ( address validator , string description ) external ;",Add account ` validator ` as a validator with a description ` description ` who can be approved to set attributes of specific types .
117,function ( ) public payable { },Any funds sent here are for dividend payment .
122,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = DISTRIBUTE ; return allPermissions ; },Return the permissions flag that are associated with STO
123,"function updateERC165Cache ( address _contract , bytes4 _interfaceId ) external { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }",Updates the cache with whether the contract implements an ERC165 interface or not .
124,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; allStarIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
127,"function removeOfficialOperator ( address _operator ) external onlyOwner { require ( mIsOfficialOperator [ _operator ] , ""_operator is not an official operator."" ) ; mIsOfficialOperator [ _operator ] = false ; emit OfficialOperatorRemoved ( _operator ) ; }",Delete an address from the list of official operators .
128,"function disapproveAll ( address _to ) public { require ( _to != msg . sender , ""cant unapprove yourself"" ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; emit ApprovalForAll ( msg . sender , _to , false ) ; }",Removes approval for another address to claim for the ownership of any tokens owned by this account .
129,function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { return questions [ question_id ] . best_answer ; },"Return the final answer to the specified question , or revert if there is n't one"
130,"function getMinerHashRate ( uint256 _halving ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , _halving ) ; }",Calculate the halving hash rate of a miner
131,"function transferAndCall ( address _to , uint _amount , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _amount ) ) ; emit Transfer ( msg . sender , _to , _amount , _data ) ; if ( isContract ( _to ) ) { ERC677Receiver ( _to ) . tokenFallback ( msg . sender , _amount , _data ) ; } return true ; }",` msg.sender ` transfers ` _amount ` to ` _to ` contract and then tokenFallback ( ) function is triggered in the ` _to ` contract .
132,"function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , ""Error: Account is not verified!"" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; return true ; }",Issues a specified account to recipient account of a given currency
133,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` on behalf of ` _from `
135,function proxyPayment ( address _owner ) payable public returns ( bool ) { return false ; },Called when ` _owner ` sends ether to the MiniMe Token contract
138,"function transferFrom ( bytes32 _from , bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; var avail = allowances [ _from ] [ sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ sender ] ; if ( avail >= _value ) { allowances [ _from ] [ sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; TransferHash ( _from , _to , _value ) ; return true ; } return false ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `
139,"function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached && now >= finalDeadline ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached && treasury == msg . sender ) { if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }",Lets treasury collect the funds if ` fundingGoal ` was reached .
141,function setTotalSupply ( uint256 _newTotalSupply ) public onlyImpl { totalSupply = _newTotalSupply ; },The function to set the total supply of tokens .
145,"function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; NewOwner ( msg . sender , _newOwner ) ; }",` owner ` can step down and assign some other address to this role
146,"function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external ;",Add to the amount this member has bought
148,"function distributeEther ( address [ ] sellers ) onlyOwner payable public { require ( currentState == State . Distribution ) ; require ( currentPeriodRate > 0 ) ; for ( uint256 i = 0 ; i < sellers . length ; i ++ ) { address seller = sellers [ i ] ; require ( seller != address ( 0 ) ) ; uint256 tokenAmount = soldTokens [ seller ] ; if ( tokenAmount == 0 ) continue ; uint256 etherAmount = tokenAmount . div ( currentPeriodRate ) ; uint256 fee = etherAmount . mul ( sellFeeMilliPercent ) . div ( MILLI_PERCENT_DIVIDER ) ; etherAmount = etherAmount . sub ( fee ) ; soldTokens [ seller ] = 0 ; currentPeriodTokenCollected = currentPeriodTokenCollected . sub ( tokenAmount ) ; if ( ! seller . send ( etherAmount ) ) { DistributionError ( seller , etherAmount ) ; owner . transfer ( etherAmount ) ; } } }",Distribute ether to sellers If not enough ether is available on contract ballance
149,"function setStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeContractAddress != address ( 0 ) ) { require ( stake . activeStakes ( ) == 0 , ""staking contract already configured, to change it must have 0 active stakes"" ) ; } stakeContractAddress = _contractAddress ; minters [ _contractAddress ] = true ; stake = StakeInterface ( _contractAddress ) ; emit StakeContractSet ( _contractAddress ) ; return true ; }",This is used to set the staking contract
153,function isProjectCanceled ( uint64 projectId ) constant returns ( bool ) { PledgeAdmin storage m = findAdmin ( projectId ) ; if ( m . adminType == PledgeAdminType . Giver ) return false ; assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . canceled ) return true ; if ( m . parentProject == 0 ) return false ; return isProjectCanceled ( m . parentProject ) ; },A getter to find if a specified Project has been canceled
154,"function finalize ( ) public onlyOwner { require ( ! isFinalized , ""STO is already finalized"" ) ; isFinalized = true ; uint256 tempReturned ; uint256 tempSold ; uint256 remainingTokens ; for ( uint8 i = 0 ; i < tokensPerTierTotal . length ; i ++ ) { remainingTokens = tokensPerTierTotal [ i ] . sub ( mintedPerTierTotal [ i ] ) ; tempReturned = tempReturned . add ( remainingTokens ) ; tempSold = tempSold . add ( mintedPerTierTotal [ i ] ) ; if ( remainingTokens > 0 ) { mintedPerTierTotal [ i ] = tokensPerTierTotal [ i ] ; } } require ( ISecurityToken ( securityToken ) . mint ( reserveWallet , tempReturned ) , ""Error in minting"" ) ; emit ReserveTokenMint ( msg . sender , reserveWallet , tempReturned , currentTier ) ; finalAmountReturned = tempReturned ; totalTokensSold = tempSold ; }",Reserve address must be whitelisted to successfully finalize
156,"function convertCountryIndexToBytes ( uint [ ] countries ) public pure returns ( uint countries1 , uint countries2 , uint countries3 ) { countries1 = 0 ; countries2 = 0 ; countries3 = 0 ; for ( uint i = 0 ; i < countries . length ; i ++ ) { uint index = countries [ i ] ; if ( index < 256 ) { countries1 = countries1 | uint ( 1 ) << index ; } else if ( index < 512 ) { countries2 = countries2 | uint ( 1 ) << ( index - 256 ) ; } else { countries3 = countries3 | uint ( 1 ) << ( index - 512 ) ; } } return ( countries1 , countries2 , countries3 ) ; }",Converts country index list into 3 uints Expects a list of country indexes such that the 2 digit country code is converted to an index .
157,function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawn ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawn ) ; } },Calculates the quantity of Melon asset that 's currently withdrawable
158,function proxyPayment ( address _owner ) public payable whenNotPaused returns ( bool ) { doPayment ( _owner ) ; return true ; },` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the tokens created in an address of their choosing
159,"function updateWhitelist ( address _account , uint8 _phase ) external onlyCapper returns ( bool ) { require ( _account != address ( 0 ) ) ; _updateWhitelist ( _account , _phase ) ; return true ; }",function to whitelist an address which can be called only by the capper address .
160,"function havvensReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInNomins = safeMul_dec ( amount , usdToEthPrice ) ; return havvensReceivedForNomins ( valueSentInNomins ) ; }",Calculate how many havvens you will receive if you transfer an amount of ether .
161,function getValidatorDescription ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; },Get a description of the validator at account ` validator ` .
162,"function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; require ( _isValidLicense ( _tokenId ) ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }",Internal function to clear current approval and transfer the ownership of a given token ID
164,"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
167,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint256 _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
168,"function setBalance ( address _owner , uint256 _newBalance ) public onlyImpl { balances [ _owner ] = _newBalance ; }",Sets the balance of ` _owner ` to ` _newBalance ` .
169,"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( ! hasBeenRevealed ( msg . sender , _pollID ) ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) pollMap [ _pollID ] . votesFor += numTokens ; else pollMap [ _pollID ] . votesAgainst += numTokens ; dllMap [ msg . sender ] . remove ( _pollID ) ; VoteRevealed ( msg . sender , _pollID , numTokens , _voteOption ) ; }",Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
170,"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , ""Time must be later than last update"" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }",Access point for the oracle to update the prices of havvens / eth .
172,function withdrawAuctionBalances ( ) external { if ( saleAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { saleAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } if ( rentAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { rentAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } },Allow withdrawing balances from the auction contracts in a single step .
173,"function _supportsAllInterfaces ( address account , bytes4 [ ] interfaceIds ) internal view returns ( bool ) { if ( ! _supportsERC165 ( account ) ) { return false ; } for ( uint256 i = 0 ; i < interfaceIds . length ; i ++ ) { if ( ! _supportsERC165Interface ( account , interfaceIds [ i ] ) ) { return false ; } } return true ; }","Query if a contract implements interfaces , also checks support of ERC165"
174,"function airdropTokens ( address _tokenAddress , uint _totalTokensToDistribute , uint _expirationTime ) public ifNotPaused { require ( tokenWhitelist [ _tokenAddress ] ) ; require ( ! airdropperBlacklist [ msg . sender ] ) ; uint tokensForOwner = _totalTokensToDistribute . mul ( ownersCut ) . div ( 100 ) ; _totalTokensToDistribute = _totalTokensToDistribute . sub ( tokensForOwner ) ; TokenAirdropID memory taid = TokenAirdropID ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length ) ; TokenAirdrop memory ta = TokenAirdrop ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length , msg . sender , now , now + _expirationTime , _totalTokensToDistribute , _totalTokensToDistribute , userSignupCount ) ; airdroppedTokens [ _tokenAddress ] . push ( ta ) ; airdrops . push ( taid ) ; E_AirdropSubmitted ( _tokenAddress , ta . tokenOwner , ta . totalDropped , ta . airdropDate , ta . airdropExpirationDate ) ; }","Before calling this function , you must have given the Airdrop Central an allowance of the tokens to distribute ."
175,function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) ;,Total amount of tokens at a specific ` _blockNumber ` .
176,"function setApprovalForAll ( address _operator , bool _approved ) external { operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets
177,function isLocked ( address _target ) public view returns ( bool ) { if ( locked [ _target ] > now ) { return true ; } else { return false ; } },Getter returns false if tokens are available and true if unavailable
180,"function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < _types . length ; i ++ ) { address [ ] memory _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( uint256 j = 0 ; j < _currentTypeModules . length ; j ++ ) { bytes32 [ ] memory _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( uint256 k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { counter ++ ; } } } } address [ ] memory _allModules = new address [ ] ( counter ) ; bytes32 [ ] memory _allPerms = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < _types . length ; i ++ ) { _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( j = 0 ; j < _currentTypeModules . length ; j ++ ) { _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { _allModules [ counter ] = _currentTypeModules [ j ] ; _allPerms [ counter ] = _allModulePerms [ k ] ; counter ++ ; } } } } return ( _allModules , _allPerms ) ; }",Used to return all permission of a single or multiple module
182,function vote ( uint256 [ ] _votes ) public { require ( _votes . length == itemCount ) ; require ( now >= start && now < end ) ; address voter = msg . sender ; if ( ! voted [ voter ] ) { voted [ voter ] = true ; voters . push ( voter ) ; } for ( uint256 i = 0 ; i < itemCount ; i ++ ) { require ( _votes [ i ] >= voteItems [ i ] . minValue && _votes [ i ] <= voteItems [ i ] . maxValue ) ; voteItems [ i ] . votes [ voter ] = _votes [ i ] ; } },Function to case vote in this carbon voting
185,"function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; require ( job . noOfPaymentsMade > 0 ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; job . totalPaidToWorker = job . totalPaidToWorker + payment ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }",this function lets the worker claim the approved payment
186,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = CHANGE_PERMISSION ; return allPermissions ; },Use to get the Permission flag related the ` this ` contract
189,"function addBalanceFor ( address account , uint256 value ) public { lockedBalances [ account ] = lockedBalances [ account ] . add ( value ) ; token . safeTransferFrom ( msg . sender , address ( this ) , value ) ; }",To be called by the account that holds Mio tokens .
190,function setCampaign ( address _campaign ) public { },"enables the setting of the campaign , if any"
191,"function setPeriodDuration ( uint64 _periodDuration ) external authP ( CHANGE_PERIOD_ROLE , arr ( uint256 ( _periodDuration ) , uint256 ( settings . periodDuration ) ) ) transitionsPeriod { require ( _periodDuration >= 1 days , ERROR_SET_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; emit ChangePeriodDuration ( _periodDuration ) ; }","Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period"
193,function removeAddressFromWhitelistAndRefund ( address _address ) public isWhitelistEnabled canDeposit ( _address ) { whitelist [ _address ] = false ; refundAddress ( _address ) ; },Removes a user from the whitelist and processes a refund .
194,"function getPrices ( address [ ] ofAssets ) view returns ( uint [ ] , uint [ ] ) { uint [ ] memory prices = new uint [ ] ( ofAssets . length ) ; uint [ ] memory timestamps = new uint [ ] ( ofAssets . length ) ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( price , timestamp ) = getPrice ( ofAssets [ i ] ) ; prices [ i ] = price ; timestamps [ i ] = timestamp ; } return ( prices , timestamps ) ; }","Price of a registered asset in format ( bool areRecent , uint [ ] prices , uint [ ] decimals )"
195,"function getSecurityTokenAddress ( string _ticker ) external view returns ( address ) { string memory ticker = Util . upper ( _ticker ) ; return getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) ) ; }",Returns the security token address by ticker symbol
197,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; return address ( new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }",used to launch the Module with the help of factory
198,function sencToken ( ) public view returns ( ERC20Basic ) { return ERC20Basic ( SENC_CONTRACT_ADDRESS ) ; },The ` sencToken ( ) ` is the getter for the SENC Token .
201,function redeemLevAndFeeByStaker ( ) external { redeemLevAndFee ( msg . sender ) ; },To unlock and recover your LEV and FEE tokens after staking and fee to any user
204,"function transfer ( address _to , uint256 _value , bytes _data ) external isRunning noFreeze returns ( bool success ) { if ( _to == selfAddress ) { return transferToSelf ( _value ) ; } else if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value ) ; } }",Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard
207,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
210,"function initialize ( address _permissionsCreator ) public onlyInit { initialized ( ) ; require ( msg . sender == address ( kernel ( ) ) , ERROR_AUTH_INIT_KERNEL ) ; _createPermission ( _permissionsCreator , this , CREATE_PERMISSIONS_ROLE , _permissionsCreator ) ; }",Initialize an ACL instance and set ` _permissionsCreator ` as the entity that can create other permissions
211,"function initializeTokenSaleWithToken ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary , address _tokenAddress ) public ownerOnly { buyModeEth = false ; payableTokenAddress = _tokenAddress ; initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }",Uses the same signature as initializeTokenSale ( ) with :
212,"function withdraw ( ERC20 _token , uint256 _value , bytes _signature ) external withBrokerSignatureOrSignal ( _token , _signature ) { address trader = msg . sender ; privateDecrementBalance ( trader , _token , _value ) ; if ( address ( _token ) == ETHEREUM ) { trader . transfer ( _value ) ; } else { CompatibleERC20 ( _token ) . safeTransfer ( trader , _value ) ; } }",Withdraws ETH or an ERC20 token from the contract .
213,function getPriceOfCampaign ( bytes32 bidId ) public view returns ( uint price ) { return advertisementStorage . getCampaignPriceById ( bidId ) ; },Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .
214,"function setGenerationSeasonController ( uint256 _season ) public onlyManager whenNotPaused { require ( generationSeasonController [ _season ] == 0 ) ; _updateGenerationSeasonFlag ( _season , 1 ) ; }",_value of 1 : means generation of collectible is allowed .
216,"function setFundraiseLimits ( uint _min_share_price , uint _fundraise_max ) public onlyOwner { require ( ! fundraise_defined ) ; require ( _min_share_price > 0 ) ; require ( _fundraise_max > 0 ) ; require ( status == state . ended ) ; fundraise_max = _fundraise_max ; min_share_price = _min_share_price ; emit FundraiseDefined ( min_share_price , fundraise_max ) ; fundraise_defined = true ; }",Allows configuration of the final parameters needed for auction end state calculation .
220,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) ;",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
221,"function deregisterSettlement ( uint64 _settlementID ) external onlyOwner { require ( settlementDetails [ _settlementID ] . registered , ""not registered"" ) ; delete settlementDetails [ _settlementID ] ; emit LogSettlementDeregistered ( _settlementID ) ; }","Deregisteres a settlement layer , clearing the details ."
223,"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token , uint256 price , uint256 nextprice , string imagepath , string category , uint256 wildcard , address _owner ) { uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; price = getNextPrice ( cardTokenToPrice [ _tokenId ] ) ; nextprice = getNextPrice ( price ) ; imagepath = card . imagepath ; category = card . category ; wildcard = card . Iswildcard ; _owner = card . owner ; }",Returns all the relevant information about a specific card .
224,"function getBasicData ( uint64 [ ] _tokenIndexes ) public view returns ( uint256 [ ] , bytes8 [ ] , address [ ] , uint64 [ ] ) { uint256 [ ] memory tokenIds = new uint256 [ ] ( _tokenIndexes . length ) ; bytes8 [ ] memory names = new bytes8 [ ] ( _tokenIndexes . length ) ; address [ ] memory owners = new address [ ] ( _tokenIndexes . length ) ; uint64 [ ] memory collectionIdxs = new uint64 [ ] ( _tokenIndexes . length ) ; for ( uint i = 0 ; i < _tokenIndexes . length ; i ++ ) { uint64 tokenIndex = _tokenIndexes [ i ] ; require ( tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; tokenIds [ i ] = pixelcons [ tokenIndex ] . tokenId ; names [ i ] = pixelconNames [ tokenIndex ] ; owners [ i ] = tokenLookup [ pixelcons [ tokenIndex ] . tokenId ] . owner ; collectionIdxs [ i ] = pixelcons [ tokenIndex ] . collectionIndex ; } return ( tokenIds , names , owners , collectionIdxs ) ; }",Get the basic data for the given PixelCon indexes
229,"function lockAccount ( address _addr , uint256 _timePeriod ) onlyOwner public { lockAccounts [ _addr ] = _timePeriod ; emit AccountLocked ( _addr , _timePeriod ) ; }",Once an account is locked it ca n't be unlocked till the time period passes
230,function claim ( ) public { require ( msg . sender == beneficiary ) ; release ( ) ; },Transfers tokens held by timelock to beneficiary .
231,"function updateIssuanceData ( address account , uint preBalance , uint lastTotalSupply ) internal { totalIssuanceData = computeIssuanceData ( lastTotalSupply , totalIssuanceData ) ; if ( issuanceData [ account ] . lastModified < feePeriodStartTime ) { hasWithdrawnFees [ account ] = false ; } issuanceData [ account ] = computeIssuanceData ( preBalance , issuanceData [ account ] ) ; }",Update the havven balance averages since the last transfer or entitlement adjustment .
232,function getPrice ( ) public view returns ( uint ) { for ( uint i = c_priceChangeDates . length - 2 ; i > 0 ; i -- ) { if ( getTime ( ) >= c_priceChangeDates [ i ] ) { return c_tokenPrices [ i ] ; } } return c_tokenPrices [ 0 ] ; },get token price in cents depending on the current date
233,"function convertToCents ( uint256 _tokenAmount , uint256 _priceInCents , uint256 _decimals ) public pure returns ( uint256 ) { return _tokenAmount . mul ( _priceInCents ) . div ( 10 ** _decimals ) ; }",Converts the amount of Ether ( wei ) or amount of any token having 18 decimal place divisibleto cent value based on the cent price supplied .
235,"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) ;",Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is currently valid .
236,"function claimTokens ( address _token ) public onlyOwner { if ( ATT . controller ( ) == address ( this ) ) { ATT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
238,function amountReceivedFromExchange ( uint value ) external view returns ( uint ) { return value . divideDecimal ( exchangeFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; },The amount the recipient will receive if you are performing an exchange and the destination currency will be worth a certain number of tokens .
239,function addForkedUniverse ( ) onlyInitialized external { IUniverse child_universe = IUniverse ( latest_universe ) . getWinningChildUniverse ( ) ; latest_universe = child_universe ; },Register a new child universe after a fork
240,function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) ;,Used to check if an address is a delegate or not
242,function proxyWithdraw ( address receiverAddress ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint amount = bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; receiverAddress . transfer ( amount ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; },Withdraw ETH for ` receiverAddress ` after the auction has canceled .
243,function resetAppendDecryptedBids ( uint _count ) public onlyOwner { require ( status == state . ended ) ; require ( bids_decrypted_count > 0 ) ; require ( _count > 0 ) ; if ( bids_reset_count == 0 ) { bids_reset_count = bids_decrypted_count ; } uint count = _count ; if ( bids_reset_count < count ) { count = bids_reset_count ; } do { bids_reset_count -- ; bids [ bids_decrypted [ bids_reset_count ] ] . is_decrypted = false ; bids [ bids_decrypted [ bids_reset_count ] ] . is_burned = false ; bids [ bids_decrypted [ bids_reset_count ] ] . will_compute = false ; count -- ; } while ( count > 0 ) ; if ( bids_reset_count == 0 ) { bids_sorted_count = 0 ; bids_ignored_count = 0 ; bids_decrypted_count = 0 ; bids_burned_count = 0 ; } },Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .
244,"function next ( address darknodeID ) external view onlyOwner returns ( address ) { return LinkedList . next ( darknodes , darknodeID ) ; }",Returns the address of the next darknode in the store after the given address .
245,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value == 0 || dataStorage . allowed ( msg . sender , _spender ) == 0 , 'Approve value is required to be zero or account has already been approved.' ) ; dataStorage . setAllowance ( msg . sender , _spender , _value ) ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",If this function is called again it overwrites the current allowance with ` _value ` .
247,function authorAddress ( ) external view returns ( address ) ;,Returns an address of the toon author .
249,"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; NanoLoanEngine _nanoLoanEngine = nanoLoanEngine ; require ( _nanoLoanEngine . registerApprove ( _nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 requiredDeposit = ( ( readLandCost ( landId ) * requiredTotal ) / 100 ) - _nanoLoanEngine . getAmount ( loanId ) ; Token _mana = mana ; _tokenTransferFrom ( _mana , msg . sender , this , requiredDeposit ) ; require ( _mana . approve ( mortgageManager , requiredDeposit ) , ""Error approve MANA transfer"" ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( _nanoLoanEngine ) , landMarket , loanId , requiredDeposit , landId , tokenConverter ) ; require ( _mana . approve ( mortgageManager , 0 ) , ""Error remove approve MANA transfer"" ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }",Request a loan and attachs a mortgage request
250,function setTimelock ( uint _newTimeLock ) onlyOwner external { require ( _newTimeLock >= absoluteMinTimeLock ) ; timeLock = _newTimeLock ; },` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
251,"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
254,"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _holderOf [ _tokenId ] != 0 , ""Asset does not exist"" ) ; URIProvider provider = _uriProvider ; return provider == address ( 0 ) ? """" : provider . tokenURI ( _tokenId ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
255,function updatePrice ( ) public payable { require ( msg . sender == priceCheckerAddress ) ; _updatePrice ( ) ; },Function for updating the price stored in this contract
257,"function setAccountSpendingLimit ( address account , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setAccountSpendingLimit ( account , limit ) , ""Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }",Sets the spending limit for a given account
259,"function approve ( address _spender , uint256 _value ) public returns ( bool ) { _allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount ."
260,function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) { return orders [ _orderID ] . matchedOrder ; },returns a list of matched orders to the given orderID .
262,"function setLimits ( uint _minAmountLimit , uint _maxAmountLimit , uint _divisorBalanceLimit , uint _multiplierSharesLimit , uint _divisorSharesLimit ) ;",Function used by the creator to set the funding limits for the funding
263,"function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] , ""TotlePrimary - tokenAddress != tokenForOrder"" ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] , ""TotlePrimary - handler not in whitelist"" ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining , ""TotlePrimary - not enough ether left to fill next order"" ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) , ""TotlePrimary - amount obtained for was not high enough"" ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) , ""TotlePrimary - failed to transfer tokens bought to msg.sender"" ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) , ""TotlePrimary - failed to transfer remaining tokens to msg.sender after sell"" ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }",The orders in this function have been wrapped in structs to reduce the local variable count
267,"function redeem ( uint256 _tokens ) public { __redeem_impl ( msg . sender , _tokens ) ; }",Redeem required amount of tokens for the real asset
268,"function setExchangeFeeRate ( uint _exchangeFeeRate ) external optionalProxy_onlyOwner { require ( _exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE , ""Exchange fee rate must be below MAX_EXCHANGE_FEE_RATE"" ) ; exchangeFeeRate = _exchangeFeeRate ; emitExchangeFeeUpdated ( _exchangeFeeRate ) ; }","Set the exchange fee , anywhere within the range 0-10 % ."
269,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenrecipiente spender = tokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
270,"function addListToWhiteList ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { if ( nonWLBalanceOf [ _addresses [ i ] ] > 0 ) { sendTokens ( _addresses [ i ] , nonWLBalanceOf [ _addresses [ i ] ] ) ; nonWLBalanceOf [ _addresses [ i ] ] = 0 ; } whiteList [ _addresses [ i ] ] = true ; } }",Add multiple addresses to white list to allow purchase for more than 10 ETH .
271,"function getInstructions ( ) public view returns ( string ) { return ""Allows an issuer to restrict the total number of non-zero token holders"" ; }",Get the Instructions that helped to used the module
273,"function getRate ( ) returns ( uint32 , uint32 ) { return ( 1 , 1 ) ; }",returns always 1 because exchange rate of the token to itself is always 1 .
274,function ( ) public payable { revert ( ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
275,"function giveReserveTo ( address to , uint256 tokens ) public onlyOwner { require ( ! readOnly , ""Read only mode engaged"" ) ; balances [ address ( 0 ) ] = balances [ address ( 0 ) ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( address ( 0 ) , to , tokens ) ; ensureInAccountList ( to ) ; }","Give tokens from the pool to account , creating the account if necessary"
276,"function buy ( uint _bidPrice , uint _amount , bool _make ) payable returns ( bool ) ;",Will buy ` _amount ` tokens at or below ` _price ` each .
277,"function buy ( uint256 x , uint256 y , uint256 sizeA , uint256 sizeB , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . value > 0 ) ; internalBuy ( x , y , sizeA , sizeB ) ; }",sell new tokens during the round 0 all except logo
278,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
279,"function finishSale ( ) external onlyIfSaleIsActive onlymanyowners ( keccak256 ( msg . data ) ) { require ( m_nextSale != address ( 0 ) ) ; m_active = false ; EthPriceDependent next = EthPriceDependent ( m_nextSale ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( m_nextSale , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( m_nextSale ) ; }","stop accepting ether , transfer remaining tokens to the next sale and give new sale permissions to transfer frozen funds and revoke own ones Can be called anytime , even before the set finish date"
280,"function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , 0x0 , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }",converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
281,"function announceCancel ( bytes32 _offerHash ) external { Offer memory offer = offers [ _offerHash ] ; require ( offer . maker == msg . sender , ""Invalid sender"" ) ; require ( offer . availableAmount > 0 , ""Offer already cancelled"" ) ; uint256 canCancelAt = now + cancelAnnounceDelay ; announcedCancellations [ _offerHash ] = canCancelAt ; emit CancelAnnounce ( offer . maker , _offerHash , canCancelAt ) ; }",Announces intent to cancel tokens using ` slowCancel `
282,"function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
283,"function mintToken ( uint256 mintedAmount ) onlyOwner public { _balanceOf [ owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , owner , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` owner `
285,"function burn ( address _address , uint256 _value ) external onlyContract ( ""FeeManager"" ) returns ( bool ) { require ( _value <= balanceOf ( _address ) ) ; spentAct [ _address ] = spentAct [ _address ] . add ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; emit Burn ( _address , _value ) ; return true ; }",Burns tokens through decrementing `` totalSupply '' and incrementing `` spentAct [ address ] ''
287,"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Percentage"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }",Get the tags related to the module factory
292,function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ( ) ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; },Removes multiple addresses to the administrator list .
293,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = politicianIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
295,"function multiERC20TransferTightlyPacked ( ERC20 _token , bytes32 [ ] _addressesAndAmounts ) public { for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeERC20Transfer ( _token , to , amount ) ; MultiERC20Transfer ( msg . sender , msg . value , to , amount , _token ) ; } }",Send ERC20 tokens to multiple contracts using a byte32 array which includes the address and the amount .
298,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
299,"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
300,"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ msg . sender ] < _value ) return false ; if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
302,function onTimeout ( uint256 ) internal { selfdestruct ( msg . sender ) ; },Default action when timeout : override this .
306,function getHealBalance ( ) view public returns ( uint256 ) { return ethealController . ethealToken ( ) . balanceOf ( address ( this ) ) ; },How many HEAL tokens do this contract have
307,"function upgrade ( uint256 value ) external { require ( upgradeAgentStatus ) ; require ( value > 0 && upgradeAgent . owner ( ) != 0x0 ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }",Upgrade tokens to the new token contract .
308,"function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) { string memory symbol = upper ( _symbol ) ; if ( registeredSymbols [ symbol ] . status == true || registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) > now ) { return ( registeredSymbols [ symbol ] . owner , registeredSymbols [ symbol ] . timestamp , registeredSymbols [ symbol ] . tokenName , registeredSymbols [ symbol ] . swarmHash , registeredSymbols [ symbol ] . status ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , """" , bytes32 ( 0 ) , false ) ; }",Returns the owner and timestamp for a given symbol
310,function ownershipLength ( ) public view returns ( uint256 ) { return ownership . length ; },Gets the length of the ownership array which represents the number of owned plots which exist
311,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferControl ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
312,"function getNextVestingIndex ( address account ) public view returns ( uint ) { uint len = numVestingEntries ( account ) ; for ( uint i = 0 ; i < len ; i ++ ) { if ( getVestingTime ( account , i ) != 0 ) { return i ; } } return len ; }",Obtain the index of the next schedule entry that will vest for a given user .
313,function computeHash ( string _key ) private pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _key ) ) ; },Computes keccak256 hash of the supplied value .
314,"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( ""dispensationPct"" ) <= 100 ) ; assert ( get ( ""pDispensationPct"" ) <= 100 ) ; now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed"
316,"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; toRecord ( msg . sender , _to , _value ) ; return true ; }",send ` _value ` token to ` _to `
317,"function getTokenDetails ( uint64 _tokens ) private view returns ( TokenPair memory ) { ( address priorityAddress , uint8 priorityDecimals , bool priorityRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens >> 32 ) ) ; ( address secondaryAddress , uint8 secondaryDecimals , bool secondaryRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens ) ) ; return TokenPair ( { priorityToken : RenExTokens . TokenDetails ( priorityAddress , priorityDecimals , priorityRegistered ) , secondaryToken : RenExTokens . TokenDetails ( secondaryAddress , secondaryDecimals , secondaryRegistered ) } ) ; }",Gets the order details of the priority and secondary token from the RenExTokens contract and returns them as a single struct .
318,"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( content ) ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }","Create a reusable template , which should be a JSON document ."
320,function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return finalPrice ; } return calcTokenPrice ( ) ; },"Get the XBET price in WEI during the auction , at the time of calling this function ."
321,function setFundingStartTime ( uint _startTime ) external ;,Function used by the main partner to set the start time of the funding
323,"function totalIssuedSynths ( bytes4 currencyKey ) public view rateNotStale ( currencyKey ) returns ( uint ) { uint total = 0 ; uint currencyRate = exchangeRates . rateForCurrency ( currencyKey ) ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { require ( ! exchangeRates . rateIsStale ( availableSynths [ i ] . currencyKey ( ) ) , ""Rate is stale"" ) ; uint synthValue = availableSynths [ i ] . totalSupply ( ) . multiplyDecimalRound ( exchangeRates . rateForCurrency ( availableSynths [ i ] . currencyKey ( ) ) ) . divideDecimalRound ( currencyRate ) ; total = total . add ( synthValue ) ; } return total ; }","Total amount of synths issued by the system , priced in currencyKey"
324,function balanceOf ( address _owner ) public view returns ( uint256 _balance ) ;,Returns the balance of an account with address ` _owner ` .
325,"function quoteBid ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }",Calculates the bid price in wei per aToken based on the current reserve amount
328,function setGasLimit ( uint256 _gasLimit ) isAdminOrOwner public { gasLimit = _gasLimit ; },"NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled"
329,function setSynthetixState ( SynthetixState _synthetixState ) external optionalProxy_onlyOwner { synthetixState = _synthetixState ; emitStateContractChanged ( _synthetixState ) ; },Set the synthetixState contract address where issuance data is held .
331,"function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { throw ; } }",This function is disabled during the funding .
332,function callWithdraw ( ) onlyOwner public { realitycheck . withdraw ( ) ; },Withdraw any accumulated question fees from the specified address into this contract
334,"function balanceOf ( address _holder , bytes32 _symbol ) public view returns ( uint ) { return _balanceOf ( getHolderId ( _holder ) , _symbol ) ; }",Returns asset balance for a particular holder .
336,function getCurrencyAddress ( ) external view returns ( address ) ;,Returns address of oracle currency ( 0x0 for ETH )
338,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cityIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
339,"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token ) { address owner = cardTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; }",Returns all the relevant information about a specific card .
342,"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
343,"function acceptAllOfficialOperators ( ) external { require ( mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , ""Official operators are already accepted by msg.sender."" ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = false ; emit OfficialOperatorsAcceptedByUser ( msg . sender ) ; }",Authorize all official operators to manage ` msg.sender ` 's tokens .
346,function getCoversForPacks ( uint [ ] _packIds ) public view returns ( bytes32 [ ] ) { require ( _packIds . length > 0 ) ; bytes32 [ ] memory covers = new bytes32 [ ] ( _packIds . length ) ; for ( uint i = 0 ; i < _packIds . length ; i ++ ) { AssetPack memory assetPack = assetPacks [ _packIds [ i ] ] ; covers [ i ] = assetPack . packCover ; } return covers ; },Function to get cover image for every assetpack
350,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ msg . sender ] = _balance [ msg . sender ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",Transfers ` _value ` amount of tokens to address ` _to ` .
351,"function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == getHolderId ( _owner ) ) ; }",Check if specified address has asset owner rights .
352,"function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { uint256 template_id = createTemplate ( content ) ; return askQuestion ( template_id , question , arbitrator , timeout , opening_ts , nonce ) ; }",Create a new reusable template and use it to ask a question
353,"function getEscrowAndHash ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) view private returns ( Escrow , bytes32 ) { bytes32 _tradeHash = keccak256 ( abi . encodePacked ( _tradeID , _seller , _buyer , _value , _fee ) ) ; return ( escrows [ _tradeHash ] , _tradeHash ) ; }",Hashes the values and returns the matching escrow object and trade hash .
355,function symbol ( ) external view returns ( string _symbol ) { return _ERC721symbol ; },An abbreviated name for NFTs in this contract
356,"function closeGame ( uint gameId , GameResults result ) external onlyOwner whenGameIsFrozen ( gameId ) { games [ gameId ] . state = GameStates . Closed ; games [ gameId ] . result = result ; emit GameHasClosed ( gameId , result ) ; }",We use this function to close a game
357,"function setPlotDataMultiple ( uint256 [ ] _deedIds , string name , string description , string imageUrl , string infoUrl ) external whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; } }",Set the data associated with multiple plots .
358,function currentResult ( ) external view returns ( uint32 [ NUMBER_OF_CHOICES ] ) { return currentVoteResults ; },Return array with sums of votes per choice .
359,function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != totalSupply ) { revert ( ) ; } },Set address of migration target contract and enable migration process .
360,"function quoteAsk ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }",Calculates the ask price in wei per aToken based on the current reserve amount
361,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external ;",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
362,function getNewRegistry ( ) public view returns ( address ) { return address ( params [ NEW_REGISTRY_KEC ] ) ; },"gets the address of the new registry , if set ."
370,function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; },"Get the RDN price in WEI during the auction , at the time of calling this function ."
372,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner canMint { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , _operatorData , false ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }",Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
373,"function decBalance ( address _acct , uint _val ) public onlyModule returns ( bool ) { balances [ _acct ] = balances [ _acct ] . sub ( _val ) ; emit BalanceAdj ( msg . sender , _acct , _val , ""-"" ) ; return true ; }",Decrement ` _acct ` balance by ` _val `
374,"function unlockPrivate ( ) public locked onlyOwner { require ( block . timestamp >= privateReleaseTime ) ; require ( privateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= privateLockedAmount ) ; token . transfer ( privateLockAddress , privateLockedAmount ) ; privateLockedAmount = 0 ; }",Transfers tokens held by timelock to private .
375,function getRegistry ( ) external view returns ( address ) ;,Get the account of the utilized attribute registry .
376,function getOrdersForSeller ( address seller ) public view validAddress ( seller ) returns ( address [ ] ) { return ordersBySeller [ seller ] ; },Gets all the data orders associated with a seller .
377,"function transferToAddress ( address _to , uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard"
378,"function name ( ) public pure returns ( string ) { return ""Pirate Kitty Token"" ; }",A descriptive name for a collection of NFTs in this contract
381,function remainingFundsToEndAuction ( ) constant public returns ( uint256 ) { uint256 required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; },"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI ."
382,"function rentOutArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint rentPricePerPeriodWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = rentals . rentOutBlocks ( msg . sender , rentPricePerPeriodWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRentsOut ( id , fromX , fromY , toX , toY , rentPricePerPeriodWei ) ; }","Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei"
383,function withdrawAccumulatedFees ( address _to ) external onlyOwner { uint256 transferAmount = accumulatedGasFees ; accumulatedGasFees = 0 ; _to . transfer ( transferAmount ) ; },Withdraw accumulated gas fees from the arbitratror releasing escrow .
384,"function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; bytes memory empty ; Transfer ( _from , _to , _value , empty ) ; }",Transfer tokens from an address to another ~ ERC-20 Standard
385,"function transferOwnershipToProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }","` transferOwnershipToProject ` allows for the transfer of ownership to the project , but it can also be called by a project to un-delegate everyone by setting one 's own id for the idReceiver"
386,"function ( ) public payable { require ( contractPoweredUp ) ; require ( now >= PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; if ( now >= PRESALE_START_DATE && now < PRESALE_SECOND_DAY_START ) { require ( whitelist [ msg . sender ] == msg . value ) ; require ( balanceOf [ msg . sender ] == 0 ) ; } else if ( now >= PRESALE_SECOND_DAY_START && now < PRESALE_THIRD_DAY_START ) { require ( whitelist [ msg . sender ] != 0 ) ; } require ( totalFunding . add ( msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; grantCreditsForParticipation ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the presale has been funded to the maximum amount
387,"function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIndexToPrice [ _tokenId ] ; owner = athleteIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific athlete .
388,"function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { burnFrom ( _owner , _value ) ; return true ; }","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly"
389,function setNewCFO ( address newCFO ) public onlyOwner { require ( newCFO != 0 ) ; CFO = newCFO ; },Separating the CFO and the CEO responsibilities requires the ability to set the CFO account
392,"function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public ;",Creates a new Security Token and saves it to the registry
393,"function attestFor ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig , bytes _delegationSig ) external { validateAttestForSig ( _subject , _attester , _requester , _reward , _dataHash , _requestNonce , _delegationSig ) ; attestForUser ( _subject , _attester , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }",Submit attestation for a user in order to pay the gas costs
394,"function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool success ) { uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
395,"function multiBatchSafeTransferFrom ( uint256 [ ] _tokenIds , address [ ] _fromB , address [ ] _toB ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _fromB . length > 0 && _toB . length > 0 ) ; uint256 _id ; address _to ; address _from ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 && _fromB [ i ] != 0 && _toB [ i ] != 0 ) ; _id = _tokenIds [ i ] ; _to = _toB [ i ] ; _from = _fromB [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }",Batch SafeTransferFrom with multiple From and to Addresses
401,"function drain ( ) public onlyOwner { for ( uint256 index = 0 ; index < membersArray . length ; index ++ ) { address memberAddress = membersArray [ index ] ; bool memberJoined = members [ memberAddress ] . stakeTimestamp != 0 ; uint256 amountRefunded = memberJoined ? refundUserBalance ( memberAddress ) : 0 ; delete registeredInvitationCodes [ members [ memberAddress ] . invitationCode ] ; delete members [ memberAddress ] ; emit MemberDrained ( memberAddress , amountRefunded ) ; } delete membersArray ; require ( ixtToken . transfer ( msg . sender , totalPoolBalance ) , ""Unable to withdraw this value of IXT."" ) ; totalPoolBalance = 0 ; emit PoolDrained ( msg . sender , totalPoolBalance ) ; emit ContractDrained ( msg . sender ) ; }",This function can only be called by the contract owner
402,function emergencyClawbackEther ( uint256 value ) external onlyOwnerOrMultisig { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( contractRefundFinished ) ; require ( value > 0 ) ; require ( value <= address ( this ) . balance ) ; msg . sender . transfer ( value ) ; },Contract owner or Multisig can clawback ether after refund period is finished
404,"function verifyMatchDetails ( OrderDetails memory _buy , OrderDetails memory _sell ) internal pure returns ( bool ) { if ( ! verifyTokens ( _buy . tokens , _sell . tokens ) ) { return false ; } if ( _buy . price < _sell . price ) { return false ; } if ( _buy . volume < _sell . minimumVolume ) { return false ; } if ( _sell . volume < _buy . minimumVolume ) { return false ; } if ( _buy . settlementID != _sell . settlementID ) { return false ; } return true ; }","Verifies that two orders match when considering the tokens , price , volumes / minimum volumes and settlement IDs ."
408,"function getBorrowBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newBorrowIndex ; uint userBorrowCurrent ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ account ] [ asset ] ; ( err , newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , newBorrowIndex ) ; require ( err == Error . NO_ERROR ) ; return userBorrowCurrent ; }",return borrow balance with any accumulated interest for ` asset ` belonging to ` account `
411,"function assingAdminship ( address _newAdmin , uint8 _level ) onlyAdmin ( 2 ) public { admin [ _newAdmin ] = _level ; emit AssignAdminship ( _newAdmin , _level ) ; }",This function transfer the adminship of the contract to _newAdmin
412,"function bid ( ) external payable { require ( block . number < _auctionEnd ) ; uint proposedBid = _bidders [ msg . sender ] . value . add ( msg . value ) ; require ( proposedBid > _lowestBid ) ; uint startPos = 99 ; if ( _bidders [ msg . sender ] . value >= _lowestBid ) { for ( uint i = 99 ; i < 100 ; -- i ) { if ( _topBids [ i ] . bidderAddress == msg . sender ) { startPos = i ; break ; } } } uint endPos ; for ( uint j = startPos ; j < 100 ; -- j ) { if ( j != 0 && proposedBid > _topBids [ j - 1 ] . bid ) { _topBids [ j ] = _topBids [ j - 1 ] ; } else { _topBids [ j ] . bid = proposedBid ; _topBids [ j ] . bidderAddress = msg . sender ; endPos = j ; break ; } } _bidders [ msg . sender ] . value = proposedBid ; _bidders [ msg . sender ] . lastTime = now ; _lowestBid = _topBids [ 99 ] . bid ; if ( endPos < 3 ) { TopThreeChanged ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; } NewBid ( msg . sender , _bidders [ msg . sender ] . value ) ; }",Bid ` ( msg.value ) ` ether for a chance of winning a RareCoin
414,function forwardFunds ( uint256 amountPaid ) internal whenNotPaused { if ( goalReached ( ) ) { wallet . transfer ( amountPaid ) ; } else { vault . deposit . value ( amountPaid ) ( msg . sender ) ; } checkCompletedCrowdsale ( ) ; },Sends the funds to the wallet or to the refund vault smart contract if the minimum goal of tokens has n't been reached yet
418,"function split ( address boardOwner , uint _amount ) internal returns ( bool ) { emit Withdrawal ( owner , _amount / 2 ) ; owner . transfer ( _amount / 2 ) ; boardOwner . transfer ( _amount / 2 ) ; return true ; }",split the revenue of a new player between boardOwner and contract owner
419,"function addValidatorApproval ( address validator , uint256 attributeTypeID ) external ;",Approve the validator at address ` validator ` to issue attributes of the type with ID ` attributeTypeID ` .
420,function addressBelongsToAccount ( address _address ) public view returns ( bool ) { return accountByAddress [ _address ] > 0 ; },Check if an address is associated with any user account
421,"function transfer ( address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( tradable ) ; if ( balances [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }",transfers sender 's tokens to a specified address .
422,function setBlacklistedUser ( address _who ) public onlyValidator { _setBlacklistedUser ( _who ) ; },Sets the necessary permissions for a `` blacklisted '' user .
423,"function existsPriceOnAssetPair ( address sellAsset , address buyAsset ) view returns ( bool isExistent ) { return hasRecentPrice ( sellAsset ) && hasRecentPrice ( buyAsset ) && ( buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET ) && ( buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET ) ; }",Checks whether data exists for a given asset pair
424,"function bid ( ) public payable auctionNotEnded isMinimumBid isHighestBid { if ( highestBidder != address ( 0 ) ) { uint lastBid = bids [ highestBidder ] ; bids [ highestBidder ] = 0 ; if ( ! highestBidder . send ( lastBid ) ) { emit CheaterBidder ( highestBidder , lastBid ) ; } } highestBidder = msg . sender ; bids [ msg . sender ] = msg . value ; auctionState = AuctionStates . Ongoing ; emit HighestBidIncreased ( msg . sender , msg . value ) ; }",Bid on the auction with the amount of ` msg.value ` The lesser value will be refunded .
428,function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; require ( msg . sender == tx . origin ) ; process_contribution ( _toAddr ) ; },This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf
431,"function getPledge ( uint64 idPledge ) constant returns ( uint amount , uint64 owner , uint64 nDelegates , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState pledgeState ) { Pledge storage p = findPledge ( idPledge ) ; amount = p . amount ; owner = p . owner ; nDelegates = uint64 ( p . delegationChain . length ) ; intendedProject = p . intendedProject ; commitTime = p . commitTime ; oldPledge = p . oldPledge ; pledgeState = p . pledgeState ; }",A getter that returns the details of the specified pledge
432,function acceptOwnership ( ) { if ( msg . sender == newOwner ) { owner = newOwner ; } },"` newOwner ` has to accept the ownership before it is transferred Any account or any contract with the ability to call ` acceptOwnership ` can be used to accept ownership of this contract , including a contract with no other functions"
433,"function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }",Add funds to the bounty for a question
434,function getCampaignEndDateById ( bytes32 bidId ) public view returns ( uint endDate ) { return campaigns [ bidId ] . getEndDate ( ) ; },"Get the end date of a campaign Based on the Campaign id , return the value ( in miliseconds ) corresponding to the end Date of the campaign ."
435,function getDeedTimestamp ( string document ) public constant returns ( uint256 ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; uint256 timestamp = documentRegistry [ documentHash ] ; require ( timestamp > 0 ) ; return timestamp ; },Returns a unix timestamp when the proof of existence for a document was created
437,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Assign allowance _value to _spender address to use the msg.sender balance
438,"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool success ) { if ( _owner == vaultAddress ) { return true ; } return false ; }","Notifies the controller about an approval , for this EarlyTokenSale all approvals are allowed by default and no extra notifications are needed"
439,"function updateCounters ( uint256 _etherAmount ) internal { etherPaid = etherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( etherPaid , _etherAmount ) ; }",Updates the counters for the amount of Ether paid
442,function endAuction ( ) public onlyOwner { require ( status == state . active ) ; status = state . ended ; emit Ended ( block . number ) ; },"Ends the auction , preventing new bids from entering"
443,"function rentOut ( address _to , uint256 _rentPeriod , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; rentOutMultiple ( _to , _rentPeriod , _deedIds ) ; }",Rents a plot out to another address .
445,function getInvestorsAt ( uint256 _checkpointId ) external view returns ( address [ ] ) ;,returns an array of investors at a given checkpoint NB - this length may differ from investorCount as it contains all investors that ever held tokens
448,function setBeneficiary ( address _beneficiary ) onlyOwner public { beneficiary = _beneficiary ; },Sets the address getting the proceedings from fishing in the aquarium
449,function deedUri ( uint256 _deedId ) external view returns ( string _uri ) ;,A distinct URI ( RFC 3986 ) for a given token .
450,"function getMatchDetails ( bytes32 _orderID ) external view returns ( bool settled , bool orderIsBuy , bytes32 matchedID , uint256 priorityVolume , uint256 secondaryVolume , uint256 priorityFee , uint256 secondaryFee , uint32 priorityToken , uint32 secondaryToken ) { matchedID = orderbookContract . orderMatch ( _orderID ) ; orderIsBuy = isBuyOrder ( _orderID ) ; ( bytes32 buyID , bytes32 sellID ) = orderIsBuy ? ( _orderID , matchedID ) : ( matchedID , _orderID ) ; SettlementDetails memory settlementDetails = calculateSettlementDetails ( buyID , sellID , getTokenDetails ( orderDetails [ buyID ] . tokens ) ) ; return ( orderStatus [ _orderID ] == OrderStatus . Settled || orderStatus [ _orderID ] == OrderStatus . Slashed , orderIsBuy , matchedID , settlementDetails . leftVolume , settlementDetails . rightVolume , settlementDetails . leftTokenFee , settlementDetails . rightTokenFee , uint32 ( orderDetails [ buyID ] . tokens >> 32 ) , uint32 ( orderDetails [ buyID ] . tokens ) ) ; }",Retrieves the settlement details of an order .
451,function unpause ( ) public onlyMEGO whenPaused { paused = false ; },This is public rather than external so it can be called by derived contracts .
455,"function honourWhitelist ( ) private returns ( bool ) { bool honourWhitelist = true ; if ( honourWhitelistEnd <= now ) { honourWhitelist = false ; preSaleCap = preSaleCap . add ( whitelistedPlannedContributions ) ; whitelistedPlannedContributions = 0 ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , 0 ) ; } return honourWhitelist ; }","Returns true if the whitelist period is still active , false otherwise ."
456,"function transfer ( address _to , uint256 _value , bytes _data ) public onlyIfLockTimePassed returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
457,"function buyAssetPack ( address _to , uint _assetPackId ) public payable { require ( ! checkHasPermissionForPack ( _to , _assetPackId ) ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; require ( msg . value >= assetPack . price ) ; artistBalance [ assetPack . creator ] += msg . value * 95 / 100 ; artistBalance [ owner ] += msg . value * 5 / 100 ; boughtAssetPacks [ _to ] . push ( _assetPackId ) ; hasPermission [ _to ] [ _assetPackId ] = true ; emit AssetPackBought ( _assetPackId , _to ) ; }",Method to buy right to use specific asset pack
458,"function giveMeToken ( DSToken token ) public auth { token . transfer ( msg . sender , token . balanceOf ( this ) ) ; }",transfer any token from this contract to the sender
459,function price ( ) public view returns ( uint256 _price ) { if ( block . timestamp <= start . add ( BONUS_DURATION_1 ) ) { return tokenPerEth . mul ( BONUS_TIER1 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_2 ) ) { return tokenPerEth . mul ( BONUS_TIER2 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_3 ) ) { return tokenPerEth . mul ( BONUS_TIER3 ) . div ( 1e2 ) ; } return tokenPerEth ; },Calculates the price as tokens/ether based on the corresponding bonus bracket .
460,function setReleaseDate ( uint256 _releaseDate ) external onlyAdmin whenNotPaused { require ( releaseDate == 0 ) ; require ( _releaseDate > now ) ; releaseDate = _releaseDate ; emit BonusReleaseDateSet ( _releaseDate ) ; },Enables the administrators to set the bonus release date.Please note that the release date can only be set once .
461,"function implementsERC165InterfaceNoCache ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { uint256 success ; uint256 result ; ( success , result ) = noThrowCall ( _contract , ERC165ID ) ; if ( success == 0 || result == 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , INVALID_ID ) ; if ( success == 0 || result != 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , _interfaceId ) ; if ( success == 1 && result == 1 ) { return true ; } return false ; }",Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .
462,function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; },Adds multiple addresses to the administrator list .
463,"function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { super . burn ( _amount , _holderData ) ; }",Burns ` _amount ` tokens from ` _tokenHolder ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
465,"function getTokenBalance ( Data storage self , string currency , address account ) internal view returns ( uint balance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }",Get the token balance for a given account
467,"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; BeneficiaryDestroyed ( _beneficiary ) ; }",Allows the owner to destroy a beneficiary .
469,"function transfer ( address to , uint tokens ) public returns ( bool success ) ;",send ` tokens ` token to ` to ` from ` msg.sender `
470,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPixels = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 pixelId ; for ( pixelId = 0 ; pixelId <= totalPixels ; pixelId ++ ) { if ( pixelIndexToOwner [ pixelId ] == _owner ) { result [ resultIndex ] = pixelId ; resultIndex ++ ; } } return result ; } },Returns a list of all Pixel IDs assigned to an address .
471,"function cancelMilestone ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . Canceled ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }",` onlyRecipient ` Cancels a previously accepted milestone
473,function confirmCustodianChangeProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmCustodianChange ( _lockId ) ; },"Pass-through control of custodian change confirmation , allowing this contract 's custodian to act as the custodian of the associated active token implementation ."
474,function burn ( uint256 _value ) public whenNotPaused { super . burn ( _value ) ; },Burns the coins held by the sender .
475,"function partialRelease ( address who , address tradingWallet , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( tradingWallet != 0 , ""The destination wallet cannot be null."" ) ; require ( ! isExistingHolding ( tradingWallet ) , ""The destination wallet must be a new fresh wallet."" ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate , ""Only affiliates can use this function; use release() for non-affiliates."" ) ; require ( amount <= holding . quantity , ""The holding has less than the specified amount of tokens."" ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( tradingWallet , amount ) ; if ( res ) { heldTokens [ who ] = Holding ( holding . quantity . sub ( amount ) , holding . releaseDate , holding . isAffiliate ) ; emit TokensReleased ( who , amount ) ; return true ; } } return false ; }",Release some of an affiliate 's tokens to a broker/trading wallet .
476,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ! funding_ended ) throw ; if ( msg . sender == founders ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .
478,function getStakeBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . stakeBalance ; },Called to obtain the stake balance of any given member
479,"function setAffiliate ( address who , bool isAffiliate ) public onlyTransferAgent returns ( bool ) { require ( who != 0 , ""The null address cannot be used."" ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate != isAffiliate , ""Attempt to set the same affiliate status that is already set."" ) ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate , isAffiliate ) ; emit AffiliateStatusChanged ( who , isAffiliate ) ; return true ; }","Company affiliates have added restriction , allow the Transfer Agent set/clear this flag as needed ."
480,"function transferAndCall ( address to , uint256 value , bytes data ) public returns ( bool ) ;",Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver
482,function releaseTo ( address _beneficiary ) public onlyOwner { release ( _beneficiary ) ; },Allows the owner to transfers vested tokens to beneficiary .
488,function withdrawBoardMeetingFees ( ) returns ( bool ) ;,Function to withdraw the rewarded board meeting fees
491,"function send ( address _to , uint256 _amount , bytes _userData ) public whenNotPaused { doSend ( msg . sender , _to , _amount , _userData , msg . sender , """" , true ) ; }",Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
492,"function getMasterpiece ( uint256 _tokenId ) external view returns ( string name , string artist , uint256 birthTime , uint256 snatchWindow , uint256 sellingPrice , address owner ) { Masterpiece storage masterpiece = masterpieces [ _tokenId ] ; name = masterpiece . name ; artist = masterpiece . artist ; birthTime = uint256 ( masterpiece . birthTime ) ; snatchWindow = masterpieceToSnatchWindow [ _tokenId ] ; sellingPrice = masterpieceToPrice [ _tokenId ] ; owner = masterpieceToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific masterpiece .
493,"function claim ( ) public onlyOwner { require ( now >= releaseTime , ""now >= releaseTime"" ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 , ""amount > 0"" ) ; token . safeTransfer ( owner , amount ) ; }",Transfers tokens held by timelock to owner .
495,"function getSolid ( uint256 _tokenId ) public view returns ( string solidName , uint256 price , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { Solid storage solid = solids [ _tokenId ] ; solidName = solid . name ; price = priceOf ( _tokenId ) ; currentOwner = solidIndexToOwner [ _tokenId ] ; bagHolderFund = solid . bagHolderFund ; isBagFundAvailable = now > ( solid . saleTime + priceFallDuration ) ; }",Returns all the relevant information about a specific solid .
497,"function addSynth ( Synth synth ) external optionalProxy_onlyOwner { bytes4 currencyKey = synth . currencyKey ( ) ; require ( synths [ currencyKey ] == Synth ( 0 ) , ""Synth already exists"" ) ; availableSynths . push ( synth ) ; synths [ currencyKey ] = synth ; emitSynthAdded ( currencyKey , synth ) ; }",Add an associated Synth contract to the Synthetix system
499,"function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { uint256 belowPlanned = plannedContribution . sub ( msg . value ) ; preSaleCap = preSaleCap . add ( belowPlanned ) ; updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }",Returns the contribution and refund value to be used when the transaction value is lower than the whitelisted contribution for the sender .
500,"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""ManualApproval"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }",Get the tags related to the module factory
504,"function howMuchCanXContributeNow ( address _beneficiary ) view public returns ( uint256 ) { require ( _beneficiary != address ( 0 ) ) ; if ( ! hasStarted ( ) || hasEnded ( ) ) { return 0 ; } uint256 weiToCap = cap . sub ( weiRaised ) ; uint8 _saleDay = getSaleDayNow ( ) ; if ( _saleDay <= whitelistDayCount ) { if ( ! whitelist [ _beneficiary ] ) { return 0 ; } uint256 weiToPersonalCap = whitelistDayMaxStake [ _saleDay ] . sub ( stakes [ _beneficiary ] ) ; if ( msg . value > 0 && maxGasPrice > 0 && tx . gasprice > maxGasPrice ) { weiToPersonalCap = weiToPersonalCap . mul ( 100 ) . div ( maxGasPricePenalty ) ; } weiToCap = uint256Min ( weiToCap , weiToPersonalCap ) ; } return weiToCap ; }",How many wei can an ethereum address contribute now .
506,"function addAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable { require ( ! _attributeTypes [ attributeTypeID ] . onlyPersonal , ""only operatable attributes may be added on behalf of another address"" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""duplicate attributes are not supported, remove existing attribute first"" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( validatorFee ) . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , ""attribute requires a greater value than is currently provided"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) , account , msg . sender , msg . value , validatorFee , attributeTypeID , value ) ) ; require ( ! _invalidAttributeApprovalHashes [ hash ] , ""signed attribute approvals from validators may not be reused"" ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; require ( canValidate ( validator , attributeTypeID ) , ""signature does not match an approved validator for provided attribute"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : msg . sender , validator : validator , value : value , stake : stake } ) ; _invalidAttributeApprovalHashes [ hash ] = true ; emit AttributeAdded ( validator , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } if ( validatorFee > 0 ) { if ( validator . send ( validatorFee ) ) { emit FeePaid ( validator , msg . sender , attributeTypeID , validatorFee ) ; } } }","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account ` account ` by passing in a signed attribute approval with signature ` signature ` ."
510,"function onTransfer ( address _from , address , uint ) public returns ( bool success ) { if ( _from == controller || _from == address ( this ) ) { return true ; } return transferable ; }","Notifies the controller about a transfer , for this TokenSale all transfers are allowed by default and no extra notifications are needed"
514,function getStatusContract ( address _contractAddress ) external view returns ( uint8 ) { return trustedCurrencyContracts [ _contractAddress ] ; },Gets the status of a trusted currencyContract .
517,function configure ( uint256 _maxHolderPercentage ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; },Used to intialize the variables of the contract
518,function setSynthetix ( Synthetix _synthetix ) external onlyOwner { synthetix = _synthetix ; emit SynthetixUpdated ( _synthetix ) ; },Set the Synthetix contract that the issuance controller uses to issue SNX .
520,function exchangeFeeIncurred ( uint value ) public view returns ( uint ) { return value . multiplyDecimal ( exchangeFeeRate ) ; },Calculate the fee charged on top of a value being sent via an exchange
521,"function changePolyRegisterationFee ( uint256 _registrationFee ) public onlyOwner { require ( registrationFee != _registrationFee ) ; emit LogChangePolyRegisterationFee ( registrationFee , _registrationFee ) ; registrationFee = _registrationFee ; }",set the ticker registration fee in POLY tokens
522,"function initLogo ( ) public onlyOwner { require ( isLogoInitied == false ) ; isLogoInitied = true ; logoId = token . mint ( platformWallet , logoX , logoY , 10 , 10 , 0 ether , 0 ether ) ; token . setTokenMetadata ( logoId , """" ) ; updateTierStatus ( 100 , 0 ) ; emit Minted ( msg . sender , logoId , logoX , logoY , 10 , 10 , 0 ether , 0 ether , now ) ; }","init logo , call it as soon as possible call it after setting platform in the token Logo is BigIOToken which has 1010 size and position in the center of map"
523,function symbolsCount ( ) public view returns ( uint ) { return symbols . length ; },Provides a cheap way to get number of symbols registered in a platform
525,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _transferFrom ( _from , _to , _tokenId ) ; }","Transfer a Asset owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
527,"function USDtoHAV ( uint usd_dec ) public view priceNotStale returns ( uint ) { return safeDiv_dec ( usd_dec , price ) ; }",The value in HAV for a given amount of USD
528,"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""DWP"" ; }","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata ."
529,"function founderSwitchRequest ( bytes32 _founderHash , bytes32 _oneTimesharedPhrase ) returns ( bool success ) { if ( sha3 ( _founderHash ) != founderHash ) throw ; tempHashes [ msg . sender ] = sha3 ( msg . sender , founderHash , _oneTimesharedPhrase ) ; FounderSwitchRequestEvent ( msg . sender ) ; return true ; }",Founder address update to ` _newFounderAddr.address ( ) ` is being requested
530,"function setApprovalForAll ( address _to , bool _approved ) public validAddress ( _to ) { require ( _to != msg . sender , ""Cannot approve self"" ) ; operatorApprovals [ msg . sender ] [ _to ] = _approved ; emit ApprovalForAll ( msg . sender , _to , _approved ) ; }",Set or unset the approval of operator ` ( _to ) `
532,"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = hashIdToMultisig [ msigId ] ; assert ( multisig . deposit + msg . value >= multisig . deposit ) ; multisig . deposit += msg . value ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }",Deposit msg.value ether into a multisig and set unlockTime
533,function orderPriority ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . priority ; },returns the priority of the given orderID .
534,function tweakUpgrading ( ) external onlyOwner { upgrading = ! upgrading ; Upgrading ( upgrading ) ; },Enable upgrading to allow tokens migration to new contract process .
535,"function move ( address _from , address _to , uint256 _amount ) external onlyModule returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; emit BalanceAdj ( msg . sender , _from , _amount , ""-"" ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit BalanceAdj ( msg . sender , _to , _amount , ""+"" ) ; return true ; }",moving ` _amount ` from ` _from ` to ` _to `
537,"function manuallyExchangeContractPreDGZtoDGZ ( address _address , uint preDGZAmount ) public onlyOwner { require ( _address != address ( 0 ) ) ; require ( preDGZAmount > 0 ) ; uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ _address ] += preDGZAmount ; tokenReward . transfer ( _address , amountSendTokens ) ; }",This function is needed to handled unlikely case when person who owns preDGZ tokens makes a mistake and send them to smartcontract without setting the allowance in advance .
538,"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
539,"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( 'dispensationPct' ) || keccak256 ( _name ) == keccak256 ( 'pDispensationPct' ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }",propose a reparamaterization of the key _name 's value to _value .
542,"function maxIssuableNomins ( address issuer ) view public priceNotStale returns ( uint ) { if ( ! isIssuer [ issuer ] ) { return 0 ; } if ( escrow != HavvenEscrow ( 0 ) ) { uint totalOwnedHavvens = safeAdd ( tokenState . balanceOf ( issuer ) , escrow . balanceOf ( issuer ) ) ; return safeMul_dec ( HAVtoUSD ( totalOwnedHavvens ) , issuanceRatio ) ; } else { return safeMul_dec ( HAVtoUSD ( tokenState . balanceOf ( issuer ) ) , issuanceRatio ) ; } }",The maximum nomins an issuer can issue against their total havven quantity .
543,"function name ( ) external pure returns ( string _name ) { return ""BlockchainCuties"" ; }",A descriptive name for a collection of NFTs in this contract
544,"function setAllowPrimaryIssuance ( bool _allowPrimaryIssuance ) public withPerm ( ADMIN ) { require ( _allowPrimaryIssuance != allowPrimaryIssuance , ""Must change setting"" ) ; allowPrimaryIssuance = _allowPrimaryIssuance ; emit SetAllowPrimaryIssuance ( _allowPrimaryIssuance , now ) ; }",sets whether or not to consider primary issuance transfers
545,"function removeBeneficiary ( address beneficiary ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( info . known , ""The address you are trying to remove is unknown to the contract"" ) ; _release ( beneficiary ) ; info . known = false ; info . totalAmount = 0 ; info . receivedAmount = 0 ; info . startTime = 0 ; info . releaseTime = 0 ; }","Remove a beneficiary from the contract , preventing them from retrieving tokens in the future ."
547,"function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; }",send everything to the new ( fixed ) ico smart contract
549,function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; },Get a description of the attribute type with ID ` attributeTypeID ` .
551,function refundable ( bytes32 _swapID ) external view returns ( bool ) { return ( now >= swaps [ _swapID ] . timelock && swapStates [ _swapID ] == States . OPEN ) ; },Checks whether a swap is refundable or not .
552,function freezeGame ( uint gameId ) external onlyOwner whenGameIsOpen ( gameId ) { games [ gameId ] . state = GameStates . Frozen ; emit GameHasFrozen ( gameId ) ; },We use this function to froze a game
553,"function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
554,"function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from ) ; uint256 tokenIndex = ownedTokensIndex [ _tokenId ] ; uint256 lastTokenIndex = balanceOf ( _from ) . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; tokenOwner [ _tokenId ] = 0 ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] [ lastTokenIndex ] = 0 ; ownedTokens [ _from ] . length -- ; ownedTokensIndex [ _tokenId ] = 0 ; ownedTokensIndex [ lastToken ] = tokenIndex ; totalTokens = totalTokens . sub ( 1 ) ; }",Internal function to remove a token ID from the list of a given address
557,function setup ( address _tokenAddress ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _tokenAddress != 0x0 ) ; token = xChaingeToken ( _tokenAddress ) ; numTokensAuctioned = token . balanceOf ( address ( this ) ) ; tokenMultiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; },Set ` _tokenAddress ` as the token address to be used in the auction .
558,"function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory standardBorrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; ( Error err2 , uint finalBorrowRate ) = div ( standardBorrowRate . mantissa , 2 ) ; assert ( err2 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , finalBorrowRate ) ; }","Gets the current borrow interest rate based on the given asset , total cash and total borrows"
559,"function addToken ( bytes32 _name32 , bytes32 _symbol32 , bytes32 _fiatCurrency32 , address _custodian , uint256 _totalSupply , uint256 _startTimeForFundingPeriod , uint256 _durationForFiatFundingPeriod , uint256 _durationForEthFundingPeriod , uint256 _durationForActivationPeriod , uint256 _fundingGoalInCents ) public onlyActiveBroker returns ( address ) { address _tokenAddress = createPoaTokenProxy ( ) ; IPoaToken ( _tokenAddress ) . initializeToken ( _name32 , _symbol32 , msg . sender , _custodian , registry , _totalSupply ) ; IPoaCrowdsale ( _tokenAddress ) . initializeCrowdsale ( _fiatCurrency32 , _startTimeForFundingPeriod , _durationForFiatFundingPeriod , _durationForEthFundingPeriod , _durationForActivationPeriod , _fundingGoalInCents ) ; tokenMap [ _tokenAddress ] = addEntity ( _tokenAddress , tokenAddressList , false ) ; emit TokenAdded ( _tokenAddress ) ; return _tokenAddress ; }","Creates a PoaToken contract with given parameters , and set active value to false"
560,"function revealCurve ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( curves [ revealedCurves ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCurves > 0 ) { require ( _limit >= curves [ revealedCurves . sub ( 1 ) ] . limit ) ; } curves [ revealedCurves ] . limit = _limit ; curves [ revealedCurves ] . slopeFactor = _slopeFactor ; curves [ revealedCurves ] . collectMinimum = _collectMinimum ; revealedCurves = revealedCurves . add ( 1 ) ; if ( _last ) allRevealed = true ; }",Anybody can reveal the next curve if he knows it .
561,"function registerSecret ( bytes32 secret ) public returns ( bool ) { bytes32 secrethash = keccak256 ( abi . encodePacked ( secret ) ) ; if ( secret == bytes32 ( 0x0 ) || secrethash_to_block [ secrethash ] > 0 ) { return false ; } secrethash_to_block [ secrethash ] = block . number ; emit SecretRevealed ( secrethash , secret ) ; return true ; }",Registers a hash time lock secret and saves the block number .
562,"function updateLandData ( uint256 id , string data ) external returns ( bool ) { Mortgage memory mortgage = mortgages [ id ] ; require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; int256 x ; int256 y ; ( x , y ) = land . decodeTokenId ( mortgage . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }",Enables the owner of a parcel to update the data field
564,"function shutForETH ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; gem . withdraw ( min ( gemBalance , gem . balanceOf ( this ) ) ) ; msg . sender . transfer ( min ( gemBalance , address ( this ) . balance ) ) ; }",Shuts a CDP and returns the value in the form of ETH .
565,"function removeAddressesFromWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , ""Cannot remove an empty list to whitelist!"" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = false ; emit WhitelistRemoved ( user ) ; } } }",Removes a list of addresses from the whitelist .
566,"function approve ( address _spender , uint _value ) public returns ( bool success ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",You must set the allowance to zero before changing to a non-zero value
567,"function addTokensToAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused public returns ( bool ) { registerAccount ( _uuid ) ; balances [ _uuid ] = balances [ _uuid ] . add ( _tokensCount ) ; tokens = tokens . add ( _tokensCount ) ; return true ; }",Function for adding tokens to specified account .
568,"function purchaseTokens ( ) saleStarted saleNotEnded payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; token . transfer ( msg . sender , tokenPurchase ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }",You 're about to purchase the equivalent of ` msg.value ` Wei in tokens
570,"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with token"" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; addMasternode ( msg . sender ) ; }",Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
571,"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
572,"function transferOutEth ( ) public onlyAdmin returns ( bool ) { uint256 balance = address ( this ) . balance ; msg . sender . transfer ( address ( this ) . balance ) ; emit EthTransferOut ( msg . sender , balance ) ; return true ; }","Transfers eth that is stuck in this contract ETH can be sent to the address this contract resides at before the contract is deployed A contract can be suicided , forcefully sending ether to this contract"
573,"function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner , ""wrong owner"" ) ; if ( tokenApprovals [ _tokenId ] != 0 ) { tokenApprovals [ _tokenId ] = 0 ; emit Approval ( _owner , 0 , _tokenId ) ; } }",Internal function to clear current approval of a given token ID
574,function uintToBytes ( uint256 i ) public view returns ( bytes32 b ) { b = bytes32 ( i ) ; },Converts a uint256 type variable to a byte32 type variable Mostly used internaly
575,"function collectTokens ( ) public onlyOwner { uint256 balance = snt . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 24 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( snt . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }",The Dev ( Owner ) will call this method to extract the tokens
576,function getOwnerOfCampaign ( bytes32 bidId ) public view returns ( address campaignOwner ) { return advertisementStorage . getCampaignOwnerById ( bidId ) ; },Get the owner of a campaign Based on the Campaign id return the address of the campaign owner
578,function getAbilitiesForCollectibleId ( uint256 _tokenId ) external view returns ( uint256 ability ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 _attributes = uint256 ( obj . attributes ) ; ability = ( _attributes % 1000 ) ; },Returns the ability of an asset/collectible/token from attributes .
580,"function release ( ) public { require ( block . timestamp >= releaseTime , ""Release time must pass"" ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 , ""Contract must hold any tokens"" ) ; require ( token . transfer ( beneficiary , amount ) , ""Transfer must succeed"" ) ; }",Transfers tokens held by timelock to beneficiary .
584,"function buy ( ) payable public { require ( buyMultiplier > 0 ) ; uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }","Buy tokens from contract by sending ether , with ` data ` = ` 0xa6f2ae3a ` ."
585,"function holdersByIndices ( uint256 low , uint256 up , bool posOnly ) public view returns ( address [ ] ) { require ( low <= up ) ; up = up > holders . length - 1 ? holders . length - 1 : up ; uint256 length = 0 ; if ( posOnly ) { for ( uint256 i = low ; i <= up ; i ++ ) if ( 0 < balanceOf ( holders [ i ] ) ) length ++ ; } else length = up - low + 1 ; address [ ] memory _holders = new address [ ] ( length ) ; uint256 j = 0 ; for ( i = low ; i <= up ; i ++ ) if ( ! posOnly || 0 < balanceOf ( holders [ i ] ) ) _holders [ j ++ ] = holders [ i ] ; return _holders ; }",Get the subset of holders ( optionally with positive balance only ) in the given 0 based index range
586,"function changeSupportRequiredPct ( uint64 _supportRequiredPct ) external authP ( MODIFY_SUPPORT_ROLE , arr ( uint256 ( _supportRequiredPct ) , uint256 ( supportRequiredPct ) ) ) { require ( minAcceptQuorumPct <= _supportRequiredPct , ERROR_CHANGE_SUPPORT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_CHANGE_SUPPORT_TOO_BIG ) ; supportRequiredPct = _supportRequiredPct ; emit ChangeSupportRequired ( _supportRequiredPct ) ; }",Change required support to ` @ formatPct ( _supportRequiredPct ) ` %
587,function motionConfirming ( uint motionID ) public view returns ( bool ) { uint startTime = motionStartTime [ motionID ] ; return startTime + votingPeriod <= now && now < startTime + votingPeriod + confirmationPeriod ; },"A vote on the target account has concluded , but the motion has not yet been approved , vetoed , or closed ."
590,"function claimHalvingsSubsidies ( uint256 _n ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { Miner miner = miners [ msg . sender ] ; uint256 start = blockHalving ( miner . block ) ; uint256 end = start . add ( _n ) ; if ( end > currentHalving ( ) ) { return 0 ; } uint256 subsidy = 0 ; uint256 totalSubsidy = 0 ; uint256 unclaimed = 0 ; uint256 hashRate = 0 ; uint256 K ; for ( K = start ; K < end && K < maxHalvings ; K ++ ) { HalvingHashRate halvingHashRate = halvingsHashRate [ K ] ; if ( ! halvingHashRate . carried ) { halvingHashRate . carried = true ; halvingHashRate . rate = halvingHashRate . rate . add ( halvingsHashRate [ K - 1 ] . rate ) ; } MinerHashRate minerHashRate = miner . hashRate [ K ] ; if ( ! minerHashRate . carried ) { minerHashRate . carried = true ; minerHashRate . rate = minerHashRate . rate . add ( miner . hashRate [ K - 1 ] . rate ) ; } hashRate = minerHashRate . rate ; if ( hashRate != 0 ) { if ( K == currentHalving ( ) . sub ( 1 ) ) { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { continue ; } } Subsidy sub = halvingsSubsidies [ K ] ; if ( ! sub . claimed ) { sub . claimed = true ; sub . value = halvingSubsidy ( K ) ; } unclaimed = sub . value ; subsidy = halvingSubsidy ( K ) . mul ( hashRate ) . div ( halvingHashRate . rate ) ; if ( subsidy > unclaimed ) { subsidy = unclaimed ; } totalSubsidy = totalSubsidy . add ( subsidy ) ; sub . value = sub . value . sub ( subsidy ) ; LogClaimHalvingSubsidy ( msg . sender , miner . block , K , subsidy ) ; LogRemainingHalvingSubsidy ( K , sub . value ) ; } miner . block = miner . block . add ( subsidyHalvingInterval ) ; } if ( K < end ) { miner . block = miner . block . add ( subsidyHalvingInterval . mul ( end . sub ( K ) ) ) ; } if ( totalSubsidy != 0 ) { balances [ msg . sender ] = balances [ msg . sender ] . add ( totalSubsidy ) ; totalSupply = totalSupply . add ( totalSubsidy ) ; } return totalSubsidy ; }",Miners subsidies must be claimed by the miners calling claimHalvingsSubsidies ( _n )
591,function getAllListings ( ) public view returns ( uint64 [ ] ) { return forSalePixelconIndexes ; },Get all PixelCon indexes being sold on the market
596,"function normalizePledge ( uint64 idPledge ) returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; if ( p . pledgeState != PledgeState . Pledged ) { return idPledge ; } if ( ( p . intendedProject > 0 ) && ( getTime ( ) > p . commitTime ) ) { uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( p . intendedProject , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , p . amount ) ; idPledge = toPledge ; p = findPledge ( idPledge ) ; } toPledge = getOldestPledgeNotCanceled ( idPledge ) ; if ( toPledge != idPledge ) { doTransfer ( idPledge , toPledge , p . amount ) ; } return toPledge ; }",` normalizePledge ` only affects pledges with the Pledged PledgeState and does 2 things : # 1 : Checks if the pledge should be committed .
597,function getPermissions ( ) external view returns ( bytes32 [ ] ) ;,Return the permission flags that are associated with a module
598,"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1508840297 ) ; }",Send ` _value ` tokens to ` _to ` from your account
604,"function issueAssetWithInitialReceiver ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; add ( store , symbolsStorage , _symbol ) ; set ( store , assetOwnerIdStorage , _symbol , creatorId ) ; set ( store , assetTotalSupply , _symbol , _value ) ; set ( store , assetName , _symbol , _name ) ; set ( store , assetDescription , _symbol , _description ) ; set ( store , assetIsReissuable , _symbol , _isReissuable ) ; set ( store , assetBaseUnit , _symbol , _baseUnit ) ; set ( store , assetWalletBalance , _symbol , holderId , _value ) ; set ( store , assetBlockNumber , _symbol , _blockNumber ) ; _emitter ( ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }",Issues new asset token on the platform .
605,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
606,"function buy ( uint32 _x , uint16 _y , uint32 _sizeSkin , bytes16 _names , bytes32 _message ) external payable returns ( uint ) { _checks ( _x , _y , _sizeSkin ) ; uint id = locks . push ( Lock ( msg . sender , _x , _y , _sizeSkin , _names , _message , block . timestamp ) ) - 1 ; Buy ( id , msg . sender , _x , _y , _sizeSkin , _names , _message ) ; return id ; }",Locks must be purchased in 20x20 pixel blocks .
607,"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,uint256,uint256,uint256,uint8[],address)"" ) ) ; }",This function returns the signature of configure function
609,function isReadyToBreed ( uint256 _dogId ) public view returns ( bool ) { require ( _dogId > 1 ) ; Dog storage dog = dogs [ _dogId ] ; return _isReadyToBreed ( dog ) ; },Checks that a given kitten is able to breed ( i.e .
614,"function mateWithAuto ( uint256 _matronId , uint256 _sireId , uint8 _incubator , bytes _sig ) external payable whenNotPaused { require ( msg . value >= autoBirthFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isMatingPermitted ( _sireId , _matronId ) ) ; Pony storage matron = ponies [ _matronId ] ; require ( _isReadyToMate ( matron ) ) ; Pony storage sire = ponies [ _sireId ] ; require ( _isReadyToMate ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; if ( _incubator == 0 && hasIncubator [ msg . sender ] ) { _mateWith ( _matronId , _sireId , _incubator ) ; } else { bytes32 hashedTx = getIncubatorHashing ( msg . sender , _incubator , nonces [ msg . sender ] ) ; require ( signedBySystem ( hashedTx , _sig ) ) ; nonces [ msg . sender ] ++ ; if ( ! hasIncubator [ msg . sender ] ) { hasIncubator [ msg . sender ] = true ; } _mateWith ( _matronId , _sireId , _incubator ) ; } }","Breed a Pony you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval ."
615,"function editClass ( uint256 _classId , string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ _classId ] ; _itemClass . name = _name ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . amount = _amount ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . price = _price ; }",All links inside the _hostfile string has to be seperated by commas .
618,"function addressAndBalance ( ) constant returns ( address sender , address receiver , uint balance ) { sender = data . sender ; receiver = data . receiver ; balance = data . balance ; }",Get the address and balance of both partners in a channel .
619,"function list ( ) public view returns ( address [ ] , uint256 [ ] ) { address [ ] memory addrs = new address [ ] ( accountCount ) ; uint256 [ ] memory tokens = new uint256 [ ] ( accountCount ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { addrs [ i ] = current ; tokens [ i ] = balances [ current ] ; current = addressLinkedList [ current ] ; i ++ ; } return ( addrs , tokens ) ; }",Return a list of addresses and their tokens
620,"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }",Token owner can approve for spender to transferFrom ( ... ) tokens from the token owner 's account
622,function paid ( address who ) public constant returns ( bool ) { return s_paid [ who ] . length > 0 ; },Returns whether the given address paid or not
623,"function appendEncryptedBid ( bytes32 _bid_hash , uint price_index ) public onlyOwner returns ( uint index ) { require ( status == state . active ) ; uint art_price ; uint art_price_blockHeight ; ( art_price , art_price_blockHeight ) = oracle . getHistoricalPrice ( price_index ) ; bids [ bids_count ] = Bid ( _bid_hash , art_price , price_index , true , false , false , false ) ; index = bids_count ; emit BidAdded ( bids_count ++ ) ; }",Append an encrypted bid to the auction .
625,"function _teamTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; teamFreezed [ _to ] = teamFreezed [ _to ] . add ( cst ) ; }",_freezeTranfer perform actual tokens transfer which will be freezed ( see also checkTransfer ( ) )
627,"function debtBalanceOf ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetixState . issuanceData ( issuer ) ; if ( initialDebtOwnership == 0 ) return 0 ; uint currentDebtOwnership = synthetixState . lastDebtLedgerEntry ( ) . divideDecimalRoundPrecise ( synthetixState . debtLedger ( debtEntryIndex ) ) . multiplyDecimalRoundPrecise ( initialDebtOwnership ) ; uint totalSystemValue = totalIssuedSynths ( currencyKey ) ; uint highPrecisionBalance = totalSystemValue . decimalToPreciseDecimal ( ) . multiplyDecimalRoundPrecise ( currentDebtOwnership ) ; return highPrecisionBalance . preciseDecimalToDecimal ( ) ; }","If a user issues synths backed by SNX in their wallet , the SNX become locked ."
628,"function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }",Withdraw ether and delete the htlc swap .
629,"function calculateGrantClaim ( uint256 _grantId ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _grantId ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint elapsedDays = elapsedTime . div ( SECONDS_PER_DAY ) ; if ( elapsedDays < tokenGrant . vestingCliff ) { return ( elapsedDays , 0 ) ; } if ( elapsedDays >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint256 daysVested = elapsedDays . sub ( tokenGrant . daysClaimed ) ; uint256 amountVestedPerDay = tokenGrant . amount . div ( uint256 ( tokenGrant . vestingDuration ) ) ; uint256 amountVested = uint256 ( daysVested . mul ( amountVestedPerDay ) ) ; return ( daysVested , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached"
631,"function grantPermission ( address _entity , address _app , bytes32 _role ) external { grantPermissionP ( _entity , _app , _role , new uint256 [ ] ( 0 ) ) ; }",Grants ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
632,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; lendersBalance [ loan . lender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered ."
633,"function modifyWhitelistMulti ( address [ ] _investors , bool [ ] _valids ) public withPerm ( WHITELIST ) { require ( _investors . length == _valids . length , ""Input array length mis-match"" ) ; for ( uint i = 0 ; i < _investors . length ; i ++ ) { modifyWhitelist ( _investors [ i ] , _valids [ i ] ) ; } }",adds or removes addresses from the whitelist .
635,"function getKYCApproval ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }",Get KYC approval status for the account holder
636,"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }",Restriction : An account can only use this function to send to itself
637,"function transferByForce ( address _from , address _to , uint _value ) external onlyOwner { _transfer ( _from , _to , _value ) ; }",Transfer anyone 's tokens to a different account can only be called by the smart contract owner
640,"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return _allowed [ _owner ] [ _spender ] ; }",Returns the amount which ` _spender ` is still allowed to withdraw from ` _owner ` .
641,function price ( ) public constant returns ( uint256 ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; },"Get the GOT price in WEI during the auction , at the time of calling this function ."
645,"function unsetAddressAlias ( address addr ) public onlyRole ( roleAddressAliaser ( ) ) { setAddressAliasUnsafe ( 0 , addr ) ; }",Change an address to no longer alias to anything else .
649,"function depositStake ( uint256 _numRTC ) public stakingEnabled ( _numRTC ) returns ( bool ) { uint256 stakeCount = getStakeCount ( msg . sender ) ; ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) = calculateStake ( _numRTC ) ; StakeStruct memory ss = StakeStruct ( { initialStake : _numRTC , blockLocked : blockLocked , blockUnlocked : blockReleased , releaseDate : releaseDate , totalCoinsToMint : totalCoinsMinted , coinsMinted : 0 , rewardPerBlock : rewardPerBlock , lastBlockWithdrawn : blockLocked , state : StakeStateEnum . staking } ) ; stakes [ msg . sender ] [ stakeCount ] = ss ; numberOfStakes [ msg . sender ] = numberOfStakes [ msg . sender ] . add ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . add ( _numRTC ) ; activeStakes = activeStakes . add ( 1 ) ; emit StakeDeposited ( msg . sender , stakeCount , totalCoinsMinted , releaseDate , blockReleased ) ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _numRTC ) , ""transfer from failed, likely needs approval"" ) ; return true ; }",This is used to deposit coins and start staking with at least one RTC
650,"function processPreSale ( address _caller ) private { var ( allowedContribution , refundAmount ) = processContribution ( ) ; require ( msg . value == allowedContribution . add ( refundAmount ) ) ; if ( allowedContribution > 0 ) { doBuy ( _caller , allowedContribution ) ; if ( refundAmount > 0 ) { msg . sender . transfer ( refundAmount ) ; } } else { revert ( ) ; } }",Processes the presale if the allowed contribution is more than zero
653,"function increaseApproval ( address _spender , uint256 _addedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _increaseApproval ( _spender , _addedValue , msg . sender ) ; return true ; }",increaseApproval should be used instead of approve when the user 's allowance is greater than 0 .
654,function availableTokens ( ) public view returns ( uint ) { uint256 timeAfterMint = now . sub ( lastMintTime ) ; uint256 refillAmount = rate . mul ( timeAfterMint ) . add ( leftOnLastMint ) ; return size < refillAmount ? size : refillAmount ; },Function to calculate and get available in bucket tokens
655,"function markMilestoneComplete ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }",` onlyRecipientOrLeadLink ` Marks a milestone as DONE and ready for review
656,function calculateWinners ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . LimitSet ) { require ( amount + lastCheckedToken <= tokens . length ) ; uint256 points = tokenToPointsMap [ pointsLimit ] ; for ( uint256 i = lastCheckedToken ; i < lastCheckedToken + amount ; i ++ ) { if ( tokenToPointsMap [ i ] > points || ( tokenToPointsMap [ i ] == points && i <= pointsLimit ) ) { winnerCounter ++ ; } } lastCheckedToken += amount ; if ( lastCheckedToken == tokens . length ) { require ( superiorQuota == winnerCounter ) ; pValidationState = pointsValidationState . LimitCalculated ; } },Sets the 10th percentile of the sorted array of points
659,function setUrl ( string _url ) public onlyOwner returns ( bool ) { infoUrl = _url ; return true ; },Sets the URL where the oracleData can be retrieved
661,"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }",Transfer the specified amount of tokens to the specified address .
662,function beneficiaryExists ( address _beneficiary ) internal view returns ( bool ) { return beneficiaryDistributionContracts [ _beneficiary ] . length > 0 ; },Checks if a beneficiary was added to the pool at least once .
665,"function getDarknodesFromEpochs ( address _start , uint256 _count , bool _usePreviousEpoch ) private view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodes ; } address [ ] memory nodes = new address [ ] ( count ) ; uint256 n = 0 ; address next = _start ; if ( next == 0x0 ) { next = store . begin ( ) ; } while ( n < count ) { if ( next == 0x0 ) { break ; } bool includeNext ; if ( _usePreviousEpoch ) { includeNext = isRegisteredInPreviousEpoch ( next ) ; } else { includeNext = isRegistered ( next ) ; } if ( ! includeNext ) { next = store . next ( next ) ; continue ; } nodes [ n ] = next ; next = store . next ( next ) ; n += 1 ; } return nodes ; }",Returns a list of darknodes registered for either the current or the previous epoch .
674,"function getDank ( uint256 _tokenId ) public view returns ( string dankName , uint256 sellingPrice , address owner ) { Dank storage dank = danks [ _tokenId ] ; dankName = dank . name ; sellingPrice = dankIndexToPrice [ _tokenId ] ; owner = dankIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific dank .
677,function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; },Allows the current owner to transfer control of the contract to a newOwner .
681,function updateDelayTime ( uint256 _newDelay ) public onlyGameManager whenNotPaused { BID_DELAY_TIME = _newDelay ; },Function helps to update the delay time for bidding
682,"function transferFrom ( address _from , address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( ! frozenAccounts [ _from ] && ! frozenAccounts [ _to ] ) ; require ( tradable ) ; if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; balances [ _to ] += _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }",Allows allowed third party to transfer tokens from one address to another .
683,function getDividendIndex ( uint256 _checkpointId ) public view returns ( uint256 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < dividends . length ; i ++ ) { if ( dividends [ i ] . checkpointId == _checkpointId ) { counter ++ ; } } uint256 [ ] memory index = new uint256 [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < dividends . length ; j ++ ) { if ( dividends [ j ] . checkpointId == _checkpointId ) { index [ counter ] = j ; counter ++ ; } } return index ; },Get the index according to the checkpoint id
686,"function canImplementInterfaceForAddress ( address addr , bytes32 interfaceHash ) public view returns ( bytes32 ) ;",Indicates whether the contract implements the interface ` interfaceHash ` for the address ` addr ` or not .
687,"function changeManufacturerWallet ( address _new ) public onlyManufacturer returns ( bool ) { require ( _new != address ( 0 ) , ""new address cannot be 0x0"" ) ; NetworkMember memory old = network [ msg . sender ] ; require ( old . isManufacturer && old . memberId != 0 , ""must be a manufacturer"" ) ; require ( ! network [ _new ] . isIRNAdmin , ""already an irn admin"" ) ; require ( ! network [ _new ] . isManufacturer , ""already a manufacturer"" ) ; require ( ! network [ _new ] . isIRNNode , ""already an irn node"" ) ; require ( network [ _new ] . memberId == 0 , ""memberId already exists"" ) ; network [ _new ] = NetworkMember ( old . isIRNAdmin , old . isManufacturer , old . isIRNNode , old . memberId ) ; require ( pools [ _new ] . balance == 0 && pools [ _new ] . rewardAmount == 0 , ""new token pool already exists"" ) ; pools [ _new ] . balance = pools [ msg . sender ] . balance ; pools [ _new ] . rewardAmount = pools [ msg . sender ] . rewardAmount ; delete pools [ msg . sender ] ; manufacturerRewards [ old . memberId ] = _new ; delete network [ msg . sender ] ; emit ManufacturerRewardWalletChanged ( msg . sender , _new , old . memberId ) ; return true ; }",changes the ethereum wallet for a manufacturer used in reputation rewards
689,"function setPreAmounts ( uint256 mtdPreAmountInWei , uint256 ethPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( ethPreAmountInWei > 0 ) ; mtdPreAmount = mtdPreAmountInWei ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }",Set both ethPreAmount and mtdPreAmount at the same time
691,"function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) ;",Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .
694,function withdraw ( address addr ) onlyOwner public { addr . transfer ( address ( this ) . balance ) ; },Withdraw any accumulated fees to the specified address
696,"function claimTokens ( address _claimtoken ) onlyOwner public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
698,"function approveAndCall ( address spender , uint256 tokens , bytes data ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }",Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account .
699,"function requestVotingRights ( uint _numTokens ) public { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; emit _VotingRightsGranted ( _numTokens , msg . sender ) ; }",Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
700,"function supply ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . SUPPLY_CONTRACT_PAUSED ) ; } Market storage market = markets [ asset ] ; Balance storage balance = supplyBalances [ msg . sender ] [ asset ] ; SupplyLocalVars memory localResults ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . SUPPLY_MARKET_NOT_SUPPORTED ) ; } err = checkTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( balance . principal , balance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyUpdated ) = add ( localResults . userSupplyCurrent , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalSupply ) = addThenSub ( market . totalSupply , localResults . userSupplyUpdated , balance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = add ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalSupply = localResults . newTotalSupply ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = balance . principal ; balance . principal = localResults . userSupplyUpdated ; balance . interestIndex = localResults . newSupplyIndex ; emit SupplyReceived ( msg . sender , asset , amount , localResults . startingBalance , localResults . userSupplyUpdated ) ; return uint ( Error . NO_ERROR ) ; }",supply ` amount ` of ` asset ` ( which must be supported ) to ` msg.sender ` in the protocol
702,function blockPendingTx ( uint _txIdx ) returns ( bool ) ;,Block a pending transaction with id ` _txIdx ` .
703,function collectMilestonePayment ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; doPayment ( _idMilestone ) ; },` onlyRecipient ` Sends the milestone payment as specified in ` payData ` ; the recipient can only call this after the ` reviewTime ` has elapsed
706,"function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( shitFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimSHIT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }",Create ` msg.value ` ETH worth of SHIT
707,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _value <= allowed [ _from ] [ msg . sender ] , ""requesting more token than allowed"" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; return true ; }",Transfer tokens from one address to another .
709,"function getTokenFrozenBalance ( Data storage self , string currency , address account ) internal view returns ( uint frozenBalance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }",Get the frozen token balance for a given account
710,"function icoBuy ( ) public icoPhase ( ) payable isActive { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balanceOf [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; }",Please make sure that ICO Pool is at least equal to your bid
711,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) ;",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
712,function proxyPayment ( address _owner ) payable public returns ( bool ) { doPayment ( _owner ) ; return true ; },` proxyPayment ( ) ` allows the caller to send ether to the Token directly and have the tokens created in an address of their choosing
714,"function transfer ( address destination , uint256 amount ) public tradable ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }",Transfers ` amount ` from msg.sender to ` destination `
715,"function setCampaignEndPointById ( bytes32 _bidId , string _endPoint ) public onlyIfCampaignExists ( ""setCampaignEndPointById"" , _bidId ) onlyIfWhitelisted ( ""setCampaignEndPointById"" , msg . sender ) { campaignEndPoints [ _bidId ] = _endPoint ; emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; }",Set campaign signing web service endpoint Sets the webservice 's endpoint to which the user should submit the proof of attention
716,"function transfer ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }",Transfers the ownership of a given token ID to another address
717,function getTopBidders ( ) external view returns ( address [ 100 ] ) { address [ 100 ] memory tempArray ; for ( uint i = 0 ; i < 100 ; ++ i ) { tempArray [ i ] = _topBids [ i ] . bidderAddress ; } return tempArray ; },Returns a sorted array of the top 100 bidders
718,"function transferAnyERC20Token ( address _tokenAddress , uint256 _amount ) onlyOwner public returns ( bool success ) { return AumonetERC223 ( _tokenAddress ) . transfer ( owner , _amount ) ; }",Allows the owner to transfer out any accidentally sent ERC20 tokens .
720,function setTokenURIBase ( string _tokenURI ) public anyOperator { _setTokenURIBase ( _tokenURI ) ; },"The user/developper needs to add the tokenID , in the end of URL , to use the URI and get all details ."
722,"function pause ( ) external whenNotPaused onlyOwner { set ( PAUSED , true ) ; emit Pause ( now ) ; }","Called by the owner to pause , triggers stopped state"
723,function price ( ) public view returns ( uint256 _price ) { return tokenPerEth ; },Calculates the price as tokens/ether based on the corresponding bonus bracket .
724,"function getTribalMask ( uint256 _tokenId ) public view returns ( string maskName , uint256 basePrice , uint256 currentPrice , address currentOwner ) { TribalMask storage mask = tribalMasks [ _tokenId ] ; maskName = mask . name ; basePrice = mask . basePrice ; currentPrice = priceOf ( _tokenId ) ; currentOwner = tokenIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific token .
725,function isCompetitionAllowed ( address user ) view returns ( bool ) { return isWhitelisted [ user ] ; },Checks whether an address is whitelisted in the competition contract and competition is active
727,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ponyIndexToOwner [ _tokenId ] ; },Returns the address currently assigned ownership of a given Pony .
728,"function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;",Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
730,"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,uint256,uint256,uint256,uint8,address)"" ) ) ; }",This function returns the signature of configure function
731,function enableTransfers ( ) public onlyWhitelisted { require ( icoEndDate > 0 ) ; require ( now >= icoEndDate ) ; require ( ! transfersEnabled ) ; transfersEnabled = true ; },This function enables token transfers for everyone .
732,"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) external ;",Used by a controller to execute a forced transfer
734,"function setDelegateAndLockTokens ( uint tokensToLock , address delegate ) public onlyShareholders onlyUndelegated notSelf { lockedDelegatingTokens [ msg . sender ] = tokensToLock ; delegatedAmountsByDelegate [ delegate ] = SafeMath . add ( delegatedAmountsByDelegate [ delegate ] , tokensToLock ) ; totalLockedTokens = SafeMath . add ( totalLockedTokens , tokensToLock ) ; delegatesByDelegator [ msg . sender ] = delegate ; require ( sharesTokenAddress . transferFrom ( msg . sender , tokenLocker , tokensToLock ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensDelegated ( msg . sender , tokensToLock , delegate ) ; }","Set the delegate address for a specified number of tokens belonging to the sending address , locking the tokens ."
735,function blacklistEscapeToken ( address _token ) internal { escapeBlacklist [ _token ] = true ; EscapeHatchBlackistedToken ( _token ) ; },"Creates the blacklist of tokens that are not able to be taken out of the contract ; can only be done at the deployment , and the logic to add to the blacklist will be in the constructor of a child contract"
736,function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) ;,Returns the list of tokens owned by the selected address
739,"function symbol ( ) public pure returns ( string ) { return ""KCT"" ; }",An abbreviated name for NFTs in this contract
740,"function deposit ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Deposit ( currency , account , amount , issuerFirm ) ; return true ; }",Deposit an amount of currency into the Ethereum account holder
741,"function mintMulti ( address [ ] _investors , uint256 [ ] _values ) external returns ( bool success ) ;",Mints new tokens and assigns them to the target investors .
743,function powerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSEC_CREDITS_MINIMAL_AMOUNT ) ; contractPoweredUp = true ; },Check if pre-sale contract has enough Parsec credits on its account balance to reward all possible participations within pre-sale period and max cap
744,function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit AllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; },Used to change the flag true - It refers that time lock is ignored for issuances ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
745,function isSubscriptionProduct ( uint256 _productId ) public view returns ( bool ) { return intervalOf ( _productId ) > 0 ; },returns if this product is a subscription or not
747,"function mul ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , y ) , ( 10 ** 18 ) / 2 ) / ( 10 ** 18 ) ; }",This function multiplies two decimals represented as ( decimal 10DECIMALS )
748,function canBeSet ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; return ( now > prop . appExpiry && now < prop . processBy && prop . challengeID == 0 ) ; },Determines whether a proposal passed its application stage without a challenge
749,function createCDPLeveragedAllDai ( ) public returns ( bytes32 id ) { return createCDPLeveragedDai ( dai . balanceOf ( msg . sender ) ) ; },"create a CDP all the Dai in the sender 's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount )"
751,"function confirmProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . evaluator ) ; job . proofOfLastWorkVerified = true ; emit ProofOfWorkConfirmed ( _JobID , job . evaluator , true ) ; }",this function lets the evaluator confirm the proof of work provided by worker
752,"function execute ( bytes32 _buyID , bytes32 _sellID , address _buyer , address _seller , TokenPair memory _tokens ) private { SettlementDetails memory settlementDetails = ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID ) ? settlementDetails = calculateAtomicFees ( _buyID , _sellID , _tokens ) : settlementDetails = calculateSettlementDetails ( _buyID , _sellID , _tokens ) ; renExBalancesContract . transferBalanceWithFee ( _buyer , _seller , settlementDetails . leftTokenAddress , settlementDetails . leftVolume , settlementDetails . leftTokenFee , orderSubmitter [ _buyID ] ) ; renExBalancesContract . transferBalanceWithFee ( _seller , _buyer , settlementDetails . rightTokenAddress , settlementDetails . rightVolume , settlementDetails . rightTokenFee , orderSubmitter [ _sellID ] ) ; }","Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap ."
755,"function revokeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
756,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } },Returns all the loans that a lender possess
757,"function doInclusionChecks ( bytes prevTxBytes , bytes exitingTxBytes , bytes prevTxInclusionProof , bytes exitingTxInclusionProof , bytes signature , uint256 [ 2 ] blocks ) private view { if ( blocks [ 1 ] % childBlockInterval != 0 ) { checkIncludedAndSigned ( exitingTxBytes , exitingTxInclusionProof , signature , blocks [ 1 ] ) ; } else { checkBothIncludedAndSigned ( prevTxBytes , exitingTxBytes , prevTxInclusionProof , exitingTxInclusionProof , signature , blocks ) ; } }","If exitingTxBytes corresponds to a deposit transaction , prevTxBytes can not have a meaningul value and thus it is ignored ."
758,"function setTokenURI ( uint256 _tokenId , string _uri ) auth ( MINT_ROLE ) public { _setTokenURI ( _tokenId , _uri ) ; }","Set ` _uri ` for ` _tokenId ` ,"
760,"function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId = pow . gameItemId ; }",Returns all the relevant information about a specific pow .
761,function enableTransfers ( bool _transfersEnabled ) onlyController { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
762,function findEndpointByAddress ( address eth_address ) public view returns ( string endpoint ) { return address_to_endpoint [ eth_address ] ; },Finds the endpoint if given a registered Ethereum address .
766,"function newPayment ( address _token , address _receiver , uint256 _amount , uint64 _initialPaymentTime , uint64 _interval , uint64 _maxRepeats , string _reference ) external authP ( CREATE_PAYMENTS_ROLE , arr ( _token , _receiver , _amount , _interval , _maxRepeats ) ) transitionsPeriod returns ( uint256 paymentId ) { require ( _amount > 0 , ERROR_NEW_PAYMENT_AMOUNT_ZERO ) ; if ( _initialPaymentTime <= getTimestamp64 ( ) && _maxRepeats == 1 ) { _makePaymentTransaction ( _token , _receiver , _amount , NO_PAYMENT , 0 , _reference ) ; return ; } require ( settings . budgets [ _token ] >= _amount || ! settings . hasBudget [ _token ] , ERROR_BUDGET ) ; paymentId = paymentsNextIndex ++ ; emit NewPayment ( paymentId , _receiver , _maxRepeats , _reference ) ; Payment storage payment = payments [ paymentId ] ; payment . token = _token ; payment . receiver = _receiver ; payment . amount = _amount ; payment . initialPaymentTime = _initialPaymentTime ; payment . interval = _interval ; payment . maxRepeats = _maxRepeats ; payment . createdBy = msg . sender ; if ( nextPaymentTime ( paymentId ) <= getTimestamp64 ( ) ) { _executePayment ( paymentId ) ; } }","Create a new payment of ` @ tokenAmount ( _token , _amount ) ` to ` _receiver `` _maxRepeats > 0 ?"
769,function setEthAmount ( uint256 ethAmountInWei ) isOwner { require ( ethAmountInWei > 0 ) ; require ( ethAmount != ethAmountInWei ) ; ethAmount = ethAmountInWei ; updatePrices ( ) ; },Set current ethAmount price in wei for one token
771,function totalSupply ( ) public view returns ( uint256 ) { return elements . length ; },Returns the total number of tokens currently in existence .
772,function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( synthesizingAuction != address ( 0 ) ) ; require ( geneSynthesis != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This should be public rather than external .
778,function _pause ( ) internal { require ( ! paused ) ; paused = true ; emit Pause ( now ) ; },"called by the owner to pause , triggers stopped state"
779,function destroyAndSend ( address _recipient ) public onlyOwner { selfdestruct ( _recipient ) ; },Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the specified recipient address .
780,"function equals ( string a , string b ) internal pure returns ( bool result ) { if ( keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ) { return true ; } return false ; }",Checks if two strings are equal or not .
781,"function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard"
782,function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
783,"function getPendingReward ( ERC20 _token , address _holder ) public constant returns ( uint ) { uint acc = 0 ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( d . token == _token ) && ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { acc += d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } } return acc ; }",Calculates the amount of a given token ( or ether ) the holder can receive
787,function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { amountToGive = data . amountToGive ; },Gets the amount that TotlePrimary needs to give for this order
788,"function mint ( address _to , uint256 _amount ) public returns ( bool ) { require ( totalSupply ( ) . add ( _amount ) <= cap ) ; return super . mint ( _to , _amount ) ; }",Overrides original mint function from MintableToken to limit minting over cap
789,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
790,"function updateBrokerVerifierContract ( RenExBrokerVerifier _newBrokerVerifierContract ) external onlyOwner { emit LogBrokerVerifierContractUpdated ( brokerVerifierContract , _newBrokerVerifierContract ) ; brokerVerifierContract = _newBrokerVerifierContract ; }",Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .
791,"function reclaimToken ( address _token ) external onlyAdmin { ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }",Transfers all ERC20 tokens held by the contract to the owner .
792,function unpause ( ) public onlyAdmin whenPaused { require ( address ( saleAuction ) != address ( 0 ) ) ; require ( address ( sanctuary ) != address ( 0 ) ) ; require ( address ( battleProvider ) != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
793,"function addAddressToAccountFor ( address _newAddress , bytes _newAddressSig , bytes _senderSig , address _sender , bytes32 _nonce ) public onlyRegistryAdmin { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , _sender , _nonce ) ; }",Add an address to an existing id on behalf of a user to pay the gas costs
794,function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _getOwner ( ) ) ; _setOwner ( address ( 0 ) ) ; },Renouncing to ownership will leave the contract without an owner .
795,function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Store . balances ( _owner ) ; },Core logic of the ERC20 ` balanceOf ` function .
796,"function getPlayerRemainingTime ( uint boardId , PlayerColor color ) view external returns ( uint , uint , uint ) { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; uint timePeriods = getPlayerTimePeriods ( board , color ) ; uint totalTimeRemaining = timePeriods * PLAYER_TURN_SINGLE_PERIOD ; if ( color == board . nextTurnColor ) { uint timePeriodsUsed = getTimePeriodsUsed ( board . lastUpdate ) ; if ( timePeriods > timePeriodsUsed ) { timePeriods -= timePeriodsUsed ; } else { timePeriods = 0 ; } uint timeUsed = ( now - board . lastUpdate ) ; if ( totalTimeRemaining > timeUsed ) { totalTimeRemaining -= timeUsed ; } else { totalTimeRemaining = 0 ; } } return ( timePeriods , PLAYER_TURN_SINGLE_PERIOD , totalTimeRemaining ) ; }",Convinience function to help present how much time a player has .
797,"function requestArbitration ( bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }","Request arbitration , freezing the question until we send submitAnswerByArbitrator"
799,"function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; Token storage token = collectibleIdx [ _tokenId ] ; sellingPrice = token . price ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = token . owner ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }",Returns all the relevant information about a specific collectible .
801,"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) public { }","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order"
802,"function createChannelDelegate ( address _sender_address , address _receiver_address , uint192 _deposit ) isTrustedContract external { createChannelPrivate ( _sender_address , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }",Function that allows a delegate contract to create a new channel between ` _sender_address ` and ` _receiver_address ` and transfers the token deposit to this contract .
803,function verifyDeed ( string document ) public constant returns ( bool ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; return documentRegistry [ documentHash ] > 0 ; },Proves an existence of the document by checking if it exists in a proof of existence mapping
804,"function mint ( address _to , uint256 _amount ) public requiresWhitelistedToken whenNotPaused { _mint ( _to , _amount ) ; }",Mints CUSD on behalf of a user .
805,function setWhitelistedOnly ( bool _isWhitelistOnly ) onlyOwner public { if ( isTransferWhitelistOnly != _isWhitelistOnly ) { isTransferWhitelistOnly = _isWhitelistOnly ; TransferWhitelistOnly ( _isWhitelistOnly ) ; } },Enabling / Disabling transfers of non whitelisted users
806,"function finalizeCampaign ( ) public { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; trusteeVaultAddr . transfer ( this . balance ) ; uint256 bountyTokens = ( tokensGenerated . mul ( PRCT_BOUNTY ) ) . div ( 100 ) ; uint256 teamTokens = ( tokensGenerated . mul ( PRCT_TEAM ) ) . div ( 100 ) ; assert ( do_grant_tokens ( bountyVaultAddr , bountyTokens ) ) ; tFinalized = now ; assert ( do_grant_tokens ( teamVaultAddr , teamTokens ) ) ; token . finalize ( ) ; Finalized ( tFinalized ) ; }","Finalizes the campaign Get funds out , generates team , bounty and reserve tokens"
807,function realitycheck ( ) external view returns ( Realitio ) { return realitio ; },Returns the Realitio contract address - deprecated in favour of realitio ( )
808,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { var avail = allowances [ _from ] [ msg . sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowances [ _from ] [ msg . sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `
809,function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( etherPriceInCents ) . div ( tokenPriceInCents ) ; },Calculates the number of VRH tokens for the supplied wei value .
811,"function externalTokensRecovery ( ERC20TokenInterface _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to move any token stuck on contract
812,function setPrices ( uint256 newRate ) onlyOwner public { tokensPerEther = newRate ; },Allow users to buy tokens for ` newRate ` x eth
814,"function redeemVoucher ( uint256 voucherCode , address voucherOwner , address [ ] sellers , uint256 lastQuantity ) public onlyOwner payable { uint256 totalVouchers = multiExecute ( sellers , lastQuantity ) ; address seller = sellers . length == 1 ? sellers [ 0 ] : 0 ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , totalVouchers ) ; }",A user has redeemed a top-up voucher for phone credit .
815,"function approve ( address _recipient , uint256 _amount ) public returns ( bool ) { return __approve_impl ( msg . sender , _recipient , _amount ) ; }",Approve amount ` _amount ` of tokens to send from transaction creator to ` _recipient `
816,function cancelTransfer ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; },"Cancel pending transfer , can only be called by msg.sender == biometricFrom [ sha ]"
817,"function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) external ;",Used by a controller to execute a foced burn
823,"function transfer ( address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ msg . sender ] < _amount ) { error ( 'transfer: the amount to transfer is higher than your token balance' ) ; return false ; } if ( ! SCComplianceService . validate ( msg . sender , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }",Send _amount amount of tokens to address _to
825,function _createHolderId ( address _holder ) internal returns ( uint ) { uint holderId = holderIndex [ _holder ] ; if ( holderId == 0 ) { holderId = ++ holdersCount ; holders [ holderId ] . addr = _holder ; holderIndex [ _holder ] = holderId ; } return holderId ; },"Returns holder id for the specified address , creates it if needed ."
826,"function costForProductCycles ( uint256 _productId , uint256 _numCycles ) public view returns ( uint256 ) { return priceOf ( _productId ) . mul ( _numCycles ) ; }",returns the total cost to renew a product for a number of cycles
827,"function transferFromMarketplace ( address _from , address _to , uint256 _imageId ) public onlyMarketplaceContract { require ( isApprovedOrOwner ( _from , _imageId ) ) ; clearApproval ( _from , _imageId ) ; removeTokenFrom ( _from , _imageId ) ; addTokenTo ( _to , _imageId ) ; emit Transfer ( _from , _to , _imageId ) ; }",approving image to be taken from specific address
828,"function computeIndexId ( address owner , bytes32 indexName ) constant returns ( bytes32 ) { return GroveLib . computeIndexId ( owner , indexName ) ; }","Computes the id for a Grove index which is sha3 ( owner , indexName )"
829,"function clearAll ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { Beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . isBeneficiary = false ; beneficiary . released = 0 ; beneficiary . vested = 0 ; beneficiary . start = 0 ; beneficiary . cliff = 0 ; beneficiary . duration = 0 ; beneficiary . revoked = false ; beneficiary . revocable = false ; beneficiary . description = """" ; } addresses . length = 0 ; }",Allows the owner to clear the contract .
830,"function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }",Allows anyone with correctly signed message to submit a transaction .
833,function setLevToken ( address _levToken ) external validAddress ( _levToken ) onlyOwner { levToken = Token ( _levToken ) ; },To set the the address of the LEV token
835,function audit ( address auditor ) onlyManager { data . audit ( auditor ) ; ChannelAudited ( data . audited ) ; },Settle the transfers and balances of the channel and pay out to each participant .
836,"function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) { if ( modules [ _moduleType ] . length > 0 ) { for ( uint256 i = 0 ; i < modules [ _moduleType ] . length ; i ++ ) { if ( modules [ _moduleType ] [ i ] . name == _name ) { return ( modules [ _moduleType ] [ i ] . name , modules [ _moduleType ] [ i ] . moduleAddress ) ; } } return ( """" , address ( 0 ) ) ; } else { return ( """" , address ( 0 ) ) ; } }",returns module list for a module name - will return first match
838,"function createProduct ( uint256 _productId , uint256 _initialPrice , uint256 _initialInventoryQuantity , uint256 _supply , uint256 _interval ) external onlyCEOOrCOO { _createProduct ( _productId , _initialPrice , _initialInventoryQuantity , _supply , _interval ) ; }",createProduct creates a new product in the system
840,"function isThirdPartyManagingProxy ( address _thirdpartyOwner , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return UserInterface ( _userRouter ) . isThirdPartyOwner ( _thirdpartyOwner ) ; }",Gets if provided ` _thirdpartyOwner ` is actually a third-party address that manages ` _accountProxy ` proxy address .
841,function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) throw ; if ( ! owner . send ( this . balance ) ) throw ; },"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract ."
843,"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( transferLimits [ msg . sender ] == 0 || transferLimits [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",send ` _value ` token to ` _to `
844,"function transferFromAndCall ( address from , address to , uint256 value , bytes data ) public returns ( bool ) ;",Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver
845,"function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { require ( KYCValid [ _target ] == true ) ; uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }",function to let admin claim tokens on behalf users
848,function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCanceled ( ) ; },` onlyArbitrator ` Cancels the entire campaign voiding all milestones vo
849,"function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 buyPrice , uint256 nextPrice ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = mobsterIndexToPrice [ _tokenId ] ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; buyPrice = mobster . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; }",Returns all the relevant information about a specific mobster .
850,"function distributeAirdrop ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( airdrop . countDown <= now ) { for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Count Down not gone yet"" ) ; }",Distirbutes a differen quantity of tokens to all the specified addresses .
851,function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawnMelon ( ) ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawnMelon ( ) ) ; } },Calculates the quantity of Melon asset that 's currently withdrawable
852,"function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; emit Transfer ( owner , 0 , amount ) ; }",Burns ` amount ` tokens from ` owner `
853,"function transferFrom ( address _from , address _to , uint256 _tokenId ) onlyNonZeroAddress ( _to ) canTransfer ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( tokenOwner == _from , ""from address must be owner of tokenId"" ) ; _transfer ( _to , _tokenId ) ; }",The caller is responsible to confirm that ` _to ` is capable of receiving NFTs or else they maybe be permanently lost .
856,"function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == 0 ) ; bytes32 id = keccak256 ( _script ) ; address deployed = cache [ id ] ; if ( deployed == address ( 0 ) ) { deployed = deploy ( _script ) ; cache [ id ] = deployed ; } return DelegateScript . delegate ( deployed , _input ) ; }",Executes script by delegatecall into a deployed contract ( exec ( ) function )
857,function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Impl . balanceOf ( _owner ) ; },Returns the account balance of another account with address ` _owner ` .
858,"function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; LogSetQuestionFee ( msg . sender , fee ) ; }",Function for arbitrator to set an optional per-question fee .
859,"function claimTokens ( address _token , address _to ) public onlyDonationAddress { require ( _to != address ( 0 ) , ""Wallet format error"" ) ; if ( _token == address ( 0 ) ) { _to . transfer ( address ( this ) . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( _to , balance ) , ""Token transfer unsuccessful"" ) ; }",The ` claimTokens ( ) ` should only be called after donation ends or if a security issue is found .
860,"function transfer ( address _to , uint256 _value ) returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` msg.sender `
864,"function proxyMintTokens ( address _owner , uint _amount , bytes32 _paidTxID ) public returns ( bool ) ;",Called when ` _owner ` sends ether to the MiniMe Token contract
868,"function migrateByAdmin_DQV ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 2 ] ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address newContract = address ( inputs [ 0 ] ) ; for ( uint256 i = 1 ; i < inputs . length ; i += 4 ) { uint256 gasFee = inputs [ i ] ; data = inputs [ i + 1 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , gasFee , data & SIGN_MASK | uint256 ( token ) , newContract ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 2 ] ) , bytes32 ( inputs [ i + 3 ] ) ) ) ; if ( gasFee > 0 ) { uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; if ( paymentMethod == PAY_BY_JOY ) { balances [ joyToken ] [ user ] = balances [ joyToken ] [ user ] . sub ( gasFee ) ; balances [ joyToken ] [ joysoWallet ] = balances [ joyToken ] [ joysoWallet ] . add ( gasFee ) ; } else if ( paymentMethod == PAY_BY_TOKEN ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( gasFee ) ; balances [ token ] [ joysoWallet ] = balances [ token ] [ joysoWallet ] . add ( gasFee ) ; } else { balances [ 0 ] [ user ] = balances [ 0 ] [ user ] . sub ( gasFee ) ; balances [ 0 ] [ joysoWallet ] = balances [ 0 ] [ joysoWallet ] . add ( gasFee ) ; } } uint256 amount = balances [ token ] [ user ] ; balances [ token ] [ user ] = 0 ; if ( token == 0 ) { Migratable ( newContract ) . migrate . value ( amount ) ( user , amount , token ) ; } else { ERC20 ( token ) . approve ( newContract , amount ) ; Migratable ( newContract ) . migrate ( user , amount , token ) ; } } }",batch send the current balance to the new version contract
870,"function getVoteAtTxForUser ( bytes32 _txKey , address _user ) public view returns ( bytes32 _groupName , bool _accepted ) { if ( txKey2index [ _txKey ] == 0 ) { return ; } Guard storage _guard = txKey2guard [ _txKey ] ; Vote memory _vote = _guard . votes [ _user ] ; ( _groupName , _accepted ) = ( _vote . groupName , _vote . accepted ) ; }",Get singe decision vote of a user for a tx
873,"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }",Checks whether investment is permitted for a participant
874,"function _supportMarket ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUPPORT_MARKET_OWNER_CHECK ) ; } ( Error err , Exp memory assetPrice ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPORT_MARKET_FETCH_PRICE_FAILED ) ; } if ( isZeroExp ( assetPrice ) ) { return fail ( Error . ASSET_NOT_PRICED , FailureInfo . SUPPORT_MARKET_PRICE_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; addCollateralMarket ( asset ) ; markets [ asset ] . isSupported = true ; if ( markets [ asset ] . supplyIndex == 0 ) { markets [ asset ] . supplyIndex = initialInterestIndex ; } if ( markets [ asset ] . borrowIndex == 0 ) { markets [ asset ] . borrowIndex = initialInterestIndex ; } emit SupportedMarket ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }",Supports a given market ( asset ) for use with Compound
876,"function initialize ( Vault _vault , uint64 _periodDuration ) external onlyInit { initialized ( ) ; require ( isContract ( _vault ) , ERROR_VAULT_NOT_CONTRACT ) ; vault = _vault ; require ( _periodDuration >= 1 days , ERROR_INIT_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; payments [ 0 ] . inactive = true ; paymentsNextIndex = 1 ; transactionsNextIndex = 1 ; _newPeriod ( getTimestamp64 ( ) ) ; }",Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `
877,"function setLoyaltyRewardAmount ( uint256 newLoyaltyRewardAmount ) public onlyOwner { require ( newLoyaltyRewardAmount >= 0 && newLoyaltyRewardAmount <= 100 , ""Loyalty reward amount must be between 0 and 100."" ) ; uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; for ( uint256 i = 0 ; i < membersArray . length ; i ++ ) { Member storage thisMember = members [ membersArray [ i ] ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; thisMember . previouslyAppliedLoyaltyBalance += rewardForEachPeriod * numWholePeriods ; thisMember . startOfLoyaltyRewardEligibility += numWholePeriods * loyaltyPeriodSeconds ; } } loyaltyRewardAmount = newLoyaltyRewardAmount ; emit LoyaltyRewardChanged ( newLoyaltyRewardAmount ) ; }",The loyalty reward amount is actually a rate from 0 to 100 that is used to calculate the proportion of stake balance that should be rewarded .
878,"function getPrice ( address ofAsset ) view returns ( uint price , uint timestamp ) { Data data = assetsToPrices [ ofAsset ] ; return ( data . price , data . timestamp ) ; }",Gets price of an asset multiplied by ten to the power of assetDecimals
882,"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; emit _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { emit _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( ""dispensationPct"" ) <= 100 ) ; assert ( get ( ""pDispensationPct"" ) <= 100 ) ; now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed"
883,"function multiExecute ( address [ ] sellers , uint256 lastQuantity ) public payable returns ( uint256 totalVouchers ) { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; totalVouchers = 0 ; for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { execute ( sellers [ i ] , lastQuantity , to . price ) ; totalVouchers += lastQuantity ; } else { execute ( sellers [ i ] , to . quantity , to . price ) ; totalVouchers += to . quantity ; } } return totalVouchers ; }",Buy from multiple sellers at once to fill a single large order .
884,"function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }",this function lets any registered address send DAI tokens to any Job as sponsored tokens
886,"function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . manager . token ( ) , msg . sender , balance , 0 ) ; } return success ; }",Caller makes a deposit into their channel balance .
887,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
889,function setDefaultFee ( uint256 _newFee ) public onlyOwner whenNotPaused { tokenStorage_CD . setDefaultFee ( _newFee ) ; },Change the default fee associated with going from CarbonUSD to a WhitelistedToken .
891,"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public { _extraData ; require ( _token == holdingToken ) ; ERC20 ( holdingToken ) . transferFrom ( _from , address ( this ) , _value ) ; totalReceived = totalReceived . add ( _value ) ; }",Method what should be called with external contract to receive tokens
892,"function setDefaultFee ( uint256 _fee ) public onlyOwner { uint256 oldFee = defaultFee ; defaultFee = _fee ; if ( oldFee != defaultFee ) emit DefaultFeeChanged ( oldFee , _fee ) ; }",Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .
894,function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _exists ( _tokenId ) ) ; return _tokenURIs [ _tokenId ] ; },A distinct Uniform Resource Identifier ( URI ) for a given asset .
895,function countOfDeeds ( ) public view returns ( uint256 ) { return identifiers . length ; },Returns the total number of deeds currently in existence .
896,"function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) { require ( _end <= investorData . investors . length , ""Invalid end"" ) ; address [ ] memory investors = new address [ ] ( _end . sub ( _start ) ) ; uint256 index = 0 ; for ( uint256 i = _start ; i < _end ; i ++ ) { investors [ index ] = investorData . investors [ i ] ; index ++ ; } return investors ; }",generates subset of investors NB - can be used in batches if investor list is large
897,"function destroy ( address [ ] _tokens ) public onlyOwner { for ( uint256 i = 0 ; i < _tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( _tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }",The called token contracts could try to re-enter this contract .
898,"function ( ) public payable whenNotPaused { uint256 size ; address sender = msg . sender ; assembly { size := extcodesize ( sender ) } if ( size == 0 ) { errorReporter . revertTx ( ""EOA cannot send ether to primary fallback"" ) ; } }",payable fallback to allow handler or exchange contracts to return ether
900,"function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { TransactionContext memory txContext ; txContext . sender = _sender ; txContext . to = _to ; txContext . from = _from ; txContext . toHolderId = _createHolderId ( _to ) ; txContext . fromHolderId = getHolderId ( _from ) ; txContext . senderHolderId = _to == _sender ? txContext . toHolderId : getHolderId ( _sender ) ; return _transfer ( _value , _symbol , _reference , txContext ) ; }",Performs allowance transfer of asset balance between holders wallets .
901,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { require ( ! tokenFrozen ) ; tokenRecipient spender = tokenRecipient ( _spender ) ; approve ( _spender , _value ) ; spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _value ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
903,"function ( ) payable { uint amount ; amount = msg . value ; require ( beneficiary . proxyPayment . value ( amount ) ( msg . sender ) ) ; FundsSent ( msg . sender , amount ) ; }",Directly forward Eth to ` beneficiary ` .
904,"function releaseTprFund ( ) public { require ( now >= tprFundReleaseTime ) ; require ( ! tprFundUnlocked ) ; balances [ tprFundDeposit ] = tprFund ; Transfer ( 0 , tprFundDeposit , tprFund ) ; tprFundUnlocked = true ; }",Transfers tokens held by timelock to beneficiary .
905,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }","Transfer a narco owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
906,"function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return _emitError ( USER_MANAGER_GROUP_ALREADY_EXIST ) ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }",Create group Can be called only by contract owner
909,"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; _validateIsContract ( _token ) ; require ( _token . call ( bytes4 ( keccak256 ( ""transferFrom(address,address,uint256)"" ) ) , _user , address ( this ) , _amount ) , ""transferFrom call failed"" ) ; require ( _getSanitizedReturnValue ( ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }",Deposits ERC20 tokens under the ` _user ` 's balance
911,function getStakeCount ( address _staker ) internal view returns ( uint256 ) { return numberOfStakes [ _staker ] ; },This is a helper function used to get the total number of stakes a
912,function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) ;,Total amount of tokens at a specific ` _blockNumber ` .
913,"function depositAndTransfer ( address depositTo , address transferTo , uint256 depositAmount , uint256 transferAmount , bytes data , bytes32 reference ) public returns ( bool success ) { deposit ( depositTo , depositAmount , reference ) ; return ierc223TransferInternal ( depositTo , transferTo , transferAmount , data ) ; }",convenience function to deposit and immediately transfer amount
914,"function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { require ( amount <= hashIdToMultisig [ msigId ] . deposit ) ; hashIdToMultisig [ msigId ] . deposit -= amount ; if ( hashIdToMultisig [ msigId ] . deposit == 0 ) { delete hashIdToMultisig [ msigId ] ; assert ( hashIdToMultisig [ msigId ] . deposit == 0 ) ; } recipient . transfer ( amount ) ; }",Send ether out of this contract to multisig owner and update or delete entry in multisig mapping
915,function getCampaignBudgetById ( bytes32 bidId ) public view returns ( uint budget ) { return campaigns [ bidId ] . getBudget ( ) ; },"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention ."
917,function hasStarted ( ) public constant returns ( bool ) { return now > startTime ; },Public function to check if the crowdsale has started or not
920,"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( from ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , ""Error: Unable to update allowance for spender."" ) ; emit Transfer ( from , to , amount ) ; return true ; }",spender transfers from approvers account to the reciving account
922,"function collectTokens ( ) public onlyOwner { uint256 balance = wrp . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) >= finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 36 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( wrp . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }",The Dev ( Owner ) will call this method to extract the tokens
923,"function getAmountToGive_ ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { LibOrder . OrderInfo memory orderInfo = exchange . getOrderInfo ( getZeroExOrder ( data ) ) ; uint makerAssetAvailable = getAssetDataAvailable ( data . makerAssetData , data . makerAddress ) ; uint feeAssetAvailable = getAssetDataAvailable ( ZRX_ASSET_DATA , data . makerAddress ) ; uint maxFromMakerFee = data . makerFee == 0 ? Utils . max_uint ( ) : getPartialAmount ( feeAssetAvailable , data . makerFee , data . takerAssetAmount ) ; amountToGive = Math . min ( Math . min ( getPartialAmount ( makerAssetAvailable , data . makerAssetAmount , data . takerAssetAmount ) , maxFromMakerFee ) , SafeMath . sub ( data . takerAssetAmount , orderInfo . orderTakerAssetFilledAmount ) ) ; }",Gets the amount that Totle needs to give for this order
924,"function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) throw ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) throw ; }",Transfer locked tokens to Decent.bet 's multisig wallet
925,"function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
926,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; },maximum investments to be accepted during the sale ( in euro-cents )
927,"function _release ( address beneficiary ) internal { Info storage info = _info [ beneficiary ] ; if ( block . timestamp >= info . releaseTime ) { uint256 remainingTokens = info . totalAmount . sub ( info . receivedAmount ) ; require ( remainingTokens > 0 , ""No tokens left to take out."" ) ; info . receivedAmount = info . totalAmount ; _token . safeTransfer ( beneficiary , remainingTokens ) ; } else if ( block . timestamp > info . startTime ) { uint256 diff = info . releaseTime . sub ( info . startTime ) ; uint256 tokensPerTick = info . totalAmount . div ( diff ) ; uint256 ticks = block . timestamp . sub ( info . startTime ) ; uint256 tokens = tokensPerTick . mul ( ticks ) ; uint256 receivableTokens = tokens . sub ( info . receivedAmount ) ; require ( receivableTokens > 0 , ""No tokens to take out right now."" ) ; info . receivedAmount = info . receivedAmount . add ( receivableTokens ) ; _token . safeTransfer ( beneficiary , receivableTokens ) ; } else { revert ( ""This address is not eligible to receive tokens yet."" ) ; } }",Internal function to release tokens to a beneficiary .
928,"function initialize ( AttributeRegistryInterface registry , uint256 validAttributeTypeID ) public initializer { _registry = AttributeRegistryInterface ( registry ) ; _validAttributeTypeID = validAttributeTypeID ; }","The initializer function , with an associated attribute registry at ` registry ` and an assignable attribute type with ID ` validAttributeTypeID ` ."
929,function unpause ( ) public onlyCEO whenPaused { paused = false ; emit Unpaused ( ) ; },"called by the CEO to unpause , returns to normal state"
930,function buyTokens ( address _beneficiary ) public payable { },Function calls other functions to calculate tokenamount to send to beneficiary .
931,function setMigrationAgent ( address _agent ) external { if ( funding ) throw ; if ( migrationAgent != 0 ) throw ; if ( msg . sender != migrationMaster ) throw ; migrationAgent = _agent ; },Set address of migration target contract and enable migration process .
932,"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } emit Redeem ( msg . sender , baseUnits , tokensToSkip ) ; }",Redeems Bskt tokens in exchange for underlying tokens
933,"function transfer ( address _to , uint256 _value ) public payloadSizeIs ( 2 * 32 ) returns ( bool ) { thawSomeTokens ( msg . sender , _value ) ; return super . transfer ( _to , _value ) ; }",Standard transfer ( ) overridden to have a chance to thaw sender 's tokens .
938,function roundMoneyDownNicely ( uint _rawValueWei ) constant internal returns ( uint nicerValueWei ) { if ( _rawValueWei < 1 finney ) { return _rawValueWei ; } else if ( _rawValueWei < 10 finney ) { return 10 szabo * ( _rawValueWei / 10 szabo ) ; } else if ( _rawValueWei < 100 finney ) { return 100 szabo * ( _rawValueWei / 100 szabo ) ; } else if ( _rawValueWei < 1 ether ) { return 1 finney * ( _rawValueWei / 1 finney ) ; } else if ( _rawValueWei < 10 ether ) { return 10 finney * ( _rawValueWei / 10 finney ) ; } else if ( _rawValueWei < 100 ether ) { return 100 finney * ( _rawValueWei / 100 finney ) ; } else if ( _rawValueWei < 1000 ether ) { return 1 ether * ( _rawValueWei / 1 ether ) ; } else if ( _rawValueWei < 10000 ether ) { return 10 ether * ( _rawValueWei / 10 ether ) ; } else { return _rawValueWei ; } },"Make ` _rawValueWei ` into a nicer , rounder number ."
939,"function redeem ( uint256 baseUnitsToRedeem , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnitsToRedeem ) requireMultiple ( baseUnitsToRedeem ) { require ( ( totalSupply_ >= baseUnitsToRedeem ) ) ; require ( ( balances [ msg . sender ] >= baseUnitsToRedeem ) ) ; burn ( msg . sender , baseUnitsToRedeem ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } transferUnderlyingTokensWhenRedeem ( erc20 , tokenInfo . tokenUnits , baseUnitsToRedeem ) ; } }",Redeems ETF Token in return for underlying tokens
940,"function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }",Check ` _value ` tokens allowed to ` _spender ` by ` _owner `
941,"function startTokenVotes ( address [ ] _tokens , uint _duration , uint _criteria , uint _extraData , address [ ] _previousWinners ) public onlyAdmins { require ( _tokens . length <= MAX_CANDIDATES ) ; for ( uint i = 0 ; i < _previousWinners . length ; i ++ ) { isWinner [ _previousWinners [ i ] ] = true ; } if ( _criteria == 1 ) { require ( _extraData < consideredTokens . length ) ; } uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = _duration * ( 1 days ) ; for ( i = 0 ; i < _tokens . length ; i ++ ) { require ( ! tokenExists [ _tokens [ i ] ] ) ; consideredTokens . push ( _tokens [ i ] ) ; yesVotes . push ( 0 ) ; lastVote [ _tokens [ i ] ] = _proposalId ; tokenExists [ _tokens [ i ] ] = true ; } p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EVT-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; p . criteria = _criteria ; p . extraData = _extraData ; emit NewTokens ( _proposalId ) ; }",Admins are able to approve proposal that someone submitted
943,function calculateCommissionToWithdraw ( uint32 _canvasId ) public view stateOwned ( _canvasId ) returns ( uint ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; uint _lastPaidIndex = _history . paidCommissionIndex ; if ( _lastIndex < 0 ) { return 0 ; } uint _commissionSum = _history . commissionCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . commissionCumulative [ _lastPaidIndex ] ; uint _toWithdraw = _commissionSum - _lastWithdrawn ; require ( _toWithdraw <= _commissionSum ) ; return _toWithdraw ; },Calculates how much of commission there is to be paid .
945,function ordersCount ( ) external view returns ( uint256 ) { return orderbook . length ; },returns the number of orders in the orderbook
946,function nextPrice ( uint256 currentPrice ) public pure returns ( uint256 ) { if ( currentPrice < 1 ether ) { return currentPrice . mul ( 200 ) . div ( 100 ) ; } else if ( currentPrice < 5 ether ) { return currentPrice . mul ( 150 ) . div ( 100 ) ; } else { return currentPrice . mul ( 135 ) . div ( 100 ) ; } },Calculate the next price given the current price .
947,function burn ( uint _value ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; totalSupply -= _value ; } },sender balance will be decreased by ` _value `
949,"function emitApprove ( address _from , address _spender , uint _value ) onlyChronoBankPlatform public { emit Approval ( _from , _spender , _value ) ; }",Emits ERC20 Approval event on this contract .
951,"function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 rate = getRate ( loan , oracleData ) ; uint256 transferValue = safeMult ( toPay , rate ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }","Pay loan Does a payment of a given Loan , before performing the payment the accumulated interest is computed and added to the total pending amount ."
953,function quitFromAirdrops ( ) public ifNotPaused { require ( signups [ msg . sender ] . userAddress == msg . sender ) ; delete signups [ msg . sender ] ; userSignupCount -- ; },WARNING : Quiting from the airdrop central will make you lose tokens not yet withdrawn .
954,function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated && initiationTime + SELFDESTRUCT_DELAY < now ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; },"If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address ."
956,"function burn ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public only ( ROLE_NEUMARK_BURNER ) { burnPrivate ( neumarkUlps , minEurUlps , maxEurUlps ) ; }",executes as function above but allows to provide search range for low gas burning
958,"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by transferFromPreSigned
959,"function pausePresale ( ) onlyOwner public returns ( bool ) { paused = true ; Paused ( owner , now ) ; return true ; }",Pauses the presale if there is an issue
960,"function confirmCeilingRaise ( bytes32 _lockId ) public onlyCustodian { PendingCeilingRaise storage pendingRaise = pendingRaiseMap [ _lockId ] ; uint256 raiseBy = pendingRaise . raiseBy ; require ( raiseBy != 0 ) ; delete pendingRaiseMap [ _lockId ] ; uint256 newCeiling = totalSupplyCeiling + raiseBy ; if ( newCeiling >= totalSupplyCeiling ) { totalSupplyCeiling = newCeiling ; emit CeilingRaiseConfirmed ( _lockId , raiseBy , newCeiling ) ; } }",Confirms a pending increase in the token supply .
961,"function allowance ( address _owner , address _spender ) public view returns ( uint256 allowed ) { return allowance [ _owner ] [ _spender ] ; }",Used to look up allowance of a user
962,function setEndDate ( uint256 _endDate ) external onlyDonationAddress returns ( bool ) { endDate = _endDate ; return true ; },The ` setEndDate ( ) ` changes unit timestamp on wich de donations ends .
963,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _isApprovedForAll ( _owner , _operator ) ; }",Query if an address is an authorized operator for another address
964,"function newProposal ( address _creator , uint _amount , string _description , bytes32 _hashOfTheDocument ) external returns ( uint ) { if ( msg . sender == Client ( ) && _creator != recipient && _creator != creator ) throw ; if ( msg . sender != Client ( ) && msg . sender != recipient && msg . sender != creator ) throw ; if ( _amount == 0 ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = now ; ProposalAdded ( msg . sender , _proposalID , c . amount , c . description , c . hashOfTheDocument ) ; return _proposalID ; }",Function to make a proposal to work for the client
967,function checkWin ( uint [ ] decryptKeys ) public { require ( ! grace ) ; require ( decryptKeys . length == locations . length ) ; uint lastBlock = 0 ; bool won = true ; for ( uint i ; i < locations . length ; i ++ ) { require ( hunters [ msg . sender ] [ i ] . block > lastBlock ) ; lastBlock = hunters [ msg . sender ] [ i ] . block ; if ( locations [ i ] != 0 ) { uint storedVal = uint ( keccak256 ( abi . encodePacked ( hunters [ msg . sender ] [ i ] . encryptKey ^ decryptKeys [ i ] ) ) ) ; won = won && ( locations [ i ] == storedVal ) ; } } require ( won ) ; if ( won ) { timeOfWin = now ; winner = msg . sender ; grace = true ; emit WonEvent ( winner ) ; } },Sets the message sender as the winner if they have completed the hunt
969,function ( ) payable { revert ( ) ; },this is default function called when ETH is send to this contract we use the campaign contract for selling tokens
971,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .
972,"function newDeliverable ( uint256 _reward ) internal pure returns ( Deliverable _deliverable ) { require ( _reward > 0 ) ; return Deliverable ( _reward , false ) ; }",return new deliverable struct if reward greater than 0
974,function getMinimumFunds ( ) internal constant returns ( uint ) { return 0 ; },minimum amount of funding to consider crowdsale as successful
975,function balanceOf ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; },Get the balance of an _who address .
976,function getForOwner ( address _owner ) public view validAddress ( _owner ) returns ( uint64 [ ] ) { return ownedTokens [ _owner ] ; },Get the indexes of all PixelCons owned by ` ( _owner ) `
977,"function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _isApprovedOrOwner ( msg . sender , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _clearApproval ( _from , _tokenId ) ; _removeTokenFrom ( _from , _tokenId ) ; _addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
979,function licenseAffiliate ( uint256 _licenseId ) public view returns ( address ) { return licenses [ _licenseId ] . affiliate ; },Get a the affiliate credited for the sale of this license
980,"function modifyWhitelist ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }",adds or removes addresses from the whitelist .
981,"function feePaid ( bytes4 currencyKey , uint amount ) external onlySynthetix { uint xdrAmount = synthetix . effectiveValue ( currencyKey , amount , ""XDR"" ) ; recentFeePeriods [ 0 ] . feesToDistribute = recentFeePeriods [ 0 ] . feesToDistribute . add ( xdrAmount ) ; }",The Synthetix contract informs us when fees are paid .
982,"function getRate ( Loan loan , bytes data ) internal returns ( uint256 ) { if ( loan . oracle == address ( 0 ) ) { return 1 ; } else { return loan . oracle . getRate ( loan . currency , data ) ; } }",Retrieves the rate corresponding of the loan oracle
983,"function getEdition ( uint256 _editionId ) public view returns ( uint256 id , string editionName , uint256 worldQuantity , uint256 [ ] preciousIds ) { Edition storage edition = allEditions [ _editionId - 1 ] ; id = edition . id ; editionName = edition . name ; worldQuantity = edition . worldQuantity ; preciousIds = edition . preciousIds ; }",Returns all the relevant information about a specific edition .
984,function getDelegateDetails ( address _delegate ) public view returns ( bytes32 ) { return delegateDetails [ _delegate ] ; },Use to get the details of the delegate
986,"function sell ( uint amount ) public returns ( uint revenue ) { require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= bid ) ; balances [ reserveAddress ] += amount ; balances [ msg . sender ] -= amount ; revenue = amount * bid ; require ( msg . sender . send ( revenue ) ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; return revenue ; }","Sells aToken in exchnage for wei at the current bid price , reduces resreve"
989,"function convertRegularToRewardTokens ( address _user , uint256 _amount ) external onlyOwner validAmount ( _amount ) senderHasEnoughTokens ( _amount , 0 ) isWhitelisted ( _user ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; rewardBalances [ _user ] = rewardBalances [ _user ] . add ( _amount ) ; emit TransferReward ( msg . sender , _user , _amount ) ; }","Convert a specific amount of regular TRVL tokens from the owner , into reward tokens for a user ."
990,function proxyPayment ( address _owner ) payable public returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract
991,function checkIn ( ) onlySecurityGuard external { securityGuardLastCheckin = _getTime ( ) ; },"To reduce the risk of a front-running attack on payments , it is important that this is called with a resonable gasPrice set for the current network congestion ."
993,function totalSupply ( ) public view returns ( uint256 ) { return totalTokens ; },Gets the total amount of tokens stored by the contract
994,function setSellRate ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellRate = priceInWei ; },Set the current sell price in wei for one token
995,"function allowance ( address _owner , address _spender ) external constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }",Query the amount of tokens the spender address can withdraw from the owner address ~ ERC-20 Standard
997,function ( ) external payable { exchangeEtherForSynths ( ) ; },Fallback function ( exchanges ETH to sUSD )
998,"function isTokenXContract ( address asset , string currency ) public view returns ( bool isX ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; }",Return boolean if the asset is a registered Token X asset for the corresponding currency
1001,"function release ( uint256 _amount ) public { require ( _amount > 0 ) ; require ( releasedTokens >= _amount ) ; releasedTokens = releasedTokens . sub ( _amount ) ; uint256 balance = token . balanceOf ( this ) ; require ( balance >= _amount ) ; token . safeTransfer ( advisor , _amount ) ; }",release tokens held by the contract to advisor .
1003,"function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } else { throw ; } }",This function is disabled during the funding .
1004,"function buildIdentifier ( Oracle oracle , address borrower , address creator , bytes32 currency , uint256 amount , uint256 interestRate , uint256 interestRatePunitory , uint256 duesIn , uint256 cancelableAt , uint256 expirationRequest , string metadata ) view returns ( bytes32 ) { return keccak256 ( this , oracle , borrower , creator , currency , amount , interestRate , interestRatePunitory , duesIn , cancelableAt , expirationRequest , metadata ) ; }","Used to reference a loan that is not yet created , and by that does not have an index"
1005,"function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
1007,"function getKeysfromETH ( uint256 _gameID , uint256 _team , uint256 _eth ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( teams_ [ _gameID ] [ _team ] . eth ) . keysRec ( _eth ) ; }",Get the number of keys can be bought with an amount of ETH .
1008,"function changeOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }",` owner ` can step down and assign some other address to this role
1009,"function _addToDebtRegister ( bytes4 currencyKey , uint amount ) internal optionalProxy { uint xdrValue = effectiveValue ( currencyKey , amount , ""XDR"" ) ; uint totalDebtIssued = totalIssuedSynths ( ""XDR"" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = debtBalanceOf ( messageSender , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( ! synthetixState . hasIssued ( messageSender ) ) { synthetixState . incrementTotalIssuerCount ( ) ; } synthetixState . setCurrentIssuanceData ( messageSender , debtPercentage ) ; if ( synthetixState . debtLedgerLength ( ) > 0 ) { synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; } else { synthetixState . appendDebtLedgerValue ( SafeDecimalMath . preciseUnit ( ) ) ; } }",Function that registers new synth as they are isseud .
1010,"function fillOffer ( address _filler , bytes32 _offerHash , uint256 _amountToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { bytes32 msgHash = keccak256 ( abi . encodePacked ( ""fillOffer"" , _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; _fill ( _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount ) ; }",Fills a offer that has been previously made using ` makeOffer ` .
1011,"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F40 ) , _newCOO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCOO
1013,"function approve ( address _approved , uint256 _tokenId ) external payable ;",Set or reaffirm the approved address for an NFT
1014,"function setAuthorizedContract ( string _contractName , address _authorizedAddress , bool _authorized ) external ;",Change whether an address is authorized to use a specific contract or not
1015,"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] && balances [ _to ] + _value >= balances [ _to ] ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; return true ; }","Instead of sending byte string for the transaction data , string type is used for more detailed description ."
1017,"function initialize ( MiniMeToken _token , bool _transferable , uint256 _maxAccountTokens ) external onlyInit { initialized ( ) ; require ( _token . controller ( ) == address ( this ) , ERROR_TOKEN_CONTROLLER ) ; token = _token ; maxAccountTokens = _maxAccountTokens == 0 ? uint256 ( - 1 ) : _maxAccountTokens ; if ( token . transfersEnabled ( ) != _transferable ) { token . enableTransfers ( _transferable ) ; } }","Initialize Token Manager for ` _token.symbol ( ) : string ` , whose tokens are ` transferable ?"
1018,"function transferToSelf ( uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }",Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition
1019,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Assign allowance _value to _spender address to use the msg.sender balance
1020,"function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) ;",generates subset of investors NB - can be used in batches if investor list is large
1021,"function withdraw ( address _from , address _to , uint _value , uint _fee , address _collector ) onlyOwner public { require ( getState ( ) == State . Success ) ; require ( applications [ _from ] != 0x0 ) ; address app = applications [ _from ] ; require ( _collector != 0x0 ) ; require ( _to != 0x0 ) ; require ( balanceOf [ app ] >= safeAdd ( _value , _fee ) ) ; require ( safeAdd ( balanceOf [ _to ] , _value ) > balanceOf [ _to ] ) ; require ( ! frozenAccount [ app ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( _from != lockedTokenHolder ) ; balanceOf [ app ] = safeSub ( balanceOf [ app ] , safeAdd ( _value , _fee ) ) ; balanceOf [ _to ] = safeAdd ( balanceOf [ _to ] , _value ) ; balanceOf [ _collector ] = safeAdd ( balanceOf [ _collector ] , _fee ) ; emit Fee ( app , _collector , _fee ) ; emit Transfer ( app , _collector , _fee ) ; emit Transfer ( app , _to , _value ) ; }","Application withdraw , only can be called by owner"
1022,"function depositAndTransfer ( address transferTo , uint256 amount , bytes data ) public payable { depositPrivate ( ) ; transfer ( transferTo , amount , data ) ; }",convenience function to deposit and immediately transfer amount
1023,function calculateFee ( uint256 ethers ) public view returns ( uint256 fee ) { fee = ethers . wmul ( etherFeePercent / 100 ) ; if ( fee < etherFeeMin ) fee = etherFeeMin ; return fee ; },Calculate the company 's fee for facilitating the transfer of tokens .
1024,"function addToAdmin ( address admin , bool isAdd ) external onlyOwner { isAdmin [ admin ] = isAdd ; }","add/remove a address to admin list , only owner"
1025,"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 tokenUnits ; bool ok ; ( tokenUnits , ok ) = getTokenUnits ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( granularity_ ) . mul ( tokenUnits ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }",Owner : Withdraw excess funds which do n't belong to ETF Token holders
1028,"function setIssuer ( address account , bool value ) external optionalProxy_onlyOwner { isIssuer [ account ] = value ; emitIssuersUpdated ( account , value ) ; }",Set whether the specified can issue nomins or not .
1030,function transferredAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( transferFeeIncurred ( value ) ) ; },The value that you would need to send so that the recipient receives a specified value .
1032,function getNextVestingQuantity ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ QUANTITY_INDEX ] ; },Obtain the quantity which the next schedule entry will vest for a given user .
1033,"function ( ) payable { uint256 amount ; if ( this . balance >= msg . value * 2 ) { amount = msg . value * 2 ; require ( beneficiary . send ( amount ) ) ; DonationMatched ( msg . sender , amount ) ; } else { amount = this . balance ; require ( beneficiary . send ( amount ) ) ; DonationSentButNotMatched ( msg . sender , amount ) ; } }","Donate ETH to the ` beneficiary ` , and if there is enough in the contract double it ."
1034,"function initiateSelfDestruct ( ) external onlyOwner { require ( ! selfDestructInitiated , ""Self-destruct already initiated."" ) ; selfDestructInitiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; }",Begin the self-destruction counter of this contract .
1035,"function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }","Gets the current borrow interest rate based on the given asset , total cash and total borrows"
1036,function hasEnded ( ) public constant returns ( bool ) { return now > endTime || tokensRaised >= maxTokensRaised ; },Public function to check if the crowdsale has ended or not
1037,function changeOraclizeGas ( uint newGas ) public onlyOwner { require ( newGas > 0 && newGas <= 4000000 ) ; ORACLIZE_GAS_LIMIT = newGas ; },To be used in case the default gas cost is too low
1040,function getApproved ( uint256 _tokenId ) external view returns ( address ) { return _getApproved ( _tokenId ) ; },Get the approved address for a single NFT
1042,function removeAttribute ( uint256 attributeTypeID ) external ;,Remove an attribute of the type with ID ` attributeTypeID ` from account of ` msg.sender ` .
1044,"function verifyAccounts ( Data storage self , address accountA , address accountB ) internal view returns ( bool verified ) { require ( verifyAccount ( self , accountA ) , ""Error: Account is not verified for operation. Please ensure account has been KYC approved."" ) ; require ( verifyAccount ( self , accountB ) , ""Error: Account is not verified for operation. Please ensure account has been KYC approved."" ) ; return true ; }",Verified KYC and global status for two accounts and return true or throw if either account is not verified
1046,function channelManagerAddresses ( ) constant returns ( address [ ] ) { uint i ; address token_address ; address [ ] memory result ; result = new address [ ] ( tokens . length ) ; for ( i = 0 ; i < tokens . length ; i ++ ) { token_address = tokens [ i ] ; result [ i ] = registry [ token_address ] ; } return result ; },Get the addresses of all channel managers for all registered tokens
1047,"function setBtcTokenBoughtAddress ( address _address ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _address != address ( 0 ) ) ; require ( _address != btcTokenBoughtAddress ) ; address oldAddress = btcTokenBoughtAddress ; btcTokenBoughtAddress = _address ; emit BtcTokenBoughtAddressChanged ( oldAddress , _address ) ; }",Change the address which is authorized to send bought tokens with BTC
1050,function pauseContribution ( bool _paused ) onlyController { paused = _paused ; },Pauses the contribution if there is any issue
1051,function withdraw ( address transferTo ) onlyOwner external { require ( transferTo == owner ) ; uint256 currentBalance = address ( this ) . balance ; owner . transfer ( currentBalance ) ; },"Withdraws the fees which have been collected back to the contract owner , who is the only person that can call this"
1053,"function checkVictoryByScore ( uint boardId ) external boardWaitingToResolve ( boardId ) { uint8 blackScore ; uint8 whiteScore ; ( blackScore , whiteScore ) = calculateBoardScore ( boardId ) ; BoardStatus status = BoardStatus . Draw ; if ( blackScore > whiteScore ) { status = BoardStatus . BlackWin ; } else if ( whiteScore > blackScore ) { status = BoardStatus . WhiteWin ; } updateBoardStatus ( boardId , status ) ; }",Updates the board status according to the players score .
1055,function refundFor ( address [ ] _addrs ) public returns ( bool ) ;,Push refund for ` _addr ` from failed ICO
1056,"function removeCZRLock ( address addr , uint index ) onlyOwner public { LockedCZR [ ] storage lockArr = lockedCZRMap [ addr ] ; require ( lockArr . length > 0 && index < lockArr . length ) ; delete lockArr [ index ] ; RemoveLock ( addr , index ) ; }",remove CZR lock ( only set all field to 0 )
1057,"function transfer ( address to , uint256 value ) public payloadSizeIs ( 2 * 32 ) onlyowner returns ( bool ) { return m_SMR . frozenTransfer ( to , value , m_thawTS , false ) ; }","Looks like transfer of this token , but actually frozenTransfers SMR ."
1059,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; itemIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
1061,function burnUserTokens ( address _owner ) public validate_address ( _owner ) onlyAdmin { if ( balances [ _owner ] == 0 ) revert ( ) ; if ( balances [ _owner ] > totalSupply ) revert ( ) ; totalSupply -= balances [ _owner ] ; balances [ _owner ] = 0 ; },only the admin is allowed to burn tokens - in case if the user have n't verified identity or performed fraud
1062,"function reducePledgedFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees >= _value ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees - _value ) ; return true ; }","Reduces pledged fees to the token holders , i.e ."
1063,"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 , ""No token specified"" ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; uint amountToWithdraw = amount ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] - amount ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; require ( StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) , ""error with transfer"" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalStopMasternode ( msg . sender ) ; }",Public function that allows any user to withdraw deposited tokens and stop as masternode
1065,"function fillOffers ( address _filler , bytes32 [ ] _offerHashes , uint256 [ ] _amountsToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerHashes . length > 0 , 'Invalid input' ) ; require ( _offerHashes . length == _amountsToTake . length , 'Invalid inputs' ) ; bytes32 msgHash = keccak256 ( abi . encodePacked ( ""fillOffers"" , _filler , _offerHashes , _amountsToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; for ( uint32 i = 0 ; i < _offerHashes . length ; i ++ ) { _fill ( _filler , _offerHashes [ i ] , _amountsToTake [ i ] , etherAddr , 0 ) ; } _paySeparateFees ( _filler , _feeAsset , _feeAmount , ReasonFillerFeeGive , ReasonFillerFeeReceive ) ; }",Fills multiple offers that have been previously made using ` makeOffer ` .
1066,"function getTot ( uint256 _tokenId ) public view returns ( string totName , uint256 sellingPrice , address owner ) { Tot storage tot = tots [ _tokenId ] ; totName = tot . name ; sellingPrice = totIndexToPrice [ _tokenId ] ; owner = totIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific tot .
1067,"function ( ) public payable { if ( now < PRESALE_START_DATE ) revert ( ) ; if ( now > PRESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the pre sale has been funded to the maximum amount
1068,"function _getHeroGenesOrClaimFirstHero ( uint _heroId ) internal returns ( uint heroId , uint heroGenes ) { heroId = _heroId ; if ( heroTokenContract . balanceOf ( msg . sender ) == 0 ) { heroId = claimHero ( ) ; } ( , , , heroGenes ) = heroTokenContract . heroes ( heroId ) ; }","Used in transport , challenge and train , to get the genes of a specific hero , a claim a hero if did n't have any ."
1069,function ownerWithdraw ( uint256 value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; },"The owner can withdraw ethers already during presale , only if the minimum funding level has been reached"
1071,"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyWhitelisted { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }",Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
1072,"function refund ( address _investor ) onlyICOContract public returns ( bool ) { if ( state != State . Refunding ) { error ( 'refund: state != State.Refunding' ) ; return false ; } if ( deposited [ _investor ] == 0 ) { error ( 'refund: no deposit to refund' ) ; return false ; } uint256 depositedValue = deposited [ _investor ] ; deposited [ _investor ] = 0 ; tokensAcquired [ _investor ] = 0 ; _investor . transfer ( depositedValue ) ; emit Refunded ( _investor , depositedValue ) ; return true ; }",ICO Smart Contract can call this function for the investor to refund
1073,"function mintTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . generateTokens ( _destination , _tokens ) ; NewSale ( _destination , 0 , _tokens ) ; }",Allows the owner to manually mint some SHP to an address if something goes wrong
1077,"function fundDaoFor ( uint _from , uint _to ) returns ( bool ) ;",Function for the funding of the Dao by a group of partners
1079,"function claimTokens ( IERC20Token _address , address _to ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }",Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
1080,"function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) , ""Cannot deposit fees into frozen accounts"" ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] , ""Fees have already been withdrawn in this period"" ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }",Compute the last period 's fee entitlement for the message sender and then deposit it into their nomin account .
1081,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) throw ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
1083,"function _createToken ( uint160 matches , uint32 bonusMatches , uint96 extraStats , string userMessage ) internal returns ( uint256 ) { Token memory token = Token ( { matches : matches , bonusMatches : bonusMatches , extraStats : extraStats , timeStamp : uint64 ( now ) , message : userMessage } ) ; uint256 tokenId = tokens . push ( token ) - 1 ; require ( tokenId == uint256 ( uint32 ( tokenId ) ) , ""Failed to convert tokenId to uint256."" ) ; return tokenId ; }",Builds ERC721 token with the predictions provided by the user .
1085,function withdrawAllEth ( address _to ) onlyContractOwner external returns ( uint ) { uint _balance = address ( this ) . balance ; if ( _balance == 0 ) { return 0 ; } _to . transfer ( _balance ) ; return OK ; },Withdraws all Ether from buyback contract to specified address .
1086,function deleteBool ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete boolStorage [ _key ] ; return true ; },Delete value for Bool associated with bytes32 id key
1087,"function ierc223TransferInternal ( address from , address to , uint256 amount , bytes data ) private returns ( bool success ) { BasicToken . mTransfer ( from , to , amount ) ; if ( isContract ( to ) ) { IERC223Callback ( to ) . tokenFallback ( from , amount , data ) ; } return true ; }",internal transfer function that checks permissions and calls the tokenFallback
1090,"function registerBroker ( address _broker ) external onlyOwner { require ( ! brokers [ _broker ] , ""already registered"" ) ; brokers [ _broker ] = true ; emit LogBrokerRegistered ( _broker ) ; }",Approved an address to sign order-opening and withdrawals .
1091,"function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( sha3 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }","owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded"
1092,"function newEtherDeposit ( uint _block ) public onlyOwner payable returns ( uint _idDeposit ) { require ( msg . value > 0 ) ; require ( _block < block . number ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = ERC20 ( 0 ) ; d . amount = msg . value ; NewDeposit ( _idDeposit , ERC20 ( 0 ) , msg . value ) ; }",Adds an ether deposit to ` deposits [ ] ` ; only the ` owner ` can deposit into this contract
1093,"function transactionReplay ( address _receiver , uint256 _amount ) public onlyOwner returns ( bool replayed ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }",Can also be used for general bulk transfers via the associated python script
1094,"function cumulative ( uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }",finds total amount of neumarks issued for given amount of Euro
1098,"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || ( ! mIsUserNotAcceptingAllOfficialOperators [ _tokenHolder ] && mIsOfficialOperator [ _operator ] ) || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
1099,"function withdrawMyDepositedNomins ( ) external { uint nominsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { nominDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { nominsToSend = safeAdd ( nominsToSend , deposit . amount ) ; delete deposits [ i ] ; } } totalSellableDeposits = safeSub ( totalSellableDeposits , nominsToSend ) ; nominsToSend = safeAdd ( nominsToSend , smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( nominsToSend > 0 , ""You have no deposits to withdraw."" ) ; nomin . transfer ( msg . sender , nominsToSend ) ; emit NominWithdrawal ( msg . sender , nominsToSend ) ; }",Allows a user to withdraw all of their previously deposited nomins from this contract if needed .
1100,"function canTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;",Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
1103,"function viewToken ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string tokenTitle_ , string tokenDescription_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescription [ _tokenId ] ; }",Returns all the relevant information about a specific token
1105,function getPrice ( ) external view returns ( uint256 ) { require ( latestUpdate >= now - staleTime ) ; return POLYUSD ; },Returns price - should throw if not valid
1106,function totalSupply ( ) public view returns ( uint _totalSupply ) { _totalSupply = activeLoans ; },"Returns the number of active loans in total , active loans are the loans with `` lent '' status ."
1107,"function setAccountSpendingAmount ( Data storage self , address account , uint amount ) internal returns ( bool success ) { require ( updateAccountSpendingPeriod ( self , account ) , ""Error: Unable to update account spending period."" ) ; uint updatedAmount = getAccountSpendingAmount ( self , account ) . add ( amount ) ; require ( getAccountSpendingLimit ( self , account ) >= updatedAmount , ""Error: Account cannot exceed its daily spend limit."" ) ; bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; require ( self . Storage . setUint ( id , updatedAmount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set the account spending amount for the daily period
1108,"function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 parentId , uint256 sellingPrice , address owner ) { Token storage token = tokenIndexToToken [ _tokenId ] ; tokenName = token . name ; parentId = token . parentId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific token .
1110,function ( ) external payable { exchangeEtherForNomins ( ) ; },Fallback function ( exchanges ETH to nUSD )
1111,function invokeTop ( ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
1112,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferWithSender ( msg . sender , _to , _value ) ; }",Transfers ` _value ` amount of tokens to address ` _to ` .
1114,function getkEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . mul ( 1000 ) . div ( phiRate ) ; },It divides ( ETH/USD rate ) / ( PHI/USD rate )
1115,"function getAuction ( uint256 _deedId ) external view returns ( address seller , uint256 startPrice , uint256 endPrice , uint256 duration , uint256 startedAt ) { Auction storage auction = identifierToAuction [ _deedId ] ; require ( _activeAuction ( auction ) ) ; return ( auction . seller , auction . startPrice , auction . endPrice , auction . duration , auction . startedAt ) ; }",Get the auction for the given deed .
1116,"function getVillain ( uint256 _tokenId ) public view returns ( uint256 id , string villainName , uint256 sellingPrice , address owner , uint256 class , uint256 level , uint256 numSkillActive , uint256 state , uint256 zappedExipryTime , uint256 buyPrice , uint256 nextPrice , uint256 affectedByToken ) { id = _tokenId ; Villain storage villain = villains [ _tokenId ] ; villainName = villain . name ; sellingPrice = villainIndexToPrice [ _tokenId ] ; owner = villainIndexToOwner [ _tokenId ] ; class = villain . class ; level = villain . level ; numSkillActive = villain . numSkillActive ; state = villain . state ; if ( villain . state == 1 && now > villain . zappedExipryTime ) { state = 0 ; } zappedExipryTime = villain . zappedExipryTime ; buyPrice = villain . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; affectedByToken = villain . affectedByToken ; }",Returns all the relevant information about a specific villain .
1117,"function migrateLink ( address _currentAddress , address _newAddress ) external onlyDuringInitialization { require ( linkIds [ _newAddress ] == 0 ) ; if ( linkIds [ _currentAddress ] == 0 ) { linkIds [ _currentAddress ] = ++ linkCounter ; } linkIds [ _newAddress ] = linkIds [ _currentAddress ] ; emit AddressLinked ( _currentAddress , _newAddress , linkIds [ _currentAddress ] ) ; }",Submit link completed prior to deployment of this contract
1118,function totalSupply ( ) public view returns ( uint256 ) { return erc20Store . totalSupply ( ) ; },Core logic of the ERC20 ` totalSupply ` function .
1119,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) ;,minimum amount of funding to consider the sale as successful ( in euro-cents )
1120,"function getGameAmounts ( uint gameId ) public view returns ( uint , uint , uint , uint , uint ) { return ( games [ gameId ] . amountToTeamA , games [ gameId ] . amountToDraw , games [ gameId ] . amountToTeamB , games [ gameId ] . bettorsCount , games [ gameId ] . frozenTimestamp ) ; }",Returns all the info related to the bets
1122,function enableTransfers ( bool _transfersEnabled ) public onlyControllerorOwner { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
1123,"function doBuyerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doBuyerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledByBuyer ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }",Cancels the trade and returns the ether to the seller .
1124,"function setTokenNameSpace ( Data storage self , string currency ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; require ( self . Storage . setAddress ( id , address ( this ) ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set contract interface associated with a given TokenIO currency symbol ( e.g .
1125,function setTransfersAllowed ( bool _allow ) onlyOwner public { transfersAllowed = _allow ; },` onlyOwner ` changes the setting to allow transfer tokens
1126,function multiTransfer ( uint [ 2 ] [ ] _t ) returns ( bool success ) { },send a set of token to different address
1127,"function getTokenIndex ( uint256 _tokenId ) validId ( _tokenId ) public view returns ( uint64 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return lookupData . tokenIndex ; }",Get the index of PixelCon ` ( _tokenId ) `
1129,"function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( _from == address ( 0 ) && allowPrimaryIssuance ) { return Result . NA ; } if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( uint256 ( 10 ) ** 18 ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }",Used to verify the transfer transaction and prevent a given account to end up with more tokens than allowed
1130,"function togglePlotBlockedTag ( uint256 plotIndex , bool plotBlocked ) onlyOwner external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; plotBlockedTags [ plotIndex ] = plotBlocked ; }",Sets whether or not the image data in a plot should be blocked from the EthPlot UI .
1131,"function mint ( address _to , string _tokenURI ) external onlyOwner { uint currentId = tokenId ++ ; _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; }",Mint a single instance of the token only the current contract owner can do that
1132,"function changeGroupActiveStatus ( bytes32 _groupName , bool _blocked ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; groupsBlocked [ _groupName ] = _blocked ; return OK ; }",Change group status Can be called only by contract owner
1133,"function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , ""Name and Symbol string length should be greater than 0"" ) ; require ( ITickerRegistry ( tickerRegistry ) . checkValidity ( _symbol , msg . sender , _name ) , ""Trying to use non-valid symbol"" ) ; if ( registrationFee > 0 ) require ( ERC20 ( polyToken ) . transferFrom ( msg . sender , this , registrationFee ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; string memory symbol = upper ( _symbol ) ; address newSecurityTokenAddress = ISTProxy ( protocolVersionST [ protocolVersion ] ) . deployToken ( _name , symbol , 18 , _tokenDetails , msg . sender , _divisible , polymathRegistry ) ; securityTokens [ newSecurityTokenAddress ] = SecurityTokenData ( symbol , _tokenDetails ) ; symbols [ symbol ] = newSecurityTokenAddress ; emit LogNewSecurityToken ( symbol , newSecurityTokenAddress , msg . sender ) ; }",Creates a new Security Token and saves it to the registry
1134,function setRBACAddress ( address rbacAddr ) public onlyOwnerOrAdmin { rbac = RBACInterface ( rbacAddr ) ; },Change the address of the deployed RBAC contract which controls access .
1137,function get_rate ( ) constant returns ( uint256 ) { if ( now < tCampaignStart ) return 0 ; if ( now > tCampaignEnd ) return 0 ; if ( now <= tBonusStageEnd ) return scale * ( baseRate + bonusAdd ) ; if ( now <= t_1st_StageEnd ) return scale * ( baseRate + stage_1_add ) ; else if ( now <= t_2nd_StageEnd ) return scale * ( baseRate + stage_2_add ) ; else if ( now <= t_3rd_StageEnd ) return scale * ( baseRate + stage_3_add ) ; else return baseRate * scale ; },computes the current rate according to time passed since the start
1138,"function collateral ( address account ) public view returns ( uint ) { uint bal = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { bal = safeAdd ( bal , escrow . balanceOf ( account ) ) ; } return bal ; }","The total havvens owned by this account , both escrowed and unescrowed , against which nomins can be issued ."
1139,"function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) { require ( approve ( spender , amount ) ) ; success = IERC677Callback ( spender ) . receiveApproval ( msg . sender , amount , this , extraData ) ; require ( success ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
1141,"function getCompletedGamesStatistics ( ) public view returns ( uint , uint ) { uint completed = 0 ; uint ethPaid = 0 ; for ( uint i = 1 ; i <= allBoards . length ; i ++ ) { GoBoard storage board = allBoards [ i - 1 ] ; if ( ( board . status == BoardStatus . BlackWin ) || ( board . status == BoardStatus . WhiteWin ) ) { ++ completed ; ethPaid += board . tableStakes . mul ( 2 ) ; } } return ( completed , ethPaid ) ; }",We would like to easily and transparantly share the game 's statistics with anyone and present on the web-app
1142,"function approve ( address _spender , uint256 _amount ) public returns ( bool ) ;",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf
1146,"function setTokenPriceProposal ( uint _initialPriceMultiplier , uint _inflationRate , uint _closingTime ) ;",Function that allow the contractor to propose a token price
1147,"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash ) ; require ( arbitrator == questions [ question_id ] . arbitrator ) ; require ( min_timeout <= questions [ question_id ] . timeout ) ; require ( min_bond <= questions [ question_id ] . bond ) ; return questions [ question_id ] . best_answer ; }","Return the final answer to the specified question , provided it matches the specified criteria ."
1148,"function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }",Reusable code to do sanity check of transfer variables
1149,"function requestDetachment ( uint256 _tokenId ) public { require ( isApprovedOrOwner ( msg . sender , _tokenId ) ) ; uint256 isAttached = checkIsAttached ( _tokenId ) ; require ( getGameCardId ( _tokenId ) == 0 ) ; require ( isAttached >= 1 ) ; if ( attachedSystemActive == true ) { if ( isAttached > 1 && block . timestamp - isAttached > detachmentTime ) { isAttached = 0 ; } else if ( isAttached > 1 ) { require ( isAttached == 1 ) ; } else { isAttached = block . timestamp ; } } else { isAttached = 0 ; } updateIsAttached ( _tokenId , isAttached ) ; }","a wallet can request to detach it collectible , so , that it can be used in other third-party contracts ."
1151,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalKydys = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 kydyId ; for ( kydyId = 1 ; kydyId <= totalKydys ; kydyId ++ ) { if ( kydyIndexToOwner [ kydyId ] == _owner ) { result [ resultIndex ] = kydyId ; resultIndex ++ ; } } return result ; } },Returns a list of all Kydy IDs assigned to an address .
1152,function getIpfsForAssets ( uint [ ] _ids ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory hashes = new bytes32 [ ] ( _ids . length ) ; for ( uint i = 0 ; i < _ids . length ; i ++ ) { Asset memory asset = assets [ _ids [ i ] ] ; hashes [ i ] = asset . ipfsHash ; } return hashes ; },Function to get array of ipfsHashes for specific assets
1153,"function reissueAssetToRecepient ( bytes32 _symbol , uint _value , address _to ) public onlyDesignatedManager ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { return _reissueAsset ( _symbol , _value , _to ) ; }",Issues additional asset tokens ` _symbol ` if the asset have dynamic supply and sends them to recepient address ` _to ` .
1155,function getPlayerId ( uint256 _tokenId ) external view returns ( uint256 playerId ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; playerId = ( ( obj . attributes . div ( 100000000000000000 ) ) % 1000 ) ; },Gets the MLB player Id from the player attributes
1156,"function generateTokens ( address _user , uint _amount ) onlyController public returns ( bool ) { require ( balanceOf [ owner ] >= _amount ) ; balanceOf [ _user ] += _amount ; balanceOf [ owner ] -= _amount ; Transfer ( 0 , _user , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
1157,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public whenNotPaused { require ( isOperatorFor ( msg . sender , _from ) , ""Only an approved operator can use operatorSend"" ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
1158,"function isValidSignatureAndData ( address _address , bytes _sig ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _sig ) ; }",the _sig parameter of the method being validated must be the `` last '' parameter
1159,"function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from , ""wrong owner"" ) ; uint256 tokenIndex = tokenOwnerAndTokensIndex [ _tokenId ] . tokenIndex ; uint256 lastTokenIndex = ownedTokens [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] . length -- ; tokenOwnerAndTokensIndex [ lastToken ] = AddressAndTokenIndex ( { owner : _from , tokenIndex : uint32 ( tokenIndex ) } ) ; }",Internal function to remove a token ID from the list of a given address
1160,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
1161,"function getBasicData ( uint64 [ ] _indexes ) public view returns ( uint64 [ ] , address [ ] , uint256 [ ] , uint64 [ ] ) { uint64 [ ] memory tokenIndexes = new uint64 [ ] ( _indexes . length ) ; address [ ] memory sellers = new address [ ] ( _indexes . length ) ; uint256 [ ] memory currPrices = new uint256 [ ] ( _indexes . length ) ; uint64 [ ] memory timeLeft = new uint64 [ ] ( _indexes . length ) ; for ( uint i = 0 ; i < _indexes . length ; i ++ ) { Listing storage listing = marketPixelconListings [ _indexes [ i ] ] ; if ( listing . seller != address ( 0 ) ) { tokenIndexes [ i ] = _indexes [ i ] ; sellers [ i ] = listing . seller ; currPrices [ i ] = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; timeLeft [ i ] = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; } else { tokenIndexes [ i ] = 0 ; sellers [ i ] = 0 ; currPrices [ i ] = 0 ; timeLeft [ i ] = 0 ; } } return ( tokenIndexes , sellers , currPrices , timeLeft ) ; }",Get market listing data for the given indexes
1163,"function addNotaryToOrder ( address orderAddr , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public whenNotPaused isOrderLegit ( orderAddr ) validAddress ( notary ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; require ( ! order . hasNotaryBeenAdded ( notary ) ) ; require ( allowedNotaries . exist ( notary ) ) ; require ( CryptoUtils . isNotaryAdditionValid ( orderAddr , notary , responsesPercentage , notarizationFee , notarizationTermsOfService , notarySignature ) ) ; bool okay = order . addNotary ( notary , responsesPercentage , notarizationFee , notarizationTermsOfService ) ; if ( okay ) { openOrders . insert ( orderAddr ) ; ordersByNotary [ notary ] . push ( orderAddr ) ; emit NotaryAddedToOrder ( order , notary ) ; } return okay ; }",Adds a notary to the Data Order .
1164,"function triggerRecovery ( uint ein , address newAssociatedAddress , uint8 v , bytes32 r , bytes32 s , uint timestamp ) public _identityExists ( ein ) _hasIdentity ( newAssociatedAddress , false ) ensureSignatureTimeValid ( timestamp ) { require ( canRecover ( ein ) , ""Cannot trigger recovery yet."" ) ; Identity storage _identity = identityDirectory [ ein ] ; if ( canChangeRecoveryAddress ( ein ) ) { require ( msg . sender == _identity . recoveryAddress , ""Only the current recovery address can trigger recovery."" ) ; } else { require ( msg . sender == recoveryAddressChangeLogs [ ein ] . oldRecoveryAddress , ""Only the recently removed recovery address can trigger recovery."" ) ; } require ( isSigned ( newAssociatedAddress , keccak256 ( abi . encodePacked ( byte ( 0x19 ) , byte ( 0 ) , address ( this ) , ""I authorize being added to this Identity via recovery."" , ein , newAssociatedAddress , timestamp ) ) , v , r , s ) , ""Permission denied."" ) ; recoveryLogs [ ein ] = Recovery ( block . timestamp , keccak256 ( abi . encodePacked ( _identity . associatedAddresses . members ) ) ) ; emit RecoveryTriggered ( msg . sender , ein , _identity . associatedAddresses . members , newAssociatedAddress ) ; resetIdentityData ( _identity , msg . sender , false ) ; addAssociatedAddress ( ein , newAssociatedAddress ) ; }",Allows recovery addresses to trigger the recovery process for an Identity .
1165,"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , """" , 0 , 0 ) ; SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }",deploys the token and adds default modules like the GeneralTransferManager .
1166,function setSecurityGuard ( address _newSecurityGuard ) onlyContractOwner { securityGuard = _newSecurityGuard ; },` onlyOwner ` Sets the address of ` securityGuard `
1168,function isAbsent ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; return channel . sender == 0 ; },Check if the channel is not present .
1171,"function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` ."
1176,"function removeTokenGrant ( uint256 _grantId ) external onlyV12MultiSig { Grant storage tokenGrant = tokenGrants [ _grantId ] ; require ( tokenGrant . isActive , ""is not active"" ) ; address recipient = tokenGrant . recipient ; uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; uint256 amountNotVested = ( tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ) . sub ( amountVested ) ; require ( token . transfer ( recipient , amountVested ) ) ; require ( token . transfer ( v12MultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . daysClaimed = 0 ; tokenGrant . totalClaimed = 0 ; tokenGrant . recipient = address ( 0 ) ; tokenGrant . isActive = false ; emit GrantRemoved ( recipient , amountVested , amountNotVested ) ; }",Terminate token grant transferring all vested tokens to the ` _grantId ` and returning all non-vested tokens to the V12 MultiSig Secured to the V12 MultiSig only
1179,"function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { require ( msg . sender == mBurnOperator ) ; super . burn ( _amount , _holderData ) ; }",Burns ` _amount ` tokens from ` _tokenHolder ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
1180,"function removePolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName ) onlyContractOwner external returns ( uint ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupNameIndex = _policy . groupName2index [ _groupName ] ; if ( _policyGroupNameIndex == 0 ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } uint _policyGroupsCount = _policy . groupsCount ; if ( _policyGroupNameIndex != _policyGroupsCount ) { Requirements storage _requirements = _policy . participatedGroups [ _policyGroupsCount ] ; _policy . participatedGroups [ _policyGroupNameIndex ] = _requirements ; _policy . groupName2index [ _requirements . groupName ] = _policyGroupNameIndex ; } _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ) ; delete _policy . groupName2index [ _groupName ] ; delete _policy . participatedGroups [ _policyGroupsCount ] ; _policy . groupsCount = _policyGroupsCount . sub ( 1 ) ; PolicyRuleRemoved ( _sig , _contract , _policyHash , _groupName ) ; return OK ; }",Remove policy rule Can be called only by contract owner
1181,"function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }",Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract
1183,function isMinter ( address _who ) public view returns ( bool ) { return minters [ _who ] ; },Look up for the minter role on providen address
1184,function ( ) public { require ( false ) ; },"If anybody sends Ether directly to this contract , consider the sender will be rejected ."
1187,"function addAddressesToAdmins ( address [ ] _admins ) external onlyOwner { require ( _admins . length > 0 , ""Cannot add an empty list to admins!"" ) ; for ( uint256 i = 0 ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; require ( user != address ( 0 ) , ""Cannot add the zero address to admins!"" ) ; if ( ! admins [ user ] ) { admins [ user ] = true ; emit AdminAdded ( user ) ; } } }",Adds a list of addresses to the admins list .
1188,"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
1190,function getMintedActFromCurrentLockPeriod ( address _address ) private view returns ( uint256 ) { return lockedBbkPerUser [ _address ] . mul ( totalMintedActPerLockedBbkToken . sub ( mintedActPerUser [ _address ] ) ) . div ( 1e18 ) ; },Calculates minted ACT from `` Current Lock Period '' for a given address
1191,"function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; supply = supply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }",Migrate tokens to the new token contract .
1192,"function adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( balanceOf ( _to ) == 0 ) && ( _to != address ( 0 ) ) ) { investorCount = investorCount . add ( 1 ) ; } if ( _value == balanceOf ( _from ) ) { investorCount = investorCount . sub ( 1 ) ; } if ( ! investorListed [ _to ] && ( _to != address ( 0 ) ) ) { investors . push ( _to ) ; investorListed [ _to ] = true ; } }",keeps track of the number of non-zero token holders
1193,function abort ( ) external withTimedTransitions ( ) onlyState ( State . Before ) only ( ROLE_WHITELIST_ADMIN ) { NEUMARK . burn ( NEUMARK . balanceOf ( this ) ) ; selfdestruct ( msg . sender ) ; },used by WHITELIST_ADMIN to kill commitment process before it starts
1195,"function ownerClawbackCredits ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; require ( ! creditsClawbacked ) ; creditsClawbacked = true ; parsecToken . transfer ( owner , parsecToken . balanceOf ( this ) ) ; }","The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract ."
1197,function getUserGroups ( address _user ) public view returns ( bytes32 [ ] _groups ) { if ( ! isRegisteredUser ( _user ) ) { return ; } Member storage _member = address2member [ _user ] ; uint _groupsCount = _member . groupsCount ; if ( _groupsCount == 0 ) { return ; } _groups = new bytes32 [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { uint _groupNameIdx = _member . index2globalIndex [ _groupIdx + 1 ] ; _groups [ _groupIdx ] = index2groupName [ _groupNameIdx ] ; } },Gets a list of groups where passed user is a member
1198,function countOfDeeds ( ) external view returns ( uint256 ) { return parts . length ; },Returns the total number of deeds currently in existence .
1199,"function destroy ( address [ ] tokens ) onlyOwner { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }",The called token contracts could try to re-enter this contract .
1202,function setMinDai ( uint wad ) public auth { minDai = wad ; },set the minimal Dai for trades ( depends on otc )
1203,"function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; }","Gets the current supply interest rate based on the given asset , total cash and total borrows"
1205,"function getBorrowRate ( address asset , uint cash , uint borrows ) public returns ( uint , uint ) { require ( isAllowed ( asset , cash ) ) ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }","Gets the current borrow interest rate based on the given asset , total cash and total borrows"
1206,"function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { require ( templates [ template_id ] > 0 , ""template must exist"" ) ; bytes32 content_hash = keccak256 ( abi . encodePacked ( template_id , opening_ts , question ) ) ; bytes32 question_id = keccak256 ( abi . encodePacked ( content_hash , arbitrator , timeout , msg . sender , nonce ) ) ; _askQuestion ( question_id , content_hash , arbitrator , timeout , opening_ts ) ; emit LogNewQuestion ( question_id , msg . sender , template_id , question , content_hash , arbitrator , timeout , opening_ts , nonce , now ) ; return question_id ; }",Ask a new question and return the ID
1207,"function settleWithdraw ( address from , uint256 amount , uint256 originalAmount , bytes32 withdrawTxHash , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { emit LogWithdrawSettled ( from , msg . sender , amount , originalAmount , withdrawTxHash , reference ) ; }",issued by deposit manager when withdraw request was settled .
1208,"function getRewardsWithdrawn ( uint32 _canvasId , address _address ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _history . rewardsCumulative . length == 0 || _index == 0 ) { return 0 ; } return ( _history . rewardsCumulative [ _index ] / PIXEL_COUNT ) * _pixelsOwned ; }",Returns total amount of rewards that has been already paid ( added to pending withdrawals ) by a given address .
1209,"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract
1210,"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Airdrop was NOT added"" ) ; }",Distirbutes a differen quantity of tokens to all the specified addresses .
1212,"function removeAddressFromAccountFor ( address _addressToRemove ) public onlyRegistryAdmin { uint256 _accountId = registry . accountIdForAddress ( _addressToRemove ) ; registry . removeAddressFromAccount ( _addressToRemove ) ; emit AddressRemoved ( _accountId , _addressToRemove ) ; }",Remove an address from an account for a user
1213,function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; },Get the token balance for a specified address
1214,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
1218,"function getDivCard ( uint _divCardId ) public view returns ( string divCardName , uint sellingPrice , address owner ) { Card storage divCard = divCards [ _divCardId ] ; divCardName = divCard . name ; sellingPrice = divCardIndexToPrice [ _divCardId ] ; owner = divCardIndexToOwner [ _divCardId ] ; }",Returns all the relevant information about a specific div card
1219,function transferOwnershipTo ( address _to ) public ;,calls ` Ownable.transferOwnership ( ) ` or ` Controlled.changeController ( ) `
1220,"function addVestingUser ( address user , uint256 amount ) public onlyOwner preInitState { uint256 oldAmount = ownersMap [ user ] ; ownersMap [ user ] = amount ; ownersMapFirstPeriod [ user ] = amount / 3 ; ownersMapSecondPeriod [ user ] = amount / 3 ; ownersMapThirdPeriod [ user ] = amount - ownersMapFirstPeriod [ user ] - ownersMapSecondPeriod [ user ] ; originalAddressTraker [ user ] = user ; changeAddressAttempts [ user ] = 0 ; totalCommitted += ( amount - oldAmount ) ; AddUser ( user , amount ) ; }",Can be called only before initialization Equal vesting in three periods
1221,function signalBackupWithdraw ( address _token ) external { traderWithdrawalSignals [ msg . sender ] [ _token ] = now ; },A trader can withdraw without needing a broker signature if they first call ` signalBackupWithdraw ` for the token they want to withdraw .
1222,"function mint ( address _to , uint _value ) public { require ( msg . sender == owner ) ; mintToken ( _to , _value ) ; }",Will cause a certain ` _value ` of coins minted for ` _to ` .
1223,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) public ;",Transfers the ownership of an NFT from one address to another address
1224,"function getPony ( uint256 _id ) external view returns ( bool isGestating , bool isReady , uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint16 upgradeIndex , uint8 unicornation ) { Pony storage pon = ponies [ _id ] ; isGestating = ( pon . matingWithId != 0 ) ; isReady = ( pon . cooldownEndBlock <= block . number ) ; cooldownIndex = uint256 ( pon . cooldownIndex ) ; nextActionAt = uint256 ( pon . cooldownEndBlock ) ; siringWithId = uint256 ( pon . matingWithId ) ; birthTime = uint256 ( pon . birthTime ) ; matronId = uint256 ( pon . matronId ) ; sireId = uint256 ( pon . sireId ) ; generation = uint256 ( pon . generation ) ; genes = pon . genes ; upgradeIndex = pon . txCount ; unicornation = pon . unicornation ; }",Returns all the relevant information about a specific Pony .
1225,function setStaleTime ( uint256 _staleTime ) onlyOwner public { staleTime = _staleTime ; },Allows owner to set time after which price is considered stale
1226,"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }",Helper function actually performing the sending of tokens .
1227,"function transfer ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value != 0 ) ; require ( data . length != 0 ) ; if ( isContract ( to ) ) { return transferToContract ( to , value , data ) ; } else { return transferToAddress ( to , value , data ) ; } }",To make token transfers to a user or a contract with additional data
1228,"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == owner || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint CROWDSALE_PCT = 62 ; uint TEAMHOLDER_PCT = 20 ; uint COMMUNITYHOLDER_PCT = 15 ; uint FUTUREHOLDER_PCT = 3 ; assert ( CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100 ) ; uint256 tokenCap = wpr . totalSupply ( ) . mul ( 100 ) . div ( CROWDSALE_PCT ) ; wpr . mint ( teamHolder , tokenCap . mul ( TEAMHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( communityHolder , tokenCap . mul ( COMMUNITYHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( futureHolder , tokenCap . mul ( FUTUREHOLDER_PCT ) . div ( 100 ) ) ; require ( wpr . finishMinting ( ) ) ; wpr . transferOwnership ( owner ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }",This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .
1229,"function changeHolderCount ( uint256 _maxHolderCount ) public withPerm ( ADMIN ) { emit LogModifyHolderCount ( maxHolderCount , _maxHolderCount ) ; maxHolderCount = _maxHolderCount ; }",sets the maximum percentage that an individual token holder can hold
1230,"function destroyTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint256 previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
1231,"function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 defense , uint32 level , uint256 exp , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; defense = captain . defense ; level = captain . level ; exp = captain . exp ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }",Returns all the relevant information about a specific tokenId .
1235,"function migrateAttestation ( address _requester , address _attester , address _subject , bytes32 _dataHash ) public onlyDuringInitialization { emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; }",Submit attestation completed prior to deployment of this contract
1236,"function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) ;",returns module list for a module name - will return first match
1238,"function getPlayerId ( bytes32 boardHash , bytes32 playerName , address playerAddress ) constant internal returns ( uint8 ) { Board storage g = boards [ boardHash ] ; for ( uint8 i = 0 ; i <= g . numPlayers ; i ++ ) { if ( ( keccak256 ( abi . encodePacked ( g . players [ i ] . playerName ) ) == keccak256 ( abi . encodePacked ( playerName ) ) || playerAddress == g . players [ i ] . playerAddress ) && g . players [ i ] . isActive == 1 ) { return i ; break ; } } return 255 ; }",Get the player id either by player Name or address
1239,function getNextVestingTime ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ TIME_INDEX ] ; },Obtain the time at which the next schedule entry will vest for a given user .
1241,"function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy notFeeAddress ( from ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; tokenState . setAllowance ( from , messageSender , tokenState . allowance ( from , messageSender ) . sub ( value ) ) ; synthetix . synthInitiatedFeePayment ( from , currencyKey , fee ) ; return _internalTransfer ( from , to , amountReceived , data ) ; }",Override ERC223 transferFrom function in order to subtract the transaction fee and send it to the fee pool for SNX holders to claim .
1242,function resetDemo ( ) external onlyOwner { voteCountTotal = 0 ; currentVoteResults [ 0 ] = 0 ; currentVoteResults [ 1 ] = 0 ; currentVoteResults [ 2 ] = 0 ; currentVoteResults [ 3 ] = 0 ; emit DemoResetted ( ) ; },"As this is just a DEMO contract , allow the onwer to reset the state of the Demo conract ."
1243,"function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber ) public returns ( uint ) { return issueAssetWithInitialReceiver ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , _blockNumber , msg . sender ) ; }",Issues new asset token on the platform .
1244,"function getGrey ( uint256 _tokenId ) public view returns ( string greyName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Grey storage grey = greys [ _tokenId ] ; greyName = grey . name ; sellingPrice = greyIndexToPrice [ _tokenId ] ; owner = greyIndexToOwner [ _tokenId ] ; previousPrice = greyIndexToPreviousPrice [ _tokenId ] ; previousOwners = greyIndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific grey .
1245,"function canReceive ( address receiver ) external view returns ( bool ) { return _registry . hasAttribute ( receiver , _validAttributeTypeID ) ; }",Check if an account is approved to receive token transfers at account ` receiver ` .
1246,"function getMeme ( uint256 _tokenId ) public view returns ( uint256 Id , string memeName , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; Id = _tokenId ; memeName = meme . name ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific meme .
1247,"function callOperator ( address _operator , address _from , address _to , uint256 _value , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensOperator"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensOperator ( recipientImplementation ) . madeOperatorForTokens ( _operator , _from , _to , _value , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" ) ; } }",Helper function that checks for IEIP777TokensOperator on the recipient and calls it .
1248,"function unlockSecondPrivate ( ) public locked onlyOwner { require ( block . timestamp >= secondPrivateReleaseTime ) ; require ( secondPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= secondPrivateLockedAmount ) ; token . transfer ( privateLockAddress , secondPrivateLockedAmount ) ; secondPrivateLockedAmount = 0 ; }",Transfers tokens held by timelock to private .
1249,"function takeSnapshot ( uint256 _year , uint256 _nextPE ) onlyOwner public { require ( _year > yearsPast [ yearsPast . length - 1 ] ) ; uint256 reward = peBalance / totalSupply ; for ( uint256 k = 1 ; k <= pos ; k ++ ) { snapShot [ _year ] [ addressList [ k ] ] = balanceOf [ addressList [ k ] ] * reward ; } yearsPast . push ( _year ) ; peLastPeriod += peBalance ; peBalance = 0 ; nextPE = _nextPE ; }",Contract owner can take snapshot of current balances and issue PE to each balance
1250,"function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }",Transfers tokens held by JZMLock to beneficiary .
1251,"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 rate = getRate ( loan , oracleData ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , rate ) ) ) ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; Lent ( index , loan . lender , cosigner ) ; return true ; }","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender ."
1252,"function splitProfits ( ) external { require ( splitInService ) ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits ) ; } } }",Split the monthly profits of the Casino to the users
1253,"function setBonuses ( uint [ ] _bonusLimits , uint [ ] _bonusPercentages ) public onlyAdmin { require ( _bonusLimits . length == _bonusPercentages . length ) ; require ( _bonusPercentages . length == 3 ) ; for ( uint8 i = 0 ; i < _bonusLimits . length ; i ++ ) { bonusLimits [ i ] = _bonusLimits [ i ] ; bonusPercentages [ i ] = _bonusPercentages [ i ] ; } }",Sets the bonus structure.The bonus limits must be in decreasing order .
1256,"function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; Burn ( msg . sender , _value ) ; }",To eliminate tokens and adjust the price of the FEE tokens
1259,"function takeOwnership ( uint256 _tokenId ) external { require ( isSenderApprovedFor ( _tokenId ) , ""not approved"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }",Claims the ownership of a given token ID
1260,"function viewTokenMeta ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string specialQuality_ , string tokenTitle_ , string tokenDescription_ , string iptcKeyword_ , string tokenClass_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; specialQuality_ = specialQualities [ _tokenId ] ; iptcKeyword_ = iptcKeywords [ _tokenId ] ; tokenClass_ = tokenClasses [ _tokenId ] ; }",Returns all the relevant information about a specific token
1262,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) external { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
1263,"function isRegisteredToFirm ( string firmName , address authority ) public view returns ( bool registered ) { return lib . isRegisteredToFirm ( firmName , authority ) ; }",Checks if an authority account is registered to a given firm
1265,function capReached ( ) public view returns ( bool ) { if ( isFinalized ) { return ( finalAmountReturned == 0 ) ; } return ( mintedPerTierTotal [ mintedPerTierTotal . length - 1 ] == tokensPerTierTotal [ tokensPerTierTotal . length - 1 ] ) ; },Checks whether the cap has been reached .
1266,function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) ;,Get the ID of PixelCon # ` ( _tokenIndex ) `
1267,function getValidatorDescription ( address validator ) external view returns ( string description ) ;,Get a description of the validator at account ` validator ` .
1268,"function findOrCreatePledge ( uint64 owner , uint64 [ ] delegationChain , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState state ) internal returns ( uint64 ) { bytes32 hPledge = sha3 ( owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ; uint64 idx = hPledge2idx [ hPledge ] ; if ( idx > 0 ) return idx ; idx = uint64 ( pledges . length ) ; hPledge2idx [ hPledge ] = idx ; pledges . push ( Pledge ( 0 , owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ) ; return idx ; }","This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet"
1269,"function transferFromWithSender ( address _sender , address _from , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfFrom = erc20Store . balances ( _from ) ; require ( _value <= balanceOfFrom ) ; uint256 senderAllowance = erc20Store . allowed ( _from , _sender ) ; require ( _value <= senderAllowance ) ; erc20Store . setBalance ( _from , balanceOfFrom - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Store . setAllowance ( _from , _sender , senderAllowance - _value ) ; erc20Proxy . emitTransfer ( _from , _to , _value ) ; return true ; }",Core logic of the ERC20 ` transferFrom ` function .
1271,"function unitExists ( uint x , uint y ) public view returns ( bool ) { return ( soldUnits [ x ] [ y ] != 0 ) ; }",Check whether exist Unit with same x any y coordinates and it was sold already in order to prevent over writing
1272,"function disableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( released , ""Invalid operation. The transfer state is already restricted."" ) ; released = false ; emit TokenReleased ( released ) ; return true ; }",This function disables token transfers for everyone .
1274,"function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner onlyState ( State . BEFORE_START ) { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }",start voting at ` startBlockNr ` for ` durationHrs ` .
1281,"function attest ( address _subject , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) external { attestForUser ( _subject , msg . sender , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }",Function for attester to submit attestation from their own account )
1283,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
1286,"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external view returns ( bool ) { bytes memory data = abi . encodePacked ( ""Republic Protocol: open: "" , _trader , _orderID ) ; address signer = Utils . addr ( data , _signature ) ; return ( brokers [ signer ] == true ) ; }",Verifies a broker 's signature for an order opening .
1288,"function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; Transfer ( _from , _to , _value ) ; }",Transfer tokens from an address to another ~ ERC-20 Standard
1289,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = memeIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a meme
1290,"function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _newdao , uint _minutesForTokensCloning , uint _minutesDebatingPeriod ) payable returns ( uint ) ;",Function to make a proposal to change the Dao rules
1291,"function rejectAllOfficialOperators ( ) external { require ( ! mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , ""Official operators are already rejected by msg.sender."" ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = true ; emit OfficialOperatorsRejectedByUser ( msg . sender ) ; }",Unauthorize all official operators to manage ` msg.sender ` 's tokens .
1294,function getDarknodeBond ( address _darknodeID ) external view returns ( uint256 ) { return store . darknodeBond ( _darknodeID ) ; },Retrieves the bond amount of a darknode in 10^-18 REN .
1296,"function approve ( address _to , uint256 _tokenId ) public validId ( _tokenId ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( _to != owner , ""Cannot approve PixelCon owner"" ) ; require ( msg . sender == owner || operatorApprovals [ owner ] [ msg . sender ] , ""Sender does not have permission to approve address"" ) ; tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }",Approve ` ( _to ) ` to transfer PixelCon ` ( _tokenId ) ` ( zero indicates no approved address )
1297,"function confirmPayment ( uint64 idPledge , uint amount ) onlyVault { Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Paying ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paid ) ; doTransfer ( idPledge , idNewPledge , amount ) ; }",Method called by the vault to confirm a payment .
1298,function setVerifier ( address _newVerifier ) external requireGod { require ( _newVerifier != address ( 0 ) ) ; verifierAddress = _newVerifier ; },The Verifier address is used to confirm the authenticity of the claim signature .
1300,"function mintTokens ( address beneficiary , uint256 amount ) internal { tokensMinted = tokensMinted . add ( amount ) ; require ( tokensMinted <= hardCap ) ; assert ( token . mint ( beneficiary , amount ) ) ; AddHOLDer ( beneficiary ) ; }",mint tokens and apply PoolParty method ( Alber Erre )
1301,"function spendFromSwap ( bytes32 swapId , uint amount , address recipient ) internal { require ( amount <= hashIdToSwap [ swapId ] . amount ) ; hashIdToSwap [ swapId ] . amount -= amount ; if ( hashIdToSwap [ swapId ] . amount == 0 ) { delete hashIdToSwap [ swapId ] ; assert ( hashIdToSwap [ swapId ] . amount == 0 ) ; } recipient . transfer ( amount ) ; }",Send ether out of this contract to swap beneficiary and update or delete entry in swap mapping
1303,function deedUri ( uint256 _deedId ) external view returns ( string _uri ) { return _metadata ( _deedId ) ; },A distinct URI ( RFC 3986 ) for a given token .
1308,"function getAccountSpendingAmount ( Data storage self , address account ) internal view returns ( uint amount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }",Return the amount spent during the current period
1310,function currentRate ( uint256 amount ) view public returns ( uint256 ) { uint8 roundNum = currentRoundNum ( ) ; if ( roundNum == 0 ) { return 0 ; } else { uint8 round = roundNum - 1 ; if ( amount < rounds [ round ] . bulkThreshold ) { return rounds [ round ] . rate ; } else { return rounds [ round ] . rateBulk ; } } },Fetches current rate ( how many tokens you get for 1 ETH )
1312,"function hasRecentPrice ( address ofAsset ) view pre_cond ( assetIsRegistered ( ofAsset ) ) returns ( bool isRecent ) { var ( , timestamp ) = getPrice ( ofAsset ) ; return ( sub ( now , timestamp ) <= VALIDITY ) ; }",Whether price of asset has been updated less than VALIDITY seconds ago
1313,function open ( ) onlyOwner public { opened = true ; },Open the Registry so that anyone can register .
1314,"function epoch ( ) external { if ( previousEpoch . blocknumber == 0 ) { require ( msg . sender == owner , ""not authorized (first epochs)"" ) ; } require ( block . number >= currentEpoch . blocknumber + minimumEpochInterval , ""epoch interval has not passed"" ) ; uint256 epochhash = uint256 ( blockhash ( block . number - 1 ) ) ; previousEpoch = currentEpoch ; currentEpoch = Epoch ( { epochhash : epochhash , blocknumber : block . number } ) ; numDarknodesPreviousEpoch = numDarknodes ; numDarknodes = numDarknodesNextEpoch ; if ( nextMinimumBond != minimumBond ) { minimumBond = nextMinimumBond ; emit LogMinimumBondUpdated ( minimumBond , nextMinimumBond ) ; } if ( nextMinimumPodSize != minimumPodSize ) { minimumPodSize = nextMinimumPodSize ; emit LogMinimumPodSizeUpdated ( minimumPodSize , nextMinimumPodSize ) ; } if ( nextMinimumEpochInterval != minimumEpochInterval ) { minimumEpochInterval = nextMinimumEpochInterval ; emit LogMinimumEpochIntervalUpdated ( minimumEpochInterval , nextMinimumEpochInterval ) ; } if ( nextSlasher != slasher ) { slasher = nextSlasher ; emit LogSlasherUpdated ( slasher , nextSlasher ) ; } emit LogNewEpoch ( ) ; }",Progress the epoch if it is possible to do so .
1315,"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
1316,function setPriceInCents ( uint256 newBuyPrice ) onlyOwner public { buyPriceInCent = newBuyPrice ; },Allow users to buy tokens for ` newBuyPrice ` eth
1317,"function callPlugin ( bool before , uint64 adminId , uint64 fromPledge , uint64 toPledge , uint64 context , uint amount ) internal returns ( uint allowedAmount ) { uint newAmount ; allowedAmount = amount ; PledgeAdmin storage admin = findAdmin ( adminId ) ; if ( ( address ( admin . plugin ) != 0 ) && ( allowedAmount > 0 ) ) { if ( before ) { newAmount = admin . plugin . beforeTransfer ( adminId , fromPledge , toPledge , context , amount ) ; require ( newAmount <= allowedAmount ) ; allowedAmount = newAmount ; } else { admin . plugin . afterTransfer ( adminId , fromPledge , toPledge , context , amount ) ; } } }",` callPlugin ` is used to trigger the general functions in the plugin for any actions needed before and after a transfer happens .
1318,"function finalize ( bytes _result , bool _success , bytes _signature ) external returns ( bool ) ;",It can be called by assigned lighthouse only
1319,"function approve ( address spender , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }",Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account
1320,"function updateNonClosingBalanceProof ( uint256 channel_identifier , address closing_participant , address non_closing_participant , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes closing_signature , bytes non_closing_signature ) external { require ( channel_identifier == getChannelIdentifier ( closing_participant , non_closing_participant ) ) ; require ( balance_hash != bytes32 ( 0x0 ) ) ; require ( nonce > 0 ) ; address recovered_non_closing_participant ; address recovered_closing_participant ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number >= block . number ) ; recovered_non_closing_participant = recoverAddressFromBalanceProofUpdateMessage ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature , non_closing_signature ) ; require ( non_closing_participant == recovered_non_closing_participant ) ; recovered_closing_participant = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature ) ; require ( closing_participant == recovered_closing_participant ) ; Participant storage closing_participant_state = channel . participants [ closing_participant ] ; require ( closing_participant_state . is_the_closer ) ; updateBalanceProofData ( channel , closing_participant , nonce , balance_hash ) ; emit NonClosingBalanceProofUpdated ( channel_identifier , closing_participant , nonce ) ; }","Called on a closed channel , the function allows the non-closing participant to provide the last balance proof , which modifies the closing participant 's state ."
1321,"function broadcastSignedRequestAsPayerAction ( bytes _requestData , bytes _payeesPaymentAddress , bytes _payerRefundAddress , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , ""expiration should be after current time"" ) ; require ( Signature . checkBtcRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , ""signature should be correct"" ) ; return createAcceptAndAdditionalsFromBytes ( _requestData , _payeesPaymentAddress , _payerRefundAddress , _additionals ) ; }",Function to broadcast and accept an offchain signed request ( the broadcaster can also pays and makes additionals ) .
1322,"function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external onlyOwner nonReentrant { _addModule ( _moduleFactory , _data , _maxCost , _budget ) ; }",Function used to attach the module in security token
1323,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _value ) revert ( ) ; allowed [ _from ] [ msg . sender ] -= _value ; return doTransfer ( _from , _to , _value ) ; }","send _value amount of tokens to _to address from _from address , on the condition it is approved by _from"
1325,"function transferFrom ( address _from , address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( _from ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }",This function is disabled during the crowdfunding .
1326,"function setWithholdingFixed ( address [ ] _investors , uint256 _withholding ) public withPerm ( MANAGE ) { require ( _withholding <= 10 ** 18 , ""Incorrect withholding tax"" ) ; emit SetWithholdingFixed ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { withholdingTax [ _investors [ i ] ] = _withholding ; } }",Function to set withholding tax rates for investors
1327,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ _from ] - _value < tokenBalanceOf [ _from ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; orderToTransfer ( msg . sender , _from , _to , _value , ""Order to transfer tokens from allowed account"" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return true ; }",deliberately authorized the sender of the message via some mechanism ;
1328,"function _verifyInput ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { require ( realitio . isPendingArbitration ( question_id ) , ""The question must be pending arbitration in realitio"" ) ; bytes32 history_hash = realitio . getHistoryHash ( question_id ) ; require ( history_hash == keccak256 ( last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) , ""The history parameters supplied must match the history hash in the realitio contract"" ) ; }",Return data needed to verify the last history item
1334,"function setPrepaid ( address _backer , uint _tokenPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external founderCall returns ( uint ) { if ( _tokenPrice == 0 || _tokenAmount == 0 || claimedPrepaidUnits > 0 || _tokenAmount + prepaidUnits + claimedUnits > promissoryUnits ) throw ; if ( earlyBackerList . length == numOfBackers && backers [ _backer ] . length == 0 ) throw ; if ( backers [ _backer ] . length == 0 ) { earlyBackerList . push ( _backer ) ; backersAddresses . push ( _backer ) ; } backers [ _backer ] . push ( backerData ( _tokenPrice , _tokenAmount , sha3 ( _privatePhrase , _backer ) , true , false , _backerRank ) ) ; prepaidUnits += _tokenAmount ; lastPrice = _tokenPrice ; AddedPrepaidTokensEvent ( _backer , backers [ _backer ] . length - 1 , _tokenPrice , _tokenAmount ) ; return backers [ _backer ] . length - 1 ; }",Adding ` _backer.address ( ) ` as an early backer
1335,"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit_ ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }",Owner : Withdraw excess funds which do n't belong to Bskt Token holders
1337,"function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) internal pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }","Compute '_k ( 1+1/_q ) ^ _n ' , with precision '_p '"
1339,"function transfer ( address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }",This function is disabled during the crowdfunding .
1340,"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }",Override the functions to not allow token transfers until the end of the ICO
1341,"function setMinMaxContribution ( uint256 _min , uint256 _max ) public isAdmin isOpenOrClosed { require ( _max <= maxAllocation ) ; require ( _min <= _max ) ; minContribution = _min ; maxContribution = _max ; }",Sets the min and the max contribution configurations .
1342,function getBook ( ) public constant returns ( uint [ ] ) ;,Returns an array of all prices and their volumes .
1344,"function getCollectionData ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 , uint64 [ ] ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return ( collectionNames [ _collectionIndex ] , collectionTokens [ _collectionIndex ] ) ; }",Get details of collection # ` ( _collectionIndex ) `
1346,function registerModule ( address _moduleFactory ) external ;,Called by the ModuleFactory owner to register new modules for SecurityToken to use
1347,"function claimByProof ( address _claimer , bytes32 [ ] data , bytes32 [ ] proofs , uint256 number ) onlyToken returns ( bool success ) { return false ; }",Only one of claimByProof ( ) or claim ( ) will potentially be activated in the future .
1349,"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = ""Capped"" ; availableTags [ 1 ] = ""Non-refundable"" ; availableTags [ 2 ] = ""POLY"" ; availableTags [ 3 ] = ""ETH"" ; return availableTags ; }",Get the tags related to the module factory
1351,function settlementContract ( uint64 _settlementID ) external view returns ( Settlement ) { return settlementDetails [ _settlementID ] . settlementContract ; },Returns the settlement contract of a settlement layer .
1352,function balanceOf ( address account ) public view returns ( uint ) { return tokenState . balanceOf ( account ) ; },Returns the ERC20 token balance of a given account .
1353,function isFinalized ( bytes32 question_id ) constant public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; },Report whether the answer to the specified question is finalized
1356,"function setUint ( bytes32 _key , uint _value ) public onlyOwner returns ( bool success ) { uIntStorage [ _key ] = _value ; return true ; }",Set value for Uint associated with bytes32 id key
1358,"function _tickerAvailable ( string _ticker ) internal view returns ( bool ) { if ( _tickerOwner ( _ticker ) != address ( 0 ) ) { if ( ( now > getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , _ticker ) ) ) && ! _tickerStatus ( _ticker ) ) { return true ; } else return false ; } return true ; }",Internal - Checks if the entered ticker is registered and has not expired
1359,"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
1364,function setETHPriceLowerBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceLowerBound = _price ; },"set the limit of ETH in cents , oraclize data smaller than this is not accepted"
1366,"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool success ) { return erc20Impl . increaseApprovalWithSender ( msg . sender , _spender , _addedValue ) ; }",Increases the amount ` _spender ` is allowed to withdraw from your account .
1367,"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }",First or second stage of atomic swap .
1368,"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with transfer"" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalAddMasternode ( msg . sender ) ; }",Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
1370,"function doTransfer ( address _from , address _to , uint256 _value ) validate_address ( _to ) is_not_locked ( _from ) internal returns ( bool success ) { if ( _value <= 0 || balances [ _from ] < _value || balances [ _to ] + _value < balances [ _to ] ) { return false ; } balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; }",send _value amount of tokens to _to address from _from address
1374,function setAutopay ( bool _automatic ) public onlyOwner { autoPay = _automatic ; AutoPaySet ( ) ; },"Used to decentralize , toggles whether the LPVault will automatically confirm a payment after the payment has been authorized"
1375,"function issueSynths ( bytes4 currencyKey , uint amount ) public optionalProxy nonZeroAmount ( amount ) { require ( amount <= remainingIssuableSynths ( messageSender , currencyKey ) , ""Amount too large"" ) ; _addToDebtRegister ( currencyKey , amount ) ; synths [ currencyKey ] . issue ( messageSender , amount ) ; }",Issue synths against the sender 's SNX .
1376,"function getAllowedContribution ( ) private returns ( uint256 , uint256 ) { uint256 allowedContribution = msg . value ; uint256 tillCap = remainingCap ( ) ; uint256 refundAmount = 0 ; if ( msg . value > tillCap ) { allowedContribution = tillCap ; refundAmount = msg . value . sub ( allowedContribution ) ; ContributionRefund ( refundAmount , msg . sender ) ; } return ( allowedContribution , refundAmount ) ; }",Calculates the allowed contribution based on the transaction value and amount remaining till cap .
1377,"function _transfer ( address _owner , address _receiver , uint256 _tokenId ) internal { nonFungibleContract . transferFrom ( _owner , _receiver , _tokenId ) ; }",Transfers an ERC721 Token owned by this contract to another address .
1380,"function setWithholding ( address [ ] _investors , uint256 [ ] _withholding ) public withPerm ( MANAGE ) { require ( _investors . length == _withholding . length , ""Mismatched input lengths"" ) ; emit SetWithholding ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _withholding [ i ] <= 10 ** 18 , ""Incorrect withholding tax"" ) ; withholdingTax [ _investors [ i ] ] = _withholding [ i ] ; } }",Function to set withholding tax rates for investors
1383,"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _getAsset ( ) . __transferFromWithReference ( _from , _to , _value , """" , msg . sender ) ; } }",Performs allowance transfer of asset balance between holders .
1384,"function approve ( address _spender , uint _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens
1386,"function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > SafeDecimalMath . unit ( ) , ""Minimum deposit amount must be greater than UNIT"" ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }",Set the minimum deposit amount required to depoist sUSD into the FIFO queue
1389,"function increaseTokenSaleAllocation ( ) public whenNotPaused onlyAdmin { uint256 allowance = token . allowance ( msg . sender , this ) ; uint256 current = totalSaleAllocation ; totalSaleAllocation = totalSaleAllocation . add ( allowance ) ; require ( token . transferFrom ( msg . sender , this , allowance ) ) ; emit TokensAllocatedForSale ( totalSaleAllocation , current ) ; }",Recalculates and/or reassigns the total tokens allocated for the private sale .
1391,"function collectFor ( address recipient ) private { uint tokensOwned = balances [ recipient ] ; if ( tokensOwned == 0 ) return ; delete balances [ recipient ] ; tokenContract . safeTransfer ( recipient , tokensOwned ) ; emit Collection ( recipient , tokensOwned ) ; }",Allows users to collect purchased tokens after the sale .
1392,"function registerPlayerToBoard ( uint tableStakes ) external payable allowedValuesOnly ( msg . value ) whenNotPaused returns ( uint ) { require ( msg . value == tableStakes ) ; GoBoard storage boardToJoin ; uint boardIDToJoin ; ( boardIDToJoin , boardToJoin ) = getOrCreateWaitingBoard ( tableStakes ) ; bool shouldStartGame = addPlayerToBoard ( boardToJoin , tableStakes ) ; PlayerAddedToBoard ( boardIDToJoin , msg . sender ) ; if ( shouldStartGame ) { startBoardGame ( boardToJoin , boardIDToJoin ) ; } return boardIDToJoin ; }",This is the first function a player will be using in order to start playing .
1393,function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) ;,Get a description of the attribute type with ID ` attributeTypeID ` .
1395,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0a0fb66b ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
1396,"function setAddress ( bytes32 _key , address _value ) public onlyOwner returns ( bool success ) { addressStorage [ _key ] = _value ; return true ; }",Set value for Address associated with bytes32 id key
1397,"function withdrawExcessToken ( address token ) external onlyOwner nonReentrant { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }",Owner : Withdraw excess funds which do n't belong to Bskt token holders
1398,"function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyProxy public returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _sender , _to ) ; if ( ! _checkTransferAllowance ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! super . __transferWithReference ( _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _sender , _fromRole ) ; _contractFallbackERC223 ( _sender , _to , _value ) ; return true ; }",Performs transfer call on the platform by the name of specified sender .
1399,"function addTokenGrant ( address _recipient , uint256 _startTime , uint128 _amount , uint16 _vestingDuration , uint16 _vestingCliff ) public onlyColonyMultiSig noGrantExistsForUser ( _recipient ) { require ( _vestingCliff > 0 ) ; require ( _vestingDuration > _vestingCliff ) ; uint amountVestedPerMonth = _amount / _vestingDuration ; require ( amountVestedPerMonth > 0 ) ; token . transferFrom ( colonyMultiSig , address ( this ) , _amount ) ; Grant memory grant = Grant ( { startTime : _startTime == 0 ? now : _startTime , amount : _amount , vestingDuration : _vestingDuration , vestingCliff : _vestingCliff , monthsClaimed : 0 , totalClaimed : 0 } ) ; tokenGrants [ _recipient ] = grant ; emit GrantAdded ( _recipient , grant . startTime , _amount , _vestingDuration , _vestingCliff ) ; }",Add a new token grant for user ` _recipient ` .
1400,"function requireValidTerms ( PlatformTerms platformTerms ) public constant returns ( bool ) { if ( ALLOW_RETAIL_INVESTORS ) { require ( ! ENABLE_TRANSFERS_ON_SUCCESS , ""NF_MUST_DISABLE_TRANSFERS"" ) ; } else { require ( MIN_TICKET_EUR_ULPS >= MIN_QUALIFIED_INVESTOR_TICKET_EUR_ULPS , ""NF_MIN_QUALIFIED_INVESTOR_TICKET"" ) ; } require ( MIN_TICKET_EUR_ULPS >= TOKEN_TERMS . TOKEN_PRICE_EUR_ULPS ( ) , ""NF_MIN_TICKET_LT_TOKEN_PRICE"" ) ; require ( ESTIMATED_MAX_CAP_EUR_ULPS ( ) >= MIN_TICKET_EUR_ULPS , ""NF_MAX_FUNDS_LT_MIN_TICKET"" ) ; require ( MIN_TICKET_EUR_ULPS >= platformTerms . MIN_TICKET_EUR_ULPS ( ) , ""NF_ETO_TERMS_MIN_TICKET_EUR_ULPS"" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) >= platformTerms . MIN_WHITELIST_DURATION ( ) , ""NF_ETO_TERMS_WL_D_MIN"" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) <= platformTerms . MAX_WHITELIST_DURATION ( ) , ""NF_ETO_TERMS_WL_D_MAX"" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) >= platformTerms . MIN_PUBLIC_DURATION ( ) , ""NF_ETO_TERMS_PUB_D_MIN"" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) <= platformTerms . MAX_PUBLIC_DURATION ( ) , ""NF_ETO_TERMS_PUB_D_MAX"" ) ; uint256 totalDuration = DURATION_TERMS . WHITELIST_DURATION ( ) + DURATION_TERMS . PUBLIC_DURATION ( ) ; require ( totalDuration >= platformTerms . MIN_OFFER_DURATION ( ) , ""NF_ETO_TERMS_TOT_O_MIN"" ) ; require ( totalDuration <= platformTerms . MAX_OFFER_DURATION ( ) , ""NF_ETO_TERMS_TOT_O_MAX"" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) >= platformTerms . MIN_SIGNING_DURATION ( ) , ""NF_ETO_TERMS_SIG_MIN"" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) <= platformTerms . MAX_SIGNING_DURATION ( ) , ""NF_ETO_TERMS_SIG_MAX"" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) >= platformTerms . MIN_CLAIM_DURATION ( ) , ""NF_ETO_TERMS_CLAIM_MIN"" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) <= platformTerms . MAX_CLAIM_DURATION ( ) , ""NF_ETO_TERMS_CLAIM_MAX"" ) ; return true ; }","checks terms against platform terms , reverts on invalid"
1402,function setFailOverStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeFailOverRestrictionLifted == false ) { stakeFailOverRestrictionLifted = true ; return true ; } else { minters [ _contractAddress ] = true ; stakeFailOverRestrictionLifted = false ; emit FailOverStakeContractSet ( _contractAddress ) ; return true ; } },"Emergency use function designed to prevent stake deadlocks , allowing a fail-over stake contract to be implemented Requires 2 transaction , the first lifts the restriction , the second enables the restriction and sets the contract"
1404,"function newVote ( bytes _executionScript , string _metadata , bool _castVote , bool _executesIfDecided ) external auth ( CREATE_VOTES_ROLE ) returns ( uint256 voteId ) { return _newVote ( _executionScript , _metadata , _castVote , _executesIfDecided ) ; }",Create a new vote about `` ` _metadata ` ``
1406,"function _proxyTransferEvent ( uint _fromId , uint _toId , uint _value , bytes32 _symbol ) internal { if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitTransfer ( _address ( _fromId ) , _address ( _toId ) , _value ) ; } }",Ask asset Proxy contract to emit ERC20 compliant Transfer event .
1407,"function _approve ( uint _spenderId , uint _value , bytes32 _symbol , uint _senderId ) internal returns ( uint ) { if ( ! isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_IS_NOT_ISSUED ) ; } if ( _senderId == _spenderId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] != 0 && _value != 0 ) { return _error ( ATX_PLATFORM_INVALID_INVOCATION ) ; } assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] = _value ; Emitter ( eventsHistory ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _symbol , _value ) ; if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _value ) ; } return OK ; }",Sets asset spending allowance for a specified spender .
1408,"function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( getAddress ( Encoder . getKey ( ""securityTokenRegistry"" ) ) ) . isSecurityToken ( msg . sender ) ) { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ) { require ( getBool ( Encoder . getKey ( ""verified"" , _moduleFactory ) ) || IOwnable ( _moduleFactory ) . owner ( ) == IOwnable ( msg . sender ) . owner ( ) , ""ModuleFactory must be verified or SecurityToken owner must be ModuleFactory owner"" ) ; } else { require ( getBool ( Encoder . getKey ( ""verified"" , _moduleFactory ) ) , ""ModuleFactory must be verified"" ) ; } require ( _isCompatibleModule ( _moduleFactory , msg . sender ) , ""Version should within the compatible range of ST"" ) ; pushArray ( Encoder . getKey ( ""reputation"" , _moduleFactory ) , msg . sender ) ; emit ModuleUsed ( _moduleFactory , msg . sender ) ; } }",Called by a SecurityToken to check if the ModuleFactory is verified or appropriate custom module
1410,function remainigTokens ( ) public view returns ( uint256 ) { return tokenReward . balanceOf ( this ) ; },Function to know how many tokens left on contract
1412,"function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }",Register new policy rule Can be called only by contract owner
1413,"function changeBoardMetadata ( bytes32 boardHash , bytes32 name , string boardDescription ) public returns ( bool ) { require ( boards [ boardHash ] . boardOwner == msg . sender ) ; boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; }",Overwrite leaderboard name and desctiption as owner only
1414,"function makeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }",Make order not implemented for smart contracts in this exchange version
1415,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) public { transferFrom ( _from , _to , _tokenId ) ; require ( checkAndCallSafeTransfer ( _from , _to , _tokenId , _data ) , ""Transfer was not safe"" ) ; }",Safely transfer the ownership of PixelCon ` ( _tokenId ) ` to ` ( _to ) `
1416,"function getCompetitionStatusOfRegistrants ( ) view returns ( address [ ] , address [ ] , bool [ ] ) { address [ ] memory fundAddrs = new address [ ] ( registrants . length ) ; address [ ] memory fundRegistrants = new address [ ] ( registrants . length ) ; bool [ ] memory isRewarded = new bool [ ] ( registrants . length ) ; for ( uint i = 0 ; i < registrants . length ; i ++ ) { fundAddrs [ i ] = registrants [ i ] . fund ; fundRegistrants [ i ] = registrants [ i ] . registrant ; isRewarded [ i ] = registrants [ i ] . isRewarded ; } return ( fundAddrs , fundRegistrants , isRewarded ) ; }",Returns an array of fund addresses and an associated array of whether competing and whether disqualified
1417,"function tokenFallback ( address _from , uint _value , bytes _data ) external { require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }",We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume .
1420,"function _safeCall ( address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _to . call . value ( _amount ) ( ) ) ; }",` _safeCall ` is used internally when call a contract safely .
1421,function registerProducer ( address aproducer ) onlyOwner external { emit producerRegistered ( aproducer ) ; producers [ aproducer ] = true ; },Allow the owner of address ` aproducer.address ( ) ` to act as a producer ( by offering energy ) .
1423,"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }","Create a reusable template , which should be a JSON document ."
1424,"function revoke ( ERC20Basic _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
1425,"function getSupplyBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newSupplyIndex ; uint userSupplyCurrent ; Market storage market = markets [ asset ] ; Balance storage supplyBalance = supplyBalances [ account ] [ asset ] ; ( err , newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , newSupplyIndex ) ; require ( err == Error . NO_ERROR ) ; return userSupplyCurrent ; }",return supply balance with any accumulated interest for ` asset ` belonging to ` account `
1426,"function claim ( bytes32 channelId , uint256 payment , bytes signature ) public { require ( canClaim ( channelId , payment , msg . sender , signature ) ) ; PaymentChannel memory channel = channels [ channelId ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channelId ] ; DidClaim ( channelId ) ; }","Claim the funds , and close the channel ."
1427,"function approve ( address _spender , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",function approve gives an address power to spend specified amount
1428,function cofounderSwitchAddress ( address _newCofounderAddr ) external returns ( bool success ) { if ( msg . sender != cofounder ) throw ; cofounder = _newCofounderAddr ; CofounderSwitchedEvent ( _newCofounderAddr ) ; return true ; },` msg.sender.address ( ) ` updating cofounder address to ` _newFounderAddr.address ( ) `
1429,"function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) throw ; if ( ! allowedSpenders [ p . spender ] ) throw ; if ( now < p . earliestPayTime ) throw ; if ( p . canceled ) throw ; if ( p . paid ) throw ; if ( this . balance < p . amount ) throw ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { throw ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }",only ` allowedSpenders [ ] ` The recipient of a payment calls this function to send themselves the ether after the ` earliestPayTime ` has expired
1430,"function withdrawHavvens ( uint amount ) external onlyOwner { havven . transfer ( owner , amount ) ; }",Allows the owner to withdraw havvens from this contract if needed .
1431,function totalSupply ( ) public view returns ( uint Supply ) { return totalHurify ; },Returns the Total Number of HUR Tokens .
1435,function initialize ( ) initializeOnceOnly public { },Initialize any state variables that would normally be set in the contructor .
1436,"function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= sencHardCap || now >= endDate , ""SENC hard cap rached OR End date reached"" ) ; require ( ! finalized , ""Donation not already finalized"" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= sencHardCap ) { donationWallet . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; donationWallet . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , foundationWallet ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , foundationWallet ) ; finalized = true ; return finalized ; }",The ` finalize ( ) ` should only be called after donation hard cap reached or the campaign reached the final day .
1438,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , ""Spender address is not provided"" ) ; require ( signatures [ _signature ] == false , ""No Signature"" ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From address is not provided"" ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
1439,function tokenPriceInEuroCents ( ) public constant returns ( uint ) { return 1000 ; },price of one token ( 1e18 wei-tokens ) in euro cents
1440,function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyContractOwner { maxSecurityGuardDelay = _maxSecurityGuardDelay ; },` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment
1441,"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) external view returns ( bytes32 ) { }","Return the final answer to the specified question , provided it matches the specified criteria ."
1443,"function createRegulatorProxy ( address regulatorImplementation ) public { address proxy = address ( new RegulatorProxy ( regulatorImplementation ) ) ; Regulator newRegulator = Regulator ( proxy ) ; newRegulator . addValidator ( msg . sender ) ; addAllPermissions ( newRegulator ) ; RegulatorProxy ( proxy ) . transferOwnership ( msg . sender ) ; regulators . push ( proxy ) ; emit CreatedRegulatorProxy ( proxy , getCount ( ) - 1 ) ; }",the method caller will have to claim ownership of regulators since regulators are claimable
1444,"function approveBlacklistedAddressSpender ( address _blacklistedAccount ) public userBlacklisted ( _blacklistedAccount ) whenNotPaused requiresPermission { tokenStorage . setAllowance ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; emit ApprovedBlacklistedAddressSpender ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; }",Allows a central authority to approve themselves as a spender on a blacklisted account .
1446,function balance ( ) constant returns ( uint ) { if ( ! between [ msg . sender ] ) { return 0 ; } uint share = totalInput / count ; uint withdrew = amountsWithdrew [ msg . sender ] ; uint available = share - withdrew ; assert ( available >= 0 && available <= share ) ; return available ; },Gets the amount of funds in Wei available to the sender .
1447,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
1448,function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( _name ) ] ; },gets the parameter keyed by the provided name value from the params mapping
1449,"function launchContract ( ) onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }","Used to launch the contract , and enabled token minting"
1451,"function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( canValidate ( msg . sender , attributeTypeID ) , ""only approved validators may assign attributes of this type"" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""duplicate attributes are not supported, remove existing attribute first"" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , ""attribute requires a greater value than is currently provided"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : address ( 0 ) , validator : msg . sender , value : value , stake : stake } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } }",Issue an attribute of the type with ID ` attributeTypeID ` and a value of ` value ` to ` account ` if ` message.caller.address ( ) ` is approved validator .
1452,"function addItemWithClassAndData ( string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ totalItemClass ] ; _itemClass . classId = totalItemClass ; _itemClass . name = _name ; _itemClass . amount = _amount ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . total = 0 ; _itemClass . price = _price ; _itemClass . active = true ; totalItemClass = globalClasses . push ( _itemClass ) ; totalItems ++ ; }",All links inside the _hostfile string has to be seperated by commas .
1453,"function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 256 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }",Sets the locks of an array of addresses .
1454,"function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) ;",Returns the owner and timestamp for a given ticker
1456,"function setPrices ( uint256 _newSellPrice , uint256 _newBuyPrice ) onlyDoftManager { sellPrice = _newSellPrice ; buyPrice = _newBuyPrice ; }",Allow users to buy tokens for ` _newBuyPrice ` eth and sell tokens for ` _newSellPrice ` eth
1458,"function multiERC20Transfer ( ERC20 _token , address [ ] _addresses , uint [ ] _amounts ) public { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeERC20Transfer ( _token , _addresses [ i ] , _amounts [ i ] ) ; MultiERC20Transfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] , _token ) ; } }",Send ERC20 tokens to multiple contracts using two arrays which includes the address and the amount .
1460,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitio . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }",Submit the arbitrator 's answer to a question .
1461,"function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerExchangeRate = shpExchangeRate . mul ( CALLER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 reserveExchangeRate = shpExchangeRate . mul ( RESERVE_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 founderExchangeRate = shpExchangeRate . mul ( FOUNDER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 bountyExchangeRate = shpExchangeRate . mul ( BOUNTY_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 callerTokens = etherAmount . mul ( callerExchangeRate ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( reserveExchangeRate ) ; uint256 founderTokens = etherAmount . mul ( founderExchangeRate ) ; uint256 bountyTokens = etherAmount . mul ( bountyExchangeRate ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }","This method sends the Ether received to the Ether escrow address and generates the calculated number of SHP tokens , sending them to the caller 's address ."
1463,"function transferOwnership ( address _tokenController , address _trusteeOwner ) public onlyOwner { require ( closed ) ; require ( _tokenController != 0x0 ) ; require ( _trusteeOwner != 0x0 ) ; shp . changeController ( _tokenController ) ; trustee . changeOwner ( _trusteeOwner ) ; }",Transfers ownership of the token smart contract and trustee
1464,"function setAttributeTypeOnlyPersonal ( uint256 ID , bool onlyPersonal ) external { require ( isAttributeType ( ID ) , ""unable to set to only personal, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . onlyPersonal = onlyPersonal ; }",Enable or disable a restriction for a given attribute type ID ` ID ` that prevents attributes of the given type from being set by operators based on the provided value for ` onlyPersonal ` .
1465,"function changeExpiryLimit ( uint256 _newExpiry ) external onlyOwner { require ( _newExpiry >= 1 days , ""Expiry should >= 1 day"" ) ; emit ChangeExpiryLimit ( getUint ( EXPIRYLIMIT ) , _newExpiry ) ; set ( EXPIRYLIMIT , _newExpiry ) ; }",Changes the expiry time for the token ticker .
1467,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
1468,"function alterBankBalance ( address _toAlter , uint256 _amount ) internal { if ( _amount > allowed [ selfAddress ] [ _toAlter ] ) { IOUSupply += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; moneySpent [ _toAlter ] += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { IOUSupply -= ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; moneySpent [ _toAlter ] += ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }",Rise or lower user bank balance - Backend Function
1469,function getVersionFor ( address _sender ) public view returns ( address ) { return userOptOutVersion [ _sender ] == 0 ? latestVersion : userOptOutVersion [ _sender ] ; },Returns asset implementation contract address assigned to sender .
1470,"function setIgnoreRequestIds ( bytes32 [ ] _requestIds , bool [ ] _ignore ) onlyOwner public { require ( _requestIds . length == _ignore . length , ""Incorrect parameter lengths"" ) ; for ( uint256 i = 0 ; i < _requestIds . length ; i ++ ) { ignoreRequestIds [ _requestIds [ i ] ] = _ignore [ i ] ; } }",Allows owner to ignore specific requestId results from Oraclize
1471,"function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }",Transfers tokens held by timelock to beneficiary .
1472,function pause ( ) public onlyCLevel whenNotPaused { paused = true ; Paused ( ) ; },"called by any C-level to pause , triggers stopped state"
1474,"function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; require ( msg . value >= MIN_FUND ) ; uint256 tokenSaling ; uint256 rValue ; uint256 t_totalContributedEth = totalContributedETH + msg . value ; uint256 reFund = 0 ; if ( t_totalContributedEth > MaxEth ) { reFund = t_totalContributedEth - MaxEth ; } rValue = msg . value - reFund ; tokenSaling = rValue . mul ( ratio ) ; if ( reFund > 0 ) msg . sender . transfer ( reFund ) ; assert ( PFC . generateTokens ( _account , tokenSaling ) ) ; destEthFoundation . transfer ( rValue ) ; totalContributedETH += rValue ; totalTokenSaled += tokenSaling ; NewSale ( msg . sender , rValue , tokenSaling ) ; }",This method will generally be called by the PFC token contract to acquire PFCs .
1475,"function activatePurchase ( uint256 _tokenId ) external whenNotPaused { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . addressToContribution [ msg . sender ] > 0 || msg . sender == ceoAddress || msg . sender == cooAddress1 || msg . sender == cooAddress2 || msg . sender == cooAddress3 || msg . sender == cfoAddress ) ; var price = linkedContract . priceOf ( _tokenId ) ; require ( group . contributedBalance >= price ) ; require ( group . purchasePrice == 0 ) ; _purchase ( _tokenId , price ) ; }",Backup function for activating token purchase requires sender to be a member of the group or CLevel
1476,"function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) public fitsIn128Bits ( _startPrice ) fitsIn128Bits ( _endPrice ) fitsIn64Bits ( _duration ) whenNotPaused { address deedOwner = deedContract . ownerOf ( _deedId ) ; require ( msg . sender == address ( deedContract ) || msg . sender == deedOwner ) ; require ( _duration >= 60 ) ; _escrow ( _deedId ) ; Auction memory auction = Auction ( deedOwner , uint128 ( _startPrice ) , uint128 ( _endPrice ) , uint64 ( _duration ) , uint64 ( now ) ) ; _createAuction ( _deedId , auction ) ; }",Create an auction for a given deed .
1477,"function multiTransfer ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeTransfer ( _addresses [ i ] , _amounts [ i ] ) ; MultiTransfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }",Send to multiple addresses using two arrays which includes the address and the amount .
1480,function totalSupply ( ) public view returns ( uint256 ) { return warriors . length ; },Returns the total number of Warriors currently in existence .
1481,function setUpgradeAgent ( address agent ) external onlyOwner { require ( agent != 0x0 && msg . sender == upgradeMaster ) ; upgradeAgent = UpgradeAgent ( agent ) ; require ( upgradeAgent . isUpgradeAgent ( ) ) ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; },Set address of upgrade target contract and enable upgrade process .
1482,"function unlockTokens ( address marketContractAddress , uint qtyToUnlock ) external { uint256 balanceAfterUnLock = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . sub ( qtyToUnlock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = balanceAfterUnLock ; transferLockedTokensBackToUser ( qtyToUnlock ) ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , balanceAfterUnLock ) ; }",allows user to unlock tokens previously allocated to trading a MarketContract
1483,function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) { return _attributeIDs [ index ] ; },Get the ID of the attribute type at index ` index ` .
1484,"function claimRewards ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 rewardClaimed = claimRewardsInternal ( msg . sender ) ; emit RewardClaimed ( msg . sender , rewardClaimed ) ; }",This function will return all eligible reward balance back to the user
1485,function pauseContribution ( ) onlyController { paused = true ; },Pauses the contribution if there is any issue
1486,"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
1487,"function mintToken ( address _to , uint256 _amount ) onlyOwner public { uint256 amount = _amount * 10 ** uint256 ( decimals ) ; totalSupply = totalSupply . add ( amount ) ; balances [ _to ] = balances [ _to ] . add ( amount ) ; emit Transfer ( this , _to , amount ) ; }",Create ` _amount ` tokens and send it to ` _to `
1488,function mNormalizePledge ( uint64 [ ] pledges ) { for ( uint i = 0 ; i < pledges . length ; i ++ ) { normalizePledge ( pledges [ i ] ) ; } },` mNormalizePledge ` allows for multiple pledges to be normalized efficiently
1489,"function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _amountBought != 0 ) ; if ( ! members [ _member ] ) { _addMember ( _member ) ; } bought [ _member ] = bought [ _member ] . add ( _amountBought ) ; emit TokensBought ( _member , _amountBought , bought [ _member ] ) ; }",Add to the amount this member has bought
1490,"function updateClientOfContractorManagers ( uint _from , uint _to ) ;",Function to update the client of the contractor managers in case of upgrade
1493,function setTotle ( address _totlePrimary ) external onlyOwner { require ( _totlePrimary != address ( 0x0 ) ) ; totlePrimary = _totlePrimary ; },A function which allows only the owner to change the address of totlePrimary
1494,"function order ( uint _clientProposalID , uint _proposalID , uint _amount ) external returns ( bool ) ;",Function used by the client to order according to the contractor proposal
1497,"function approve ( address _spender , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . approve ( _spender , _value ) ; }",Override the functions to not allow token transfers until the end of the ICO
1498,"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( msg . sender ) ) ; spentAct [ msg . sender ] = spentAct [ msg . sender ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",Same as the default ERC20 transfer ( ) with two differences : 1 .
1499,function hasNotaryBeenAdded ( address notary ) public view validAddress ( notary ) returns ( bool ) { return notaryInfo [ notary ] . addedAt != 0 ; },Checks if the given notary was added to notarize this DataOrder .
1500,"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transfer ( lib . getTokenSymbol ( address ( this ) ) , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters."" ) ; return true ; }",transfers 'amount ' from msg.sender to a receiving account 'to '
1501,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
1504,"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MinimalTokenInterface token = MinimalTokenInterface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
1505,function claimReward ( uint256 _blockNumber ) internal isCoinbase ( _blockNumber ) submittedBlock ( _blockNumber ) returns ( uint256 ) { blocks [ _blockNumber ] . state = BlockStateEnum . claimed ; return BLOCKREWARD ; },Used by a miner to claim their merged mined RTC
1506,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
1507,"function transferAllFunds ( address _destination ) public onlyAllowed { uint256 balance = appc . balanceOf ( address ( this ) ) ; appc . transfer ( _destination , balance ) ; }",Transfers all funds of the contract to a single address This function is used for finance contract upgrades in order to be more cost efficient .
1508,"function tokenURI ( uint256 _tokenId ) external view returns ( string infoUrl ) { return concat ( toSlice ( metadataUrlPrefix ) , toSlice ( concat ( toSlice ( uintToString ( _tokenId ) ) , toSlice ( metadataUrlSuffix ) ) ) ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
1509,"function setManager ( address _addr , address _newManager ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; managers [ addr ] = _newManager == addr ? 0 : _newManager ; emit ManagerChanged ( addr , _newManager ) ; }",Sets the ` _newManager ` as manager for the ` _addr ` address .
1511,function lastRateUpdateTimesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory lastUpdateTimes = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { lastUpdateTimes [ i ] = lastRateUpdateTimes [ currencyKeys [ i ] ] ; } return lastUpdateTimes ; },Retrieve the last update time for a specific currency
1512,function withdrawPayments ( ) external ;,"withdraw accumulated balance , called by payee in case crowdsale failed"
1514,function setController ( address _controller ) external ;,Used by the issuer to set the controller addresses
1516,function capReached ( ) public view returns ( bool ) { return tokensRaised >= tokenCap ; },Checks whether the tokenCap has been reached .
1518,function changeTokenOwnerWalletAddress ( address _tokenOwnerWallet ) public validate_address ( _tokenOwnerWallet ) onlyOwner { tokenOwnerWallet = _tokenOwnerWallet ; },Function to change the token fund owner wallet address
1519,function setPriceStalePeriod ( uint _time ) external onlyOwner { priceStalePeriod = _time ; emit PriceStalePeriodUpdated ( priceStalePeriod ) ; },Set the stale period on the updated price variables
1521,"function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external ;",Called when tokens are bought in token sale
1522,"function transfer ( Data storage self , string currency , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address cannot be null."" ) ; require ( amount > 0 , ""Error: `amount` must be greater than zero"" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , msg . sender , getFxUSDAmount ( self , currency , amount ) ) , ""Error: Unable to set spending amount for account."" ) ; require ( forceTransfer ( self , currency , msg . sender , to , amount , data ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , currency , msg . sender , feeContract , fees , getFeeMsg ( self , feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; return true ; }",Transfer an amount of currency token from msg.sender account to another specified account
1523,"function updateRenExTokens ( RenExTokens _newRenExTokensContract ) external onlyOwner { emit LogRenExTokensUpdated ( renExTokensContract , _newRenExTokensContract ) ; renExTokensContract = _newRenExTokensContract ; }",The owner of the contract can update the RenExTokens address .
1524,"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F43 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
1525,"function destroyTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
1526,"function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external ;","Set a secondary source for a given attribute type ID ` ID ` , with an address ` registry ` of the secondary source in question and a given ` sourceAttributeTypeID ` for attribute type ID to check on the secondary source ."
1527,"function _allowance ( uint _fromId , uint _toId , bytes32 _symbol ) internal view returns ( uint ) { return assets [ _symbol ] . wallets [ _fromId ] . allowance [ _toId ] ; }",Returns asset allowance from one holder to another .
1528,"function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; matingAllowedToAddress [ _sireId ] = _addr ; }",Grants approval to another user to sire with one of your Ponies .
1529,function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) ;,returns a list of matched orders to the given orderID .
1531,"function setTokenXCurrency ( address asset , string currency ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; require ( setAssetCurrency ( asset , currency ) ) ; return true ; }",This method may be deprecated or refactored to allow for multiple interfaces
1533,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( ( controller != 0 ) && ( isContract ( controller ) ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf
1534,"function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external { require ( hasPermission ( msg . sender , address ( this ) , CREATE_PERMISSIONS_ROLE ) ) ; _createPermission ( _entity , _app , _role , _manager ) ; }",Create a new permission granting ` _entity ` the ability to perform actions of role ` _role ` on ` _app ` ( setting ` _manager ` as the permission manager )
1535,function floorLog2 ( uint256 _n ) internal pure returns ( uint8 ) { uint8 res = 0 ; if ( _n < 256 ) { while ( _n > 1 ) { _n >>= 1 ; res += 1 ; } } else { for ( uint8 s = 128 ; s > 0 ; s >>= 1 ) { if ( _n >= ( ONE << s ) ) { _n >>= s ; res |= s ; } } } return res ; },Compute the largest integer smaller than or equal to the binary logarithm of the input
1536,"function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner ) ; tokenApprovals [ _tokenId ] = 0 ; Approval ( _owner , 0 , _tokenId ) ; }",Internal function to clear current approval of a given token ID
1538,"function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) ;",Returns the owner and timestamp for a given symbol
1539,function unpause ( ) public onlyCEO whenPaused { paused = false ; },This is public rather than external so it can be called by derived contracts .
1540,"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }",Applies the discount based on the discount tiers
1543,"function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 4 years ) ) ; uint256 balance = wrp . balanceOf ( address ( this ) ) ; require ( wrp . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }",The Dev ( Owner ) will call this method to extract the tokens
1544,"function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { updateERC165Cache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] != 0 ; }",Checks whether a contract implements an ERC165 interface or not .
1545,"function renounceOwnership ( ) public onlyOwner { emit OwnershipTransferred ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }",Renouncing to ownership will leave the contract without an owner .
1546,function deposit ( uint256 _value ) private { reserveAddress . transfer ( _value ) ; balances [ reserveAddress ] += _value ; },Deposits '_value ' in wei to the reserve address
1550,function getOwner ( ) public view returns ( address ) { return owners [ 0 ] ; },Gets owner 's address that is used to confirm txs .
1552,"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
1553,"function _isValidSignatureAndData ( address _address , bytes _signature ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _signature ) ; }",the _signature parameter of the method being validated must be the `` last '' parameter
1554,"function isSignedBy ( bytes32 hash , address signer , bytes signature ) private pure returns ( bool ) { require ( signer != address ( 0 ) ) ; bytes32 prefixedHash = ECRecovery . toEthSignedMessageHash ( hash ) ; address recovered = ECRecovery . recover ( prefixedHash , signature ) ; return recovered == signer ; }",Checks if the signature was created by the signer .
1555,function checkValidityOfBalance ( ) private view { assert ( this . balance >= m_myDebtInWei ) ; },"It is always must be true , for correct withdrawals and receivers ETH ."
1556,"function updateEarnedBy ( uint256 _tokenId , uint256 _earnedBy ) public onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; _updateEarnedBy ( _tokenId , _earnedBy ) ; }",Helps in updating the earned _by property of an asset/token .
1557,"function extendRequestTimeLock ( bytes32 _requestMsgHash ) public onlyPrimary { Request storage request = requestMap [ _requestMsgHash ] ; require ( request . callbackAddress != address ( 0 ) ) ; require ( request . extended != true ) ; request . extended = true ; emit TimeLockExtended ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; }",Extend the time lock of a pending request .
1558,"function mint ( address target , uint256 mintedAmount ) public onlyManager whenNotPaused { require ( target != 0 ) ; require ( mintedAmount > 0 ) ; require ( balanceOf [ target ] + mintedAmount >= balanceOf [ target ] ) ; require ( totalSupply + mintedAmount >= totalSupply ) ; balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }",function mint to be executed by Manager of token
1559,"function isCreatorAndOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; address owner = lookupData . owner ; address creator = pixelcons [ lookupData . tokenIndex ] . creator ; return ( _address == owner && _address == creator ) ; }",Check whether the given editor is the current owner and original creator of a given token ID
1561,"function disapproveAll ( address _to ) public whenNotPaused { require ( _to != msg . sender ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; ApprovalForAll ( msg . sender , _to , false ) ; }",Removes approval for another address to claim for the ownership of any tokens owned by this account .
1562,"function offerCanvasForSale ( uint32 _canvasId , uint _minPrice ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , 0x0 ) ; }",Offer canvas for sale for a minimal price .
1564,"function do_grant_tokens ( address _to , uint256 _nTokens ) internal returns ( bool ) { require ( token . generate_token_for ( _to , _nTokens ) ) ; tokensGenerated = tokensGenerated . add ( _nTokens ) ; return true ; }",triggers token generaton for the recipient can be called only from the token sale contract itself side effect : increases the generated tokens counter CAUTION : we do not check campaign state and parameters assuming that 's callee 's task
1565,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { doMint ( _tokenHolder , _amount , _operatorData ) ; }",Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
1568,"function buy ( ) public payable whenNotPaused isWhitelisted ( msg . sender ) { uint256 amount = msg . value . mul ( 1e18 ) ; amount = amount . div ( sellPrice ) ; require ( amount >= MINIMUM_BUY_AMOUNT , ""Buy amount too small"" ) ; _transfer ( this , msg . sender , amount ) ; }",buy function has minimum allowed amount one can buy
1569,function _recordFeePayment ( uint xdrAmount ) internal { uint remainingToAllocate = xdrAmount ; for ( uint i = FEE_PERIOD_LENGTH - 1 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint delta = recentFeePeriods [ i ] . feesToDistribute . sub ( recentFeePeriods [ i ] . feesClaimed ) ; if ( delta > 0 ) { uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate ; recentFeePeriods [ i ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed . add ( amountInPeriod ) ; remainingToAllocate = remainingToAllocate . sub ( amountInPeriod ) ; if ( remainingToAllocate == 0 ) return ; } } assert ( remainingToAllocate == 0 ) ; },Record the fee payment in our recentFeePeriods .
1570,"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { token . transfer ( _beneficiary , _tokenAmount ) ; }",Function transfers tokens from contract to beneficiary address .
1571,"function redeemCoinsToICO ( uint256 amountOfCoinsToRedeem ) public returns ( bool success ) { uint amount = amountOfCoinsToRedeem ; msgSndr [ msg . sender ] = amount ; bool isPreview = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; uint redeemPaymentValue ; ( icosuccess , redeemPaymentValue ) = ico . redeemCoin ( amount , msg . sender , isPreview ) ; require ( icosuccess == true ) ; require ( _getIcoAddr ( ) . balance >= safeAdd ( ico . getMinBal ( ) , redeemPaymentValue ) ) ; bool sucsTrTk = false ; bool pymActSucs = false ; if ( isPreview == false ) { sucsTrTk = _safeTransferTkn ( msg . sender , owner , amount ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = redeemPaymentValue ; pymActSucs = _safePaymentActionAtIco ( redeemPaymentValue , msg . sender , 1 ) ; require ( pymActSucs == true ) ; } msgSndr [ msg . sender ] = 0 ; return ( true ) ; }",Allows Token owners to Redeem Tokens to this Contract for its value promised
1572,"function confirmCustodianChange ( bytes32 _lockId ) public onlyCustodian { custodian = getCustodianChangeReq ( _lockId ) ; delete custodianChangeReqs [ _lockId ] ; emit CustodianChangeConfirmed ( _lockId , custodian ) ; }",Confirms a pending change of the custodian associated with this contract .
1573,"function getContributors ( bool _pending , bool _claimed ) view public returns ( address [ ] contributors ) { uint256 i = 0 ; uint256 results = 0 ; address [ ] memory _contributors = new address [ ] ( contributorsKeys . length ) ; if ( goalReached ( ) ) { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && stakes [ contributorsKeys [ i ] ] > 0 || _claimed && stakes [ contributorsKeys [ i ] ] == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } else { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && vault . deposited ( contributorsKeys [ i ] ) > 0 || _claimed && vault . deposited ( contributorsKeys [ i ] ) == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } contributors = new address [ ] ( results ) ; for ( i = 0 ; i < results ; i ++ ) { contributors [ i ] = _contributors [ i ] ; } return contributors ; }",Get contributor addresses to manage refunds or token claims .
1574,"function getKittyInfo ( uint256 _tokenId ) external view returns ( uint32 kittyId , uint256 price , address owner , bool selled ) { Kitty storage kitty = kitties [ _tokenId ] ; kittyId = kitty . kittyId ; price = TokenIdToPrice [ _tokenId ] ; owner = TokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }",Returns all the relevant information about a specific tokenId .
1575,function name ( ) public view returns ( string ) ;,A descriptive name for a collection of NFTs in this contract
1576,"function addDataResponseToOrder ( address orderAddr , address seller , address notary , string dataHash , bytes signature ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; allDistinct ( [ orderAddr , buyer , seller , notary , address ( this ) ] ) ; require ( order . hasNotaryBeenAdded ( notary ) ) ; require ( CryptoUtils . isDataResponseValid ( orderAddr , seller , notary , dataHash , signature ) ) ; bool okay = order . addDataResponse ( seller , notary , dataHash ) ; require ( okay ) ; chargeBuyer ( order , seller ) ; ordersBySeller [ seller ] . push ( orderAddr ) ; emit DataAdded ( order , seller ) ; return true ; }",Adds a new DataResponse to the given order .
1577,"function allowNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = true ; require ( RTI . stakeContractAddress ( ) == address ( this ) , ""rtc token contract is not set to use this contract as the staking contract"" ) ; return true ; }",Used to allow new stakes to be made
1579,"function createRequest ( address _creator , address [ ] _payees , int256 [ ] _expectedAmounts , address _payer , string _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( _creator != 0 , ""creator should not be 0"" ) ; require ( isTrustedContract ( msg . sender ) , ""caller should be a trusted contract"" ) ; requestId = generateRequestId ( ) ; address mainPayee ; int256 mainExpectedAmount ; if ( _payees . length != 0 ) { mainPayee = _payees [ 0 ] ; mainExpectedAmount = _expectedAmounts [ 0 ] ; } requests [ requestId ] = Request ( _payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , _payer , _creator , _data ) ; initSubPayees ( requestId , _payees , _expectedAmounts ) ; return requestId ; }",Function used by currency contracts to create a request in the Core .
1581,function areAllBalanceNull ( bytes32 _requestId ) public view returns ( bool isNull ) { isNull = requests [ _requestId ] . payee . balance == 0 ; for ( uint8 i = 0 ; isNull && subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { isNull = subPayees [ _requestId ] [ i ] . balance == 0 ; } return isNull ; },Checks if all the payees balances are null .
1583,"function setTokenTLA ( Data storage self , string tokenTLA ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenTLA ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set the token three letter abreviation ( TLA ) for Token interfaces
1584,function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit LogAllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; },Used to change the flag true - It refers that time lock is ignored for transfers ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
1585,"function cooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig , bytes _closing_sig ) external { address sender = extractBalanceProofSignature ( _receiver_address , _open_block_number , _balance , _balance_msg_sig ) ; address receiver = extractClosingSignature ( sender , _open_block_number , _balance , _closing_sig ) ; require ( receiver == _receiver_address ) ; settleChannel ( sender , receiver , _open_block_number , _balance ) ; }","Function called by the sender , receiver or a delegate , with all the needed signatures to close the channel and settle immediately ."
1586,"function bulkMint ( address _to , string _tokenURI , uint number ) external onlyOwner { uint currentId = tokenId ; for ( uint i = 0 ; i < number ; i ++ ) { _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; currentId ++ ; } tokenId = currentId ; }","Same as mint ( ) , but mints multiple identical tokens at once only the current contract owner can do that"
1587,function reclaim ( IBasicToken token ) public { require ( token != RECLAIM_ETHER ) ; Reclaimable . reclaim ( token ) ; },allows EtherToken to reclaim tokens wrongly sent to its address
1588,"function moveTokensToEscrowLockupFor ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) external { validateLockupTokensSig ( _sender , _amount , _nonce , _delegationSig ) ; moveTokensToEscrowLockupForUser ( _sender , _amount ) ; }",Lockup tokens for set time period on behalf of user .
1589,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; }",Transfer Spork tokens from ` msg.sender ` to another account .
1590,"function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = Medianizer ( makerDAO ) . peek ( ) ; require ( valid , ""MakerDAO Oracle returning invalid value"" ) ; return uint256 ( price ) ; }",Returns price - should throw if not valid
1592,"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens = challenges [ _challengeID ] . winningTokens . sub ( voterTokens ) ; challenges [ _challengeID ] . rewardPool = challenges [ _challengeID ] . rewardPool . sub ( reward ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward ) ; require ( token . transfer ( msg . sender , reward ) ) ; }",claim the tokens owed for the msg.sender in the provided challenge
1594,function hasIdentity ( address _address ) public view returns ( bool ) { return identityExists ( associatedAddressDirectory [ _address ] ) ; },Checks if the passed address is associated with an Identity .
1595,function darknodeDeregisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . deregisteredAt ; },Returns the deregistration time of a given darknode .
1597,function topUp ( ) external payable { },add more ether to use in oraclize queries
1599,function setHiddenCeilings ( bytes32 [ ] _ceilingHashes ) public onlyOwner { require ( ceilings . length == 0 ) ; ceilings . length = _ceilingHashes . length ; for ( uint256 i = 0 ; i < _ceilingHashes . length ; i = i . add ( 1 ) ) { ceilings [ i ] . hash = _ceilingHashes [ i ] ; } },This should be called by the creator of the contract to commit all the ceilings .
1600,"function setConverterRamp ( ConverterRamp _converterRamp ) external onlyOwner returns ( bool ) { require ( _isContract ( _converterRamp ) , ""Should be a contract"" ) ; emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }",Sets a new converter ramp to delegate the pay of the loan
1601,function setMergedMinerValidator ( address _mergedMinerValidator ) external onlyOwner nonAdminAddress ( _mergedMinerValidator ) returns ( bool ) { mergedMinerValidatorAddress = _mergedMinerValidator ; minters [ _mergedMinerValidator ] = true ; emit MergedMinerValidatorSet ( _mergedMinerValidator ) ; return true ; },This is used to set the merged miner validator contract
1602,function getReserves ( ) constant returns ( KyberReserve [ ] ) { return reserves ; },should be called off chain with as much gas as needed
1603,"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , ""Interval between scheduled time should be greater than zero"" ) ; require ( _iters > 0 , ""No iterations specified"" ) ; require ( _startTime >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; require ( oraclize_getPrice ( oracleQueryType , gasLimit ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }",Allows owner to schedule future Oraclize calls on a rolling schedule
1605,"function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 atk_min , uint32 atk_max , uint32 defense , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; atk_min = captain . atk_min ; atk_max = captain . atk_max ; defense = captain . defense ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }",Returns all the relevant information about a specific tokenId .
1606,"function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; emit Transfer ( 0 , msg . sender , _amount ) ; return true ; }",Used to create new tokens and increase total supply
1608,"function _mintFromDeposit ( address owner , uint amount ) public onlyTrusted { balances [ owner ] += amount ; totalOnDeposit -= amount ; totalInCirculation += amount ; }",used by subscription module to re-create token from returning deposit .
1609,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock > block . number ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
1610,function getRemainingBonus ( ) public view returns ( uint256 ) { return bonusProvided . sub ( bonusWithdrawn ) ; },Returns the remaining bonus held on behalf of the crowdsale contributors by this contract .
1611,function finalize ( ) onlyOwner afterDeadline public { require ( ! crowdsaleClosed ) ; emit Finalized ( ) ; withdrawTokens ( ) ; crowdsaleClosed = true ; isFinalized = true ; },Function to indicate the end of ICO .
1612,function parentOf ( uint256 identifier ) external view returns ( uint256 parentIdentifier ) { parentIdentifier = identifierToParentIdentifier [ identifier ] ; },Returns the identifier of the parent of an identifier .
1613,"function getMinerHashRateCurrentHalving ( ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , currentHalving ( ) ) ; }",Calculate the halving hash rate of a miner
1614,"function metaApproveHash ( address _spender , uint256 _addedValue , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaIncreaseApproval"" , _spender , _addedValue , _nonce , _reward ) ) ; }",Return hash containing all of the information about the increaseApproval ( ) metatransaction
1616,function _getFeeHistory ( uint32 _canvasId ) private view returns ( FeeHistory storage ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; return _history ; },Gets a fee history of a canvas .
1617,"function _suspendMarket ( address asset ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUSPEND_MARKET_OWNER_CHECK ) ; } if ( ! markets [ asset ] . isSupported ) { return uint ( Error . NO_ERROR ) ; } markets [ asset ] . isSupported = false ; emit SuspendedMarket ( asset ) ; return uint ( Error . NO_ERROR ) ; }",Suspends a given supported market ( asset ) from use with Compound .
1618,"function calculateRewardTokens ( uint256 amount , uint8 stageNumber ) public view returns ( uint256 rewardAmount ) { if ( stageNumber < 1 || stageNumber > totalStages ) revert ( ) ; uint8 stageIndex = stageNumber - 1 ; return safeDiv ( safeMul ( amount , stageBonusPercentage [ stageIndex ] ) , 100 ) ; }",calculate reward based on amount of tokens that will be issued to the purchaser
1620,"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; }",This is a private function which should be called from user-implemented external mint function .
1622,"function computeFee ( uint256 _amount , uint256 _fee ) public pure returns ( uint256 ) { return _amount . mul ( _fee ) . div ( 1000 ) ; }",Compute the fee that will be charged on a `` burn '' operation .
1625,"function remainingIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint alreadyIssued = debtBalanceOf ( issuer , currencyKey ) ; uint max = maxIssuableSynths ( issuer , currencyKey ) ; if ( alreadyIssued >= max ) { return 0 ; } else { return max . sub ( alreadyIssued ) ; } }",The remaining synths an issuer can issue against their total synthetix balance .
1629,function lastDebtLedgerEntry ( ) external view returns ( uint ) { return debtLedger [ debtLedger . length - 1 ] ; },Retrieve the most recent entry from the debt ledger
1630,"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public view returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }",Converts an amount to RCN using the loan oracle .
1631,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _transfer ( _from , _to , _tokenId ) ; }","Transfer a Warrior owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
1633,"function getExchangeRate ( address numeratorToken , address denominatorToken ) public constant returns ( uint256 rateFraction , uint256 timestamp ) ;",provides actual price of 'numeratorToken ' in 'denominatorToken ' returns timestamp at which price was obtained in oracle
1634,"function authorizePayment ( string _name , bytes32 _reference , address _recipient , address _token , uint _amount , uint _paymentDelay ) whenNotPaused external returns ( uint ) { require ( allowedSpenders [ msg . sender ] ) ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment storage p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; require ( _paymentDelay <= 10 ** 18 ) ; p . earliestPayTime = _paymentDelay >= timeLock ? _getTime ( ) + _paymentDelay : _getTime ( ) + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; p . token = _token ; emit PaymentAuthorized ( idPayment , p . recipient , p . amount , p . token , p . reference ) ; return idPayment ; }",only ` allowedSpenders [ ] ` Creates a new ` Payment `
1636,function totalSupply ( ) public view returns ( uint ) { return WIDTH * HEIGHT ; },Returns the total number of pixels currently in existence .
1637,function balanceOf ( address _owner ) public view returns ( uint _balance ) { _balance = lendersBalance [ _owner ] ; },Returns the number of active loans that a lender possess ; active loans are the loans with `` lent '' status .
1639,"function swapID ( address _withdrawTrader , bytes32 _secretLock , uint256 _timelock ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _withdrawTrader , _secretLock , _timelock ) ) ; }",Generates a deterministic swap id using initiate swap details .
1640,"function releaseTokens ( ) public { Allocations memory allocation ; allocation = allocations [ msg . sender ] ; require ( allocation . released == false ) ; require ( allocation . allocated > 0 ) ; require ( allocation . unlockedAt > 0 ) ; require ( now >= allocation . unlockedAt ) ; uint256 allocated = allocation . allocated ; ovc . transfer ( msg . sender , allocated ) ; allocation . allocated = 0 ; allocation . unlockedAt = 0 ; allocation . released = true ; allocations [ msg . sender ] = allocation ; }",called by allocated address to release the token
1642,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { bool onApprove = TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ; require ( onApprove ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
1643,"function getemoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific emoji .
1644,function _trimQuestion ( string q ) internal pure returns ( string ) { return q . toSlice ( ) . split ( REALITIO_DELIMITER . toSlice ( ) ) . toString ( ) ; },Trim the realitio question content to the part before the initial delimiter .
1645,"function getLockedBalanceForUser ( address marketContractAddress , address userAddress ) external view returns ( uint ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] ; }",get the currently locked balance for a user given the specific contract address
1646,function cancelApprove ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; },"Cancel pending Approval , can only be called by msg.sender == biometricFrom [ sha ]"
1647,"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowance [ _owner ] [ _spender ] ; }",function allowance : displays address allow to transfer tokens from owner
1648,"function mGenerateTokens ( address owner , uint256 amount ) internal { require ( owner != address ( 0 ) ) ; require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; uint256 newTotalSupply = curTotalSupply + amount ; require ( newTotalSupply >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( owner ) ; uint256 newBalanceTo = previousBalanceTo + amount ; assert ( newBalanceTo >= previousBalanceTo ) ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceTo ) ; Transfer ( 0 , owner , amount ) ; }",Generates ` amount ` tokens that are assigned to ` owner `
1649,"function setNextGame ( uint256 _price , uint256 _timeout , uint256 _finalTimeout , uint256 _numberOfWagersToFinalTimeout ) external onlyCFO { nextPrice = _price ; nextTimeout = _timeout ; nextFinalTimeout = _finalTimeout ; nextNumberOfWagersToFinalTimeout = _numberOfWagersToFinalTimeout ; NextGame ( nextPrice , nextTimeout , nextFinalTimeout , nextNumberOfWagersToFinalTimeout ) ; }",Set the parameters for the next game .
1650,"function requestMembership ( ) public payable { Member storage sender = members [ msg . sender ] ; require ( msg . value >= memberFee && sender . membershipType == 0 ) ; membersAccts . push ( msg . sender ) ; sender . memberId = membersAccts . length ; sender . membershipType = 1 ; emit NewMember ( msg . sender , sender . memberId , sender . membershipType ) ; }",Allows a user to become DDA members if they pay the fee .
1651,"function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; uint256 day = today ( ) ; require ( msg . value >= MIN_FUND ) ; uint256 toDev ; if ( proportion < 100 ) { toDev = msg . value * 100 / proportion ; destEthFoundationDev . transfer ( toDev ) ; destEthFoundation . transfer ( msg . value - toDev ) ; } else { destEthFoundationDev . transfer ( msg . value ) ; } uint256 r = ratio [ day ] ; require ( r > 0 ) ; uint256 tokenSaling = r . mul ( msg . value ) ; assert ( FCC . generateTokens ( _account , tokenSaling ) ) ; totalContributedETH += msg . value ; totalTokenSaled += tokenSaling ; NewSale ( day , msg . sender , msg . value ) ; }",This method will generally be called by the FCC token contract to acquire FCCs .
1652,"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , decreaseApprovalSig , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _fee <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
1653,"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) ;",Applies the discount based on the discount tiers
1654,"function _setRiskParameters ( uint collateralRatioMantissa , uint liquidationDiscountMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_RISK_PARAMETERS_OWNER_CHECK ) ; } Exp memory newCollateralRatio = Exp ( { mantissa : collateralRatioMantissa } ) ; Exp memory newLiquidationDiscount = Exp ( { mantissa : liquidationDiscountMantissa } ) ; Exp memory minimumCollateralRatio = Exp ( { mantissa : minimumCollateralRatioMantissa } ) ; Exp memory maximumLiquidationDiscount = Exp ( { mantissa : maximumLiquidationDiscountMantissa } ) ; Error err ; Exp memory newLiquidationDiscountPlusOne ; if ( lessThanExp ( newCollateralRatio , minimumCollateralRatio ) ) { return fail ( Error . INVALID_COLLATERAL_RATIO , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } if ( lessThanExp ( maximumLiquidationDiscount , newLiquidationDiscount ) ) { return fail ( Error . INVALID_LIQUIDATION_DISCOUNT , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } ( err , newLiquidationDiscountPlusOne ) = addExp ( newLiquidationDiscount , Exp ( { mantissa : mantissaOne } ) ) ; assert ( err == Error . NO_ERROR ) ; if ( lessThanOrEqualExp ( newCollateralRatio , newLiquidationDiscountPlusOne ) ) { return fail ( Error . INVALID_COMBINED_RISK_PARAMETERS , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } Exp memory oldCollateralRatio = collateralRatio ; Exp memory oldLiquidationDiscount = liquidationDiscount ; collateralRatio = newCollateralRatio ; liquidationDiscount = newLiquidationDiscount ; emit NewRiskParameters ( oldCollateralRatio . mantissa , collateralRatioMantissa , oldLiquidationDiscount . mantissa , liquidationDiscountMantissa ) ; return uint ( Error . NO_ERROR ) ; }",Sets the risk parameters : collateral ratio and liquidation discount
1655,function interfaceHash ( string _interfaceName ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; },Compute the keccak256 hash of an interface given its name .
1656,"function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) { address [ ] memory activeUsers = getArrayAddress ( Encoder . getKey ( ""activeUsers"" ) ) ; bytes32 [ ] memory tickers ; address token ; uint256 count = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { count = count + 1 ; } } } } uint256 index = 0 ; address [ ] memory result = new address [ ] ( count ) ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { result [ index ] = token ; index = index + 1 ; } } } } return result ; }",Returns the list of tokens owned by the selected address
1657,function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return USER_MANAGER_INVALID_INVOCATION ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; },Discard user registration Can be called only by contract owner
1659,function price ( ) public view returns ( uint256 ) { return tokenPerEth . mul ( BONUS ) . div ( 1e2 ) ; },Calculates the price as tokens/ether based on the corresponding bonus .
1660,"function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }",Withdraw tokens from the fee pool into a given account .
1661,"function requestInvestment ( uint giveQuantity , uint shareQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed ) pre_cond ( module . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . invest , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }",Give melon tokens to receive shares of this fund
1662,"function calculateAccountValuesInternal ( address userAddress ) internal view returns ( Error , uint , uint ) { AccountValueLocalVars memory localResults ; localResults . sumSupplies = Exp ( { mantissa : 0 } ) ; localResults . sumBorrows = Exp ( { mantissa : 0 } ) ; Error err ; localResults . collateralMarketsLength = collateralMarkets . length ; for ( uint i = 0 ; i < localResults . collateralMarketsLength ; i ++ ) { localResults . assetAddress = collateralMarkets [ i ] ; Market storage currentMarket = markets [ localResults . assetAddress ] ; Balance storage supplyBalance = supplyBalances [ userAddress ] [ localResults . assetAddress ] ; Balance storage borrowBalance = borrowBalances [ userAddress ] [ localResults . assetAddress ] ; if ( supplyBalance . principal > 0 ) { ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( currentMarket . supplyIndex , currentMarket . supplyRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . supplyTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userSupplyCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumSupplies ) = addExp ( localResults . supplyTotalValue , localResults . sumSupplies ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } if ( borrowBalance . principal > 0 ) { ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( currentMarket . borrowIndex , currentMarket . borrowRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . borrowTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userBorrowCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumBorrows ) = addExp ( localResults . borrowTotalValue , localResults . sumBorrows ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } } return ( Error . NO_ERROR , localResults . sumSupplies . mantissa , localResults . sumBorrows . mantissa ) ; }","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 ."
1663,"function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }",Access point for the oracle to update the price of havvens .
1665,"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( _totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , modules . pricefeed . getInterval ( ) ) && modules . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; var ( isRecent , , ) = modules . pricefeed . getPriceInfo ( address ( request . requestAsset ) ) ; require ( isRecent ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset != address ( QUOTE_ASSET ) ) { var ( isPriceRecent , invertedRequestAssetPrice , requestAssetDecimal ) = modules . pricefeed . getInvertedPriceInfo ( request . requestAsset ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedRequestAssetPrice ) / 10 ** requestAssetDecimal ; } if ( isInvestAllowed [ request . requestAsset ] && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; require ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , address ( this ) , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; if ( ! isInAssetList [ request . requestAsset ] ) { ownedAssets . push ( request . requestAsset ) ; isInAssetList [ request . requestAsset ] = true ; } } else { revert ( ) ; } }","Executes active investment and redemption requests , in a way that minimises information advantages of investor"
1667,"function addRestrictedAttributeType ( uint256 ID , string description ) external ;",Add a restricted attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
1668,function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return balances [ tokenOwner ] ; },Get the token balance for account ` tokenOwner `
1669,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = colorIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
1671,function fundAnswerBounty ( bytes32 question_id ) external payable { },Add funds to the bounty for a question
1672,"function setPermissionManager ( address _newManager , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( _newManager , _app , _role ) ; }",Set ` _newManager ` as the manager of ` _role ` in ` _app `
1673,"function buy ( address _to , uint _value , uint _paymentId ) { transfer ( _to , _value ) ; LogBuy ( msg . sender , _to , _value , _paymentId ) ; }",Transfer from msg.sender for downloading of content .
1674,"function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { _allowedTransferFrom [ from ] = allowed ; LogAllowedFromAddress ( from , allowed ) ; }",enables or disables address to be sender of EUR-T
1675,"function sellBkgAtExchg ( uint amountOfCoinsOffer , uint priceOfOneCoinInWEI ) public returns ( bool success ) { uint amntTkns = amountOfCoinsOffer ; uint tknPrice = priceOfOneCoinInWEI ; bool successSlrl ; ( successSlrl ) = _chkSellerLmts ( msg . sender , amntTkns ) ; require ( successSlrl == true ) ; msgSndr [ msg . sender ] = amntTkns ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emsuccess ; ( emsuccess ) = em . sell_Exchg_Reg ( amntTkns , tknPrice , msg . sender ) ; require ( emsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }",allows a seller to formally register his sell offer at ExchangeMacroansy
1676,"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ >= baseUnits ) ) ; require ( ( balances [ msg . sender ] >= baseUnits ) ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }",Redeems Basket Token in return for underlying tokens
1677,function closeSale ( ) public onlyOwner { closed = true ; SaleClosed ( now ) ; },Public function enables closing of the crowdsale manually if necessary
1678,function stopSale ( ) onlyBy ( owner ) external { isStopped = true ; },Stop sale in case of emergency ( i.e .
1679,"function list_bytesarray ( uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _function_first ( ) , _count , true , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _function_last ( ) , _count , true , _function_first , _function_previous ) ; } }",Lists a Bytes collection from start or end
1680,"function onERC721Received ( address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( keccak256 ( ""onERC721Received(address,uint256,bytes)"" ) ) ; } }",Callback used to accept the ERC721 parcel tokens
1683,function withdraw ( uint _ether ) external returns ( bool success_ ) ;,Will withdraw ` _ether ` to your account .
1684,"function getOrderHash ( OrderData data ) internal pure returns ( bytes32 orderHash , bytes32 prefixedHash ) { orderHash = keccak256 ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce ) ; bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; prefixedHash = keccak256 ( prefix , orderHash ) ; }","Get both hash ( data ) and hash ( prefix , hash ( data ) )"
1685,"function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , ""ValidFrom is too early"" ) ; require ( _validTo >= now , ""ValidTo is too late"" ) ; require ( ! nonceMap [ _investor ] [ _nonce ] , ""Already used signature"" ) ; nonceMap [ _investor ] [ _nonce ] = true ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo , _nonce ) ) ; _checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit ModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }",Adds or removes addresses from the whitelist - can be called by anyone with a valid signature
1687,"function transferFrom ( address _from , address _to , uint256 _tokenId , uint256 _price , uint256 _x , uint256 _y ) public auctionNotOngoing ( _x , _y ) { _subFromValueHeld ( msg . sender , _price , false ) ; _addToValueHeld ( _to , _price ) ; require ( _to == msg . sender ) ; Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; super . transferFrom ( _from , _to , _tokenId ) ; }",This transfer has to be approved and then triggered by the _to address in order to avoid sending unwanted pixels
1688,"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }",Owner can transfer out any accidentally sent ERC20 tokens .
1691,function _unpause ( ) internal { require ( paused ) ; paused = false ; emit Unpause ( now ) ; },"called by the owner to unpause , returns to normal state"
1693,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { latinotokenrecipiente spender = latinotokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
1694,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",Assign allowance _value to _spender address to use the msg.sender balance
1696,function unproposeMilestones ( ) onlyRecipient campaignNotCanceled { delete proposedMilestones ; changingMilestones = false ; NewMilestoneListUnproposed ( ) ; },` onlyRecipient ` Cancels the proposed milestones and reactivates the previous set of milestones
1697,"function getAllStar ( uint256 _tokenId ) public view returns ( string allStarName , uint allStarGen , uint256 sellingPrice , address owner ) { AllStar storage allStar = allStars [ _tokenId ] ; allStarName = allStar . name ; allStarGen = allStar . gen ; sellingPrice = allStarIndexToPrice [ _tokenId ] ; owner = allStarIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific AllStar .
1698,"function transfer ( address _to , uint256 _value ) notPendingWithdrawal { if ( balanceOf [ msg . sender ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; }",send ` _value ` token to ` _to ` from ` msg.sender `
1699,"function transfer ( address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }",Owner initates the transfer of the token to another account
1700,"function finalize ( ) public initialized { Tier tier = tiers [ tierCount ] ; assert ( tier . finalizedTime ( ) == 0 ) ; assert ( getBlockTimestamp ( ) >= tier . startTime ( ) ) ; assert ( msg . sender == controller || getBlockTimestamp ( ) > tier . endTime ( ) || isCurrentTierCapReached ( ) ) ; tier . finalize ( ) ; tierCount ++ ; FinalizedTier ( tierCount , tier . finalizedTime ( ) ) ; }",This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .
1701,"function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) { if ( value > 0 ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _isApprovedOrOwner ( msg . sender , tokenId ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( to == address ( 0 ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _checkOnERC721Received ( from , to , tokenId , """" ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _registry . hasAttribute ( to , _validAttributeTypeID ) ) { return ( false , bytes1 ( hex""10"" ) ) ; } return ( true , bytes1 ( hex""01"" ) ) ; }",Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
1702,function deregisterProducer ( address aproducer ) onlyOwner external { emit producerDeregistered ( aproducer ) ; producers [ aproducer ] = false ; },Cease allowing the owner of address ` aproducer.address ( ) ` to act as a producer ( by offering energy ) .
1703,"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }","challenge the provided proposal ID , and put tokens at stake to do so ."
1704,"function setTokenEscrowMarketplace ( TokenEscrowMarketplace _newTokenEscrowMarketplace ) external onlyDuringInitialization { address oldTokenEscrowMarketplace = tokenEscrowMarketplace ; tokenEscrowMarketplace = _newTokenEscrowMarketplace ; emit TokenEscrowMarketplaceChanged ( oldTokenEscrowMarketplace , tokenEscrowMarketplace ) ; }",Set the implementation of the TokenEscrowMarketplace contract by setting a new address
1706,"function withdraw ( address _token ) public onlyOwner { require ( _token != address ( 0 ) , ""Token address cannot be zero address"" ) ; uint256 balance = ERC20 ( _token ) . balanceOf ( address ( this ) ) ; require ( balance > 0 , ""Cannot withdraw from a balance of zero"" ) ; ERC20 ( _token ) . transfer ( owner , balance ) ; }",Generic withdraw function in the case of having leftover tokens to withdraw
1707,"function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) { require ( approve ( _spender , _value ) ) ; ERC20RecipientInterface ( _spender ) . receiveApproval ( msg . sender , _value , this , _data ) ; return true ; }","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount ."
1708,function collectEther ( uint256 amount ) onlyOwner public { owner . transfer ( amount ) ; },Collect ether received for token purshases This is possible both during Collection and Distribution phases
1711,"function mintFish ( address [ ] _owner , uint32 [ ] _weight , uint8 [ ] _power , uint8 [ ] _agility , uint8 [ ] _speed , bytes16 [ ] _color ) onlyMinter public { for ( uint i = 0 ; i < _owner . length ; i ++ ) { _mintFish ( _owner [ i ] , _weight [ i ] , _power [ i ] , _agility [ i ] , _speed [ i ] , _color [ i ] ) ; } }",Mints fishes according to params can only be called by the owner
1712,"function burn ( uint256 _amount , bytes _holderData ) public canBurn { super . burn ( _amount , _holderData ) ; }",Burns ` _amount ` tokens from ` _tokenHolder ` Sample burn function to showcase the use of the ` Burned ` event .
1713,"function transfer ( address _to , uint _value ) returns ( bool ) { if ( balanceOf [ msg . sender ] >= _value ) { balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",` _value ` tokens will be sended to ` _to `
1714,"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256)"" ) ) ; }",This function returns the signature of configure function
1718,function getValidators ( ) external view returns ( address [ ] ) ;,Get the accounts of all available validators on the jurisdiction .
1720,"function updateAllowance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . setUint ( id , self . Storage . getUint ( id ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }",Low-level method to update spender allowance for account
1722,function setTokenSaleHardCap ( uint256 newTokenSaleHardCap ) onlyAuthorized public { tokenSaleHardCap = newTokenSaleHardCap ; },Allow users to buy tokens for ` newTokenSaleHardCap ` XCR
1723,function getInvitationRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . invitationRewards ; },Called to obtain the invitation reward balance of any given member
1724,function burnTokens ( ) external onlyCrowdsale whenNotPaused { uint256 remainingICOToken = limitCrowdsale . sub ( tokensDistributedCrowdsale ) ; if ( remainingICOToken > 0 && ! remainingTokenBurnt ) { remainingTokenBurnt = true ; limitCrowdsale = limitCrowdsale . sub ( remainingICOToken ) ; totalSupply = totalSupply . sub ( remainingICOToken ) ; } },Burn the amount of tokens remaining after ICO ends
1725,function collectionExists ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { return _collectionIndex < totalCollections ( ) ; },Check if collection # ` ( _collectionIndex ) ` exists
1726,"function allowance ( address _owner , address _spender ) public view returns ( uint256 _allowance ) { return allowed [ _owner ] [ _spender ] ; }",Used to retrieve the allowed balance of someone
1728,"function getPrecious ( uint256 _tokenId ) public view returns ( string preciousName , uint256 number , uint256 editionId , uint256 collectionId , address owner ) { Precious storage precious = allPreciouses [ _tokenId ] ; preciousName = precious . name ; number = precious . number ; editionId = precious . editionId ; collectionId = precious . collectionId ; owner = preciousIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific precious .
1729,"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) private whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _from ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) , ""You cannot invoke doSend with a the burn address (0x0) as the recipient 'to' address"" ) ; require ( balanceAvailable >= _amount , ""You can only invoke doSend when the 'from' address has an unlocked balance >= the '_amount' sent"" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }",Helper function actually performing the sending of tokens .
1730,function fundingGoal ( ) public constant returns ( uint256 amount ) { },the goal the campaign must reach in order for it to succeed
1732,"function buyBkgAtExchg ( address seller , uint sellersCoinAmountOffer , uint sellersPriceOfOneCoinInWEI , uint myProposedPaymentInWEI ) public returns ( bool success ) { uint amountTkns = sellersCoinAmountOffer ; uint priceOfr = sellersPriceOfOneCoinInWEI ; uint payment = myProposedPaymentInWEI ; msgSndr [ msg . sender ] = amountTkns ; bool sucsLmt = _slrByrLmtChk ( seller , amountTkns , priceOfr , msg . sender ) ; require ( sucsLmt == true ) ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emBkgsuccess ; ( emBkgsuccess ) = em . buy_Exchg_booking ( seller , amountTkns , priceOfr , msg . sender , payment ) ; require ( emBkgsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }",payment booking value and actual payment value should be exact
1733,function reclaimDividend ( uint256 _dividendIndex ) external ;,"Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends"
1735,"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }",` onlySecurityGuard ` Delays a payment for a set number of seconds
1736,"function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 10 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }",Transfers awarded MILs to the caller 's account .
1738,"function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _transfer ( _to , msg . sender , _amount ) ; return true ; }",Initiates a `` send '' operation towards another user .
1739,"function setReputationIRNNodeShare ( uint256 _reputationIRNNodeShare ) public onlyOwner returns ( bool ) { require ( _reputationIRNNodeShare > 0 , ""new share must be larger than zero"" ) ; require ( _reputationIRNNodeShare < 100 , ""new share must be less than to 100"" ) ; require ( reputationIRNNodeShare != _reputationIRNNodeShare , ""new share must be different"" ) ; reputationIRNNodeShare = _reputationIRNNodeShare ; emit ReputationIRNNodeShareUpdated ( msg . sender , _reputationIRNNodeShare ) ; return true ; }",sets the global reputation reward share allotted to the authors and manufacturers
1740,"function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external ;","Set a required fee for a given attribute type ID ` ID ` and an amount of ` fee ` , to be paid to the owner of the jurisdiction upon assignment of attributes of the given type ."
1741,"function updateProject ( uint64 idProject , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage project = findAdmin ( idProject ) ; require ( project . adminType == PledgeAdminType . Project ) ; require ( project . addr == msg . sender ) ; project . addr = newAddr ; project . name = newName ; project . url = newUrl ; project . commitTime = newCommitTime ; ProjectUpdated ( idProject ) ; }","Updates a Project 's info to change the address , name , url , or commitTime , it can not be used to change a plugin or a parentProject , and it must be called by the current address of the Project"
1743,"function deposit ( bytes32 _userKey , uint _value , uint _feeAmount , address _feeAddress , uint _lockupDate ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; ERC20 _token = ERC20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE ; } uint _depositedAmount = _value - _feeAmount ; _makeDepositForPeriod ( _userKey , _depositedAmount , _lockupDate ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = _periodsCount ; delete periods [ _periodsCount ] . startDate ; if ( ! _token . transferFrom ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } TreasuryDeposited ( _userKey , _depositedAmount , _lockupDate ) ; return OK ; }",Deposits tokens on behalf of users Allowed only for oracle .
1745,function confirmPayment ( uint _idPayment ) public onlyOwner { doConfirmPayment ( _idPayment ) ; },Allows the owner to confirm payments ; since ` authorizePayment ` is the only way to populate the ` payments [ ] ` array this is generally used when ` autopay ` is ` false ` after a payment has has been authorized
1748,"function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }",Handles transfer to a contract ~ ERC-223 Proposed Standard
1749,"function claimMultipleAndWithdrawBalance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateAny ( ) public { uint256 qi ; uint256 i ; for ( qi = 0 ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = 0 ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claimWinnings ( qid , hh , ad , bo , an ) ; } withdraw ( ) ; }","Convenience function to assign bounties/bonds for multiple questions in one go , then withdraw all your funds ."
1750,function tokensOf ( address _owner ) public view returns ( uint256 [ ] ) { return ownedTokens [ _owner ] ; },Gets the list of tokens owned by a given address
1752,"function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched value parameter and tx value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether transfer"" ) ; CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , _value ) ; }",Deposits ETH or an ERC20 token into the contract .
1754,"function approve ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender ) ; loan . approvedTransfer = to ; Approval ( msg . sender , to , index ) ; return true ; }","Approves the transfer of a given loan in the name of the lender , the behavior of this function is similar to `` approve '' in the ERC20 standard , but only one approved address is allowed at a time ."
1756,"function addressAndBalance ( ) constant returns ( address participant1 , uint balance1 , address participant2 , uint balance2 ) { NettingChannelLibrary . Participant storage node1 = data . participants [ 0 ] ; NettingChannelLibrary . Participant storage node2 = data . participants [ 1 ] ; participant1 = node1 . node_address ; balance1 = node1 . balance ; participant2 = node2 . node_address ; balance2 = node2 . balance ; }",Get the address and balance of both partners in a channel .
1757,function getValidatorInformation ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; },Get a description of the validator at account ` validator ` .
1758,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { var _allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= _allowance ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; return sell ( _from , _value ) ; } else { return super . transferFrom ( _from , _to , _value ) ; } }",Transfer tokens from one address to another or sell them if _to is this contract or zero address
1760,"function onApprove ( address _owner , address _spender , uint _amount_old , uint _amount_new ) public returns ( bool ) ;",Notifies the controller about an approval allowing the controller to react if desired
1761,function addNewReservContract ( address newRcAddr ) public onlyOwner { require ( isContract ( newRcAddr ) == true ) ; require ( newRcAddr != 0x0 && newRcAddr != address ( this ) && newRcAddr != address ( token ) ) ; require ( reservationContracts [ newRcAddr ] == false ) ; reservationContracts [ newRcAddr ] = true ; },Call this before the startTime to avoid delays
1762,"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E96 ) , _newCOO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCOO
1763,"function burn ( uint256 _value ) public onlyIfLockTimePassed { require ( _value > 0 ) ; require ( balances [ msg . sender ] >= _value ) ; require ( totalSupply >= _value ) ; uint pre_balance = balances [ msg . sender ] ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burn ( burner , _value ) ; Transfer ( burner , 0x0 , _value ) ; assert ( balances [ burner ] == pre_balance . sub ( _value ) ) ; }",Allows ` msg.sender ` to simply destroy ` _value ` token units ( sphi ) .
1765,function getTotalDonations ( ) public view returns ( uint256 ) { return convertToEther ( finalized ? totalSencCollected : getSencBalance ( ) ) ; },The ` getTotalDonations ( ) ` retrieve the Ether balance collected so far in Wei .
1766,"function tokenFallback ( address _from , uint _value , bytes ) external { require ( msg . sender == address ( abioToken ) ) ; require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }",We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume .
1767,"function distributeReward ( uint intelIndex ) public returns ( bool success ) { require ( intelIndex > 0 ) ; IntelState storage intel = intelDB [ intelIndex ] ; require ( ! intel . rewarded ) ; require ( now >= intel . rewardAfter ) ; intel . rewarded = true ; uint distributed_amount = 0 ; if ( intel . balance > intel . desiredReward ) { distributed_amount = intel . desiredReward ; } else { distributed_amount = intel . balance ; } uint fee = distributed_amount . div ( 10 ) ; distributed_amount = distributed_amount . sub ( fee ) ; token . transfer ( intel . intelProvider , distributed_amount ) ; token . transfer ( msg . sender , fee ) ; emit RewardDistributed ( intelIndex , distributed_amount , intel . intelProvider , msg . sender , fee ) ; return true ; }",this function distributes rewards to the Intel provider
1768,function totalSupply ( ) public view returns ( uint ) { return dungeons . length ; },Returns the total number of tokens currently in existence .
1769,"function removeBudget ( address _token ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , uint256 ( 0 ) , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = 0 ; settings . hasBudget [ _token ] = false ; emit SetBudget ( _token , 0 , false ) ; }","Remove spending limit for ` _token.symbol ( ) : string ` , effective immediately"
1770,"function removeAttributeType ( uint256 ID ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) , ""unable to remove, no attribute type with the provided ID"" ) ; uint256 lastAttributeID = _attributeIDs [ _attributeIDs . length . sub ( 1 ) ] ; _attributeIDs [ _attributeTypes [ ID ] . index ] = lastAttributeID ; _attributeTypes [ lastAttributeID ] . index = _attributeTypes [ ID ] . index ; _attributeIDs . length -- ; delete _attributeTypes [ ID ] ; emit AttributeTypeRemoved ( ID ) ; }",Remove the attribute type with ID ` ID ` from the jurisdiction .
1771,function closeSetup ( ) returns ( bool ) { if ( smartContractStartDate != 0 || ( msg . sender != creator && msg . sender != Client ( ) ) ) return ; smartContractStartDate = now ; return true ; },Function to close the setting procedure and start to use this smart contract
1772,"function saleAirdrop ( address beneficiary , uint256 amount ) onlyOwner external { mintTokens ( beneficiary , amount ) ; }",Mint tokens for Airdrops ( only external ) by Alber Erre
1773,"function submitChallengeOrder ( bytes details , uint64 settlementID , uint64 tokens , uint256 price , uint256 volume , uint256 minimumVolume ) external onlyDarknode { SettlementUtils . OrderDetails memory order = SettlementUtils . OrderDetails ( { settlementID : settlementID , tokens : tokens , price : price , volume : volume , minimumVolume : minimumVolume } ) ; bytes32 orderID = SettlementUtils . hashOrder ( details , order ) ; require ( ! orderSubmitted [ orderID ] , ""already submitted"" ) ; orderDetails [ orderID ] = order ; challengers [ orderID ] = msg . sender ; orderSubmitted [ orderID ] = true ; }",Submits the details for one of the two orders of a challenge .
1774,"function issueAssetToAddress ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _error ( ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; symbols . push ( _symbol ) ; assets [ _symbol ] = Asset ( creatorId , _value , _name , _description , _isReissuable , _baseUnit ) ; assets [ _symbol ] . wallets [ holderId ] . balance = _value ; Emitter ( eventsHistory ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }",Issues new asset token on the platform .
1775,"function getPlayerByBoard ( bytes32 boardHash , uint8 playerID ) constant public returns ( bytes32 , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; require ( p . isActive == 1 ) ; return ( p . playerName , p . score , p . score_unconfirmed ) ; }",Get player data by leaderboard hash and player id/index
1776,"function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }","Request arbitration , freezing the question until we send submitAnswerByArbitrator"
1777,"function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external { require ( isAttributeType ( ID ) , ""unable to set minimum stake, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . minimumStake = minimumRequiredStake ; }","Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type ."
1778,function isDuringSalePeriod ( uint256 _blockNumber ) view internal returns ( bool ) { return ( _blockNumber >= startBlock && _blockNumber < endBlock ) ; },check if the block number is during the sale period
1781,"function exchange ( bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external optionalProxy returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , ""Exchange must use different synths"" ) ; require ( sourceAmount > 0 , ""Zero amount"" ) ; return _internalExchange ( messageSender , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress == address ( 0 ) ? messageSender : destinationAddress , true ) ; }",Function that allows you to exchange synths you hold in one flavour for another .
1782,"function getEscrowDeposit ( string _id ) external view returns ( address bidder , bytes data , uint256 amount ) { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; bidder = escrowDeposit . bidder ; data = escrowDeposit . data ; amount = escrowDeposit . amount ; }",Gets the EscrowDeposit based on the input id .
1787,"function redeem ( uint _amount , address _backerAddr ) returns ( bool ) { if ( backersRedeemed [ _backerAddr ] == true ) { return false ; } uint totalTokens = 0 ; for ( uint i = 0 ; i < backers [ _backerAddr ] . length ; i ++ ) { if ( backers [ _backerAddr ] [ i ] . claimed == false ) { return false ; } totalTokens += backers [ _backerAddr ] [ i ] . tokenAmount ; } if ( totalTokens == _amount ) { backersRedeemed [ _backerAddr ] = true ; RedeemEvent ( _backerAddr , totalTokens ) ; return true ; } else { return false ; } }",Backer ` _bacherAddr.address ( ) ` is redeeming ` _amount ` superDAO Tokens
1788,function darknodePublicKey ( address darknodeID ) external view onlyOwner returns ( bytes ) { return darknodeRegistry [ darknodeID ] . publicKey ; },Returns the encryption public key of a given darknode .
1790,"function updateXDRRate ( uint timeSent ) internal { uint total = 0 ; for ( uint i = 0 ; i < xdrParticipants . length ; i ++ ) { total = rates [ xdrParticipants [ i ] ] . add ( total ) ; } rates [ ""XDR"" ] = total ; lastRateUpdateTimes [ ""XDR"" ] = timeSent ; bytes4 [ ] memory eventCurrencyCode = new bytes4 [ ] ( 1 ) ; eventCurrencyCode [ 0 ] = ""XDR"" ; uint [ ] memory eventRate = new uint [ ] ( 1 ) ; eventRate [ 0 ] = rates [ ""XDR"" ] ; emit RatesUpdated ( eventCurrencyCode , eventRate ) ; }",Update the Synthetix Drawing Rights exchange rate based on other rates already updated .
1791,"function getFeeMsg ( Data storage self , address contractAddress ) internal view returns ( bytes feeMsg ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.msg' , contractAddress ) ) ; return self . Storage . getBytes ( id ) ; }",Get the flat message of the contract address ; typically TokenIOFeeContract
1792,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
1793,"function approve ( address _to , uint _tokenId ) public isNotContract { require ( _owns ( msg . sender , _tokenId ) ) ; divCardIndexToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
1794,"function viewTokenMeta ( uint256 _tokenId ) external view returns ( string tokenTitle_ , string tokenDescription_ ) { tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; }",Returns all the relevant information about a specific token
1796,"function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) { string memory ticker = Util . upper ( _ticker ) ; bool tickerStatus = _tickerStatus ( ticker ) ; uint256 expiryDate = getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) ; if ( ( tickerStatus == true ) || ( expiryDate > now ) ) { return ( _tickerOwner ( ticker ) , getUint ( Encoder . getKey ( ""registeredTickers_registrationDate"" , ticker ) ) , expiryDate , getString ( Encoder . getKey ( ""registeredTickers_tokenName"" , ticker ) ) , tickerStatus ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) , """" , false ) ; }",Returns the owner and timestamp for a given ticker
1799,"function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) { require ( _tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; return pixelcons [ _tokenIndex ] . tokenId ; }",Get the ID of PixelCon # ` ( _tokenIndex ) `
1803,function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit LogAllowAllBurnTransfers ( _allowAllBurnTransfers ) ; },Used to change the flag true - It allow to burn the tokens false - It deactivate the burning mechanism .
1806,"function setMaxRate ( uint ethMax , uint btcMax ) public onlyOwnerAndDirector { ethRateMax = ethMax ; btcRateMax = btcMax ; }",setMaxRate sets max rate for both BTC/ETH to soften negative consequences in case our backend gots hacked .
1807,"function buy ( address seller , uint256 quantity , uint256 price ) public payable { TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , ""Buy price does not match the listed sell price."" ) ; require ( block . timestamp < order . expiry , ""Sell order has expired."" ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; uint256 cost = multiplyAtPrecision ( tradeQuantity , order . price , 9 ) ; require ( msg . value >= cost , ""You did not send enough Ether to purchase the tokens."" ) ; uint256 tokenFee ; uint256 etherFee ; ( tokenFee , etherFee ) = calculateFee ( tradeQuantity , cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity . sub ( tokenFee ) ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } if ( tokenFee > 0 && ! ERC20Interface ( tokenContract ) . transferFrom ( seller , owner , tokenFee ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } order . quantity = order . quantity . sub ( tradeQuantity ) ; orderBook [ seller ] = order ; seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }",Buy tokens from an existing sell order .
1808,function getInvestors ( ) external view returns ( address [ ] ) ;,Gets length of investors array NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors
1809,function nominateNewOwner ( address _owner ) external onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; },Nominate a new owner of this contract .
1810,"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { require ( b <= a , ""Error: Unsafe subtraction operation!"" ) ; return a - b ; }","Subtracts two numbers , throws on underflow ."
1811,"function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }",Allow withdrawing any token other than the relevant one
1812,"function MultiplesaleAirdrop ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { for ( uint256 r = 0 ; r < beneficiaries . length ; r ++ ) { mintTokens ( address ( beneficiaries [ r ] ) , uint256 ( amounts [ r ] ) ) ; } }",Mint tokens for multiple addresses for Airdrops ( only external ) - Alber Erre
1813,"function newPinnedAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxyPinned ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }","Create a new non-upgradeable instance of ` _appId ` app linked to the Kernel , setting its code to ` _appBase ` ."
1814,"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; if ( _delay > 10 ** 18 ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }",` onlySecurityGuard ` Delays a payment for a set number of seconds
1816,"function upgrade ( ) external isHuman ( ) { address _agent = msg . sender ; require ( player [ _agent ] . isAgent ) ; require ( player [ _agent ] . level < maxLevel ) ; if ( player [ _agent ] . accumulatedAff >= requirement [ player [ _agent ] . level ] ) { player [ _agent ] . level = ( 1 ) . add ( player [ _agent ] . level ) ; emit UPGRADE ( _agent , player [ _agent ] . level ) ; } }",Upgrade when a player 's affiliate bonus meet the promotion
1817,"function getKey ( address _sender_address , address _receiver_address , uint32 _open_block_number ) public pure returns ( bytes32 data ) { return keccak256 ( _sender_address , _receiver_address , _open_block_number ) ; }",Returns the unique channel identifier used in the contract .
1819,function claimableHalvings ( ) public constant returns ( uint256 ) { return claimableHalvingsOf ( msg . sender ) ; },Compute the number of halvings claimable by the miner caller
1820,function enableTransfers ( bool _transfersEnabled ) public onlyOwner { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
1822,function setKYCProvider ( address KYCProvider ) external validAddress ( KYCProvider ) privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_KYCProvider = IKYCProvider ( KYCProvider ) ; },Sets current KYC provider of the token .
1823,function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWei = tokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWei <= receivedWei ) { return 0 ; } return requiredWei - receivedWei ; },"Get the missing funds needed to end the auction , calculated at the current XBET price in WEI ."
1824,"function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
1825,function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; uint256 senderBalance = balanceOf [ msg . sender ] ; require ( senderBalance >= value ) ; balanceOf [ msg . sender ] = senderBalance . sub ( value ) ; msg . sender . transfer ( value ) ; },The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
1826,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable ;",Transfers the ownership of an NFT from one address to another address
1827,"function getTotalBmcDaysAmount ( uint _date ) public view returns ( uint ) { return _getTotalBmcDaysAmount ( _date , periodsCount ) ; }",Gets total amount of bmc-day accumulated due provided date
1831,"function getGame ( uint256 _tokenId ) public view returns ( string gameName , uint256 sellingPrice , address owner ) { Game storage game = games [ _tokenId ] ; gameName = game . name ; sellingPrice = gameIndexToPrice [ _tokenId ] ; owner = gameIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific game .
1832,"function mGenerateTokens ( address owner , uint256 amount ) internal ;",Generates ` amount ` tokens that are assigned to ` owner `
1833,function getEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . div ( phiRate ) ; },"It divides ( ETH/USD rate ) / ( PHI/USD rate ) , use the custom function ` getEthPhiRate ( false ) ` if you want a more accurate rate"
1836,"function tokenFallback ( address _from , uint _value , bytes _data ) external ;",Standard ERC223 function that will handle incoming token transfers .
1837,"function getHashRateOf ( address _miner , uint256 _halving ) public constant notBeforeGenesis isMiner ( _miner ) returns ( bool , uint256 ) { require ( _halving <= currentHalving ( ) ) ; Miner miner = miners [ _miner ] ; MinerHashRate hashRate = miner . hashRate [ _halving ] ; return ( hashRate . carried , hashRate . rate ) ; }",Calculate the hash rate of a miner in a halving
1838,"function hold ( address who , uint256 quantity ) public onlyIssuer { require ( who != 0x0 , ""The null address cannot own tokens."" ) ; require ( quantity != 0 , ""Quantity must be greater than zero."" ) ; require ( ! isExistingHolding ( who ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; Holding memory holding = Holding ( quantity , block . timestamp + oneYear , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }",Keep a US Citizen 's tokens for one year .
1839,"function deposit ( address from , address contractAddress , uint256 uid , uint256 denomination , Mode mode ) private { currentBlock = currentBlock . add ( 1 ) ; uint64 slot = uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( numCoins , msg . sender , from ) ) ) ) ; Coin storage coin = coins [ slot ] ; coin . uid = uid ; coin . contractAddress = contractAddress ; coin . denomination = denomination ; coin . depositBlock = currentBlock ; coin . owner = from ; coin . state = State . DEPOSITED ; coin . mode = mode ; childChain [ currentBlock ] = ChildBlock ( { root : keccak256 ( abi . encodePacked ( slot ) ) , createdAt : block . timestamp } ) ; emit Deposit ( slot , currentBlock , denomination , from , contractAddress ) ; numCoins += 1 ; }",Appends a deposit block to the Plasma chain
1841,function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) ;,Query a contract to see if it supports a certain interface
1842,"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( _from ) ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; spentAct [ _from ] = spentAct [ _from ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Same as the default ERC20 transferFrom ( ) with two differences : 1 .
1845,"function setBytes ( bytes32 _key , bytes _value ) public onlyOwner returns ( bool success ) { bytesStorage [ _key ] = _value ; return true ; }",Set value for Bytes associated with bytes32 id key
1848,"function bulkRegisterPoA ( bytes32 bidId , bytes32 rootHash , bytes signedRootHash , uint256 newHashes ) public onlyIfWhitelisted ( ""createCampaign"" , msg . sender ) { address addressSig = recoverSigner ( rootHash , signedRootHash ) ; if ( msg . sender != addressSig ) { emit Error ( ""bulkRegisterPoA"" , ""Invalid signature"" ) ; return ; } uint price = _getStorage ( ) . getCampaignPriceById ( bidId ) ; uint budget = _getStorage ( ) . getCampaignBudgetById ( bidId ) ; address owner = _getStorage ( ) . getCampaignOwnerById ( bidId ) ; uint maxConversions = division ( budget , price ) ; uint effectiveConversions ; uint totalPay ; uint newBudget ; if ( maxConversions >= newHashes ) { effectiveConversions = newHashes ; } else { effectiveConversions = maxConversions ; } totalPay = price * effectiveConversions ; newBudget = budget - totalPay ; _getFinance ( ) . pay ( owner , msg . sender , totalPay ) ; _getStorage ( ) . setCampaignBudgetById ( bidId , newBudget ) ; if ( newBudget < price ) { _getStorage ( ) . setCampaignValidById ( bidId , false ) ; } emit BulkPoARegistered ( bidId , rootHash , signedRootHash , newHashes , effectiveConversions ) ; }",Function to submit in bulk PoAs This function can only be called by whitelisted addresses and provides a cost efficient method to submit a batch of validates PoAs at once .
1849,function brokerVerifierContract ( uint64 _settlementID ) external view returns ( BrokerVerifier ) { return settlementDetails [ _settlementID ] . brokerVerifierContract ; },Returns the broker verifier contract of a settlement layer .
1850,function ( ) payable { if ( isContract ( controller ) ) { if ( ! Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { throw ; } },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
1851,"function genericTransfer ( address _to , uint _value , bytes _data ) onlyOwner public { require ( _to . call . value ( _value ) ( _data ) ) ; }",generic transfer function can interact with contracts by supplying data / function calls
1852,"function burnSynths ( bytes4 currencyKey , uint amount ) external optionalProxy { uint debt = debtBalanceOf ( messageSender , currencyKey ) ; require ( debt > 0 , ""No debt to forgive"" ) ; uint amountToBurn = debt < amount ? debt : amount ; _removeFromDebtRegister ( currencyKey , amountToBurn ) ; synths [ currencyKey ] . burn ( messageSender , amountToBurn ) ; }",Burn synths to clear issued synths/free SNX .
1853,"function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) public onlyController { bool verified = _burn ( _from , _value , _data ) ; emit ForceBurn ( msg . sender , _from , _value , verified , _log ) ; }",Used by a controller to execute a forced burn
1855,function getHalvingOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockHalving ( miners [ _miner ] . block ) ; },Return the miner halving ( starting halving or last claimed )
1856,"function getPoo ( uint256 _tokenId ) public view returns ( string pooName , uint256 sellingPrice , address owner ) { Poo storage poo = poos [ _tokenId ] ; pooName = poo . name ; sellingPrice = pooIndexToPrice [ _tokenId ] ; owner = pooIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific poo .
1858,"function release ( ) public returns ( bool ) { address target = msg . sender ; FrozenStatus storage frozenStatus = frozenStatuses [ target ] ; require ( frozenStatus . frozenAmount > 0 ) ; uint256 actualLastReleaseTimestamp ; if ( frozenStatus . lastReleaseTimestamp == 0 ) { actualLastReleaseTimestamp = frozenStatus . frozenTimestamp + firstReleasePeriod ; } else { actualLastReleaseTimestamp = frozenStatus . lastReleaseTimestamp + regularReleasePeriod ; } require ( now >= actualLastReleaseTimestamp ) ; frozenStatus . lastReleaseTimestamp = actualLastReleaseTimestamp ; uint256 actualReleaseAmount = Math . min256 ( frozenStatus . frozenAmount , frozenStatus . releaseAmount ) ; token . safeTransfer ( target , actualReleaseAmount ) ; frozenStatus . frozenAmount = frozenStatus . frozenAmount . sub ( actualReleaseAmount ) ; totalFrozen = totalFrozen . sub ( actualReleaseAmount ) ; ReleaseTokens ( target , actualReleaseAmount ) ; return true ; }",Transfers tokens held by PeriodicReleaseLock to beneficiary .
1861,"function addCommissionToPendingWithdrawals ( uint32 _canvasId ) public onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw = calculateCommissionToWithdraw ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . paidCommissionIndex = _lastIndex ; addPendingWithdrawal ( owner , _toWithdraw ) ; emit CommissionAddedToWithdrawals ( _canvasId , _toWithdraw ) ; }",Adds all unpaid commission to the owner 's pending withdrawals .
1866,function getBalance ( ) constant returns ( uint ) { if ( address ( baseToken ) != 0 ) { return baseToken . balanceOf ( this ) ; } else { return this . balance ; } },Returns the balance of the ` baseToken ` stored in this contract
1868,"function appendDarknode ( address _darknodeID , address _darknodeOwner , uint256 _bond , bytes _publicKey , uint256 _registeredAt , uint256 _deregisteredAt ) external onlyOwner { Darknode memory darknode = Darknode ( { owner : _darknodeOwner , bond : _bond , publicKey : _publicKey , registeredAt : _registeredAt , deregisteredAt : _deregisteredAt } ) ; darknodeRegistry [ _darknodeID ] = darknode ; LinkedList . append ( darknodes , _darknodeID ) ; }",Instantiates a darknode and appends it to the darknodes linked-list .
1869,"function addAddressToAccount ( address _newAddress , bytes _newAddressSig , bytes _senderSig , bytes32 _nonce ) public onlyUser { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , msg . sender , _nonce ) ; }",Add an address to an existing id by a user
1870,"function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } Asset storage asset = assets [ _symbol ] ; uint holderId = getHolderId ( msg . sender ) ; if ( asset . wallets [ holderId ] . balance < _value ) { return _error ( ATX_PLATFORM_NOT_ENOUGH_TOKENS ) ; } asset . wallets [ holderId ] . balance = asset . wallets [ holderId ] . balance . sub ( _value ) ; asset . totalSupply = asset . totalSupply . sub ( _value ) ; Emitter ( eventsHistory ) . emitRevoke ( _symbol , _value , _address ( holderId ) ) ; _proxyTransferEvent ( holderId , 0 , _value , _symbol ) ; return OK ; }",Destroys specified amount of senders asset tokens .
1871,function getBytes ( bytes32 _key ) public view returns ( bytes _value ) { return bytesStorage [ _key ] ; },Get value for Bytes associated with bytes32 id key
1872,"function cleanUpAfterYourself ( ) public { require ( auctionState == AuctionStates . Ended , ""Auction is not ended."" ) ; if ( escrowModerator != address ( 0 ) ) { selfdestruct ( escrowModerator ) ; } else { selfdestruct ( beneficiary ) ; } }",selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `
1873,function getBond ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bond ; },Returns the highest bond posted so far for a question
1874,function currentClaimPriceWei ( ) constant returns ( uint priceInWei ) { if ( ! isLivingMonarch ( ) ) { return rules . startingClaimPriceWei ; } else { uint lastClaimPriceWei = latestMonarchInternal ( ) . claimPriceWei ; uint newClaimPrice = ( lastClaimPriceWei * ( 100 + rules . claimPriceAdjustPercent ) ) / 100 ; newClaimPrice = roundMoneyDownNicely ( newClaimPrice ) ; if ( newClaimPrice < rules . startingClaimPriceWei ) { newClaimPrice = rules . startingClaimPriceWei ; } if ( newClaimPrice > rules . maximumClaimPriceWei ) { newClaimPrice = rules . maximumClaimPriceWei ; } return newClaimPrice ; } },"How much you must pay to claim the throne now , in wei ."
1875,"function purchaseWithBTC ( address _to , uint _satoshi , uint _wei ) public onlyAdmin { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; ethSold = ethSold . add ( _wei ) ; uint cst ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 12 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; } else { cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 16 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }","purchaseWithBTC is called from backend , where we convert BTC to ETH , and then assign tokens to purchaser , using BTC / $ exchange rate ."
1876,"function setApprovalForAll ( address _operator , bool _approved ) external { revert ( ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all your assets .
1877,"function approveAddress ( address addressToApprove , address token ) internal { if ( ERC20 ( token ) . allowance ( address ( this ) , addressToApprove ) == 0 ) { require ( ERC20SafeTransfer . safeApprove ( token , addressToApprove , MAX_UINT ) ) ; } }",A function which allows the caller to approve the max amount of any given token
1878,"function removeSynth ( bytes4 currencyKey ) external optionalProxy_onlyOwner { require ( synths [ currencyKey ] != address ( 0 ) , ""Synth does not exist"" ) ; require ( synths [ currencyKey ] . totalSupply ( ) == 0 , ""Synth supply exists"" ) ; require ( currencyKey != ""XDR"" , ""Cannot remove XDR synth"" ) ; address synthToRemove = synths [ currencyKey ] ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { if ( availableSynths [ i ] == synthToRemove ) { delete availableSynths [ i ] ; availableSynths [ i ] = availableSynths [ availableSynths . length - 1 ] ; availableSynths . length -- ; break ; } } delete synths [ currencyKey ] ; emitSynthRemoved ( currencyKey , synthToRemove ) ; }",Remove an associated Synth contract from the Synthetix system
1879,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom due to insufficent Allowance provided"" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == countTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( countTransferManager ) . call ( _data ) , ""Unsuccessful call"" ) ; emit GenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( countTransferManager ) ; }",Used to launch the Module with the help of factory
1880,"function getBorrowRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;","Gets the current borrow interest rate based on the given asset , total cash and total borrows"
1881,"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Store . allowed ( _owner , _spender ) ; }",Core logic of the ERC20 ` allowance ` function .
1882,"function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( ( exchanges [ exchangeIndex ] . exchangeAdapter ) . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }",See adapter contracts for parameters needed for each exchange
1884,"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }",First or second stage of atomic swap .
1885,"function refundLosersBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_sorted_count . sub ( winner_bids ) < bids_sorted_refunded . add ( count ) ) { count = bids_sorted_count . sub ( winner_bids ) . sub ( bids_sorted_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_sorted_refunded . add ( winner_bids ) ; bids_sorted_refunded = bids_sorted_refunded . add ( count ) ; BidData memory bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; if ( bid . closed ) { continue ; } bids_sorted [ cursor ] . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }",Performs the refund of the `` loser '' bids ART tokens
1886,"function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
1887,"function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) public { require ( msg . sender == mBurnOperator ) ; super . operatorBurn ( _tokenHolder , _amount , _holderData , _operatorData ) ; }",Burns ` _amount ` tokens from ` _tokenHolder ` by ` _operator ` Silly example of overriding the ` operatorBurn ` function to only let a specific operator burn tokens .
1888,"function createSeedTeam ( uint8 _teamId , uint256 [ 9 ] _attributes , uint256 [ 9 ] _mlbPlayerId ) public onlyGameManager whenNotPaused { require ( _teamId != 0 ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { nonFungibleContract . createSeedCollectible ( _teamId , uint8 ( ii . add ( 1 ) ) , _attributes [ ii ] , address ( this ) , 0 , 0 , _mlbPlayerId [ ii ] ) ; } }",Creates a team and transfers all minted assets to SaleManager
1889,function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit AllowAllBurnTransfers ( _allowAllBurnTransfers ) ; },Used to change the flag true - It allow to burn the tokens false - It deactivate the burning mechanism .
1894,function hasError ( ) public onlyGameManager whenPaused { error = true ; },This is public rather than external so it can be called by derived contracts .
1895,"function claimRefund ( ) public stopInEmergency returns ( bool ) { if ( ! isFinalized ) { error ( 'claimRefund: ICO is not yet finalized.' ) ; return false ; } if ( ! SCRefundVault . isRefunding ( ) ) { error ( 'claimRefund: RefundVault state != State.Refunding' ) ; return false ; } uint256 tokenAmount = SCRefundVault . getTokensAcquired ( msg . sender ) ; emit GetBackTokensOnRefund ( msg . sender , this , tokenAmount ) ; if ( ! SCTokens . refundTokens ( msg . sender , tokenAmount ) ) { error ( 'claimRefund: unable to transfer investor tokens to ICO contract before refunding' ) ; return false ; } if ( ! SCRefundVault . refund ( msg . sender ) ) { error ( 'claimRefund: SCRefundVault.refund() failed' ) ; return false ; } return true ; }","If ICO is unsuccessful , investors can claim refunds here"
1896,"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }",Returns a deed identifier of the owner at the given index .
1898,"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
1900,function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; },Returns the number of Assets owned by a specific address .
1901,"function changeMinAcceptQuorumPct ( uint64 _minAcceptQuorumPct ) external authP ( MODIFY_QUORUM_ROLE , arr ( uint256 ( _minAcceptQuorumPct ) , uint256 ( minAcceptQuorumPct ) ) ) { require ( _minAcceptQuorumPct <= supportRequiredPct , ERROR_CHANGE_QUORUM_PCTS ) ; minAcceptQuorumPct = _minAcceptQuorumPct ; emit ChangeMinQuorum ( _minAcceptQuorumPct ) ; }",Change minimum acceptance quorum to ` @ formatPct ( _minAcceptQuorumPct ) ` %
1902,"function destroyTokens ( address _owner , uint _amount ) returns ( bool ) ;",Burns ` _amount ` tokens from ` _owner `
1903,"function refundForAll ( uint _from , uint _to ) ;",Function to refund for a group of partners after the closing time
1904,"function _redeemSameClassAdoptedAxies ( address _receiver , uint8 _class , uint256 _quantity ) private returns ( uint256 _remainingQuantity ) { _remainingQuantity = this . numAdoptedAxies ( _receiver , _class , true ) . sub ( _quantity ) ; if ( _quantity > 0 ) { _numDeductedAdoptedAxies [ _receiver ] [ _class ] = _numDeductedAdoptedAxies [ _receiver ] [ _class ] . add ( _quantity ) ; _totalDeductedAdoptedAxies [ _class ] = _totalDeductedAdoptedAxies [ _class ] . add ( _quantity ) ; AdoptedAxiesRedeemed ( _receiver , _class , _quantity ) ; } }",Redeem adopted Axies from the same class .
1905,"function blockTransfer ( address _shareHolder , uint _deadLine ) external ;",Function used by the client to block the transfer of shares from and to a share holder
1906,"function hasAllAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes == _attributes ; }",Check if asset has all attributes passed by parameter
1907,"function send ( address _to , uint256 _amount , bytes _userData ) external { doSend ( msg . sender , msg . sender , _to , _amount , _userData , """" , true ) ; }",Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
1908,"function getInstructions ( ) public view returns ( string ) { return ""Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)"" ; }",Get the Instructions that helped to used the module
1909,function setOracle ( address _oracle ) external optionalProxy_onlyOwner { oracle = _oracle ; emitOracleUpdated ( _oracle ) ; },Set the Oracle that pushes the havven price to this contract
1910,"function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , ""Value unchanged"" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }",Function to set allowBeneficialInvestments ( allow beneficiary to be different to funder )
1911,function getMinimumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMinimumFundsInEuroCents ( ) ) ; },minimum amount of funding to consider the sale as successful ( in wei )
1912,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
1914,function ( ) public payable isValidated notClosed notPaused isApproved { address caller = msg . sender ; processPreSale ( caller ) ; },This function fires when someone sends Ether to the address of this contract .
1916,"function freezeAccountAndAddToken ( address target , uint256 _value ) onlyOwner public { frozenAccount [ target ] = true ; FrozenFunds ( target , true ) ; _transfer ( msg . sender , target , _value ) ; }",Transfer initial coins to ` target ` and prevent from sending & receiving tokens
1917,"function depositWithToken ( bytes _signature , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( tokenContract . transferPreSignedHashing ( tokenAddress , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; uint256 prevBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( tokenContract . transferPreSigned ( _signature , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; uint256 curBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( curBalance == prevBalance + _value ) ; marginBalances [ from ] = marginBalances [ from ] . add ( _value ) ; emit DepositWithToken ( from , _value ) ; return true ; }",Submit a presigned transfer which transfer tokens to this contract
1919,function setBuyPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; },Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
1920,"function mint ( uint amount , address account ) onlyCrowdsaleMinter isNotStartedOnly { totalSupply += amount ; balances [ account ] += amount ; }",mint new token for given account in crowdsale stage
1924,"function mintToken ( address target , uint256 mintedAmount ) onlyCrowdsaleAgent public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( this , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
1925,function releaseToken ( ) public onlyOwner { if ( block . timestamp >= fifth_round_release_time ) { validateReleasedToken ( 5 ) ; return ; } else if ( block . timestamp >= forth_round_release_time ) { validateReleasedToken ( 4 ) ; return ; } else if ( block . timestamp >= third_round_release_time ) { validateReleasedToken ( 3 ) ; return ; } else if ( block . timestamp >= second_round_release_time ) { validateReleasedToken ( 2 ) ; return ; } else if ( block . timestamp >= first_round_release_time ) { validateReleasedToken ( 1 ) ; return ; } },Transfers tokens held by timelock to beneficiaries .
1926,function proxyPayment ( address _owner ) payable returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract
1927,"function fastCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator { require ( announcedCancellations [ _offerHash ] != 0 , ""Missing annoncement"" ) ; delete announcedCancellations [ _offerHash ] ; _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }",Cancels an offer immediately once cancellation intent has been announced .
1929,"function allowAddress ( address _address , bool _allow ) onlyOwner external { allowedAddresses [ _address ] = _allow ; }",Set allowance for address to interact with contract .
1931,"function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIdToPrice [ _tokenId ] ; owner = athleteIdToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific athlete .
1932,"function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) { uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; Member storage thisMember = members [ memberAddress ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; loyaltyReward += rewardForEachPeriod * numWholePeriods ; } }",Called to obtain the loyalty reward balance of any given member
1933,"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return true ; }","Notifies the controller about a transfer , for this Campaign all transfers are allowed by default and no extra notifications are needed"
1934,function setExchangeRate ( uint256 _exchangeRate ) onlyOwner public { exchangeRate = _exchangeRate ; exchangeRateAt = block . number ; },` onlyOwner ` changes the exchange rate of token to ETH
1935,"function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit LogChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }",used to change the fee of the subscription cost
1936,"function initialize ( address _fcc , address _fccController , uint256 _startTimeEarlyBird , uint256 _startTime , uint256 _endTime , uint256 _dayCycle , address _destEthFoundationDev , address _destEthFoundation , uint256 _proportion ) public onlyOwner { require ( address ( FCC ) == 0x0 ) ; FCC = MiniMeToken ( _fcc ) ; require ( FCC . totalSupply ( ) == 0 ) ; require ( FCC . controller ( ) == address ( this ) ) ; require ( FCC . decimals ( ) == 18 ) ; startTime = _startTime ; startTimeEarlyBird = _startTimeEarlyBird ; endTime = _endTime ; dayCycle = _dayCycle ; assert ( startTime < endTime ) ; require ( _fccController != 0x0 ) ; fccController = _fccController ; require ( _destEthFoundationDev != 0x0 ) ; destEthFoundationDev = _destEthFoundationDev ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; proportion = _proportion ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters
1937,function changeBalancesDB ( address _newDB ) public onlyOwner { balancesDB = CStore ( _newDB ) ; },change the balances database to ` _newDB `
1939,"function removeValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( canValidate ( validator , attributeTypeID ) , ""unable to remove validator approval, attribute is already unapproved"" ) ; delete _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] ; uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 lastAttributeID = _validatorApprovals [ validator ] [ lastIndex ] ; uint256 index = _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; _validatorApprovals [ validator ] [ index ] = lastAttributeID ; _validatorApprovals [ validator ] . length -- ; _validatorApprovalsIndex [ validator ] [ lastAttributeID ] = index ; delete _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; emit ValidatorApprovalRemoved ( validator , attributeTypeID ) ; }",Deny the validator at address ` validator ` the ability to continue to issue attributes of the type with ID ` attributeTypeID ` .
1940,function setAllowStart ( bool _allowStart ) external onlyCFO { allowStart = _allowStart ; AllowStart ( _allowStart ) ; },Allow the game to start once outside of active times .
1941,"function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetWalletBalance , _symbol , _holderId ) ; }",Returns asset balance for a particular holder id .
1943,"function approve ( address _to , uint256 _tokenId ) public ;",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( )
1944,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
1946,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { return erc20Impl . approveWithSender ( msg . sender , _spender , _value ) ; }","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount ."
1948,function finalizeCrowdsale ( ) onlyOwner external { state = State . Finished ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( icoCollected >= icoGoal && this . balance > 0 ) { claimEther ( ) ; } },"Close crowdsale , finish minting ( allowing token transfers ) , transfers token ownership to the founder"
1952,"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
1953,function removeOwnership ( address _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone"
1954,"function getReputationRewards ( address author , address manufacturer , bytes32 deviceId ) public view returns ( uint256 irnReward , uint256 manufacturerReward ) { uint256 lastWrite = authorWrites [ author ] [ deviceId ] ; uint256 blocks = 0 ; if ( lastWrite > 0 ) { blocks = block . number . sub ( lastWrite ) ; } uint256 totalRewards = calculateReward ( pools [ manufacturer ] . rewardAmount , blocks ) ; irnReward = totalRewards . mul ( settings . reputationIRNNodeShare ( ) ) . div ( 100 ) ; manufacturerReward = totalRewards . sub ( irnReward ) ; }",computes the portion of the reputation reward allotted to the manufacturer and author
1955,function setQuestionFee ( uint256 fee ) onlyOwner public { realitio . setQuestionFee ( fee ) ; emit LogSetQuestionFee ( fee ) ; },Set a fee for asking a question with us as the arbitrator
1959,function balanceOf ( address _address ) public view returns ( uint256 ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; return totalMintedActPerLockedBbkToken == 0 ? 0 : mintedActFromCurrentLockPeriodPerUser [ _address ] . add ( mintedActFromPastLockPeriodsPerUser [ _address ] ) . add ( receivedAct [ _address ] ) . sub ( spentAct [ _address ] ) ; },Combines all balance sheets to calculate the correct balance ( see explanation on top )
1960,function tokenHardcap ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapValue ; },Gets absolute hardcap value which means it will be greater than softcap value .
1961,function totalSupply ( ) public view returns ( uint256 ) { return ethernautsStorage . totalSupply ( ) ; },Returns the total number of Assets currently in existence .
1962,function getUint ( bytes32 _key ) public view returns ( uint _value ) { return uIntStorage [ _key ] ; },Get value for Uint associated with bytes32 id key
1963,"function getVestingScheduleEntry ( address account , uint index ) public view returns ( uint [ 2 ] ) { return vestingSchedules [ account ] [ index ] ; }",Get a particular schedule entry for an account .
1967,"function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) { return tradingOpen ; }","Notifies the controller about a transfer , for this Campaign all transfers are allowed by default and no extra notifications are needed"
1968,function setCost ( uint _cost ) onlyOwner public { cost = _cost ; },Admin function to set the price of submitting a location
1969,"function mintToken ( uint256 mintedAmount ) onlyOwner public { uint256 mintSupply = mintedAmount . mul ( 10 ** uint256 ( decimals ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( mintSupply ) ; totalSupply = totalSupply . add ( mintSupply ) ; emit Transfer ( 0 , this , mintSupply ) ; emit Transfer ( this , msg . sender , mintSupply ) ; }",Create ` mintedAmount ` tokens and send it to ` msg.sender `
1970,function reclaim ( IBasicToken token ) public { require ( token != ASSET_TOKEN ) ; Reclaimable . reclaim ( token ) ; },allows LockedAccount to reclaim tokens wrongly sent to its address
1971,"function burnToken ( address target , uint256 burnAmount ) onlyOwner public { require ( balanceOf [ target ] >= burnAmount ) ; balanceOf [ target ] -= burnAmount ; totalSupply -= burnAmount ; emit Burn ( target , burnAmount ) ; }",Burn ` burnAmount ` tokens for ` target `
1972,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( _from ) ; payDividendsTo ( _to ) ; return super . transferFrom ( _from , _to , _value ) ; }",hook on standard ERC20 # transferFrom to pay dividends
1973,function getAccountBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getStakeBalance ( memberAddress ) + getRewardBalance ( memberAddress ) ; },Called to obtain the account balance of any given member
1974,"function addNFToken ( address _to , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; idToOwner [ _tokenId ] = _to ; ownerToNFTokenCount [ _to ] = ownerToNFTokenCount [ _to ] . add ( 1 ) ; }",Use and override this function with caution .
1975,"function createPromoCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } if ( allNFTs . length > 0 ) { promoCreatedCount [ _teamId ] ++ ; } uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }",The generation of an asset if limited via the generationSeasonController
1977,"function withdrawTokens ( uint index , uint _amount ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; airdrop . tokenSC . transfer ( owner , _amount ) ; }",Distirbutes a constant quantity of tokens to all the specified addresses .
1979,"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryId , uint256 minimumRequiredStake , uint256 jurisdictionFee ) ;",Get comprehensive information on an attribute type with ID ` attributeTypeID ` .
1980,function setRelayer ( address _newRelayer ) onlyOwner external { relayer = _newRelayer ; },Change the relayer to a new address .
1983,"function getUserContracts ( address _account ) public view returns ( address [ ] _users ) { _users = store . get ( ownedUsersStorage , bytes32 ( _account ) ) ; }",Gets a list of contracts that are associated with provided user
1984,function changeOwner ( address _owner ) public onlyOwner returns ( bool ) { ChangeOwnerTo ( _owner ) ; newOwner = _owner ; return true ; },Initiate a change of owner to ` _owner `
1985,"function initialize ( address _baseAcl , address _permissionsCreator ) onlyInit public { initialized ( ) ; IACL acl = IACL ( newAppProxy ( this , ACL_APP_ID ) ) ; _setApp ( APP_BASES_NAMESPACE , ACL_APP_ID , _baseAcl ) ; _setApp ( APP_ADDR_NAMESPACE , ACL_APP_ID , acl ) ; acl . initialize ( _permissionsCreator ) ; }",Initializes a kernel instance along with its ACL and sets ` _permissionsCreator ` as the entity that can create other permissions
1986,"function tokenFallback ( address from , uint amount , bytes data ) external onlySynth returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = smallDeposits [ from ] . add ( amount ) ; emit SynthDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = synthDeposit ( { user : from , amount : amount } ) ; emit SynthDeposit ( from , amount , depositEndIndex ) ; depositEndIndex = depositEndIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . add ( amount ) ; } }","Triggers when users send us SNX or sUSD , but the modifier only allows sUSD calls to proceed ."
1987,"function addAddressesToWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , ""Cannot add an empty list to whitelist!"" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; require ( user != address ( 0 ) , ""Cannot add the zero address to whitelist!"" ) ; if ( ! whitelist [ user ] ) { whitelist [ user ] = true ; emit WhitelistAdded ( user ) ; } } }",Adds a list of addresses to the whitelist .
1988,"function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; if ( bytes ( idToUri [ _tokenId ] ) . length != 0 ) { delete idToUri [ _tokenId ] ; } }",This is a internal function which should be called from user-implemented external burn function .
1989,"function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , _to , _amount , _userData , msg . sender , """" , true ) ; }",Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
1993,function getApproved ( uint256 _tokenId ) public view validNFToken ( _tokenId ) returns ( address ) { return idToApprovals [ _tokenId ] ; },Throws if ` _tokenId ` is not a valid NFT .
1994,"function generateTokens ( address _owner , uint _amount ) returns ( bool ) ;",Generates ` _amount ` tokens that are assigned to ` _owner `
1996,function availableSynthCount ( ) public view returns ( uint ) { return availableSynths . length ; },"Returns the count of available synths in the system , which you can use to iterate availableSynths"
1999,function getOrdersForNotary ( address notary ) public view validAddress ( notary ) returns ( address [ ] ) { return ordersByNotary [ notary ] ; },Gets all the data orders associated with a notary .
2000,function claimTokens ( ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { return proxyClaimTokens ( msg . sender ) ; },Claim auction tokens for ` msg.sender ` after the auction has ended .
2001,"function updateDarknodeDeregisteredAt ( address darknodeID , uint256 deregisteredAt ) external onlyOwner { darknodeRegistry [ darknodeID ] . deregisteredAt = deregisteredAt ; }",Updates the deregistration timestamp of a darknode .
2002,"function addOwnToken ( ) onlyOwner public returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }",Allow the dev to set it 's own token as accepted payment .
2003,function refundAddress ( address _address ) public isAdmin isAdminRefundable userHasFundedPool ( _address ) { processRefundInternal ( _address ) ; },Refund a given address for all the Ether they have contributed .
2005,function pause ( ) public onlyCLevel whenNotPaused { paused = true ; emit Paused ( ) ; },"called by any C-level to pause , triggers stopped state"
2007,"function settle ( address _receiver_address , uint32 _open_block_number ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( closing_requests [ key ] . settle_block_number > 0 ) ; require ( block . number > closing_requests [ key ] . settle_block_number ) ; settleChannel ( msg . sender , _receiver_address , _open_block_number , closing_requests [ key ] . closing_balance ) ; }","Function called by the sender after the challenge period has ended , in order to settle and delete the channel , in case the receiver has not closed the channel himself ."
2010,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
2014,"function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( exchanges [ exchangeIndex ] . exchangeAdapter . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }",See adapter contracts for parameters needed for each exchange
2017,"function proposeAssignProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 toPledge = findOrCreatePledge ( p . owner , p . delegationChain , idReceiver , uint64 ( getTime ( ) + maxCommitTime ( p ) ) , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }",` proposeAssignProject ` proposes the assignment of a pledge to a specific project .
2019,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
2020,"function buyout ( uint256 _deedId ) external payable whenNotPaused { buyoutWithData ( _deedId , """" , """" , """" , """" ) ; }",Buy the current owner out of the plot .
2022,"function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }",Removes a pairs of addresses from manual approvals
2026,"function reclaimExpiredSwap ( bytes32 msigId , bytes32 swapId ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; require ( msigId == atomicswaps [ swapId ] . msigId ) ; require ( now >= atomicswaps [ swapId ] . expirationTime ) ; uint amount = atomicswaps [ swapId ] . amount ; delete atomicswaps [ swapId ] ; multisigs [ msigId ] . deposit = add ( multisigs [ msigId ] . deposit , amount ) ; }","Reclaim an expired , non-empty swap into a multisig"
2027,"function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) public onlyProxy returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _from , _to ) ; bool _isTransferFromHolderToContractOwner = ( _fromRole == Roles . Holder ) && ( contractOwner == _to ) && ( dataController . allowance ( _from ) >= _value ) && super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ; if ( _isTransferFromHolderToContractOwner ) { return true ; } if ( ! _checkTransferAllowanceFrom ( _to , _toRole , _value , _from , _fromRole , _sender ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _from , _fromRole ) ) { return false ; } if ( ! super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _from , _fromRole ) ; _contractFallbackERC223 ( _from , _to , _value ) ; return true ; }",Performs allowance transfer call on the platform by the name of specified sender .
2028,"function resumeWhitelist ( ) public onlyAdmin returns ( bool ) { paused = false ; Resumed ( msg . sender , now ) ; return true ; }",resumes the whitelist if there is any issue
2030,"function pruneInvestors ( uint256 _start , uint256 _iters ) external ;",Removes addresses with zero balances from the investors list
2031,"function approve ( address spender , uint tokens ) public returns ( bool success ) ;",` msg.sender ` approves ` spender ` to spend ` tokens ` tokens
2032,function setRateStalePeriod ( uint _time ) external onlyOwner { rateStalePeriod = _time ; emit RateStalePeriodUpdated ( rateStalePeriod ) ; },Set the stale period on the updated rate variables
2033,function begin ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . next ; },Get the node at the beginning of a double linked list .
2034,"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",Assign allowance _value to _spender address to use the msg.sender balance
2036,"function doPurchase ( uint256 _usd , uint256 _eth , uint256 _btc , address _address , uint256 _vestingEnds ) internal isActive returns ( uint256 ) { require ( _usd >= 10 ) ; uint256 soldAmount = computeTokens ( _usd ) ; updateStats ( _usd , soldAmount ) ; grantVestedTokens ( _address , soldAmount , vestingStarts , _vestingEnds ) ; NewBuyer ( _address , soldAmount , _usd , _eth , _btc ) ; return soldAmount ; }",The owner of this contract is the owner of token 's contract
2037,function isOpen ( ) public view returns ( bool ) { if ( isFinalized ) return false ; if ( now < startTime ) return false ; if ( now >= endTime ) return false ; if ( capReached ( ) ) return false ; return true ; },This function returns whether or not the STO is in fundraising mode ( open )
2042,function isRefunding ( ) public constant returns ( bool ) { return ( state == State . Refunding ) ; },To allow ICO contracts to check whether RefundVault is ready to refund investors
2043,"function withdraw ( ) external { uint256 bal = balanceOf [ msg . sender ] ; require ( bal > 0 , ""Balance must be positive"" ) ; balanceTotal = balanceTotal . sub ( bal ) ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( bal ) ; emit LogWithdraw ( msg . sender , bal ) ; assert ( address ( this ) . balance >= balanceTotal ) ; }",Withdraw the address balance to the owner account
2044,"function mintTokens ( address _owner , uint _amount ) public onlyController notFinalized returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Mint ` _amount ` tokens that are assigned to ` _owner `
2046,function setbuyPrice ( uint256 newBuyPrice ) onlyOwner public { require ( newBuyPrice > 0 ) ; buyPrice = newBuyPrice ; },Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
2048,"function ( ) public payable isValidated notClosed notPaused { require ( msg . value > 0 ) ; doBuy ( msg . sender , msg . value ) ; }",This function fires when someone sends Ether to the address of this contract .
2052,"function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( _deedId < 1000000 ) ; uri = ""https://meta.quazr.io/card/xxxxxxx"" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 7 ; i ++ ) { _uri [ 33 - i ] = byte ( 48 + ( _deedId / 10 ** i ) % 10 ) ; } }",Returns an ( off-chain ) metadata url for the given deed .
2053,"function claimTokens ( ) respectTimeFrame registeredUser isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( gmtFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimGMT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }",Create ` msg.value ` ETH worth of GMT
2054,"function cancelTask ( uint uuid ) public onlyCurator { communityAccount . setTotalTaskEscrow ( SafeMath . sub ( communityAccount . totalTaskEscrow ( ) , communityAccount . escrowedTaskBalances ( uuid ) ) ) ; communityAccount . setEscrowedTaskBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""cancelTask"" , """" ) ; }",Subtracts the tasks escrow and sets tasks escrow balance to 0
2055,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` msg.sender `
2056,"function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : false , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }",Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
2058,"function get_Sponsored_Amount_in_Job_By_Address ( uint _JobID , address _sponsor ) public view returns ( uint ) { require ( _JobID >= 0 ) ; require ( _sponsor != 0x0 ) ; Job storage job = Jobs [ _JobID ] ; return job . sponsors [ _sponsor ] ; }",this function lets get an amount of sponsored DAI by an address in a given job
2059,function unpause ( ) public onlyManager whenPaused { paused = false ; },This is public rather than external so it can be called by derived contracts .
2061,"function isNotaryVeredictValid ( address order , address seller , address notary , bool wasAudited , bool isDataValid , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , seller , wasAudited , isDataValid ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }",Checks if the notary 's signature to close the ` DataResponse ` is valid .
2062,"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; require ( token . transfer ( owner , refund ) ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
2063,"function paybackContribution ( uint i ) payable onlyAdmin { address memberRefunded = members [ i ] . member ; if ( memberRefunded == 0 ) throw ; uint amountTokens = msg . value ; if ( vips [ memberRefunded ] ) { amountTokens += amountTokens / 3 ; remainingTokensVIPs += amountTokens ; } if ( amountTokens > balances [ memberRefunded ] ) throw ; balances [ memberRefunded ] -= amountTokens ; totalTokens -= amountTokens ; if ( balances [ memberRefunded ] == 0 ) { delete members [ i ] ; vips [ memberRefunded ] = false ; indexMembers [ memberRefunded ] = 0 ; } if ( ! memberRefunded . send ( msg . value ) ) { failingRefund ( memberRefunded , msg . value ) ; } Refund ( memberRefunded , msg . value ) ; }",Pay back the ether contributed to the DAO
2064,"function fulfillQuery ( uint256 id ) private returns ( bool ) { Status status = Status ( getStatus ( id ) ) ; require ( status != Status . Fulfilled , ""Error: Status already fulfilled"" ) ; address subscriber = getSubscriber ( id ) ; address provider = getProvider ( id ) ; bytes32 endpoint = getEndpoint ( id ) ; if ( status == Status . Canceled ) { uint256 canceled = getCancel ( id ) ; require ( block . number == canceled , ""Error: Cancel ignored"" ) ; setCanceled ( id , false ) ; bondage . escrowDots ( subscriber , provider , endpoint , 1 ) ; emit RevertCancelation ( id , subscriber , provider ) ; } setFulfilled ( id ) ; bondage . releaseDots ( subscriber , provider , endpoint , 1 ) ; emit FulfillQuery ( subscriber , provider , endpoint ) ; return true ; }",Transfer dots from Bondage escrow to data provider 's Holder object under its own address
2065,"function destroyBlacklistedTokens ( address _who , uint256 _amount ) public userBlacklisted ( _who ) whenNotPaused requiresPermission { tokenStorage . subBalance ( _who , _amount ) ; tokenStorage . subTotalSupply ( _amount ) ; emit DestroyedBlacklistedTokens ( _who , _amount ) ; }",Destroy the tokens owned by a blacklisted account .
2066,"function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; emit LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }",Add funds to the bounty for a question
2067,function addAdmin ( address _newAdmin ) public onlyOwner { admins [ _newAdmin ] = true ; },The owner is able to add new admin
2068,function getCanvasPainters ( uint32 _canvasId ) external view returns ( address [ ] ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; address [ ] memory result = new address [ ] ( PIXEL_COUNT ) ; for ( uint32 i = 0 ; i < PIXEL_COUNT ; i ++ ) { result [ i ] = canvas . pixels [ i ] . painter ; } return result ; },Returns array of all the owners of all of pixels .
2070,function intervalOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . interval ; },The renewal interval of a product in seconds
2071,"function removeAttributeFor ( address account , uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , ""only jurisdiction or issuing validator may remove a restricted attribute"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . operator == msg . sender , ""only an assigning operator may remove attribute on behalf of an address"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( msg . sender . send ( stake ) ) { emit StakeRefunded ( msg . sender , attributeTypeID , stake ) ; } } }",Remove an attribute of the type with ID ` attributeTypeID ` from account of ` account ` .
2072,"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonus = calculateBonus ( _tokenAmount , assignedBonusRates [ _beneficiary ] ) ; require ( totalTokensSold . add ( _tokenAmount ) . add ( bonus ) <= totalSaleAllocation ) ; assignBonus ( _beneficiary , bonus ) ; totalTokensSold = totalTokensSold . add ( _tokenAmount ) . add ( bonus ) ; super . _processPurchase ( _beneficiary , _tokenAmount ) ; }",This function is automatically called when a contribution request passes all validations .
2073,"function approveBreeding ( address _addr , uint40 _dadId ) public whenNotPaused { require ( _isOwner ( msg . sender , _dadId ) ) ; sireAllowedToAddress [ _dadId ] = _addr ; emit BreedingApproval ( msg . sender , _addr , _dadId ) ; }",Grants approval to another user to sire with one of your Cuties .
2074,"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }",use to check the permission on delegate corresponds to module contract address
2077,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = dogIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given Dog .
2078,"function approve ( address _to , uint256 _deedId ) external ;","Approve a new owner to take your deed , or revoke approval by setting the zero address ."
2080,"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
2081,function takeOwnership ( uint256 _deedId ) external payable ;,Become owner of a deed for which you are currently approved
2082,"function calculateSettlementDetails ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : priorityVwF . value , rightVolume : secondaryVwF . value , leftTokenFee : priorityVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; }",Calculates the details required to execute two matched orders .
2084,"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , loan . amount ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , transferValue ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender ."
2089,function changeCap ( uint256 _cap ) public onlyOwner { if ( _cap < minimumCap ) revert ( ) ; if ( _cap <= totalRaised ) revert ( ) ; hardCap = _cap ; if ( totalRaised + minimumInvestment >= hardCap ) { isCapReached = true ; doFinalizeSale ( ) ; } },change hard cap and if it reaches hard cap finalize sale
2090,"function acceptOwnership ( ) external { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; emit OwnershipTransferred ( oldOwner , owner ) ; }","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership"
2092,"function getPlayerInstWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( ( ( teams_ [ _gameID ] [ _team ] . mask ) . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) ) / ( 1000000000000000000 ) ) . sub ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . mask ) ) ; }",Get a player 's current instant pot winnings .
2093,"function getTokenDataByIndex ( uint64 _tokenIndex ) public view returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { require ( _tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ _tokenIndex ] ; TokenLookup storage lookupData = tokenLookup [ pixelcon . tokenId ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }",Get all details of PixelCon # ` ( _tokenIndex ) `
2094,"function isSpecificallyApprovedFor ( address _asker , uint256 _tokenId ) internal view returns ( bool ) { return getApproved ( _tokenId ) == _asker ; }",Tells whether the msg.sender is approved for the given token ID or not
2096,"function boom ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , ""Transfer did not work"" ) ; selfdestruct ( msg . sender ) ; }",Extract balance in ETH + SNT from the contract and destroy the contract
2099,"function withdraw ( uint256 _amount , address _destination ) public onlyOwner { require ( _destination != address ( 0 ) ) ; require ( _amount <= this . balance ) ; _destination . transfer ( _amount == 0 ? this . balance : _amount ) ; }","Proceeds are paid out right away , but the contract might receive unexpected funds"
2100,"function approve ( address _approved , uint256 _tokenId ) canOperate ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( _approved != tokenOwner , ""approved address cannot be owner of the token"" ) ; nft [ _tokenId ] . approval = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }",The zero address indicates there is no approved address .
2101,function name ( ) external view returns ( string ) { return _name ; },A descriptive name for a collection of NFTs in this contract
2102,"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by transferFromPreSigned
2103,"function adjustBalanceCheckpoints ( address _investor ) internal { adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) ) ; }",adjust token holder balance at checkpoint after a token transfer
2105,"function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , ""Mortgage not ongoing"" ) ; require ( mortgage . loanId == loanId , ""Mortgage don't match loan id"" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , ""Sender not authorized"" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , ""Sender not lender"" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( ""Mortgage not defaulted/paid"" ) ; } delete mortgageByLandId [ mortgage . landId ] ; return true ; }",Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds .
2106,"function depositNomins ( uint amount ) external { nomin . transferFrom ( msg . sender , this , amount ) ; }",depositNomins : Allows users to deposit nomins via the approve / transferFrom workflow if they 'd like .
2107,"function liabilityFinalized ( ILiability _liability , uint256 _start_gas ) external returns ( bool ) ;",This method is for lighthouse contract use only
2108,"function sell ( uint256 amount ) public returns ( uint256 revenue ) { uint256 a = 0 ; require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= amount ) ; a = _totalSupply - amount ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * _totalSupply / SU ) , 1e5 ) ; p = ( S * p ) >> ps ; uint256 p2 = 0 ; uint8 ps2 = 0 ; ( p2 , ps2 ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * a / SU ) , 1e5 ) ; p2 = ( S * p2 ) >> ps2 ; revenue = ( SU * p - SU * p2 ) * R / S ; _totalSupply -= amount ; require ( balances [ reserveAddress ] >= revenue ) ; balances [ reserveAddress ] -= revenue ; balances [ msg . sender ] -= amount ; Contract reserve = Contract ( reserveAddress ) ; reserve . sendFunds ( msg . sender , revenue ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; quoteAsk ( ) ; quoteBid ( ) ; return revenue ; }","Sells aToken in exchnage for wei at the current bid price , reduces resreve"
2110,"function setConverterRamp ( address _converterRamp ) external onlyOwner returns ( bool ) { emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }",Sets a new converter ramp to delegate the pay of the loan
2112,"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
2113,"function setTokenPrice ( uint week , uint price , uint price5 , uint price10 ) public onlyOwner { require ( crowdsaleClosed == false ) ; require ( week >= 1 && week <= 3 ) ; if ( week == 1 ) price1stWeek = [ price , price5 , price10 ] ; else if ( week == 2 ) price2ndWeek = [ price , price5 , price10 ] ; else if ( week == 3 ) price3rdWeek = [ price , price5 , price10 ] ; }",Function to define prices for some particular week .
2118,"function getFeeMax ( Data storage self , address contractAddress ) internal view returns ( uint feeMax ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }",Get the maximum fee of the contract address ; typically TokenIOFeeContract
2119,"function getAmount ( uint _price , address _trader ) public constant returns ( uint ) ;",Returns the order amount for trader ` _trader ` at '_price '
2120,"function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) return ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) return ; if ( now < p . earliestPayTime ) return ; if ( p . canceled ) return ; if ( p . paid ) return ; if ( this . balance < p . amount ) return ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { return ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }",only ` allowedSpenders [ ] ` The recipient of a payment calls this function to send themselves the ether after the ` earliestPayTime ` has expired
2123,function setAdmin ( address _newAdmin ) external onlyOwner { admin = _newAdmin ; },"Change the address of the admin , who has the privilege to create new accounts"
2124,"function getTokenTLA ( Data storage self , address contractAddress ) internal view returns ( string tokenTLA ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }",Get the token Three letter abbreviation ( TLA ) for Token interfaces
2125,function created ( ) public constant returns ( uint256 timestamp ) { },the block number that the campaign was created
2128,"function tokenURI ( uint256 _tokenId ) external view returns ( string _tokenURI ) { _tokenURI = ""https://corsarium.playdarkwinds.com/cards/00000.json"" ; bytes memory tokenUriBytes = bytes ( _tokenURI ) ; tokenUriBytes [ 33 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10000 ) % 10 ) ; tokenUriBytes [ 34 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1000 ) % 10 ) ; tokenUriBytes [ 35 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 100 ) % 10 ) ; tokenUriBytes [ 36 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10 ) % 10 ) ; tokenUriBytes [ 37 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1 ) % 10 ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
2131,"function _burn ( address _owner , uint256 _tokenId ) internal { assert ( tokens . length > 0 ) ; super . _burn ( _owner , _tokenId ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens [ lastTokenIndex ] = 0 ; tokens . length -- ; idToIndex [ _tokenId ] = 0 ; idToIndex [ lastToken ] = tokenIndex ; }",This is a private function which should be called from user-implemented external burn function .
2132,function claimToken ( ) public afterSaleSuccess { claimTokenFor ( msg . sender ) ; },Claim token for msg.sender after token sale based on stake .
2133,"function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) public view returns ( address [ ] ) { uint256 _len = getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) . length ; address [ ] memory _addressList = getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) ; bool _isCustomModuleAllowed = IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < _len ; i ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ i ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( ""verified"" , _addressList [ i ] ) ) ) if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } else if ( getBool ( Encoder . getKey ( ""verified"" , _addressList [ i ] ) ) ) { if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } } address [ ] memory _tempArray = new address [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < _len ; j ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ j ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( ""verified"" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } else if ( getBool ( Encoder . getKey ( ""verified"" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } return _tempArray ; }",Returns the list of available Module factory addresses of a particular type for a given token .
2135,"function getBidDetails ( address _addr ) external view returns ( uint , uint ) { return ( _bidders [ _addr ] . value , _bidders [ _addr ] . lastTime ) ; }",Returns the value of ` ( _addr ) ` 's bid and the time it occurred
2136,"function endAuction ( ) public onlyHighestBidderOrEscrow { require ( now >= auctionEnd , ""Auction not yet ended."" ) ; require ( auctionState != AuctionStates . Ended , ""Auction has already ended."" ) ; auctionState = AuctionStates . Ended ; emit AuctionEnded ( highestBidder , bids [ highestBidder ] ) ; if ( ! beneficiary . send ( bids [ highestBidder ] ) ) { } }",Ends the auction and sends the ` bids [ highestBidder ] ` to ` beneficiary `
2138,function validateProposedMonarchName ( string _monarchName ) constant returns ( bool allowed ) { return validateNameInternal ( _monarchName ) ; },Check if a name can be used as a monarch name .
2139,function removeAttributeType ( uint256 ID ) external ;,Remove the attribute type with ID ` ID ` from the jurisdiction .
2140,function unpack ( uint24 _packedVersion ) internal pure returns ( uint8 [ ] ) { uint8 [ ] memory _unpackVersion = new uint8 [ ] ( 3 ) ; _unpackVersion [ 0 ] = uint8 ( _packedVersion >> 16 ) ; _unpackVersion [ 1 ] = uint8 ( _packedVersion >> 8 ) ; _unpackVersion [ 2 ] = uint8 ( _packedVersion ) ; return _unpackVersion ; },Used to convert packed data into uint8 array
2141,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS , ""answerer must be provided"" ) ; emit LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }","Submit the answer for a question , for use by the arbitrator ."
2142,"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { require ( token . transfer ( prop . owner , prop . deposit ) ) ; } else { revert ( ) ; } delete proposals [ _propID ] ; }","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed"
2143,function replaceSelf ( address new_addr ) external { uint256 idx = _firstRecipientIndex ( msg . sender ) ; assert ( recipients [ idx ] == msg . sender ) ; recipients [ idx ] = new_addr ; },Replace your own address with a different one
2144,"function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) { uint counter = 0 ; bytes32 [ ] memory tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , _owner ) ) ; for ( uint i = 0 ; i < tickers . length ; i ++ ) { string memory ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { counter ++ ; } } bytes32 [ ] memory tempList = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < tickers . length ; i ++ ) { ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { tempList [ counter ] = tickers [ i ] ; counter ++ ; } } return tempList ; }",Returns the list of tickers owned by the selected address
2146,"function transferFrom ( address from , address to , uint value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }",This function is disabled during the funding .
2147,"function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner { require ( _target != 0x0 ) ; balanceOf [ _target ] += _mintedAmount ; totalSupply += _mintedAmount ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }",Create ` _mintedAmount ` tokens and send it to ` _target `
2149,"function _addTeamSale ( uint256 [ 9 ] _tokenIds , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( nonFungibleContract . exists ( _tokenIds [ ii ] ) ) ; tokenIdToSale [ _tokenIds [ ii ] ] = _sale ; } emit TeamSaleCreated ( _tokenIds , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }",Adds an sale to the list of open sales .
2151,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }",Send `` _value '' tokens to `` _to '' from `` msg.sender '' .
2156,"function addCustomSecurityToken ( string _name , string _symbol , address _owner , address _securityToken , string _tokenDetails , bytes32 _swarmHash ) public onlyOwner whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , ""Name and Symbol string length should be greater than 0"" ) ; string memory symbol = upper ( _symbol ) ; require ( _securityToken != address ( 0 ) && symbols [ symbol ] == address ( 0 ) , ""Symbol is already at the polymath network or entered security token address is 0x"" ) ; require ( _owner != address ( 0 ) ) ; require ( ! ( ITickerRegistry ( tickerRegistry ) . isReserved ( symbol , _owner , _name , _swarmHash ) ) , ""Trying to use non-valid symbol"" ) ; symbols [ symbol ] = _securityToken ; securityTokens [ _securityToken ] = SecurityTokenData ( symbol , _tokenDetails ) ; emit LogAddCustomSecurityToken ( _name , symbol , _securityToken , now ) ; }",Add a new custom ( Token should follow the ISecurityToken interface ) Security Token and saves it to the registry
2157,function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { uint missing_funds = missingFundsToEndAuction ( ) ; require ( missing_funds == 0 ) ; final_price = token_multiplier * received_wei / num_tokens_auctioned ; end_time = now ; stage = Stages . AuctionEnded ; AuctionEnded ( final_price ) ; assert ( final_price > 0 ) ; },Finalize the auction - sets the final RDN token price and changes the auction stage after no bids are allowed anymore .
2158,"function removeAt ( MapStorage storage self , uint index ) public returns ( bool ) { return remove ( self , self . addresses [ index ] ) ; }",Removes the given index from the storage .
2159,"function takeOwnership ( uint256 _tokenId ) external whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }",Claims the ownership of a given token ID
2160,"function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , bytes32 _name ) external withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , _token , _amount , excluded , _name ) ; }",Creates a dividend and checkpoint for the dividend
2161,"function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused payable returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; require ( getBreedingFee ( _momId , _dadId ) <= msg . value ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }","Breed cuties that you own , or for which you have previously been given Breeding approval ."
2164,"function increaseBalance ( address _user , uint256 _value ) public onlyAllowed { if ( userExists [ _user ] == false ) { users . push ( _user ) ; userExists [ _user ] = true ; } balanceUsers [ _user ] += _value ; }",Increases balance of a user This function can only be called by the registered Advertisement contract and increases the balance of a specific user on this contract .
2165,"function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , ""ValidFrom is too early"" ) ; require ( _validTo >= now , ""ValidTo is too late"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo ) ) ; checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }",adds or removes addresses from the whitelist - can be called by anyone with a valid signature
2166,"function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , ""Approval already exists"" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }",Adds a pair of addresses to manual approvals
2168,"function gasExchange ( address gasRecipient , uint256 amountEurUlps , uint256 exchangeFeeFraction ) public ;",will exchange amountEurUlps of gasRecipient balance into ether
2171,function calculateTheEndPrice ( uint256 howManyTokenToBuy ) constant returns ( uint256 summarizedPriceInWeis ) { if ( howManyTokenToBuy > 0 ) { summarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice ; } else { summarizedPriceInWeis = 0 ; } },Calculates amount of weis needed to buy more than one token
2172,"function transferGIM ( address _from , address _to , uint256 _amount ) returns ( bool success ) { require ( msg . sender == streamerContract ) ; require ( tx . origin == _from ) ; require ( _amount <= streamerContractMaxAmount ) ; if ( balances [ _from ] < _amount || _amount <= 0 ) return false ; balances [ _from ] = safeSub ( balances [ _from ] , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; }",Called by a Gimli contract to transfer GIM
2173,"function approve ( address _spender , uint _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
2174,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = TRANSFER_APPROVAL ; return allPermissions ; },Returns the permissions flag that are associated with ManualApproval transfer manager
2175,"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
2177,"function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }",returns additional amount of neumarks issued for euroUlps at totalEuroUlps
2178,"function resignFromMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; board . isHonorableLoss = true ; playerLost ( board , boardId , activeColor ) ; }","Resigns a player from a specific board , can get called by either player on the board ."
2179,"function addDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = _createHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , true ) ; _emitter ( ) . emitOwnershipChange ( 0x0 , _manager , _symbol ) ; return OK ; }",Adds a asset manager for an asset with provided symbol .
2182,"function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; return true ; }",Issues a specified account to recipient account of a given currency
2187,"function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }","Returns holder id for the specified address , creates it if needed ."
2190,function getValidatorSigningKey ( address validator ) external view returns ( address signingKey ) { return _validators [ validator ] . signingKey ; },Get the signing key of the validator at account ` validator ` .
2192,"function getModulesByType ( uint8 _moduleType ) public view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) ; }",Returns the list of addresses of Module Factory of a particular type
2193,"function getNextVestingEntry ( address account ) public view returns ( uint [ 2 ] ) { uint index = getNextVestingIndex ( account ) ; if ( index == numVestingEntries ( account ) ) { return [ uint ( 0 ) , 0 ] ; } return getVestingScheduleEntry ( account , index ) ; }",Obtain the next schedule entry that will vest for a given user .
2194,function currentPrice ( uint256 _deedId ) public view returns ( uint256 price ) { address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ _deedId ] ; if ( currentOwner == 0x0 ) { price = gameSettings . unclaimedTilePrice ; } else { price = gameStates [ gameIndex ] . identifierToBuyoutPrice [ _deedId ] ; } },Get the price for the given tile .
2195,"function setUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , ""Permission being set must be for a valid method signature"" ) ; userPermissions [ _who ] [ _methodsignature ] = true ; }",Sets a permission in the list of permissions that a user has .
2197,"function getIntel ( uint intelIndex ) public view returns ( address intelProvider , uint depositAmount , uint desiredReward , uint balance , uint intelID , uint rewardAfter , bool rewarded ) { IntelState storage intel = intelDB [ intelIndex ] ; intelProvider = intel . intelProvider ; depositAmount = intel . depositAmount ; desiredReward = intel . desiredReward ; balance = intel . balance ; rewardAfter = intel . rewardAfter ; intelID = intel . intelID ; rewarded = intel . rewarded ; }",this function provide the Intel based on its index
2198,"function _issueAttribute ( address account ) internal returns ( bool ) { _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; return true ; }",Issue an attribute of the type with the default ID to account ` account ` on the jurisdiction .
2199,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { token . mint ( target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
2200,"function registerPreSignedHashing ( address _investContract , bytes32 _strategyID , uint256 _registerFee , uint256 _periodLength , uint256 _maxMarginDeposit , uint256 _minMarginDeposit , uint256 _rewardPercentage , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7fa5aa9d ) , _investContract , _strategyID , _registerFee , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by registerTradeProfile
2202,"function votingEndsInHHMM ( ) constant returns ( uint16 , uint16 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint16 ( tsec / 1 hours ) , uint16 ( tsec % 1 hours / 1 minutes ) ) ; }","return voting remaining time ( hours , minutes ) ."
2203,function getModulesByType ( uint8 _type ) external view returns ( address [ ] ) { return modules [ _type ] ; },Returns a list of modules that match the provided module type
2204,function escapeHatch ( ) onlyEscapeCallerOrOwner { uint total = this . balance ; if ( ! escapeDestination . send ( total ) ) { throw ; } EscapeCalled ( total ) ; },The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
2205,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) external { }","Submit the answer for a question , for use by the arbitrator ."
2207,function getVersion ( ) external view returns ( uint8 [ ] ) ;,Used to get the version of the securityToken
2209,"function matchByAdmin_TwH36 ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 3 ] ; address user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; address token ; bool isBuy ; ( token , isBuy ) = decodeOrderTokenAndIsBuy ( data ) ; bytes32 orderHash = keccak256 ( this , inputs [ 0 ] , inputs [ 1 ] , inputs [ 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( orderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 etherExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; data = inputs [ i + 3 ] ; user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = keccak256 ( this , inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( makerOrderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , etherExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data , tokenExecute , etherExecute , isBuy , token , 0 , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , etherExecute , isBuy , token , 0 , orderHash ) ; }","match orders with admins involved , only admin"
2211,function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; buyNormal ( _th ) ; return true ; },This method will generally be called by the ATT token contract to acquire ATTs .
2213,"function isValidSignature ( address signer , bytes32 hash , uint8 v , bytes32 r , bytes32 s ) private pure returns ( bool ) { return signer == ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , hash ) ) , v , r , s ) ; }",Verifies that a hash signature is valid .
2214,"function release ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , ""Must be seller"" ) ; return doRelease ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }",Release ether in escrow to the buyer .
2215,"function onApprove ( address _owner , address _spender , uint _amount ) external returns ( bool ) ;",Notifies the controller about an approval allowing the controller to react if desired
2216,"function incApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . add ( _value ) ; return true ; }",Increase allowance of ` _spender ` in behalf of ` _from ` at ` _value `
2217,function ownerClawback ( ) external onlyOwner { require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; },"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract ."
2218,"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific Property via transferFrom ( ) .
2219,"function exchangeNominsForHavvensAtRate ( uint nominAmount , uint guaranteedRate ) public pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToHavPrice ) ; return exchangeNominsForHavvens ( nominAmount ) ; }",Exchange nUSD for Havvens while insisting on a particular rate .
2220,"function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external whenNotPausedOrOwner { require ( bytes ( _name ) . length > 0 && bytes ( _ticker ) . length > 0 , ""Ticker length > 0"" ) ; string memory ticker = Util . upper ( _ticker ) ; bytes32 statusKey = Encoder . getKey ( ""registeredTickers_status"" , ticker ) ; require ( ! getBool ( statusKey ) , ""Already deployed"" ) ; set ( statusKey , true ) ; require ( _tickerOwner ( ticker ) == msg . sender , ""Not authorised"" ) ; require ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now , ""Ticker gets expired"" ) ; uint256 launchFee = getSecurityTokenLaunchFee ( ) ; if ( launchFee > 0 ) require ( IERC20 ( getAddress ( POLYTOKEN ) ) . transferFrom ( msg . sender , address ( this ) , launchFee ) , ""Insufficient allowance"" ) ; address newSecurityTokenAddress = ISTFactory ( getSTFactoryAddress ( ) ) . deployToken ( _name , ticker , 18 , _tokenDetails , msg . sender , _divisible , getAddress ( POLYMATHREGISTRY ) ) ; _storeSecurityTokenData ( newSecurityTokenAddress , ticker , _tokenDetails , now ) ; set ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) , newSecurityTokenAddress ) ; emit NewSecurityToken ( ticker , _name , newSecurityTokenAddress , msg . sender , now , msg . sender , false , launchFee ) ; }",Deploys an instance of a new Security Token and records it to the registry
2223,"function verifyTokens ( uint64 _buyTokens , uint64 _sellToken ) internal pure returns ( bool ) { return ( ( uint32 ( _buyTokens ) == uint32 ( _sellToken >> 32 ) ) && ( uint32 ( _sellToken ) == uint32 ( _buyTokens >> 32 ) ) && ( uint32 ( _buyTokens >> 32 ) <= uint32 ( _buyTokens ) ) ) ; }",Verifies that two token requirements can be matched and that the tokens are formatted correctly .
2224,function setPayoutDistributionId ( ) internal { uint24 [ 21 ] memory auxArr = PayoutDistribution . getDistribution ( tokens . length ) ; for ( uint256 i = 0 ; i < auxArr . length ; i ++ ) { payoutDistribution [ i ] = auxArr [ i ] ; } superiorQuota = PayoutDistribution . getSuperiorQuota ( tokens . length ) ; },"Sets the structures for payout distribution , last position and superior quota ."
2225,function exists ( uint64 _pixelconIndex ) public view returns ( bool ) { return ( marketPixelconListings [ _pixelconIndex ] . seller != address ( 0 ) ) ; },Check if a market listing exists for PixelCon # ` ( _pixelconIndex ) `
2230,"function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; _VotingRightsGranted ( _numTokens , msg . sender ) ; }",Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
2232,"function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }",Used to check the permission on delegate corresponds to module contract address
2234,function withdraw ( ) external returns ( bool ) { require ( _ended ) ; for ( uint i = 0 ; i < 100 ; ++ i ) { require ( _topBids [ i ] . bidderAddress != msg . sender ) ; } uint amount = _bidders [ msg . sender ] . value ; if ( amount > 0 ) { _bidders [ msg . sender ] . value = 0 ; msg . sender . transfer ( amount ) ; } return true ; },Withdraw your deposit at the end of the auction
2235,"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Distribution Failed: Coun Down not gone yet"" ) ; }",Distributes a constant quantity of tokens to all the specified addresses .
2236,"function deposit ( address _darknode , ERC20 _token , uint256 _value ) public payable { uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched ether value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether value"" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( msg . sender , address ( this ) , _value ) ; } darknodeBalances [ _darknode ] [ _token ] = darknodeBalances [ _darknode ] [ _token ] . add ( receivedValue ) ; }",Deposit fees into the vault for a Darknode .
2237,"function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ from ] ) ; require ( tokenAmount <= allowed [ from ] [ msg . sender ] ) ; balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }",Transfer tokens from an address to another one through an allowance made before
2238,"function _mintItem ( uint256 _classId , address _address ) internal { ItemClass storage class = classIdToClass [ _classId ] ; uint [ ] memory stats = new uint [ ] ( 6 ) ; for ( uint j = 0 ; j < class . statsMin . length ; j ++ ) { if ( class . statsMax [ j ] > 0 ) { if ( stats . length == class . statsMin . length ) { stats [ j ] = getRandom ( class . statsMin [ j ] , class . statsMax [ j ] , uint8 ( j + _classId + class . total ) , lastMinter ) ; } } else { if ( stats . length == class . statsMin . length ) { stats [ j ] = 0 ; } } } ItemData storage _itemData = tokenToData [ totalTokens + 1 ] ; _itemData . tokenId = totalTokens + 1 ; _itemData . classId = _classId ; _itemData . stats = stats ; _itemData . gen = currentGen ; class . total += 1 ; totalTokens += 1 ; _mint ( _address , totalTokens ) ; _setTokenURI ( totalTokens , addToString ( _baseURI , uint2str ( totalTokens ) ) ) ; lastMinter = _address ; emit ItemMinted ( class . classId , class . price , class . total , totalTokens ) ; }",All stats of the item are randomly generated by using the getRandom ( ) function using min and max values
2239,"function importIssuerData ( address [ ] accounts , uint [ ] sUSDAmounts ) external onlyOwner onlyDuringSetup { require ( accounts . length == sUSDAmounts . length , ""Length mismatch"" ) ; for ( uint8 i = 0 ; i < accounts . length ; i ++ ) { _addToDebtRegister ( accounts [ i ] , sUSDAmounts [ i ] ) ; } }",Import issuer data from the old Synthetix contract before multicurrency
2240,"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _data , _operatorData ) ; }",Helper function that checks for ERC777TokensSender on the sender and calls it .
2241,function tokenHardcapIssued ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapIssuedValue ; },Gets absolute issued hardcap volume which means it will be greater than softcap value .
2242,function calculateMint ( uint256 _stakeNumber ) internal view returns ( uint256 reward ) { uint256 currentBlock = calculateCurrentBlock ( _stakeNumber ) ; uint256 lastBlockWithdrawn = stakes [ msg . sender ] [ _stakeNumber ] . lastBlockWithdrawn ; uint256 blocksToReward = currentBlock . sub ( lastBlockWithdrawn ) ; reward = blocksToReward . mul ( stakes [ msg . sender ] [ _stakeNumber ] . rewardPerBlock ) ; uint256 totalToMint = stakes [ msg . sender ] [ _stakeNumber ] . totalCoinsToMint ; uint256 currentCoinsMinted = stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted ; uint256 newCoinsMinted = currentCoinsMinted . add ( reward ) ; if ( newCoinsMinted > totalToMint ) { reward = newCoinsMinted . sub ( totalToMint ) ; } },This is a helper function used to calculate how many coins will be awarded in a given internal
2243,function symbol ( ) external view returns ( string _symbol ) ;,An abbreviated name for NFTs in this contract
2245,"function broadcastSignedRequestAsPayerAction ( bytes _requestData , address [ ] _payeesPaymentAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , ""expiration should be after current time"" ) ; require ( Signature . checkRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , ""signature should be correct"" ) ; return createAcceptAndPayFromBytes ( _requestData , _payeesPaymentAddress , _payeeAmounts , _additionals ) ; }",Function to broadcast and accept an offchain signed request ( the broadcaster can also pays and makes additionals ) .
2246,"function buyPriceAt ( uint256 _tokenAllocWithoutDiscount ) internal returns ( uint ) { if ( stageNow ( ) == stageAt . publicSale ) { publicAllocatingToken = publicAllocatingToken . add ( _tokenAllocWithoutDiscount ) ; require ( publicAllocatingToken <= publicSaleSupply ) ; return _tokenAllocWithoutDiscount ; } if ( stageNow ( ) == stageAt . privatePresale ) { uint _privatePresaleAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 5 ) ; privatePresaleAllocatingToken = privatePresaleAllocatingToken . add ( _privatePresaleAlloc ) ; require ( privatePresaleAllocatingToken <= privatePresaleSupply ) ; return _privatePresaleAlloc ; } if ( stageNow ( ) == stageAt . privatePlacement ) { uint _privatePlacementAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 10 ) ; privatePlacementAllocatingToken = privatePlacementAllocatingToken . add ( _privatePlacementAlloc ) ; require ( privatePlacementAllocatingToken <= privatePlacementSupply ) ; return _privatePlacementAlloc ; } if ( stageNow ( ) == stageAt . notStart ) { return 0 ; } if ( stageNow ( ) == stageAt . finalState ) { return 0 ; } }",Calculate exchange : private Placement Stage : 10 % OFF private Presale Stage : 5 % OFF
2247,"function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) ;",Returns all the tags related to the a module type which are valid for the given token
2250,"function checkBalance ( address _backerAddress , uint index ) constant returns ( uint , uint , bytes32 , bool , bool ) { return ( backers [ _backerAddress ] [ index ] . tokenPrice , backers [ _backerAddress ] [ index ] . tokenAmount , backers [ _backerAddress ] [ index ] . privateHash , backers [ _backerAddress ] [ index ] . prepaid , backers [ _backerAddress ] [ index ] . claimed ) ; }",checking ` _backerAddress.address ( ) ` superDAO Token balance : ` index `
2251,"function batchTransferFrom ( address [ ] spenders , address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing requireSameLength ( spenders . length , recipients . length ) requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = spenders . length ; for ( uint i = 0 ; i < length ; i ++ ) { transferFrom ( spenders [ i ] , recipients [ i ] , quantities [ i ] ) ; } return true ; }","Performs ERC20 transferFroms in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from ` spenders [ i ] ` to ` recipients [ i ] ` if the sender is approved ."
2252,function trimAddressArray ( address [ 11 ] addresses ) internal pure returns ( address [ ] ) { uint256 length = 0 ; for ( uint256 index = 0 ; index < 11 ; index ++ ) { if ( addresses [ index ] == 0x0 ) { continue ; } length ++ ; } address [ ] memory trimmedArray = new address [ ] ( length ) ; for ( index = 0 ; index < length ; index ++ ) { trimmedArray [ index ] = addresses [ index ] ; } return trimmedArray ; },"Takes the static array , trims the excess and returns a dynamic array"
2254,"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) ;",Deploys the token and adds default modules like permission manager and transfer manager .
2255,function canRelease ( address who ) public view returns ( bool ) { Holding memory holding = heldTokens [ who ] ; if ( holding . releaseDate == 0 || holding . quantity == 0 ) return false ; return block . timestamp > holding . releaseDate ; },Check if a user 's holding are eligible for release .
2256,"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }",Claim the tokens owed for the msg.sender in the provided challenge
2257,function votedPerCent ( address voter ) constant public returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; },returns current voting result for given address in percent .
2259,"function createAccountForUser ( address _newUser ) internal nonZero ( _newUser ) { registry . createNewAccount ( _newUser ) ; uint256 _accountId = registry . accountIdForAddress ( _newUser ) ; emit AccountCreated ( _accountId , _newUser ) ; }",Create an account for a user and emit an event
2262,"function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } SNKToken token = SNKToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
2263,function ownerWithdraw ( uint256 value ) external onlyOwner { if ( ! owner . send ( value ) ) revert ( ) ; },"The owner can withdraw ethers already during Private Sale ,"
2265,"function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external ;",Changing versions does not affect existing tokens .
2266,function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) { return _attributeIDs ; },Get the IDs of all available attribute types on the jurisdiction .
2268,"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; require ( module . pricefeed . hasRecentPrice ( address ( request . requestAsset ) ) ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }","Executes active investment and redemption requests , in a way that minimises information advantages of investor"
2270,"function inject ( address who , address origin ) external only_owner { s_paid [ who ] . push ( origin ) ; Paid ( who , origin ) ; }","This method can only be called by the contract owner , and can be used to virtually create a new payment , by ` origin ` for ` who ` ."
2271,"function deposit ( address _user ) public payable isOpen depositIsConfigCompliant canDeposit ( _user ) { if ( ! invested [ _user ] ) { swimmersList . push ( _user ) ; invested [ _user ] = true ; } weiRaised = weiRaised . add ( msg . value ) ; swimmers [ _user ] = swimmers [ _user ] . add ( msg . value ) ; emit Deposit ( msg . sender , msg . value ) ; }",Deposit Ether where the contribution is credited to the address specified in the parameter .
2276,"function withdraw ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( getTime ( ) > userLock [ msg . sender ] && userLock [ msg . sender ] != 0 ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }","must claim by lockme first , after a period of time it would be valid"
2277,"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }",Get the remaining allowance for a spender on a given address
2278,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
2279,"function multiTransferTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeTransfer ( to , amount ) ; MultiTransfer ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }",Send to multiple addresses using a byte32 array which includes the address and the amount .
2282,"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
2283,function revealPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . revealEndDate ) && ! commitPeriodActive ( _pollID ) ; },Checks if the reveal period is still active for the specified poll
2284,function balanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; },Version of balanceOf ( ) which includes all frozen tokens .
2285,"function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , ""Self-destruct not yet initiated."" ) ; require ( selfDestructInitiationTime + SELFDESTRUCT_DELAY < now , ""Self-destruct delay has not yet elapsed."" ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }","If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address ."
2286,function transferAdminship ( address _newAdmin ) onlyAdmin public { admin = _newAdmin ; TransferAdminship ( admin ) ; },This function transfer the adminship of the contract to _newAdmin
2289,"function changeMinter ( address newMinter ) public validate_address ( newMinter ) onlyAdmin { if ( minter == newMinter ) revert ( ) ; MinterOwnershipTransferred ( minter , newMinter ) ; minter = newMinter ; }",only the admin is allowed to change the minter .
2290,"function onBurn ( address _owner , uint _tokensToBurn ) public returns ( bool ) { require ( msg . sender == address ( tokenContract ) ) ; uint256 feeTotal = tokenContract . totalPledgedFees ( ) ; uint256 totalTokens = tokenContract . totalSupply ( ) ; uint256 feeValueOfTokens = ( feeTotal . mul ( _tokensToBurn ) ) . div ( totalTokens ) ; require ( tokenContract . destroyTokens ( _owner , _tokensToBurn ) ) ; require ( this . balance >= feeValueOfTokens ) ; require ( _owner . send ( feeValueOfTokens ) ) ; LogClaim ( _owner , feeValueOfTokens ) ; return true ; }",Notifies the controller about a burn attempt .
2291,"function reissueAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { return reissueAssetToRecepient ( _symbol , _value , msg . sender ) ; }",Issues additional asset tokens if the asset have dynamic supply .
2292,function getModulesByType ( uint8 _moduleType ) external view returns ( address [ ] ) ;,Returns the list of addresses of Module Factory of a particular type
2293,function unlock ( ) public { unlockInvestor ( msg . sender ) ; },"unlocks investors funds , see unlockInvestor for details"
2295,"function sell ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract ."
2296,function burnAllTokens ( ) public onlyOwner mustBeAtStage ( Stage . Finalized ) { uint thisTokenBalance = token . balanceOf ( address ( this ) ) ; if ( thisTokenBalance > 0 ) { token . burn ( thisTokenBalance ) ; } },Get the token balance of this contract and burns all tokens
2297,function setMyICOContract ( address _SCICO ) public onlyOwner { addressSCICO = _SCICO ; },The owner can specify which ICO contract is allowed to transfer tokens while timelock is on
2298,"function approve ( address _spender , uint256 _amount ) stopOnPause public returns ( bool success ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }",gives ` _spender ` allowance to spend ` amount ` from sender 's balance .
2299,"function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalHurify = safeSub ( totalHurify , _value ) ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
2300,function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
2303,"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { require ( questions [ question_id ] . bond > 0 , ""Question must already have an answer when arbitration is requested"" ) ; questions [ question_id ] . is_pending_arbitration = true ; emit LogNotifyOfArbitrationRequest ( question_id , requester ) ; }","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision ."
2304,"function burn ( uint256 _value ) public onlyOwner returns ( bool success ) { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly"
2305,"function getForwardedAccount ( Data storage self , address account ) internal view returns ( address registeredAccount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , account ) ) ; address originalAccount = self . Storage . getAddress ( id ) ; if ( originalAccount != 0x0 ) { return originalAccount ; } else { return account ; } }",Get the original address for a forwarded account
2306,"function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit LogChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }",used to change the fee of the setup cost
2307,"function distribute ( uint256 _amount ) external onlyContract ( ""FeeManager"" ) returns ( bool ) { totalMintedActPerLockedBbkToken = totalMintedActPerLockedBbkToken . add ( _amount . mul ( 1e18 ) . div ( totalLockedBBK ) ) ; uint256 _delta = ( _amount . mul ( 1e18 ) % totalLockedBBK ) . div ( 1e18 ) ; mintedActFromPastLockPeriodsPerUser [ owner ] = mintedActFromPastLockPeriodsPerUser [ owner ] . add ( _delta ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; emit Mint ( _amount ) ; return true ; }","Distribute ACT tokens to all BBK token holders , that have currently locked their BBK tokens into this contract ."
2308,"function isRegisteredFirm ( Data storage self , string issuerFirm ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; return self . Storage . getBool ( id ) ; }",Return the boolean ( true/false ) registration status for an issuer firm
2309,"function buy_energy ( address aproducer , uint32 aday , uint32 aprice , uint64 aenergy ) onlyRegisteredConsumers external { buy_energy_core ( aproducer , aday , aprice , aenergy , consumers [ msg . sender ] , 0 ) ; }",Buy ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy on for day ` aday ` at a surcharge ` ( aprice / 1.0e3 ) .toFixed ( 3 ) ` ct/kWh from the energy producer using the address ` aproducer.address ( ) ` .
2310,"function giftAsset ( address _to , uint256 _tokenId ) public whenNotPaused { safeTransferFrom ( msg . sender , _to , _tokenId ) ; }",Transfers the ownership of NFT from one address to another address
2313,"function setIcosMinLimit ( uint256 newIcoMin , uint256 newPreIcoLimit ) isOwner { require ( newIcoMin > 0 ) ; require ( newPreIcoLimit > 0 ) ; icoMin = newIcoMin ; preIcoLimit = newPreIcoLimit ; updatePrices ( ) ; }",Set both ico min at the same time
2314,"function enableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) executorExists ( _executorId ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( ! executorEntry . enabled , ERROR_EXECUTOR_ENABLED ) ; executorEntry . enabled = true ; emit EnableExecutor ( _executorId , executorEntry . executor ) ; }",Enable script executor with ID ` _executorId `
2316,"function tokenFallback ( address from , uint amount , bytes data ) external onlyNomin returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = safeAdd ( smallDeposits [ from ] , amount ) ; emit NominDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = nominDeposit ( { user : from , amount : amount } ) ; depositEndIndex = safeAdd ( depositEndIndex , 1 ) ; totalSellableDeposits = safeAdd ( totalSellableDeposits , amount ) ; emit NominDeposit ( from , amount ) ; } }","Triggers when users send us HAV or nUSD , but the modifier only allows nUSD calls to proceed ."
2317,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _getApproved ( _tokenId ) == msg . sender ) ; require ( _ownerOf ( _tokenId ) == _from ) ; require ( _to != address ( 0 ) ) ; _clearApprovalAndTransfer ( _from , _to , _tokenId ) ; Approval ( _from , 0 , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
2318,"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( msg . sender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }",transfers 'amount ' from msg.sender to a receiving account 'to '
2321,"function sendPendingAmounts ( uint _from , uint _to , address _buyer ) returns ( bool ) ;",Function to send tokens or refund after the closing time of the funding proposals
2322,function getBool ( bytes32 _key ) public view returns ( bool _value ) { return boolStorage [ _key ] ; },Get value for Bool associated with bytes32 id key
2323,"function acceptTermsAndJoinDXF ( ) payable external { if ( now > startingDateFunding + 365 days ) throw ; if ( ! dxfOpen ) throw ; if ( vips [ msg . sender ] ) throw ; if ( msg . value < 10 ether ) throw ; if ( msg . value > ( tokensCreationCap - totalTokens ) ) throw ; if ( msg . value > ( 10000 ether - balances [ msg . sender ] ) ) throw ; if ( balances [ msg . sender ] == 0 ) { newMember ( msg . sender ) ; indexMembers [ msg . sender ] = members . length ; members . push ( Member ( msg . sender , now , msg . value ) ) ; } else { members [ indexMembers [ msg . sender ] ] . initial_value += msg . value ; } if ( members . length > maxNumberMembers ) throw ; if ( multisigDXF == 0 ) throw ; if ( ! multisigDXF . send ( msg . value ) ) throw ; uint numTokens = msg . value ; totalTokens += numTokens ; if ( ( tokensCreationCap - totalTokens ) < remainingTokensVIPs ) throw ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }",By using this function you accept the terms of DXF
2324,"function createAndJoinCDPDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; tub . give ( id , msg . sender ) ; }",create a CDP from the given amount of Dai in the sender 's balance - needs Dai transfer approval
2325,function deedsOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 deedCount = countOfDeedsByOwner ( _owner ) ; if ( deedCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( deedCount ) ; uint256 totalDeeds = countOfDeeds ( ) ; uint256 resultIndex = 0 ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { result [ resultIndex ] = identifier ; resultIndex ++ ; } } return result ; } },Returns a list of all deed identifiers assigned to an address .
2326,"function newRepo ( string _name , address _dev ) auth ( CREATE_REPO_ROLE ) public returns ( Repo ) { return _newRepo ( _name , _dev ) ; }",Create new repo in registry with ` _name `
2329,"function removeTicker ( string _ticker ) external onlyOwner { string memory ticker = Util . upper ( _ticker ) ; address owner = _tickerOwner ( ticker ) ; require ( owner != address ( 0 ) , ""Ticker doesn't exist"" ) ; _deleteTickerOwnership ( owner , ticker ) ; set ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) , address ( 0 ) ) ; _storeTickerDetails ( ticker , address ( 0 ) , 0 , 0 , """" , false ) ; emit TickerRemoved ( ticker , now , msg . sender ) ; }","Removes the ticker details , associated ownership & security token mapping"
2330,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""insufficent allowance"" ) ; address erc20DividendCheckpoint = new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( erc20DividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return erc20DividendCheckpoint ; }",Used to launch the Module with the help of factory
2331,"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific item .
2332,"function matchTokenOrderByAdmin_k44j ( uint256 [ ] inputs ) external onlyAdmin { address user = userId2Address [ decodeOrderUserId ( inputs [ 3 ] ) ] ; require ( inputs [ 3 ] >> 224 > userNonce [ user ] ) ; address token ; address base ; bool isBuy ; ( token , base , isBuy ) = decodeTokenOrderTokenAndIsBuy ( inputs [ 3 ] ) ; bytes32 orderHash = getTokenOrderDataHash ( inputs , 0 , inputs [ 3 ] , token , base ) ; require ( verify ( orderHash , user , uint8 ( retrieveV ( inputs [ 3 ] ) ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 baseExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; user = userId2Address [ decodeOrderUserId ( inputs [ i + 3 ] ) ] ; require ( inputs [ i + 3 ] >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = getTokenOrderDataHash ( inputs , i , inputs [ i + 3 ] , token , base ) ; require ( verify ( makerOrderHash , user , uint8 ( retrieveV ( inputs [ i + 3 ] ) ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , baseExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , inputs [ i + 3 ] , tokenExecute , baseExecute , isBuy , token , base , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , baseExecute , isBuy , token , base , orderHash ) ; }","match token orders with admins involved , only admin"
2335,"function ownerOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return owner ; }",Get the owner of PixelCon ` ( _tokenId ) `
2336,"function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external onlyOwner { require ( keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( ""lowerBound"" ) ) || keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( ""upperBound"" ) ) , ""Must be a valid bound type"" ) ; require ( _newVersion . length == 3 ) ; if ( compatibleSTVersionRange [ _boundType ] != uint24 ( 0 ) ) { uint8 [ ] memory _currentVersion = VersionUtils . unpack ( compatibleSTVersionRange [ _boundType ] ) ; require ( VersionUtils . isValidVersion ( _currentVersion , _newVersion ) , ""Failed because of in-valid version"" ) ; } compatibleSTVersionRange [ _boundType ] = VersionUtils . pack ( _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; emit ChangeSTVersionBound ( _boundType , _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; }",Function use to change the lower and upper bound of the compatible version st
2338,function destroyContract ( ) public onlyOwner { selfdestruct ( owner ) ; },Terminate contract and send any ETH left in contract to owner
2341,"function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) ;",Check if the validator is approved to revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
2342,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F41 ) , _token , _to , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
2343,function getLastDeedTimestampByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; string memory deed = addressRegistry [ propertyAddressHash ] [ addressRegistry [ propertyAddressHash ] . length - 1 ] ; return getDeedTimestamp ( deed ) ; },Gets the last deed registration timestamp by property address
2345,"function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( block . timestamp < accountInMem . unlockDate ) { address penaltyDisbursalAddress = UNIVERSE . feeDisbursal ( ) ; require ( penaltyDisbursalAddress != address ( 0 ) ) ; uint112 penalty = uint112 ( decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ) ; assert ( PAYMENT_TOKEN . transfer ( penaltyDisbursalAddress , penalty , abi . encodePacked ( NEUMARK ) ) ) ; emit LogPenaltyDisbursed ( penaltyDisbursalAddress , investor , penalty , PAYMENT_TOKEN ) ; accountInMem . balance -= penalty ; } assert ( PAYMENT_TOKEN . transfer ( investor , accountInMem . balance , """" ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }",unlocks 'investor ' tokens by making them withdrawable from paymentToken
2347,"function getCryptoAvatar ( uint256 _id ) external view returns ( uint256 statistics , uint256 avatarType , uint256 level , uint256 experience , uint256 creationTime , bool isHibernated ) { require ( exists ( _id ) ) ; CryptoAvatar storage avatar = avatars [ _id ] ; statistics = uint256 ( avatar . statistics ) ; avatarType = uint256 ( avatar . avatarType ) ; level = uint256 ( avatar . level ) ; experience = uint256 ( avatar . experience ) ; creationTime = uint256 ( avatar . creationTime ) ; isHibernated = avatar . isHibernated ; }",Returns all the relevant information about a specific avatar .
2348,"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( oraclize_getPrice ( ""URL"" ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }",Allows owner to schedule future Oraclize calls on a rolling schedule
2350,"function endAuction ( ) external { require ( block . number >= _auctionEnd ) ; require ( ! _ended ) ; _ended = true ; AuctionEnded ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; }","End the auction , allowing the withdrawal of ether and tokens"
2351,"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
2352,"function claimAddress ( address _address ) public isCompleted userHasFundedPool ( _address ) { for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { ERC20Basic token = ERC20Basic ( tokenAddress [ i ] ) ; uint256 poolTokenBalance = token . balanceOf ( this ) ; payoutTokensInternal ( _address , poolTokenBalance , token ) ; } }",Process a claim function for a specified address .
2353,"function _transferSenderPaysFee_byProxy ( address sender , address to , uint value , bytes data ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee , data ) ; }",Ability to transfer where the sender pays the fees ( not ERC20 )
2354,"function transferFromAndCall ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) ;",Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver
2356,"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external returns ( bool ) ;",The function signature that will be called when a trader opens an order .
2357,function ( ) payable { contribute ( msg . sender ) ; },Fallback function which implements how miners participate in BTH
2359,function countAttributeTypes ( ) external view returns ( uint256 ) ;,Count the number of attribute types defined by the registry .
2360,function claimEth ( ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; require ( creator . send ( this . balance ) ) ; },Function to claim any eth stuck on contract
2361,"function drop ( address [ ] holders ) external returns ( bool ) { for ( uint256 i = 0 ; i < holders . length ; i ++ ) { address holder = holders [ i ] ; if ( ! isAirdropped ( holder ) ) { uint256 balance = balances [ holder ] ; undropped = undropped . sub ( balance ) ; balances [ holder ] = airdropAmount ( balance ) ; uint256 amount = balances [ holder ] . sub ( balance ) ; totalSupply_ = totalSupply_ . add ( amount ) ; Transfer ( address ( 0 ) , holder , amount ) ; setAirdropped ( holder ) ; } } }",Execute airdrop for a bunch of addresses .
2362,"function setICOEndDate ( uint _date ) external onlyAdmin returns ( bool ) { require ( icoEndDate == 0 , ""The ICO end date was already set."" ) ; icoEndDate = _date ; emit ICOEndDateSet ( _date ) ; return true ; }",This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
2365,"function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( validIdentifier ( _deedId ) ) ; var ( x , y ) = identifierToCoordinate ( _deedId ) ; uri = ""https://dworld.io/plot/xxxxx/xxxxx"" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 5 ; i ++ ) { _uri [ 27 - i ] = byte ( 48 + ( x / 10 ** i ) % 10 ) ; _uri [ 33 - i ] = byte ( 48 + ( y / 10 ** i ) % 10 ) ; } }",Returns an ( off-chain ) metadata url for the given deed .
2368,function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= minCap && this . balance > 0 ) { owner . transfer ( this . balance ) ; } },"Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner"
2369,function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( abi . encodePacked ( _name ) ) ] ; },gets the parameter keyed by the provided name value from the params mapping
2370,"function getPrice ( address ofAsset ) view returns ( bool isRecent , uint price , uint decimal ) { return ( hasRecentPrice ( ofAsset ) , information [ ofAsset ] . price , information [ ofAsset ] . decimal ) ; }",Gets price of an asset multiplied by ten to the power of assetDecimals
2372,"function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( msg . sender == burnOperator , ""Not a burn operator"" ) ; super . operatorBurn ( _tokenHolder , _amount , _data , _operatorData ) ; }",Burns ` _amount ` tokens from ` _tokenHolder ` by ` _operator ` Silly example of overriding the ` operatorBurn ` function to only let a specific operator burn tokens .
2373,"function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer ( _from ) returns ( bool ) { require ( _to != address ( 0 ) , ""Invalid address."" ) ; return super . transferFrom ( _from , _to , _value ) ; }",Transfers tokens from a specified wallet address .
2374,function cancelPayment ( uint _idPayment ) public onlyOwner { doCancelPayment ( _idPayment ) ; },When ` autopay ` is ` false ` and after a payment has been authorized to allow the owner to cancel a payment instead of confirming it .
2375,"function enableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( ! released , ""Invalid operation. The transfer state is no more restricted."" ) ; released = true ; emit TokenReleased ( released ) ; return true ; }",This function enables token transfers for everyone.Can only be enabled after the end of the ICO .
2376,"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( abi . encodePacked ( answer , nonce ) ) ; bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , bond ) ) ; require ( ! commitments [ commitment_id ] . is_revealed , ""commitment must not have been revealed yet"" ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) , ""reveal deadline must not have passed"" ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } emit LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }",Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
2377,"function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _tokenId != 0 ) ; require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; }",This is a private function which should be called from user-implemented external mint function .
2378,"function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint preBalance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == preBalance - num ) ; }",Allows ` msg.sender ` to simply destroy ` num ` token units ( Xei ) .
2379,function motionWaiting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] + votingPeriod + confirmationPeriod <= now ; },"A vote motion either not begun , or it has completely terminated ."
2380,"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes calldata _data ) external returns ( bytes4 ) ;",The contract address is always the message sender .
2381,function onStateChange ( Crowdsale . State _state ) public onlyCrowdsale ;,"Takes actions on state change , un-pause tokens and disable minting on Crowdsale success"
2382,function getThirdPartyOwners ( ) public view returns ( address [ ] _owners ) { if ( owners . length <= TWO_FACTOR_RESERVED_OWNERS_LENGTH ) { return ; } _owners = new address [ ] ( owners . length - TWO_FACTOR_RESERVED_OWNERS_LENGTH ) ; uint _pointer = 0 ; for ( uint _ownerIdx = TWO_FACTOR_RESERVED_OWNERS_LENGTH ; _ownerIdx < owners . length ; ++ _ownerIdx ) { _owners [ _pointer ++ ] = owners [ _ownerIdx ] ; } },Gets a list of 3rd party owners ( if such exist ) .
2383,function getSubPayeesCount ( bytes32 _requestId ) public view returns ( uint8 ) { for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { } return i ; },Gets number of subPayees for a request .
2384,"function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 value ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; if ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) { return _issuedAttributes [ account ] [ attributeTypeID ] . value ; } else if ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) ) { require ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . hasAttribute ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) , ""attribute of the provided type is not assigned to the provided account"" ) ; return ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . getAttributeValue ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ; } revert ( ""could not find an attribute value at the provided account and ID"" ) ; }","Retrieve the value of the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` , assuming it is valid ."
2386,"function transferOwnership ( address newOwner ) public onlyContractOwner returns ( bool ) { if ( newOwner == 0x0 ) { return false ; } emit OwnershipTransferred ( contractOwner , newOwner ) ; contractOwner = newOwner ; delete pendingContractOwner ; return true ; }",Allows the current owner to transfer control of the contract to a newOwner .
2388,function acceptProposedMilestones ( bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i ; if ( ! changingMilestones ) throw ; if ( sha3 ( proposedMilestones ) != _hashProposals ) throw ; for ( i = 0 ; i < milestones . length ; i ++ ) { if ( milestones [ i ] . status != MilestoneStatus . Paid ) { milestones [ i ] . status = MilestoneStatus . Canceled ; } } bytes memory mProposedMilestones = proposedMilestones ; var itmProposals = mProposedMilestones . toRLPItem ( true ) ; if ( ! itmProposals . isList ( ) ) throw ; var itrProposals = itmProposals . iterator ( ) ; while ( itrProposals . hasNext ( ) ) { var itmProposal = itrProposals . next ( ) ; Milestone milestone = milestones [ milestones . length ++ ] ; if ( ! itmProposal . isList ( ) ) throw ; var itrProposal = itmProposal . iterator ( ) ; milestone . description = itrProposal . next ( ) . toAscii ( ) ; milestone . url = itrProposal . next ( ) . toAscii ( ) ; milestone . minCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . maxCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . reviewer = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewTime = itrProposal . next ( ) . toUint ( ) ; milestone . paymentSource = itrProposal . next ( ) . toAddress ( ) ; milestone . payData = itrProposal . next ( ) . toData ( ) ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; } delete proposedMilestones ; changingMilestones = false ; NewMilestoneListAccepted ( ) ; },` onlyDonor ` Approves the proposed milestone list
2389,function finishMinting ( address _burnable ) public onlyController ( ) { require ( _burnable != address ( 0x0 ) ) ; assert ( totalSupply ( ) <= maxSupply ) ; enableTransfers ( true ) ; changeController ( address ( 0x0 ) ) ; burnable = _burnable ; },Finishes minting process and throws out the controller .
2390,"function getCrypton ( uint256 _tokenId ) public view returns ( string cryptonName , uint8 category , uint256 markup , uint256 sellingPrice , address owner , bool isProtected ) { Crypton storage crypton = cryptons [ _tokenId ] ; cryptonName = crypton . name ; sellingPrice = cryptonIndexToPrice [ _tokenId ] ; owner = cryptonIndexToOwner [ _tokenId ] ; isProtected = cryptonIndexToProtected [ _tokenId ] ; category = crypton . category ; markup = crypton . markup ; }",Returns all the relevant information about a specific crypton .
2391,"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( tokens [ token ] [ msg . sender ] >= amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; DataVault . _externalStopMasternode ( msg . sender ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }",Public function that allows any user to withdraw deposited tokens and stop as masternode
2392,function isApproved ( uint index ) public view returns ( bool ) { Loan storage loan = loans [ index ] ; return loan . approbations [ loan . borrower ] ; },Used to know if a loan is ready to lend
2394,"function migrate ( uint256 _value ) external { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }",Migrate tokens to the new token contract .
2396,"function offer ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract ."
2398,"function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }",Withdraw ether and delete the htlc swap .
2399,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
2401,"function depositStake ( StakeLevel _stakeLevel ) public whenNotPaused ( ) isMember ( msg . sender ) notStaking ( msg . sender ) isValidStakeLevel ( _stakeLevel ) { uint256 amountDeposited = depositInternal ( msg . sender , ixtStakingLevels [ uint256 ( _stakeLevel ) ] , false ) ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = block . timestamp ; member . startOfLoyaltyRewardEligibility = block . timestamp ; registeredInvitationCodes [ member . invitationCode ] = msg . sender ; emit StakeDeposited ( msg . sender , member . membershipNumber , amountDeposited ) ; }",Before calling the prospective member must have approved the appropriate amount of IXT token to be transferred by this contract
2402,"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; return doApprove ( _spender , _amount ) ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
2403,"function verifyAccount ( Data storage self , address account ) internal view returns ( bool verified ) { require ( getKYCApproval ( self , account ) , ""Error: Account does not have KYC approval."" ) ; require ( getAccountStatus ( self , account ) , ""Error: Account status is `false`. Account status must be `true`."" ) ; return true ; }",Verified KYC and global status for a single account and return true or throw if account is not verified
2404,"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] - getLockedTokens ( msg . sender ) ; require ( availableTokens >= _numTokens ) ; require ( token . transfer ( msg . sender , _numTokens ) ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; VotingRightsWithdrawn ( msg . sender , _numTokens ) ; }","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights"
2408,"function revokeOperator ( address _operator ) public whenNotPaused { require ( _operator != msg . sender , ""You cannot authorize yourself as an operator"" ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
2409,"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F44 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by transferFromPreSigned
2410,"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 3 ) ; availableTags [ 0 ] = ""ERC20"" ; availableTags [ 1 ] = ""Dividend"" ; availableTags [ 2 ] = ""Checkpoint"" ; return availableTags ; }",Get the tags related to the module factory
2411,function getOrganization ( uint256 index ) external view returns ( address organization ) { return _organizationAccounts [ index ] ; },Get the account of the organization at index ` index ` .
2412,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ;",Query if an address is an authorized operator for another address
2413,"function getAllowance ( address _owner , address _spender ) external view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }",Get allowance of ` _spender ` in behalf of ` _owner `
2414,"function createSeedCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } seedCreatedCount ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }",Helps in creating seed collectible.The generation of an asset if limited via the generationSeasonController
2415,"function redeemAllOwnedAssets ( uint shareQuantity ) external returns ( bool success ) { return emergencyRedeem ( shareQuantity , ownedAssets ) ; }",Redeems by allocating an ownership percentage of each asset to the participant
2416,"function synthInitiatedFeePayment ( address from , bytes4 sourceCurrencyKey , uint sourceAmount ) external onlySynth returns ( bool ) { require ( sourceAmount > 0 , ""Source can't be 0"" ) ; bool result = _internalExchange ( from , sourceCurrencyKey , sourceAmount , ""XDR"" , feePool . FEE_ADDRESS ( ) , false ) ; feePool . feePaid ( sourceCurrencyKey , sourceAmount ) ; return result ; }",Function that allows synth contract to delegate sending fee to the fee Pool .
2419,function getPermissions ( ) public view returns ( bytes32 [ ] ) ;,Return the permissions flag that are associated with Module
2420,function getDistributionContracts ( address _beneficiary ) public view validAddress ( _beneficiary ) returns ( address [ ] ) { return beneficiaryDistributionContracts [ _beneficiary ] ; },Gets an array of all the distribution contracts for a given beneficiary .
2422,"function createBurnedPermission ( address _app , bytes32 _role ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }","Burn non-existent ` _role ` in ` _app ` , so no modification can be made to it ( grant , revoke , permission manager )"
2424,"function createCloneToken ( address _parentToken , uint256 _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
2425,function withdrawETH ( uint256 _amount ) external onlyOwner { owner . transfer ( _amount ) ; },Withdraw ether contained in this contract and send it back to owner
2428,"function setMerkleRoot ( bytes32 _updatedMerkleRoot ) external onlySigner returns ( uint ) { merkleRoot = _updatedMerkleRoot ; emit LogMerkleRootUpdated ( _updatedMerkleRoot , msg . sender ) ; return OK ; }",Updates merkle root after changes in airdrop records .
2429,"function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE , ""Transfer fee rate must be below MAX_TRANSFER_FEE_RATE"" ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; }","Set the transfer fee , anywhere within the range 0-10 % ."
2430,"function upgrade ( uint256 value ) external { if ( ! upgradeAgentStatus ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }",Upgrade tokens to the new token contract .
2431,function ( ) public payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
2432,function ( ) payable { require ( false ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
2433,function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = getMinerHalving ( ) ; MinerHashRate hashRate = miner . hashRate [ halving ] ; if ( halving == 0 ) { return hashRate . rate ; } else { if ( ! hashRate . carried ) { return hashRate . rate . add ( miner . hashRate [ halving - 1 ] . rate ) ; } else { return hashRate . rate ; } } },Total hash rate of a miner in a halving
2434,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; if ( _from == owner && _to != owner ) { shareholdersBalance += _value ; } if ( _from != owner && _to == owner ) { shareholdersBalance -= _value ; } if ( owner != _to ) { insertShareholder ( _to ) ; } Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
2435,function changeOraclizeGasPrice ( uint _gasPrice ) public onlyOwner { require ( _gasPrice >= 1000000000 ) ; oraclize_setCustomGasPrice ( _gasPrice ) ; },To be used in case the default gas price is too low
2436,"function transferTokensToAccount ( bytes16 _from , bytes16 _to , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _from ) whenNotPaused public returns ( bool ) { registerAccount ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokensCount ) ; balances [ _to ] = balances [ _to ] . add ( _tokensCount ) ; return true ; }",Function for transfering tokens from one account to another .
2438,"function _addToken ( address _to , uint256 _tokenId ) private { require ( tokenOwner [ _tokenId ] == address ( 0 ) ) ; tokenOwner [ _tokenId ] = _to ; uint256 length = balanceOf ( _to ) ; ownedTokens [ _to ] . push ( _tokenId ) ; ownedTokensIndex [ _tokenId ] = length ; totalTokens = totalTokens . add ( 1 ) ; }",Internal function to add a token ID to the list of a given address
2439,"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) public onlyPermissionManager ( _app , _role ) { bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }",Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `
2440,"function createKingdom ( string _kingdomName , uint _startingClaimPriceWei , uint _claimPriceAdjustPercent , uint _curseIncubationDurationSeconds , uint _commissionPerThousand ) { externalEnter ( ) ; createKingdomRP ( _kingdomName , _startingClaimPriceWei , _claimPriceAdjustPercent , _curseIncubationDurationSeconds , _commissionPerThousand ) ; externalLeave ( ) ; }",Create a new kingdom using custom rules .
2443,function getMinimumFunds ( ) internal constant returns ( uint ) ;,minimum amount of funding to consider crowdsale as successful
2445,function getDarknodeOwner ( address _darknodeID ) external view returns ( address ) { return store . darknodeOwner ( _darknodeID ) ; },Retrieves the address of the account that registered a darknode .
2449,function getLandEstateId ( uint256 landId ) external view returns ( uint256 ) { return landIdEstate [ landId ] ; },Get the Estate id for a given LAND id
2450,"function cancelAuction ( address _tokenAddress , uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenAddress ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenAddress , _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
2451,function withdrawPrize ( ) external checkState ( pointsValidationState . Finished ) { uint256 prize = 0 ; uint256 [ ] memory tokenList = ownedTokens [ msg . sender ] ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { prize += tokenToPayoutMap [ tokenList [ i ] ] ; tokenToPayoutMap [ tokenList [ i ] ] = 0 ; } require ( prize > 0 ) ; msg . sender . transfer ( ( prizePool . mul ( prize ) ) . div ( 1000000 ) ) ; },Allows any user to retrieve their asigned prize .
2453,function releaseTo ( address target ) onlyBeneficiary public { require ( now >= cliff ) ; _releaseTo ( target ) ; },Transfers vested tokens to a target address .
2454,function numberOfPledgeAdmins ( ) constant returns ( uint ) { return admins . length - 1 ; },A constant getter used to check how many total Admins exist
2456,"function symbol ( ) external pure returns ( string ) { return ""SU"" ; }",An abbreviated name for NFTs in this contract
2457,"function externalTokensRecovery ( Token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract
2458,"function getPlotInfo ( uint256 plotIndex ) public view returns ( uint24 x , uint24 y , uint24 w , uint24 h , address owner , uint256 price ) { require ( plotIndex < ownership . length ) ; return ( ownership [ plotIndex ] . x , ownership [ plotIndex ] . y , ownership [ plotIndex ] . w , ownership [ plotIndex ] . h , ownership [ plotIndex ] . owner , plotIdToPrice [ plotIndex ] ) ; }",Gets the information for a specific plot based on its index .
2459,"function onTransfer ( address , address , uint256 ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }",Notifies the controller about a token transfer allowing the controller to react if desired
2460,"function resolveDispute ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint8 _v , bytes32 _r , bytes32 _s , uint8 _buyerPercent ) external onlyArbitrator { address _signature = recoverAddress ( keccak256 ( abi . encodePacked ( _tradeID , INSTRUCTION_RESOLVE ) ) , _v , _r , _s ) ; require ( _signature == _buyer || _signature == _seller , ""Must be buyer or seller"" ) ; Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; require ( _escrow . exists , ""Escrow does not exist"" ) ; require ( _buyerPercent <= 100 , ""_buyerPercent must be 100 or lower"" ) ; uint256 _totalFees = _escrow . totalGasFeesSpentByRelayer + ( GAS_doResolveDispute * uint128 ( tx . gasprice ) ) ; require ( _value - _totalFees <= _value , ""Overflow error"" ) ; feesAvailableForWithdraw += _totalFees ; delete escrows [ _tradeHash ] ; emit DisputeResolved ( _tradeHash ) ; if ( _buyerPercent > 0 ) _buyer . transfer ( ( _value - _totalFees ) * _buyerPercent / 100 ) ; if ( _buyerPercent < 100 ) _seller . transfer ( ( _value - _totalFees ) * ( 100 - _buyerPercent ) / 100 ) ; }",Called by the arbitrator to resolve a dispute .
2461,"function proxyChangeCrowdsaleMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( ""PoaManager"" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaCrowdsaleMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaCrowdsaleMaster ; poaCrowdsaleMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( ""PoaLogger"" ) . call ( bytes4 ( keccak256 ( ""logProxyUpgraded(address,address)"" ) ) , _oldMaster , _newMaster ) ; return true ; }",Update the stored ` poaCrowdsaleMaster ` address to upgrade the PoaCrowdsale master contract
2463,"function getContractAddress ( string _name ) public view returns ( address _contractAddress ) { bytes4 _signature = bytes4 ( keccak256 ( ""getContractAddress32(bytes32)"" ) ) ; bytes32 _name32 = keccak256 ( abi . encodePacked ( _name ) ) ; assembly { let _registry := sload ( registry_slot ) let _pointer := mload ( 0x40 ) mstore ( _pointer , _signature ) mstore ( add ( _pointer , 0x04 ) , _name32 ) let result := staticcall ( gas , _registry , _pointer , 0x24 , _pointer , 0x20 ) if iszero ( result ) { revert ( 0 , 0 ) } _contractAddress := mload ( _pointer ) mstore ( 0x40 , add ( _pointer , 0x24 ) ) } }",Gets a given contract address by bytes32 in order to save gas
2464,"function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",This is used to approve someone to send tokens on your behalf
2465,"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific person .
2466,"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }",Used to transfer funds on behalf of one person
2467,"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }",Redeems Bskt tokens in exchange for underlying tokens
2468,function removeOwnership ( address _dece ) onlyOwner { require ( _dece == 0xdece ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone"
2469,"function depositETH ( ) payable { DonationDeposited4Doubling ( msg . sender , msg . value ) ; }",Simple function to deposit more ETH to Double Donations
2470,function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . timeout ; },Returns the timeout in seconds used after each answer
2473,function commitUpgrade ( ) public returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } if ( pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now ) { return false ; } latestVersion = pendingVersion ; delete pendingVersion ; delete pendingVersionTimestamp ; return true ; },Finalize an upgrade process setting new asset implementation contract address .
2474,function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } },Removes multiple addresses to the administrator list .
2476,"function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
2479,"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,bool)"" ) ) ; }",This function returns the signature of configure function
2480,function purchase ( ) payable returns ( bool ) ;,Create tokens to the value of ` msg.value ` + ` holder.etherBalance `
2481,"function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = safeSub ( totalVestedBalance , totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }",Destroy the vesting information associated with an account .
2482,"function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) ; }",only the Sale is allowed to send tokens
2483,"function approveSpender ( address _spender ) external { require ( whitelistedSpenders [ _spender ] , ""Spender is not whitelisted"" ) ; approvedSpenders [ msg . sender ] [ _spender ] = true ; emit SpenderApprove ( msg . sender , _spender ) ; }",Approve an address for spending any amount of any token from the ` msg.sender ` 's balances
2484,"function burn ( address _where , uint256 _amount ) public onlyEthealMultisig { require ( _where == address ( this ) || _where == SALE ) ; require ( ethealToken . destroyTokens ( _where , _amount ) ) ; }",contract can burn its own or its sale tokens
2485,function emergencyWithdraw ( ) external hasFinalized { uint256 balance = STARTING_PRICE * ownedTokens [ msg . sender ] . length ; delete ownedTokens [ msg . sender ] ; msg . sender . transfer ( balance ) ; },"if there is an unresolvable problem , users can call to this function to get a refund ."
2486,"function isAssociatedAddressFor ( uint ein , address _address ) public view returns ( bool ) { return identityDirectory [ ein ] . associatedAddresses . contains ( _address ) ; }",Checks whether the passed EIN is associated with the passed address .
2487,"function exchangeEtherForSynthsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice , ""Guaranteed rate would not be received"" ) ; return exchangeEtherForSynths ( ) ; }",Exchange ETH to sUSD while insisting on a particular rate .
2488,function approveLoanIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return approveLoan ( index ) ; },Approves a loan using the Identifier and not the index
2490,"function splitProfits ( ) external { uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 400000000000000 , balances [ selfAddress ] ) + IOUSupply ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 1000000000000 ; if ( msg . gas < 250000 ) { currentIteration = i ; break ; } if ( ! eligibleForDividence ( users [ i ] ) ) { moneySpent [ users [ i ] ] = 0 ; checkSplitEnd ( i ) ; continue ; } moneySpent [ users [ i ] ] = 0 ; actualProfitSplit += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; Transfer ( selfAddress , users [ i ] , ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ) ; balances [ users [ i ] ] += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; } } }",Split the monthly profits of the Casino to the users
2491,function enableTransfers ( bool _transfersEnabled ) onlyOwner { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
2492,"function withdraw ( uint amount ) { Splitter . withdrawInternal ( amount , false ) ; }",Withdraws from the sender 's share of funds and deposits into the sender 's account .
2493,"function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 0x20 ) ) s := mload ( add ( sig , 0x40 ) ) v := byte ( 0 , mload ( add ( sig , 0x60 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }",Recover signer address from a message by using his signature
2494,"function getWorlCupByID ( uint256 _tokenId ) public view returns ( string wctDesc , uint256 sellingPrice , address owner ) { wctDesc = worldCupTeamDescribe [ _tokenId ] ; sellingPrice = worldCupIdToPrice [ _tokenId ] ; owner = worldCupIdToOwnerAddress [ _tokenId ] ; }",Returns all the world cup team information by token id .
2495,"function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , ""not enough allowance to transfer"" ) ; require ( _to != address ( 0 ) , ""to address cannot be 0x0"" ) ; require ( _amount <= balanceOf ( _from ) , ""not enough balance to transfer"" ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; tokenStorage . subBalance ( _from , _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }",Initiates a transfer operation between address ` _from ` and ` _to ` .
2497,function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; },"( Deprecated ) Return the final answer to the specified question , or revert if there is n't one"
2498,function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWeiAtPrice = numTokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWeiAtPrice <= receivedWei ) { return 0 ; } return requiredWeiAtPrice - receivedWei ; },"Get the missing funds needed to end the auction , calculated at the current XCH price in WEI ."
2499,"function hashOrder ( bytes _prefix , uint64 _settlementID , uint64 _tokens , uint256 _price , uint256 _volume , uint256 _minimumVolume ) external pure returns ( bytes32 ) { return SettlementUtils . hashOrder ( _prefix , SettlementUtils . OrderDetails ( { settlementID : _settlementID , tokens : _tokens , price : _price , volume : _volume , minimumVolume : _minimumVolume } ) ) ; }",Exposes the hashOrder function for computing a hash of an order 's details .
2500,"function incrementalInverse ( uint256 totalEuroUlps , uint256 burnNeumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public constant returns ( uint256 euroUlps ) { uint256 totalNeumarkUlps = cumulative ( totalEuroUlps ) ; require ( totalNeumarkUlps >= burnNeumarkUlps ) ; uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps ; uint newTotalEuroUlps = cumulativeInverse ( fromNmk , minEurUlps , maxEurUlps ) ; assert ( totalEuroUlps >= newTotalEuroUlps ) ; return totalEuroUlps - newTotalEuroUlps ; }",returns amount of euro corresponding to burned neumarks
2503,"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
2504,"function safetyInvariantCheck ( uint256 _value ) public { if ( ! newToken . isNewToken ( ) ) revert ( ) ; uint oldSupply = oldToken . totalSupply ( ) ; uint newSupply = newToken . totalSupply ( ) ; if ( safeAdd ( oldSupply , newSupply ) != safeSub ( correctOriginalSupply , _value ) ) { InvariantCheckFailed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } else { InvariantCheckPassed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } }",Check to make sure that the current sum of old and new version tokens is still equal to the original number of old version tokens
2505,"function tokenFactory ( uint256 _amount ) public onlyAdmin returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; require ( tokenMint ( msg . sender , _amount ) ) ; return true ; }","Used to mint tokens , only usable by the contract owner"
2506,"function checkMinimalGoal ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - icoMin ) { minimalGoalReached = true ; minGoalReached ( icoMin , ""Minimal goal of ICO is reached!"" ) ; } }",Check if minimal goal of ICO is reached
2507,function getNumberOfDeedsByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] . length ; },Returns number of deeds registered for a particular address
2508,"function setCampaignPriceById ( bytes32 bidId , uint price ) public onlyIfWhitelisted ( ""setCampaignPriceById"" , msg . sender ) onlyIfCampaignExists ( ""setCampaignPriceById"" , bidId ) { campaigns [ bidId ] . setPrice ( price ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new price for a campaign Based on the Campaign id , updates the value paid for each proof of attention registered ."
2509,function setKingdomFactory ( KingdomFactory _kingdomFactory ) { externalEnter ( ) ; setKingdomFactoryRP ( _kingdomFactory ) ; externalLeave ( ) ; },Used by topWizard to vary the factory contract which will be used to create future Kingdoms .
2510,function setSellCeiling ( uint256 ceiling ) public onlyOwner { sellCeiling = ceiling ; },Set the highest price an ask can be listed .
2511,"function transferableHavvens ( address account ) public view returns ( uint ) { uint draft = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( draft > collat ) { return 0 ; } uint bal = balanceOf ( account ) ; if ( draft > safeSub ( collat , bal ) ) { return safeSub ( collat , draft ) ; } return bal ; }",The number of havvens that are free to be transferred by an account .
2513,function lockedCollateral ( address account ) public view returns ( uint ) { uint debt = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( debt > collat ) { return collat ; } return debt ; },"Collateral that has been locked due to issuance , and can not be transferred to other addresses ."
2514,function setCrowdsaleAddress ( address _crowdsale ) external onlyOwner whenNotPaused { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; },Function to set the crowdsale smart contract 's address only by the owner of this token
2515,function findAdmin ( uint64 idAdmin ) internal returns ( PledgeAdmin storage ) { require ( idAdmin < admins . length ) ; return admins [ idAdmin ] ; },A getter to look up a Admin 's details
2516,"function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint pre_balance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == pre_balance - num ) ; }",Allows ` msg.sender ` to simply destroy ` num ` token units ( Rei ) .
2518,"function withdrawBonuses ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; require ( _withdrawAddress != 0x0 ) ; DepositWalletInterface _wallet = DepositWalletInterface ( wallet ) ; ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . balanceOf ( _wallet ) < _value ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE ) ; } if ( OK != _withdrawBonuses ( _userKey , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || OK == _wallet . withdraw ( _bonusToken , _feeAddress , _feeAmount ) ) ) { revert ( ) ; } if ( OK != _wallet . withdraw ( _bonusToken , _withdrawAddress , _value - _feeAmount ) ) { revert ( ) ; } BonusesWithdrawn ( _userKey , _value , now ) ; return OK ; }",Allows to withdraw user 's bonuses that he deserves due to Treasury shares for every distribution period .
2519,"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; bytes32 _nameKec = keccak256 ( abi . encodePacked ( _name ) ) ; if ( _nameKec == DISPENSATION_PCT_KEC || _nameKec == P_DISPENSATION_PCT_KEC ) { require ( _value <= 100 ) ; } if ( keccak256 ( abi . encodePacked ( _name ) ) == NEW_REGISTRY_KEC ) { require ( getNewRegistry ( ) == address ( 0 ) ) ; require ( _value != 0 ) ; require ( msg . sender == owner ) ; require ( ( _value & 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff ) == _value ) ; require ( this . doesContractImplementInterface ( address ( _value ) , REGISTRY_INTERFACE_REQUIREMENT ) ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry ) ; return propID ; }",propose a reparamaterization of the key _name 's value to _value .
2520,function name ( ) external pure returns ( string _name ) ;,A descriptive name for a collection of NFTs in this contract
2521,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { require ( _tokenId < warriors . length ) ; owner = warriorToOwner [ _tokenId ] ; },Returns the address currently assigned ownership of a given Warrior .
2523,"function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) { return ( _validAttributeTypeID == attributeTypeID && _jurisdiction . canIssueAttributeType ( address ( this ) , _validAttributeTypeID ) ) ; }",Check if the validator is approved to issue attributes of the type with ID ` attributeTypeID ` on the jurisdiction .
2524,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
2526,"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
2527,function disableTransfer ( ) ;,Function to disable the transfer of Dao shares
2528,function addPriceTier ( uint price ) public onlyOwner { tableStakesOptions . push ( price ) ; },In case we need extra price tiers ( table stakes where people can play ) we can add additional ones
2530,"function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }",Recover signer address from a message by using his signature
2531,"function claimTokens ( address _token ) onlyController public { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; emit ClaimedTokens ( _token , controller , balance ) ; }",Extracting the wrongly sent token back into the contract set to 0 if want to get ether .
2532,"function removeHolderAddress ( bytes32 _externalHolderId , address _address ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; uint _tempIndex = _holderData . address2Index [ _address ] ; require ( _tempIndex != 0 ) ; address _lastAddress = _holderData . index2Address [ _holderData . holderAddressCount ] ; _holderData . address2Index [ _lastAddress ] = _tempIndex ; _holderData . index2Address [ _tempIndex ] = _lastAddress ; delete _holderData . address2Index [ _address ] ; _holderData . holderAddressCount = _holderData . holderAddressCount . sub ( 1 ) ; delete holderAddress2Id [ _address ] ; _emitHolderAddressRemoved ( _externalHolderId , _address , _holderIndex ) ; return OK ; }",Remove an address owned by a holder .
2533,function refundNonWhitelistedPerson ( address _address ) public onlyOwner { uint refundAmount = nonWLBalanceOf [ _address ] ; nonWLBalanceOf [ _address ] = 0 ; _address . transfer ( refundAmount ) ; },Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .
2534,"function unpause ( ) external whenPaused onlyOwner { set ( PAUSED , false ) ; emit Unpause ( now ) ; }","Called by the owner to unpause , returns to normal state"
2535,"function removeValidator ( address validator ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) , ""unable to remove, no validator located at the provided address"" ) ; while ( _validatorApprovals [ validator ] . length > 0 && gasleft ( ) > 25000 ) { uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 targetApproval = _validatorApprovals [ validator ] [ lastIndex ] ; delete _attributeTypes [ targetApproval ] . approvedValidators [ validator ] ; delete _validatorApprovalsIndex [ validator ] [ targetApproval ] ; _validatorApprovals [ validator ] . length -- ; } require ( _validatorApprovals [ validator ] . length == 0 , ""Cannot remove validator - first remove any existing validator approvals"" ) ; address lastAccount = _validatorAccounts [ _validatorAccounts . length . sub ( 1 ) ] ; _validatorAccounts [ _validators [ validator ] . index ] = lastAccount ; _validators [ lastAccount ] . index = _validators [ validator ] . index ; _validatorAccounts . length -- ; delete _validators [ validator ] ; emit ValidatorRemoved ( validator ) ; }",Remove the validator at address ` validator ` from the jurisdiction .
2536,function addMarketplaceContract ( address _marketplaceContract ) public onlyOwner { require ( address ( marketplaceContract ) == 0x0 ) ; marketplaceContract = _marketplaceContract ; },adds marketplace address to contract only if it does n't already exist
2538,function _depositEscrow ( uint256 _amount ) internal returns ( bool ) { currentBalance = currentBalance . add ( _amount ) ; return true ; },"update current balance , if proper token amount approved"
2539,"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; if ( keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( ""dispensationPct"" ) ) || keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( ""pDispensationPct"" ) ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }",propose a reparamaterization of the key _name 's value to _value .
2541,"function withdrawFunds ( uint256 _amount ) external whenNotPaused onlyAdmin { require ( _amount <= address ( this ) . balance , ""The amount should be less than the balance/"" ) ; msg . sender . transfer ( _amount ) ; emit FundsWithdrawn ( msg . sender , _amount ) ; }",This feature enables the admins to withdraw Ethers held in this contract .
2542,function setTopWinnerPrizes ( ) external onlyAdmin checkState ( pointsValidationState . OrderChecked ) { uint256 percent = 0 ; uint [ ] memory tokensEquals = new uint [ ] ( 30 ) ; uint16 tokenEqualsCounter = 0 ; uint256 currentTokenId ; uint256 currentTokenPoints ; uint256 lastTokenPoints ; uint32 counter = 0 ; uint256 maxRange = 13 ; if ( tokens . length < 201 ) { maxRange = 10 ; } while ( payoutRange < maxRange ) { uint256 inRangecounter = payDistributionAmount [ payoutRange ] ; while ( inRangecounter > 0 ) { currentTokenId = sortedWinners [ counter ] ; currentTokenPoints = tokenToPointsMap [ currentTokenId ] ; inRangecounter -- ; if ( inRangecounter == 0 && payoutRange == maxRange - 1 ) { if ( currentTokenPoints == lastTokenPoints ) { percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; } else { tokenToPayoutMap [ currentTokenId ] = payoutDistribution [ payoutRange ] ; } } if ( counter != 0 && ( currentTokenPoints != lastTokenPoints || ( inRangecounter == 0 && payoutRange == maxRange - 1 ) ) ) { for ( uint256 i = 0 ; i < tokenEqualsCounter ; i ++ ) { tokenToPayoutMap [ tokensEquals [ i ] ] = percent . div ( tokenEqualsCounter ) ; } percent = 0 ; tokensEquals = new uint [ ] ( 30 ) ; tokenEqualsCounter = 0 ; } percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; counter ++ ; lastTokenPoints = currentTokenPoints ; } payoutRange ++ ; } pValidationState = pointsValidationState . TopWinnersAssigned ; lastPrizeGiven = counter ; },Assigns prize percentage for the lucky top 30 winners .
2543,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cardTokenToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
2544,function configure ( uint256 _maxHolderCount ) public onlyFactory { maxHolderCount = _maxHolderCount ; },Used to intialize the variables of the contract
2545,function ( ) public payable { if ( msg . sender != owner ) revert ( ) ; },"Fall Back Function , not to receive ether directly and/or accidentally"
2546,function ownerDeclareFailure ( ) external onlyOwner { require ( ! contractFailed ) ; contractFailed = true ; },Declare Crowdsale failure ( no more ETH are accepted from participants )
2547,function ( ) { externalEnter ( ) ; fallbackRP ( ) ; externalLeave ( ) ; },Claim throne by sending funds to the contract .
2549,function getRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getInvitationRewardBalance ( memberAddress ) + getLoyaltyRewardBalance ( memberAddress ) ; },Called to obtain the reward balance of any given member
2551,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { mywoowcoinrecipiente spender = mywoowcoinrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
2552,"function depositPool ( uint256 amountToDeposit ) public onlyOwner { uint256 amountDeposited = depositInternal ( msg . sender , amountToDeposit , true ) ; emit PoolDeposit ( msg . sender , amountDeposited ) ; }",This function can only be called by the contract owner
2554,"function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , ""invalid address"" ) ; require ( _modules . length > 0 , ""0 length is not allowed"" ) ; require ( _modules . length == _perms . length , ""Array length mismatch"" ) ; require ( _valids . length == _perms . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _perms . length ; i ++ ) { _changePermission ( _delegate , _modules [ i ] , _perms [ i ] , _valids [ i ] ) ; } }",Used to change one or more permissions for a single delegate at once
2555,"function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , ""not enough allowance to transfer"" ) ; _transfer ( _to , _from , _amount ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; return true ; }",Initiates a transfer operation between address ` _from ` and ` _to ` .
2557,"function fillUpAllowance ( ) public { uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . approve ( token , amount ) ; }",Allow the token itself to send tokens using transferFrom ( ) .
2560,function reclaimEther ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; },Reclaim Ether that is accidentally sent to this contract .
2561,"function doBuy ( ) internal { Tier tier = tiers [ tierCount ] ; assert ( msg . value <= tier . maxInvestorCap ( ) ) ; address caller = msg . sender ; WhitelistedInvestor storage investor = investors [ caller ] ; uint256 investorTokenBP = investorAmountTokensToBuy ( caller ) ; require ( investorTokenBP > 0 ) ; if ( investor . contributedAmount == 0 ) { assert ( msg . value >= tier . minInvestorCap ( ) ) ; } uint256 toFund = msg . value ; uint256 tokensGenerated = toFund . mul ( tier . exchangeRate ( ) ) ; require ( tokensGenerated >= 1 ) ; uint256 tokensleftForSale = leftForSale ( ) ; if ( tokensleftForSale > investorTokenBP ) { if ( tokensGenerated > investorTokenBP ) { tokensGenerated = investorTokenBP ; toFund = investorTokenBP . div ( tier . exchangeRate ( ) ) ; } } if ( investorTokenBP > tokensleftForSale ) { if ( tokensGenerated > tokensleftForSale ) { tokensGenerated = tokensleftForSale ; toFund = tokensleftForSale . div ( tier . exchangeRate ( ) ) ; } } investor . contributedAmount = investor . contributedAmount . add ( toFund ) ; tier . increaseInvestedWei ( toFund ) ; if ( tokensGenerated == tokensleftForSale ) { finalize ( ) ; } assert ( cnd . generateTokens ( caller , tokensGenerated ) ) ; totalTokensSold = totalTokensSold . add ( tokensGenerated ) ; contributionWallet . transfer ( toFund ) ; NewSale ( caller , toFund , tokensGenerated ) ; uint256 toReturn = msg . value . sub ( toFund ) ; if ( toReturn > 0 ) { caller . transfer ( toReturn ) ; Refund ( toReturn ) ; } }",actual method that funds investor and contribution wallet
2562,"function transferFeeIncurred ( uint value ) public view returns ( uint ) { return safeMul_dec ( value , transferFeeRate ) ; }",Calculate the Fee charged on top of a value being sent
2563,function addNewAddress ( address _newAddress ) public ownerOnly { addresses . push ( _newAddress ) ; },Adds new community logic contract address to Registrar
2564,"function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external { require ( locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _beneficiary != address ( 0 ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; _transfer ( depositAddress , _beneficiary , _tokens ) ; }",Called when tokens are bought in token sale
2565,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _amount , this , _extraData ) ) { throw ; } return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender `"
2566,"function doDisableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; if ( _escrow . sellerCanCancelAfter == 0 ) return false ; escrows [ _tradeHash ] . sellerCanCancelAfter = 0 ; emit SellerCancelDisabled ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doDisableSellerCancel + _additionalGas ) ; } return true ; }",Prevents the seller from cancelling an escrow .
2567,"function _investAsBonusProgram ( address _beneficiary , uint256 _amountTokens ) internal { uint256 bonusTokens = _calculateBonus ( _amountTokens , tokensBoughtInBonusProgram ) ; uint256 amountTokensWithBonus = _amountTokens . add ( bonusTokens ) ; tokensBoughtInBonusProgram = tokensBoughtInBonusProgram . add ( _amountTokens ) ; _depositTokens ( _beneficiary , amountTokensWithBonus ) ; emit BoughtBonusProgram ( _beneficiary , _amountTokens , bonusTokens ) ; if ( tokensBoughtInBonusProgram >= INITIAL_BONUSLIST_TOKENS ) { bonusProgramEnded = true ; } }",Internal function for invest as a bonusprogram member
2568,"function updatePlotData ( uint256 plotIndex , string ipfsHash , string url ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; data [ plotIndex ] = PlotData ( ipfsHash , url ) ; }",Updates the data for a specific plot .
2569,"function exitThisIcoForHalfOfTokenPrice ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance >= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( revenue ) ; }",Sell all metadollars for half of a price and exit this ICO
2570,"function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) , ""Amount must be less than or equal to remaining issuable nomins"" ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }",Issue nomins against the sender 's havvens .
2571,"function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) { bytes32 hash = calculateAttributeApprovalHash ( account , msg . sender , attributeTypeID , value , fundsRequired , validatorFee ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; return ( fundsRequired >= minimumStake . add ( jurisdictionFee ) . add ( validatorFee ) && ! _invalidAttributeApprovalHashes [ hash ] && canValidate ( validator , attributeTypeID ) && ! _issuedAttributes [ account ] [ attributeTypeID ] . exists ) ; }",Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .
2572,"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific emoji .
2573,function detach ( ) public { if ( m_state == State . MINTING2PUBLIC_SALES ) { require ( msg . sender == m_sale ) ; m_sale = address ( 0 ) ; } else if ( m_state == State . MINTING2POOLS ) { require ( msg . sender == m_pools ) ; m_pools = address ( 0 ) ; changeState ( State . CIRCULATING_TOKEN ) ; m_SMR . disableMinting ( ) ; assert ( m_SMR . startCirculation ( ) ) ; m_SMR . detachControllerForever ( ) ; } else { revert ( ) ; } },Detach is executed by sale contract or token pools contract
2574,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) public onlyOwner { sellPrice_ = newSellPrice ; buyPrice_ = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
2575,"function collectFee ( address token ) external onlyOwner { uint256 amount = balances [ token ] [ joysoWallet ] ; require ( amount > 0 ) ; balances [ token ] [ joysoWallet ] = 0 ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , joysoWallet , amount , 0 ) ; }","collect the fee to owner 's address , only owner"
2576,function commitPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . commitEndDate ) ; },Checks if the commit period is still active for the specified poll
2581,"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }",Checks if the makeOrder price is reasonable and not manipulative
2582,"function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; idCounter = airdrop . id + 1 ; }",Adds a new airdrop to the smart contract and starts the count down until it is distributed
2585,"function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) throw ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the presale has been funded to the maximum amount
2586,"function getTokenSupply ( Data storage self , string currency ) internal view returns ( uint supply ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; return self . Storage . getUint ( id ) ; }",Get the token supply for a given TokenIO TSM currency symbol ( e.g .
2587,"function claimTokens ( address _claimtoken ) onlyAdmin public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
2588,"function updateDarknodeRegistry ( DarknodeRegistry _newDarknodeRegistry ) external onlyOwner { emit LogDarknodeRegistryUpdated ( darknodeRegistry , _newDarknodeRegistry ) ; darknodeRegistry = _newDarknodeRegistry ; }",Allows the owner to update the address of the DarknodeRegistry contract .
2589,function fundDao ( ) returns ( bool ) ;,Function to fund the Dao with 'msg.sender ' as 'beneficiary '
2590,"function claimReward ( uint _challengeID ) public { Challenge storage challenge = challenges [ _challengeID ] ; require ( challenge . tokenClaims [ msg . sender ] == false ) ; require ( challenge . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID ) ; uint reward = voterReward ( msg . sender , _challengeID ) ; challenge . winningTokens -= voterTokens ; challenge . rewardPool -= reward ; challenge . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }",Claim the tokens owed for the msg.sender in the provided challenge
2591,"function setCustomDisputeFee ( bytes32 question_id , uint256 fee ) onlyOwner public { custom_dispute_fees [ question_id ] = fee ; emit LogSetCustomDisputeFee ( question_id , fee ) ; }",Set a custom fee for this particular question
2593,"function clearInventory ( uint256 _productId ) external onlyCLevel { _clearInventory ( _productId ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }",clearInventory clears the inventory of a product .
2594,function getApproved ( uint256 _tokenId ) external view returns ( address ) ;,Get the approved address for a single NFT
2595,"function setInitialBuyoutPrice ( uint256 _deedId , uint256 price ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( ! identifierToBoughtOutOnce [ _deedId ] ) ; require ( validInitialBuyoutPrice ( _deedId , price ) ) ; identifierToBuyoutPrice [ _deedId ] = price ; SetBuyoutPrice ( _deedId , price ) ; }",Manually set the initial buyout price of a plot .
2597,function isReadyToSynthesize ( uint256 _kydyId ) public view returns ( bool ) { require ( _kydyId > 0 ) ; Kydy storage kyd = kydys [ _kydyId ] ; return _isReadyToSynthesize ( kyd ) ; },Checks if this Kydy is able to synthesize
2598,function takeFee ( uint256 _amount ) external returns ( bool ) ;,Used to withdraw the fee by the factory owner
2599,"function modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) external onlyOwner { require ( bytes ( _ticker ) . length > 0 && bytes ( _ticker ) . length <= 10 , ""Ticker length range (0,10]"" ) ; require ( _expiryDate != 0 && _registrationDate != 0 , ""Dates should not be 0"" ) ; require ( _registrationDate <= _expiryDate , ""Registration date should < expiry date"" ) ; require ( _owner != address ( 0 ) , ""Invalid address"" ) ; string memory ticker = Util . upper ( _ticker ) ; _modifyTicker ( _owner , ticker , _tokenName , _registrationDate , _expiryDate , _status ) ; }",Only allowed to modify the tickers which are not yet deployed .
2600,function setRate ( uint _rateMe ) public ownerOnly { rateMe = _rateMe ; },This function will set the conversion rate .
2602,function multiConfirm ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doConfirmPayment ( _idPayments [ i ] ) ; } },` onlyOwner ` An efficient way to confirm multiple payments
2603,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
2604,"function creditBoardGameRevenues ( GoBoard storage board ) private boardGameEnded ( board ) boardNotPaid ( board ) { uint updatedHostShare = HOST_SHARE ; uint updatedLoserShare = 0 ; uint amountBlack = 0 ; uint amountWhite = 0 ; uint amountCFO = 0 ; uint fullAmount = 1000 ; if ( board . status == BoardStatus . BlackWin || board . status == BoardStatus . WhiteWin ) { if ( board . isHonorableLoss ) { updatedHostShare = HOST_SHARE - HONORABLE_LOSS_BONUS ; updatedLoserShare = HONORABLE_LOSS_BONUS ; } if ( board . status == BoardStatus . BlackWin ) { amountBlack = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountWhite = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . WhiteWin ) { amountWhite = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountBlack = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } amountCFO = board . boardBalance . mul ( updatedHostShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . Draw || board . status == BoardStatus . Canceled ) { amountCFO = 0 ; if ( board . whiteAddress != 0 ) { amountBlack = board . boardBalance . div ( 2 ) ; amountWhite = board . boardBalance . div ( 2 ) ; } else { amountBlack = board . boardBalance ; } } assert ( amountBlack + amountWhite + amountCFO == board . boardBalance ) ; board . boardBalance = 0 ; asyncSend ( board . blackAddress , amountBlack ) ; asyncSend ( board . whiteAddress , amountWhite ) ; asyncSend ( CFO , amountCFO ) ; }","The main function to split game revenues , this is triggered only by changing the game 's state to one of the ending game states ."
2605,"function assignVested ( address _receiver , uint256 _amount , uint64 _start , uint64 _cliff , uint64 _vested , bool _revokable ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) returns ( uint256 ) { require ( vestingsLengths [ _receiver ] < MAX_VESTINGS_PER_ADDRESS , ERROR_TOO_MANY_VESTINGS ) ; require ( _start <= _cliff && _cliff <= _vested , ERROR_WRONG_CLIFF_DATE ) ; uint256 vestingId = vestingsLengths [ _receiver ] ++ ; vestings [ _receiver ] [ vestingId ] = TokenVesting ( _amount , _start , _cliff , _vested , _revokable ) ; _assign ( _receiver , _amount ) ; emit NewVesting ( _receiver , vestingId , _amount ) ; return vestingId ; }","Assign ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens to ` _receiver ` from the Token Manager 's holdings with a ` _revokable : 'revokable ' : `` ` vesting starting at ` @ formatDate ( _start ) ` , cliff at ` @ formatDate ( _cliff ) ` ( first portion of tokens transferable ) , and completed vesting at ` @ formatDate ( _vested ) ` ( all tokens transferable )"
2606,function name ( ) external constant returns ( string _name ) { return name ; },Check the name of the token ~ ERC-20 Standard
2609,"function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( address ( this ) . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( newICO ) ; }",send everything to the new ( fixed ) ico smart contract
2610,"function claim ( ) payable external MinimumBackersClaimed { if ( lastPrice == 0 ) throw ; if ( msg . value == 0 ) throw ; uint discountPrice = lastPrice * discountAmount / divisor ; uint tokenAmount = ( msg . value / discountPrice ) ; if ( tokenAmount + claimedUnits + prepaidUnits > promissoryUnits ) throw ; if ( backers [ msg . sender ] . length == 0 ) { backersAddresses . push ( msg . sender ) ; } backers [ msg . sender ] . push ( backerData ( discountPrice , tokenAmount , sha3 ( msg . sender ) , false , true , 0 ) ) ; claimedUnits += tokenAmount ; TokensClaimedEvent ( msg . sender , backers [ msg . sender ] . length - 1 , discountPrice , tokenAmount ) ; }",` msg.sender.address ( ) ` is Purchasing ` ( msg.value / lastPrice ) .toFixed ( 0 ) ` superDAO Tokens at ` lastPrice `
2613,function setQuestionFee ( uint256 fee ) external { },Function for arbitrator to set an optional per-question fee .
2614,"function setApprovalForAll ( address _operator , bool _approved ) external { ownerOperators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .
2615,"function withdrawMarginPreSigned ( bytes _signature , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( withdrawMarginPreSignedHashing ( address ( this ) , _from , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( _from == from ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; marginBalances [ _from ] = marginBalances [ _from ] . sub ( _value ) . sub ( _fee ) ; require ( tokenContract . transfer ( _from , _value ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; emit WithdrawMargin ( _from , _value ) ; emit WithdrawMarginPreSigned ( _from , msg . sender , _value , _fee ) ; return true ; }",Submit a presigned withdraw to withdraw specified amount of margin
2617,function setMtdAmount ( uint256 mtdAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( mtdAmount != mtdAmountInWei ) ; mtdAmount = mtdAmountInWei ; updatePrices ( ) ; },Set current mtdAmount price in wei for one token
2621,"function unregister ( bytes32 _key , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external returns ( uint ) ;",Only registrations in future can be removed .
2622,"function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }","Used to launch the contract , and enabled token minting"
2624,"function updateAccountSpendingPeriod ( Data storage self , address account ) internal returns ( bool success ) { uint begDate = getAccountSpendingPeriod ( self , account ) ; if ( begDate > now ) { return true ; } else { uint duration = 86400 ; require ( setAccountSpendingPeriod ( self , account , begDate . add ( ( ( now . sub ( begDate ) ) . div ( duration ) . add ( 1 ) ) . mul ( duration ) ) ) , ""Error: Unable to update account spending period."" ) ; return true ; } }",Low-level API to ensure the account spending period is always current
2627,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
2629,"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( msg . sender == address ( this ) ) ; require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
2630,"function transfer ( address to , uint256 amount ) public returns ( bool success ) ;",Send ` amount ` tokens to ` to ` from ` msg.sender `
2631,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
2632,function amountRaised ( ) public constant returns ( uint256 amount ) { },the goal the campaign must reach in order for it to succeed
2634,"function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( admins [ _address ] , ""This address isn't an administrator."" ) ; require ( _address != owner ( ) , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }",Removes the specified address from the list of administrators .
2635,"function close ( Data storage self , uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { address transfer_address ; uint closer_index ; uint counterparty_index ; require ( self . closed == 0 ) ; self . closed = block . number ; closer_index = index_or_throw ( self , msg . sender ) ; self . closing_address = msg . sender ; if ( signature . length == 65 ) { transfer_address = recoverAddressFromSignature ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; counterparty_index = index_or_throw ( self , transfer_address ) ; require ( closer_index != counterparty_index ) ; Participant storage counterparty = self . participants [ counterparty_index ] ; counterparty . nonce = uint64 ( nonce ) ; counterparty . locksroot = locksroot ; counterparty . transferred_amount = transferred_amount ; } }",Close a channel between two parties that was used bidirectionally
2638,function name ( ) external view returns ( string _name ) { return _ERC721name ; },A descriptive name for a collection of NFTs in this contract
2639,function collateral ( address account ) public view returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { balance = balance . add ( escrow . balanceOf ( account ) ) ; } return balance ; },"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued ."
2641,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { testmonedarecipientefinal spender = testmonedarecipientefinal ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
2644,function isRegularAddress ( address _addr ) internal constant returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; },Check whether an address is a regular address or not .
2645,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",Approve transfer of tokens on behalf of _from
2646,function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; },` owner ` can step down and assign some other address to this role
2647,"function _tagsByModules ( address [ ] _modules ) internal view returns ( bytes32 [ ] , address [ ] ) { uint256 counter = 0 ; uint256 i ; uint256 j ; for ( i = 0 ; i < _modules . length ; i ++ ) { counter = counter + IModuleFactory ( _modules [ i ] ) . getTags ( ) . length ; } bytes32 [ ] memory tags = new bytes32 [ ] ( counter ) ; address [ ] memory modules = new address [ ] ( counter ) ; bytes32 [ ] memory tempTags ; counter = 0 ; for ( i = 0 ; i < _modules . length ; i ++ ) { tempTags = IModuleFactory ( _modules [ i ] ) . getTags ( ) ; for ( j = 0 ; j < tempTags . length ; j ++ ) { tags [ counter ] = tempTags [ j ] ; modules [ counter ] = _modules [ i ] ; counter ++ ; } } return ( tags , modules ) ; }",Returns all the tags related to the modules provided
2648,"function signFork ( uint256 number , bytes32 hash ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( block . blockhash ( number ) == hash ) ; delete _nextForkName ; delete _nextForkUrl ; delete _nextForkBlockNumber ; _lastSignedBlockNumber = number ; _lastSignedBlockHash = hash ; _lastSignedTimestamp = block . timestamp ; LogForkSigned ( _lastSignedBlockNumber , _lastSignedBlockHash ) ; }",Declare that the current fork ( as identified by a blockhash ) is the valid fork .
2650,"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operators [ _owner ] [ _operator ] ; }",Returns true if the _operator can transfer the loans of the _owner
2651,"function migrationSetBoard ( bytes32 boardHash , bytes32 name , string boardDescription , uint8 numPlayers , address boardOwner ) isOwner public returns ( bool ) { boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; boards [ boardHash ] . numPlayers = numPlayers ; boards [ boardHash ] . boardOwner = boardOwner ; return true ; }",Write board metadata for migration as contract owner only
2652,"function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }",Removes a pairs of addresses from manual approvals
2653,function unpause ( ) public onlyGameManager whenPaused { require ( nonFungibleContract != address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
2654,"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; walletAddress . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missingFunds , block . timestamp ) ; assert ( receivedWei >= msg . value ) ; }",Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
2656,"function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _createPermission ( _entity , _app , _role , _manager ) ; }","Create a new permission granting ` _entity ` the ability to perform actions requiring ` _role ` on ` _app ` , setting ` _manager ` as the permission 's manager"
2658,function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; emit UpgradedController ( _newControllerAddress ) ; },` onlyOwner ` can upgrade the controller contract
2660,"function blocksList ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) internal pure returns ( uint16 [ ] memory r ) { uint i = 0 ; r = new uint16 [ ] ( countBlocks ( fromX , fromY , toX , toY ) ) ; for ( uint8 ix = fromX ; ix <= toX ; ix ++ ) { for ( uint8 iy = fromY ; iy <= toY ; iy ++ ) { r [ i ] = blockID ( ix , iy ) ; i ++ ; } } }",get an array of all block ids ( i.e .
2661,"function allowance ( address owner , address spender ) public view returns ( uint ) { return tokenState . allowance ( owner , spender ) ; }",Returns the ERC20 allowance of one party to spend on behalf of another .
2662,"function withdrawBonus ( ) external whenNotPaused { require ( releaseDate != 0 ) ; require ( now > releaseDate ) ; uint256 amount = bonusHolders [ msg . sender ] ; require ( amount > 0 ) ; bonusWithdrawn = bonusWithdrawn . add ( amount ) ; bonusHolders [ msg . sender ] = 0 ; require ( bonusCoin . transfer ( msg . sender , amount ) ) ; emit BonusWithdrawn ( msg . sender , amount ) ; }",Enables contributors to withdraw their bonus.The bonus can only be withdrawn after the release date .
2663,function getBond ( bytes32 question_id ) public view returns ( uint256 ) { },Returns the highest bond posted so far for a question
2664,function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit LogAllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; },Used to change the flag true - It refers that time lock is ignored for issuances ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
2667,"function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { return implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] == _contract ; }",Checks whether a contract implements an ERC165 interface or not .
2669,"function insertBefore ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , ""already in list"" ) ; require ( isInList ( self , target ) || target == NULL , ""not in list"" ) ; address prev = self . list [ target ] . previous ; self . list [ newNode ] . next = target ; self . list [ newNode ] . previous = prev ; self . list [ target ] . previous = newNode ; self . list [ prev ] . next = newNode ; self . list [ newNode ] . inList = true ; }",Insert a new node before an existing node .
2670,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _from ) ) ; require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` on behalf of ` _from `
2674,function setJackpotCompleted ( ) public onlyOwner { jackpotCompleted = true ; finalJackpotValue = address ( this ) . balance ; uint256 jackpotShare = ( ( address ( this ) . balance ) . mul ( 20 ) ) . div ( 100 ) ; msg . sender . transfer ( jackpotShare ) ; },set jackpotComplete to true and transfer 20 percent share of jackpot to owner
2676,"function withdrawToken ( uint tokenNumber ) external returns ( bool ) { require ( _ended ) ; require ( ! _coinWithdrawn [ tokenNumber - 1 ] ) ; _coinWithdrawn [ tokenNumber - 1 ] = true ; RareCoin ( _rcContract ) . CreateToken ( _topBids [ tokenNumber - 1 ] . bidderAddress , tokenNumber ) ; return true ; }",Withdraw your RareCoin if you are in the top 100 bidders at the end of the auction
2677,function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; if ( address ( upgradeAgent ) != 0x0 && upgradeAgent . upgradeHasBegun ( ) ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( upgradeAgent . originalSupply ( ) != totalSupply ) throw ; UpgradeAgentSet ( upgradeAgent ) ; },Set address of upgrade target contract and enable upgrade process .
2678,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; },maximum investments to be accepted during the sale ( in euro-cents )
2679,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _isIdle ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }","Transfer a Player owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
2680,"function assignBonus ( address _investor , uint256 _bonus ) internal { if ( _bonus == 0 ) { return ; } bonusProvided = bonusProvided . add ( _bonus ) ; bonusHolders [ _investor ] = bonusHolders [ _investor ] . add ( _bonus ) ; emit BonusAssigned ( _investor , _bonus ) ; }",Assigns bonus tokens to the specific contributor .
2682,"function redeem ( bytes preimage ) public { require ( sha256 ( preimage ) == sha256hash ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; selfdestruct ( msg . sender ) ; }",Transfer to the specified address if anyone can provide the correct preimage .
2683,"function name ( ) public pure returns ( string _deedName ) { _deedName = ""Burnup Tiles"" ; }","Name of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata ."
2684,"function collectTokens ( ) public onlyOwner { uint256 balance = att . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 ) ; uint256 canExtract = total . div ( 2 ) ; if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( att . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }",The Owner will call this method to extract the tokens
2686,"function cancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount , address _feeAsset , uint256 _feeAmount , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { require ( _recoverAddress ( keccak256 ( abi . encodePacked ( ""cancel"" , _offerHash , _feeAsset , _feeAmount ) ) , _v , _r , _s ) == offers [ _offerHash ] . maker , ""Invalid signature"" ) ; _cancel ( _offerHash , _expectedAvailableAmount , _feeAsset , _feeAmount ) ; }",Cancels an offer that was preivously made using ` makeOffer ` .
2687,"function mAllowanceOverride ( address owner , address spender ) internal constant returns ( uint256 allowance ) ;","Allows to override allowance approved by the owner Primary role is to enable forced transfers , do not override if you do not like it Following behavior is expected in the observer approve ( ) - should revert if mAllowanceOverride ( ) > 0 allowance ( ) - should return mAllowanceOverride ( ) if set transferFrom ( ) - should override allowance if mAllowanceOverride ( ) > 0"
2688,"function calculateBoardScore ( uint boardId ) public view returns ( uint8 blackScore , uint8 whiteScore ) { GoBoard storage board = allBoards [ boardId ] ; uint8 [ BOARD_SIZE ] memory boardEmptyGroups ; uint8 maxEmptyGroupId ; ( boardEmptyGroups , maxEmptyGroupId ) = getBoardEmptyGroups ( board ) ; uint8 [ BOARD_SIZE ] memory groupsSize ; uint8 [ BOARD_SIZE ] memory groupsState ; blackScore = 0 ; whiteScore = 0 ; for ( uint8 position = 0 ; position < BOARD_SIZE ; position ++ ) { if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . Black ) { blackScore ++ ; } else if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . White ) { whiteScore ++ ; } else { uint8 groupId = boardEmptyGroups [ position ] ; groupsSize [ groupId ] ++ ; if ( ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) || ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { uint8 [ MAX_ADJACENT_CELLS ] memory adjacentArray = getAdjacentCells ( position ) ; for ( uint8 currAdjacentIndex = 0 ; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray [ currAdjacentIndex ] < MAX_UINT8 ; currAdjacentIndex ++ ) { if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . Black ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . Black ) ; } else if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . White ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . White ) ; } } } } } for ( uint8 currGroupId = 1 ; currGroupId < maxEmptyGroupId ; currGroupId ++ ) { if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { blackScore += groupsSize [ currGroupId ] ; } else if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { whiteScore += groupsSize [ currGroupId ] ; } } return ( blackScore , whiteScore ) ; }","Calculates the board 's score , using area scoring ."
2691,"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
2692,"function issuanceDraft ( address account ) public view returns ( uint ) { uint issued = nominsIssued [ account ] ; if ( issued == 0 ) { return 0 ; } return USDtoHAV ( safeDiv_dec ( issued , issuanceRatio ) ) ; }","The collateral that would be locked by issuance , which can exceed the account 's actual collateral ."
2693,function transferFor ( address _beneficiary ) public onlyOwner vaultUnlocked returns ( bool ) { return _transferTokens ( _beneficiary ) ; },Utility function to actually transfer allocated tokens to their owners .
2694,function getPendingVersion ( ) public view returns ( address ) { return pendingVersion ; },Returns proposed next asset implementation contract address .
2695,"function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _owner , _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }",This is a private function which should be called from user-implemented external burn function .
2697,"function process_contribution ( address _toAddr ) internal { require ( ( campaignState == 2 ) && ( now <= tCampaignEnd ) && ( paused == false ) ) ; require ( msg . value >= minContribution ) ; amountRaised = amountRaised . add ( msg . value ) ; if ( ! participantList [ _toAddr ] . participatedFlag ) { participantList [ _toAddr ] . participatedFlag = true ; joinedCrowdsale . push ( _toAddr ) ; } if ( msg . value >= preCrowdMinContribution ) { participantList [ _toAddr ] . contributedAmountPreCrowd = participantList [ _toAddr ] . contributedAmountPreCrowd . add ( msg . value ) ; RaisedPreCrowd ( _toAddr , msg . value ) ; } else { if ( now <= t_1st_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage1 = participantList [ _toAddr ] . contributedAmountStage1 . add ( msg . value ) ; RaisedStage1 ( _toAddr , msg . value ) ; } else if ( now <= t_2nd_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage2 = participantList [ _toAddr ] . contributedAmountStage2 . add ( msg . value ) ; RaisedStage2 ( _toAddr , msg . value ) ; } else { participantList [ _toAddr ] . contributedAmountStage3 = participantList [ _toAddr ] . contributedAmountStage3 . add ( msg . value ) ; RaisedStage3 ( _toAddr , msg . value ) ; } } uint256 opEth = ( PRCT100_ETH_OP . mul ( msg . value ) ) . div ( 10000 ) ; opVaultAddr . transfer ( opEth ) ; reserveVaultAddr . transfer ( opEth ) ; }","processes the contribution checks campaign state , time window and minimal contribution throws if one of the conditions fails"
2702,"function buyTokensForProposal ( uint _proposalID , address _buyer ) payable returns ( bool ) { if ( _buyer == 0 ) _buyer = msg . sender ; if ( fundings [ _proposalID ] . moderator != 0 ) throw ; return buyTokensFor ( _proposalID , _buyer , now , true ) ; }",Function to buy tokens and promote a proposal
2703,"function transferTokensOut ( address tokenContractAddress , address destination , uint amount ) public ownerOnly returns ( bool result ) { IERC20 token = IERC20 ( tokenContractAddress ) ; return token . transfer ( destination , amount ) ; }",This function allows the community to transfer tokens out of the contract .
2704,"function getAddressAndSharePriceOfFunds ( ) view returns ( address [ ] , uint [ ] , uint [ ] ) { uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; uint sharePrice = fund . calcSharePrice ( ) ; uint creationTime = fund . getCreationTime ( ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = sharePrice ; creationTimes [ i ] = creationTime ; } return ( fundAddrs , sharePrices , creationTimes ) ; }",Returns an array of fund addresses and associated arrays of share prices and creation times
2705,"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific item .
2706,"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = tokens . length . sub ( 1 ) ; }",This is a private function which should be called from user-implemented external mint function .
2707,"function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint payment = m_weiBalances [ payee ] ; uint tokens = m_tokenBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; require ( m_token . allowance ( payee , this ) >= m_tokenBalances [ payee ] ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; m_tokenBalances [ payee ] = 0 ; m_token . transferFrom ( payee , this , tokens ) ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }","withdraw accumulated balance , called by payee in case crowdsale failed"
2709,function getTags ( ) external view returns ( bytes32 [ ] ) ;,Get the tags related to the module factory
2711,"function buy ( ) public payable returns ( uint256 amount ) { uint256 refund = 0 ; debugVal = 0 ; if ( initialSaleComplete ) { uint256 units_to_buy = 0 ; uint256 etherRemaining = msg . value ; uint256 etherToReserve = 0 ; debugVal = fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal2 = RS * msg . value ; debugVal3 = RS * msg . value / 1e18 + fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal4 = ( ln ( debugVal3 , 1 ) - lnS ) ; units_to_buy = debugVal4 ; reserveAddress . transfer ( etherToReserve ) ; mintToken ( msg . sender , amount ) ; refund = etherRemaining ; msg . sender . transfer ( refund ) ; } else { ask = ICOask ; amount = 1e18 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e18 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }",Buys aToken in exchnage for wei at the current ask price
2712,"function burn ( uint256 _value ) onlyOwner ( ) external { require ( _value <= balances [ msg . sender ] ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; tokenTotalSupply = tokenTotalSupply . sub ( _value ) ; emit Burn ( owner , _value ) ; emit Transfer ( owner , address ( 0x0 ) , _value ) ; }",Only owner is allowed to perform this operation .
2716,"function updateOrderbook ( Orderbook _newOrderbookContract ) external onlyOwner { emit LogOrderbookUpdated ( orderbookContract , _newOrderbookContract ) ; orderbookContract = _newOrderbookContract ; }",The owner of the contract can update the Orderbook address .
2717,"function addInterest ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; internalAddInterest ( loan , block . timestamp ) ; }",Updates the loan accumulated interests up to the current Unix time .
2718,"function changeClosingTime ( uint256 _closingTime ) public whenNotPaused onlyAdmin { emit ClosingTimeChanged ( _closingTime , closingTime ) ; closingTime = _closingTime ; }",Adjusts the closing time of the crowdsale .
2720,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = itemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
2722,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` msg.sender `
2726,"function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }",Bringing this in from the Math library as we 've run out of space in TotlePrimary ( see EIP-170 )
2727,function withdrawEther ( uint _value ) external ;,"withdraw ` _value ` of ether to his address , can be called if crowdsale succeeded"
2728,function changeOwner ( address _owner ) public returns ( bool ) ;,Initiate a change of owner to ` _owner `
2730,"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Token price updated!"" ) ; } }",Set current ICO prices in wei for one token
2731,"function transferFrom ( address _owner , address _recipient , uint256 _amount ) public transfersNotFrozen nonZeroAddress ( _recipient ) returns ( bool ) { require ( balances [ _owner ] >= _amount , ""owner does not have enough tokens"" ) ; require ( allowed [ _owner ] [ msg . sender ] >= _amount , ""sender does not have enough allowance"" ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; emit Transfer ( _owner , _recipient , _amount ) ; return true ; }",Used to transfer tokens on behalf of someone else
2732,"function checkPermission ( address [ ] storage _modules , address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( _modules . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < _modules . length ; i ++ ) { if ( IPermissionManager ( _modules [ i ] ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } return false ; }",Validates permissions with PermissionManager if it exists .
2733,function setPriceStalePeriod ( uint time ) external optionalProxy_onlyOwner { priceStalePeriod = time ; },Set the stale period on the updated havven price
2734,"function allocate ( ) public notAllocated endedSale returns ( bool ) { finalAllocation = true ; uint256 totalSupplyCDN = totalTokensSold . mul ( 100 ) . div ( 75 ) ; uint256 foundersAllocation = totalSupplyCDN . div ( 5 ) ; assert ( cnd . generateTokens ( foundersWallet , foundersAllocation ) ) ; uint256 advisorsAllocation = totalSupplyCDN . mul ( 38 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( advisorsWallet , advisorsAllocation ) ) ; uint256 bountyAllocation = totalSupplyCDN . mul ( 12 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( bountyWallet , bountyAllocation ) ) ; return true ; }",This method will can be called by the anybody to make final allocation
2735,"function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( now >= multisigs [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }",Withdraw ether and delete the htlc swap .
2736,"function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; token . transfer ( escapeHatchDestination , balance ) ; EscapeHatchCalled ( _token , balance ) ; }",The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
2737,"function getFundDetails ( address ofVersion ) view returns ( address [ ] , uint [ ] , uint [ ] , bytes32 [ ] ) { Version version = Version ( ofVersion ) ; uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; bytes32 [ ] memory names = new bytes32 [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = fund . calcSharePrice ( ) ; creationTimes [ i ] = fund . getCreationTime ( ) ; names [ i ] = fund . getName ( ) ; } return ( fundAddrs , sharePrices , creationTimes , names ) ; }",Returns an array of fund addresses and associated arrays of share prices and creation times
2738,function removePermission ( bytes4 _methodsignature ) public onlyValidator { permissions [ _methodsignature ] . active = false ; emit PermissionRemoved ( _methodsignature ) ; },Removes a permission the list of permissions .
2740,function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ) { return true ; } return admins [ _address ] ; },Checks if an address is an administrator .
2741,"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",Used to approve a third-party to send funds on your behalf
2742,function setWhitelistedUser ( address _who ) public onlyValidator { _setWhitelistedUser ( _who ) ; },Sets the necessary permissions for a `` whitelisted '' user .
2744,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
2745,"function lockTokensForTradingMarketContract ( address marketContractAddress , uint qtyToLock ) external { uint256 lockedBalance = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . add ( qtyToLock ) ; transfer ( this , qtyToLock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = lockedBalance ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , lockedBalance ) ; }",allows user to lock tokens to enable trading for a given market contract
2747,"function nominsReceivedForEther ( uint amount ) public view returns ( uint ) { uint nominsTransferred = safeMul_dec ( amount , usdToEthPrice ) ; return nomin . amountReceived ( nominsTransferred ) ; }",Calculate how many nomins you will receive if you transfer an amount of ether .
2749,"function setBudget ( address _token , uint256 _amount ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , _amount , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = _amount ; if ( ! settings . hasBudget [ _token ] ) { settings . hasBudget [ _token ] = true ; } emit SetBudget ( _token , _amount , true ) ; }","Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately"
2750,"function addDelegate ( string name , string url , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idDelegate ) { require ( isValidPlugin ( plugin ) ) ; idDelegate = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Delegate , msg . sender , name , url , commitTime , 0 , false , plugin ) ) ; DelegateAdded ( idDelegate ) ; }",Creates a Delegate Admin with the ` msg.sender ` as the Admin addr
2752,"function distribute ( address _to , uint256 _value , uint256 _lockupRate ) public onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _lockupBalances [ _to ] == 0 ) ; require ( _value <= _balances [ owner ] ) ; require ( _lockupRate == 50 || _lockupRate == 100 ) ; _balances [ owner ] = _balances [ owner ] . sub ( _value ) ; uint256 lockupValue = _value . mul ( _lockupRate ) . div ( 100 ) ; uint256 givenValue = _value . sub ( lockupValue ) ; uint256 ExpireTime = now + LOCKUP_TERM ; if ( _lockupRate == 100 ) { ExpireTime += LOCKUP_TERM ; } _balances [ _to ] = _balances [ _to ] . add ( givenValue ) ; _lockupBalances [ _to ] = _lockupBalances [ _to ] . add ( lockupValue ) ; _lockupExpireTime [ _to ] = ExpireTime ; emit Transfer ( owner , _to , _value ) ; return true ; }","If you lock 50 % , the lockout time is six months ."
2754,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return addressToApprovedAll [ _owner ] == _operator ; }",Query if an address is an authorized operator for another address
2755,function getDepositsAmountLeft ( uint _distributionDate ) public view returns ( uint _amount ) { return distributionDeposits [ _distributionDate ] . left ; },Gets an amount of deposits that has left after users ' bonus withdrawals for selected date
2756,"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = person . sellingPrice ; owner = personIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific person .
2757,"function approveMultiple ( address _to , uint256 [ ] _deedIds ) public whenNotPaused { require ( msg . sender != _to ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( _owns ( msg . sender , _deedId ) ) ; _approve ( msg . sender , _to , _deedId ) ; } }",Approve a given address to take ownership of multiple deeds .
2758,"function recoverSigner ( bytes32 message , bytes sig ) public pure returns ( address ) { uint8 v ; bytes32 r ; bytes32 s ; ( v , r , s ) = splitSignature ( sig ) ; return ecrecover ( message , v , r , s ) ; }",recoverSigner Based on a message and signature returns the address
2760,"function getCreator ( uint256 _tokenId ) public view returns ( string creatorName , uint256 sellingPrice , address owner , uint256 collectiblesOrdered ) { Creator storage creator = creators [ _tokenId ] ; creatorName = creator . name ; collectiblesOrdered = creator . collectiblesOrdered ; sellingPrice = creatorIndexToPrice [ _tokenId ] ; owner = creatorIndexToOwner [ _tokenId ] ; }",Returns all the information about Creator token .
2761,"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20Interface token = ERC20Interface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
2762,"function transfer ( address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ msg . sender ] - _value < tokenBalanceOf [ msg . sender ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }",Transfer amount of tokens from own wallet to someone else
2763,"function synthInitiatedExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external onlySynth returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , ""Can't be same synth"" ) ; require ( sourceAmount > 0 , ""Zero amount"" ) ; return _internalExchange ( from , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress , false ) ; }",Function that allows synth contract to delegate exchanging of a synth that is not the same sourceCurrency
2764,"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
2765,"function updateWhitelist ( address _account , uint8 _phase ) public returns ( bool ) { require ( _account != address ( 0 ) ) ; require ( _phase <= 1 ) ; require ( isOps ( msg . sender ) ) ; whitelist [ _account ] = _phase ; emit WhitelistUpdated ( _account , _phase ) ; return true ; }",function to whitelist an address which can be called only by the ops address .
2767,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Function approves ` _addr ` to spend ` _value ` tokens of msg.sender
2768,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
2769,"function beginMotion ( address target ) external returns ( uint ) { require ( ( havven . issuanceLastAverageBalance ( msg . sender ) >= minStandingBalance ) || msg . sender == owner ) ; require ( votingPeriod <= havven . feePeriodDuration ( ) ) ; require ( targetMotionID [ target ] == 0 ) ; require ( ! nomin . frozen ( target ) ) ; havven . rolloverFeePeriodIfElapsed ( ) ; uint motionID = nextMotionID ++ ; motionTarget [ motionID ] = target ; targetMotionID [ target ] = motionID ; uint startTime = havven . feePeriodStartTime ( ) + havven . feePeriodDuration ( ) ; motionStartTime [ motionID ] = startTime ; emit MotionBegun ( msg . sender , target , motionID , startTime ) ; return motionID ; }",Begin a motion to confiscate the funds in a given nomin account .
2771,"function isDepositSkiped ( address _holder , uint _idDeposit ) public constant returns ( bool ) { return skipDeposits [ _holder ] [ _idDeposit ] ; }",Checks to see if a specific deposit has been skipped
2772,"function mint ( address to , uint x , uint y , uint sizeA , uint sizeB , uint256 totalPrice , uint256 actualPrice ) public onlyPlatform ( ) returns ( uint256 ) { require ( to != address ( 0 ) ) ; require ( sizeA . mul ( sizeB ) <= 100 ) ; uint256 inner ; uint256 total ; ( total , inner ) = calculateCounters ( x , y , sizeA , sizeB ) ; uint256 tokenId = ( allMinedTokens . length ) . add ( 1 ) ; Token memory minted = Token ( tokenId , x , y , sizeA , sizeB , totalPrice , actualPrice , 0 , 0 , 0 , inner , total . sub ( inner ) , 0 ) ; copyToAllUnits ( x , y , sizeA , sizeB , tokenId ) ; updateInternalState ( minted , to ) ; return tokenId ; }","Mint new token , not sell new token BE sends : owner , x coordinate , y coordinate , price"
2776,function transferStoreOwnership ( address _newOwner ) external onlyOwner { store . transferOwnership ( _newOwner ) ; },Allows the contract owner to transfer ownership of the DarknodeRegistryStore .
2777,"function safeApprove ( address token , address spender , uint256 amount ) internal { CompatibleERC20 ( token ) . approve ( spender , amount ) ; require ( previousReturnValue ( ) , ""approve failed"" ) ; }",Calls approve on the token and reverts if the call fails .
2779,function changeMultiSigAddress ( address _newAddress ) { require ( multiSigAddress == msg . sender ) ; multiSigAddress = _newAddress ; LogChangeMultiSigAddress ( _newAddress ) ; },This method will change old multi signature address with new one .
2783,"function contest ( address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) external { contestForUser ( msg . sender , _requester , _reward , _requestNonce , _requesterSig ) ; }",Function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId
2784,"function modifySecurityToken ( string _name , string _ticker , address _owner , address _securityToken , string _tokenDetails , uint256 _deployedAt ) external ;",Adds a new custom Security Token and saves it to the registry .
2785,"function safeApprove ( address _spender , uint256 _value ) public returns ( bool ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; require ( approve ( _spender , _value ) ) ; }",Call this only after you decreased the approve to zero using decreaseApproval .
2787,"function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; var ( pricefeed , , ) = Fund ( address ( this ) ) . modules ( ) ; uint fillTakerQuantity = orderValues [ 6 ] ; var ( maxMakerQuantity , makerAsset , maxTakerQuantity , takerAsset ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takerAsset != address ( this ) && makerAsset != address ( this ) ) ; require ( address ( makerAsset ) != address ( takerAsset ) ) ; require ( pricefeed . existsPriceOnAssetPair ( takerAsset , makerAsset ) ) ; require ( fillMakerQuantity <= maxMakerQuantity ) ; require ( fillTakerQuantity <= maxTakerQuantity ) ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( targetExchange , fillTakerQuantity ) ) ; require ( MatchingMarket ( targetExchange ) . buy ( uint ( identifier ) , fillMakerQuantity ) ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }",Takes an active order on the selected exchange
2788,"function createChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) public payable returns ( bytes32 channelId ) { require ( amount + commission >= amount , ""UINT256_OVERFLOW"" ) ; require ( msg . value == amount + commission , ""INACCURATE_MSG_VALUE_SENT"" ) ; _setupChannel ( beneficiary , amount , commission , expiresAt , hashedSecret ) ; }",Creates a Channel to initiate or participate in .
2791,"function allocateUnclaimedFees ( ) pre_cond ( isOwner ( ) ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; }",Converts unclaimed fees of the manager into fund shares
2792,"function getOrders ( uint256 _offset , uint256 _limit ) external view returns ( bytes32 [ ] , address [ ] , uint8 [ ] ) { if ( _offset >= orderbook . length ) { return ; } uint256 limit = _limit ; if ( _offset + limit > orderbook . length ) { limit = orderbook . length - _offset ; } bytes32 [ ] memory orderIDs = new bytes32 [ ] ( limit ) ; address [ ] memory traderAddresses = new address [ ] ( limit ) ; uint8 [ ] memory states = new uint8 [ ] ( limit ) ; for ( uint256 i = 0 ; i < limit ; i ++ ) { bytes32 order = orderbook [ i + _offset ] ; orderIDs [ i ] = order ; traderAddresses [ i ] = orders [ order ] . trader ; states [ i ] = uint8 ( orders [ order ] . state ) ; } return ( orderIDs , traderAddresses , states ) ; }",returns order details of the orders starting from the offset .
2793,"function getKeysFromETHs ( uint256 _gameID , uint256 [ ] memory _eths ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalKeys = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _eths . length , ""Incorrect number of teams"" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _eths [ i ] > 0 ) { _keys [ i ] = getKeysfromETH ( _gameID , i , _eths [ i ] ) ; _totalKeys = _totalKeys . add ( _keys [ i ] ) ; } } return ( _totalKeys , _keys ) ; }",Get all numbers of keys can be bought with amounts of ETH .
2794,"function recoverTokens ( IERC20 token ) public onlyOwner { uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( owner ( ) , balance ) , ""Token transfer failed, transfer() returned false."" ) ; }",Recover tokens accidentally sent to this contract .
2795,function calm ( ) returns ( bool ) ;,Release the contract from a Panic after the panic period has expired .
2796,function createAndJoinCDPAllDai ( ) public returns ( bytes32 id ) { return createAndJoinCDPDai ( dai . balanceOf ( msg . sender ) ) ; },create a CDP from all the Dai in the sender 's balance - needs Dai transfer approval
2797,"function transferFrom ( Data storage self , string currency , address from , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address must not be null."" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , from , getFxUSDAmount ( self , currency , amount ) ) , ""Error: Unable to set account spending amount."" ) ; require ( forceTransfer ( self , currency , from , to , amount , data ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , currency , from , feeContract , fees , getFeeMsg ( self , feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; require ( updateAllowance ( self , currency , from , amount ) , ""Error: Unable to update allowance for spender."" ) ; return true ; }",Transfer an amount of currency token from account to another specified account via an approved spender account
2799,"function purchaseWithPromoter ( address _to , address _ref ) payable public { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; uint _wei = msg . value ; uint cst ; ethSent [ msg . sender ] = ethSent [ msg . sender ] . add ( _wei ) ; ethSold = ethSold . add ( _wei ) ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _wei . mul ( ethRate ) . div ( 12000000 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; if ( _ref == wuguAddr || _ref == richardAddr ) { promoterClients [ _ref ] . push ( _to ) ; promoterBonus [ _ref ] [ _to ] = _wei . mul ( 5 ) . div ( 100 ) ; } } else { cst = _wei . mul ( ethRate ) . div ( 16000000 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }",5 % return must work only on crowdsale
2800,"function decline ( bytes32 _key , bytes32 _votingGroupName ) external returns ( uint ) { if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } if ( ! GroupsAccessManager ( accessManager ) . isUserInGroup ( _votingGroupName , msg . sender ) ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Guard storage _guard = txKey2guard [ _key ] ; if ( _guard . state != GuardState . InProcess ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } if ( _guard . votes [ msg . sender ] . groupName != bytes32 ( 0 ) && ! _guard . votes [ msg . sender ] . accepted ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _policyGroupIndex = _policy . groupName2index [ _votingGroupName ] ; uint _groupDeclinedVotesCount = _guard . declinedCount [ _votingGroupName ] ; if ( _groupDeclinedVotesCount == _policy . participatedGroups [ _policyGroupIndex ] . declineLimit ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } _guard . votes [ msg . sender ] = Vote ( _votingGroupName , false ) ; _guard . declinedCount [ _votingGroupName ] = _groupDeclinedVotesCount + 1 ; uint _alreadyDeclinedCount = _guard . alreadyDeclined + 1 ; _guard . alreadyDeclined = _alreadyDeclinedCount ; ProtectionTxDeclined ( _key , msg . sender , _votingGroupName ) ; if ( _alreadyDeclinedCount == _policy . totalDeclinedLimit ) { _guard . state = GuardState . Decline ; ProtectionTxCancelled ( _key ) ; } return OK ; }",Decline transaction Can be called only by registered user in GroupsAccessManager
2801,"function recomputeLastAverageBalance ( address account ) external returns ( uint ) { updateIssuanceData ( account , nominsIssued [ account ] , nomin . totalSupply ( ) ) ; return issuanceData [ account ] . lastAverageBalance ; }",Recompute and return the given account 's last average balance .
2802,"function prolong ( uint _timeInMins ) external onlyOwner { require ( ! didProlong ) ; require ( now <= deadline - 4 days ) ; uint t = _timeInMins * 1 minutes ; require ( t <= 3 weeks ) ; deadline += t ; length += t ; didProlong = true ; emit Prolonged ( msg . sender , deadline ) ; }",Is going to be called in an extreme case where we need to prolong the ICO ( e.g .
2803,"function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific Pony via transferFrom ( ) .
2804,function ( ) public payable { require ( msg . value != 0 ) ; friendsFingersWallet . transfer ( msg . value ) ; },This is for people who want to donate ETH to FriendsFingers
2805,function getEndPointOfCampaign ( bytes32 bidId ) public view returns ( string url ) { return ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . getCampaignEndPointById ( bidId ) ; },Returns the signing Endpoint of a camapign Function returning the Webservice URL responsible for validating and signing a PoA
2807,"function claimTokens ( token _address ) onlyAdmin public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( admin , remainder ) ; }",Function to claim any token stuck on contract
2809,"function transfer ( address to , uint value , bytes data ) public optionalProxy notFeeAddress ( messageSender ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; synthetix . synthInitiatedFeePayment ( messageSender , currencyKey , fee ) ; return _internalTransfer ( messageSender , to , amountReceived , data ) ; }",Override ERC223 transfer function in order to subtract the transaction fee and send it to the fee pool for SNX holders to claim .
2810,function unlockStatus ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyOwner { lockedAccounts [ _owner ] = false ; _unlockAccount ( _owner ) ; },only the admin is allowed to unlock accounts .
2812,function changeAccountAddressForSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; accountAddressForSponseeAddress = _newAddress ; LogChangeAccountAddressForSponseeAddress ( _newAddress ) ; },This method will change old multi signature for sponsee address with new one .
2813,function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( fundingStartBlock == 0 && fundingEndBlock == 0 ) return State . PrivateFunding ; else if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && tokensSold < tokenCreationMax ) return State . Funding ; else if ( tokensSold >= tokenCreationMin ) return State . Success ; else return State . Failure ; },This manages the crowdfunding state machine We make it a function and do not assign the result to a variable So there is no chance of the variable being stale
2814,function finalizeTokensale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setBarrierAsOpen ( true ) ; token . transferOwnership ( owner ) ; forwardCollectedEther ( ) ; },"ICO End : `` openBarrier '' no longer applied , allows token transfers"
2817,"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( _address != tokenReward ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract
2818,"function isSTOAttached ( ) internal view returns ( bool ) { address _sto ; ( , _sto ) = ISecurityToken ( securityToken ) . getModule ( 3 , 0 ) ; if ( _sto == address ( 0 ) ) return false ; return true ; }",Internal function use to know whether the STO is attached or not
2821,function isPendingDeregistration ( address _darknodeID ) external view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt > currentEpoch . blocknumber ; },Returns if a darknode is in the pending deregistered state .
2822,"function getPeriod ( uint256 _lockTypeIndex , uint256 _timeDifference ) internal view returns ( uint256 ) { if ( _lockTypeIndex == 1 ) { uint256 _period1 = ( _timeDifference . div ( oneMonth ) ) . div ( 12 ) ; if ( _period1 >= 3 ) { _period1 = 3 ; } return _period1 ; } if ( _lockTypeIndex == 2 ) { uint256 _period2 = _timeDifference . div ( oneMonth ) ; if ( _period2 >= 3 ) { _period2 = 3 ; } return _period2 ; } if ( _lockTypeIndex == 3 ) { uint256 _period3 = _timeDifference . div ( oneMonth ) ; if ( _period3 >= 6 ) { _period3 = 6 ; } return _period3 ; } revert ( ) ; }",get time period for the given '_lockTypeIndex '
2823,"function issueAttribute ( address account ) external whenNotPaused whenIssuanceNotPaused { require ( account != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ msg . sender ] . exists == true , ""only organizations may issue attributes"" ) ; uint256 maximum = uint256 ( _organizations [ msg . sender ] . maximumAccounts ) ; require ( _organizations [ msg . sender ] . accounts . length < maximum , ""the organization is not permitted to issue any additional attributes"" ) ; _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == true , ""attribute addition was not accepted by the jurisdiction"" ) ; _organizations [ msg . sender ] . issuedAccounts [ account ] = true ; uint256 index = _organizations [ msg . sender ] . accounts . length ; _organizations [ msg . sender ] . issuedAccountsIndex [ account ] = index ; _organizations [ msg . sender ] . accounts . push ( account ) ; emit AttributeIssued ( msg . sender , account ) ; }",Add an attribute to account ` account ` .
2826,function numVestingEntries ( address account ) public view returns ( uint ) { return vestingSchedules [ account ] . length ; },The number of vesting dates in an account 's schedule .
2828,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , increaseApprovalSig , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( allowed [ from ] [ _spender ] . add ( _addedValue ) . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
2835,function getSecretRevealBlockHeight ( bytes32 secrethash ) public view returns ( uint256 ) { return secrethash_to_block [ secrethash ] ; },Get the stored block number at which the secret was revealed .
2836,"function updateRewardPercentageByIndex ( uint256 _index , uint256 _percentage ) public onlyAdmin isValidRewardIndex ( _index ) isValidRewardPercentage ( _percentage ) { rewardPercentage [ _index ] = _percentage ; emit RewardPercentage ( _index , _percentage ) ; }","Edits the contents of the percentage array , with the specified parameters ."
2837,function changeMinimumBetAmount ( uint newMinimumBetAmount ) external onlyOwner { if ( newMinimumBetAmount > 0 ) { minimumBetAmount = newMinimumBetAmount ; } },Changes the minimum amount needed to place a bet
2838,"function ownerUnlock ( address target , uint256 amount ) onlyOwner public returns ( bool res ) { require ( lockedAmount [ target ] >= amount ) ; balanceOf [ target ] += amount ; lockedAmount [ target ] -= amount ; OwnerUnlock ( target , amount ) ; return true ; }",cotnract owner unlock some token for target address despite of time
2839,"function authorizeSpender ( address _spender , bool _authorize ) onlyOwner external { allowedSpenders [ _spender ] = _authorize ; emit SpenderAuthorization ( _spender , _authorize ) ; }",` onlyOwner ` Adds a spender to the ` allowedSpenders [ ] ` white list
2841,function changeSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; },This method will change old sponsee address with new one .
2844,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
2846,function isWhitelisted ( address _investor ) public onlyOwner constant returns ( bool ) { return canPurchase [ _investor ] ; },Notifies if an investor is whitelisted for contribution
2847,"function setWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != wallet ) ; address oldAddress = wallet ; wallet = _walletAddress ; emit WalletAddressChanged ( oldAddress , _walletAddress ) ; }",Change the wallet where ether will be sent to when tokens are bought
2848,"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E95 ) , _newCFO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCFO
2850,"function transfer ( address _to , uint256 _deedId ) external ;",Transfer a deed to a new owner .
2851,"function SetPresaleAmountLimits ( uint _minPresaleAmount , uint _maxPresaleAmount ) ;",Function used by the creator to set the presale limits
2852,function tokenMinter ( uint256 _amount ) private returns ( bool minted ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; require ( balances [ owner ] . add ( _amount ) > 0 ) ; require ( balances [ owner ] . add ( _amount ) > balances [ owner ] ) ; return true ; },Low level function Used to create new tokens and increase total supply
2853,"function setPreICOSoldAmount ( uint256 _soldTokens , uint256 _raisedWei ) onlyOwner beforeICO public { tokensSold = tokensSold . add ( _soldTokens ) ; totalWeiRaised = totalWeiRaised . add ( _raisedWei ) ; }",Sets how many tokens have we sold in PRE-ICO phase
2855,"function instantiate ( bytes _bytecode , bytes _args ) public payable returns ( address contractAddress ) { require ( bytecodeHash == keccak256 ( _bytecode ) ) ; bytes memory calldata = abi . encodePacked ( _bytecode , _args ) ; assembly { contractAddress := create ( 0 , add ( calldata , 0x20 ) , mload ( calldata ) ) } if ( contractAddress == address ( 0 ) ) { revert ( ""Cannot instantiate contract"" ) ; } else { Contract c = Contract ( contractAddress ) ; require ( c . supportsInterface ( 0x01ffc9a7 ) ) ; require ( c . supportsInterface ( 0x6125ede5 ) ) ; if ( price > 0 ) { require ( msg . value == price ) ; beneficiary . transfer ( msg . value ) ; } emit Instantiated ( msg . sender , contractAddress ) ; } }",` msg.sender ` is passed as first argument for the newly created ` Contract ` .
2856,"function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }",start voting at ` startBlockNr ` for ` durationHrs ` .
2859,"function burnFromWithData ( address _from , uint256 _value , bytes _data ) external ;",Used to burn the securityToken on behalf of someone else
2860,"function paymentRegularTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 regularTokensAvailable = balances [ msg . sender ] ; if ( regularTokensAvailable >= _amount ) { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } else { if ( regularTokensAvailable > 0 ) { uint256 amountOfRewardsTokens = _amount . sub ( regularTokensAvailable ) ; paymentMixed ( regularTokensAvailable , amountOfRewardsTokens , _rewardPercentageIndex ) ; } else { paymentRewardTokens ( _amount ) ; } } }",Process a payment that prioritizes the use of regular tokens .
2862,"function execute ( address _to , uint _value , bytes _data ) returns ( uint8 ) ;",Send a transaction to ` _to ` containing ` _value ` with RLP encoded arguments of ` _data `
2863,"function setFee ( address stablecoin , uint256 _newFee ) public onlyOwner whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; tokenStorage_CD . setFee ( stablecoin , _newFee ) ; }",Change fees associated with going from CarbonUSD to a particular stablecoin .
2864,"function splitProfits ( ) external { require ( splitInService ) ; bytes memory empty ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits , empty ) ; } } }",Split the monthly profits of the Casino to the users
2865,"function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit LogChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }",used to change the fee of the usage cost
2866,"function transferFromFrozenAccount ( address _from , address _to , uint256 _amount ) external onlyOwner whenNotPaused whenAccountFrozen ( _from ) whenAccountNotFrozen ( _to ) whenAccountNotFrozen ( msg . sender ) { super . doSend ( msg . sender , _from , _to , _amount , """" , """" , true ) ; }",super.doSend to skip `` _from '' frozen checking
2867,"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }",Use and override this function with caution .
2868,function confirmPrintProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmPrint ( _lockId ) ; },"Pass-through control of print confirmation , allowing this contract 's custodian to act as the custodian of the associated active token implementation ."
2869,"function withdrawDAI ( address _receiver , uint _amount ) public onlyArbitrator { require ( _receiver != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . balanceOf ( address ( this ) ) >= _amount ) ; DAI . transfer ( _receiver , _amount ) ; emit DAIWithdrawn ( _receiver , _amount ) ; }",this function lets arbitrator withdraw DAI to the provided address
2870,"function reportAnswer ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) onlyInitialized public { IMarket market = realitio_questions [ question_id ] . augur_market ; require ( realitio_questions [ question_id ] . bounty > 0 , ""Arbitration must have been requested for this question"" ) ; bool is_answered ; bytes32 last_answer ; _verifyInput ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; ( is_answered , last_answer ) = _answerData ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; require ( market . isFinalized ( ) , ""The augur market must have been finalized"" ) ; bytes32 answer = realitioAnswerFromAugurMarket ( market ) ; address winner ; if ( is_answered && last_answer == answer ) { winner = last_answerer ; } else { winner = realitio_questions [ question_id ] . disputer ; } realitio . submitAnswerByArbitrator ( question_id , answer , winner ) ; address owner = realitio_questions [ question_id ] . owner ; balanceOf [ owner ] += realitio_questions [ question_id ] . bounty ; delete realitio_questions [ question_id ] ; }",Report the answer from a finalized Augur market to a Realitio contract with a question awaiting arbitration
2872,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _spender ) ) ; if ( balances [ msg . sender ] >= _value ) { approved [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; } return false ; }",Approve ` _value ` tokens for ` _spender `
2873,"function ( ) public payable { if ( msg . sender != address ( exchange ) ) { errorReporter . revertTx ( ""An address other than the exchange cannot send ether to EDHandler fallback"" ) ; } }",payable fallback to allow the exchange to return ether directly to this contract
2874,"function finalizeAndPayoutForHopeful ( uint withId , uint payoutQuantity , uint finalSharePrice , uint finalCompetitionRank ) pre_cond ( isOracle ( ) ) pre_cond ( hopefuls [ withId ] . isDisqualified == false ) pre_cond ( block . timestamp >= endTime ) { hopefuls [ withId ] . finalSharePrice = finalSharePrice ; hopefuls [ withId ] . finalCompetitionRank = finalCompetitionRank ; hopefuls [ withId ] . payoutQuantity = payoutQuantity ; require ( MELON_CONTRACT . transfer ( hopefuls [ withId ] . registrant , payoutQuantity ) ) ; }","Closing oracle service , inputs final stats and triggers payouts"
2875,"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { require ( module . pricefeed . hasRecentPrice ( address ( QUOTE_ASSET ) ) ) ; require ( module . pricefeed . hasRecentPrices ( ownedAssets ) ) ; var ( isRecent , , ) = module . pricefeed . getInvertedPrice ( address ( QUOTE_ASSET ) ) ; Request request = requests [ id ] ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePrice ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { if ( ! isInAssetList [ address ( QUOTE_ASSET ) ] ) { ownedAssets . push ( address ( QUOTE_ASSET ) ) ; isInAssetList [ address ( QUOTE_ASSET ) ] = true ; } request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }","Executes active investment and redemption requests , in a way that minimises information advantages of investor"
2876,"function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 50 ) . div ( 50 ) ; lock ( 0xf03eb5eD89Da5ccAC43498A2C56434e30505AB09 , totalProjectToken . mul ( 90 ) . div ( 100 ) , now ) ; lock ( 0xCAF7149Ef61E54F72ACdC7f44a05E5d7D1Db134B , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }","BXN Allocation - finalize crowdfunding & time-locked vault of tokens allocated to BXN company , developers and Airdrop program ."
2879,"function adminImportOldMEBlock ( uint8 x , uint8 y ) external onlyOwner { ( uint id , address newLandlord ) = market . importOldMEBlock ( x , y ) ; emit LogBuys ( id , x , y , x , y , newLandlord ) ; }",import blocks from previous version Million Ether Homepage
2882,"function canValidate ( address validator , uint256 attributeTypeID ) internal view returns ( bool ) { return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }",Internal function to determine if a validator at account ` validator ` can issue attributes of the type with ID ` attributeTypeID ` .
2883,"function registerConsumer ( address aconsumer , uint32 auserID ) onlyOwner external { if ( auserID != 0 ) { emit consumerRegistered ( aconsumer ) ; } else { emit consumerDeregistered ( aconsumer ) ; } consumers [ aconsumer ] = auserID ; }",Allow the owner of the address ` aconsumer.address ( ) ` to make transactions on behalf of user id ` auserID ` .
2885,"function _check ( uint8 _fundraiseType ) internal { require ( _fundraiseType == 0 || _fundraiseType == 1 , ""Not a valid fundraise type"" ) ; if ( _fundraiseType == 0 ) { fundraiseType = FundraiseType . ETH ; } if ( _fundraiseType == 1 ) { require ( address ( polyToken ) != address ( 0 ) , ""Address of the polyToken should not be 0x"" ) ; fundraiseType = FundraiseType . POLY ; } }",Internal function used to check the type of fund raise currency
2886,function changeAPTController ( address _newController ) public onlyController { apt . changeController ( _newController ) ; },"The owner of this contract can change the controller of the APT token Please , be sure that the owner is a trusted agent or 0x0 address ."
2888,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MisToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
2889,"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ; }",Hash ( keccak256 ) of the payload used by setCOO
2892,"function makeOffer ( address _maker , address _offerAsset , address _wantAsset , uint256 _offerAmount , uint256 _wantAmount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerAmount > 0 && _wantAmount > 0 , ""Invalid amounts"" ) ; require ( _offerAsset != _wantAsset , ""Invalid assets"" ) ; bytes32 offerHash = keccak256 ( abi . encodePacked ( ""makeOffer"" , _maker , _offerAsset , _wantAsset , _offerAmount , _wantAmount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( offerHash , _v , _r , _s ) == _maker , ""Invalid signature"" ) ; _validateAndAddHash ( offerHash ) ; _decreaseBalanceAndPayFees ( _maker , _offerAsset , _offerAmount , _feeAsset , _feeAmount , ReasonMakerGive , ReasonMakerFeeGive , ReasonMakerFeeReceive ) ; Offer storage offer = offers [ offerHash ] ; offer . maker = _maker ; offer . offerAsset = _offerAsset ; offer . wantAsset = _wantAsset ; offer . offerAmount = _offerAmount ; offer . wantAmount = _wantAmount ; offer . availableAmount = _offerAmount ; offer . nonce = _nonce ; emit Make ( _maker , offerHash ) ; }",Makes an offer which can be filled by other users .
2893,function isTokenEscapable ( address _token ) constant public returns ( bool ) { return ! escapeBlacklist [ _token ] ; },Checks to see if ` _token ` is in the blacklist of tokens
2895,function getApproved ( uint256 _tokenId ) external view returns ( address ) { return tokenApprovals [ _tokenId ] ; },Get the approved address for a single NFT
2897,"function extractAddress ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= _data . length , ""offset value should be in the correct range"" ) ; assembly { m := and ( mload ( add ( _data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }",Extracts an address from a bytes at a given position .
2899,function ownerWithdraw ( uint256 _value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( ! owner . send ( _value ) ) revert ( ) ; },"The owner can withdraw ethers already during pre sale , only if the minimum funding level has been reached"
2900,"function getCodeToken ( uint256 _tokenId ) public view returns ( string codetokenName , uint256 sellingPrice , address owner ) { Code storage codetoken = codetokens [ _tokenId ] ; codetokenName = codetoken . name ; sellingPrice = codetokenIndexToPrice [ _tokenId ] ; owner = codetokenIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific codetoken .
2901,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = DISTRIBUTE ; allPermissions [ 1 ] = MANAGE ; return allPermissions ; },Return the permissions flag that are associated with this module
2904,function _onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; },Internal function used to check whether the investor is in the whitelist or not & also checks whether the KYC of investor get expired or not
2905,"function _adjustTotalSupplyCheckpoints ( ) internal { TokenLib . adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) , currentCheckpointId ) ; }",Internal - adjusts totalSupply at checkpoint after minting or burning tokens
2906,function changeController ( address _newController ) public onlyController { msp . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The controller of this contract can change the controller of the MSP token Please , be sure that the controller is a trusted agent or 0x0 address ."
2907,function setIcoContractAddress ( address contractAddress ) public onlyOwner { freezeBypassing [ contractAddress ] = true ; icoContractAddress = contractAddress ; },Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .
2909,function getOracle ( ) public view returns ( address ) { return owners [ 1 ] ; },Gets oracle address that is used to confirm txs .
2910,"function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; require ( token . transfer ( escapeHatchDestination , balance ) ) ; EscapeHatchCalled ( _token , balance ) ; }",The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
2912,"function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }",Transfer tokens from an address to another one through an allowance made before
2914,function capReached ( ) public view returns ( bool ) { return tokensSold >= cap ; },Checks whether the cap has been reached .
2915,"function getExtraPoints ( uint96 extras , Extras extraStats ) private pure returns ( uint16 extraPoints ) { uint16 interceptions = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 missedFieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 overtimes = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 sacks = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fumbles = uint16 ( extras & EXTRA_STATS_MASK ) ; if ( interceptions == extraStats . interceptions ) { extraPoints += 6 ; } if ( missedFieldGoals == extraStats . missedFieldGoals ) { extraPoints += 6 ; } if ( overtimes == extraStats . overtimes ) { extraPoints += 6 ; } if ( sacks == extraStats . sacks ) { extraPoints += 6 ; } if ( fieldGoals == extraStats . fieldGoals ) { extraPoints += 6 ; } if ( fumbles == extraStats . fumbles ) { extraPoints += 6 ; } }",calculates points won by yellow and red cards predictions
2919,"function _callERC165SupportsInterface ( address account , bytes4 interfaceId ) private view returns ( bool success , bool result ) { bytes memory encodedParams = abi . encodeWithSelector ( _InterfaceId_ERC165 , interfaceId ) ; assembly { let encodedParams_data := add ( 0x20 , encodedParams ) let encodedParams_size := mload ( encodedParams ) let output := mload ( 0x40 ) mstore ( output , 0x0 ) success := staticcall ( 30000 , account , encodedParams_data , encodedParams_size , output , 0x20 ) result := mload ( output ) } }",Calls the function with selector 0x01ffc9a7 ( ERC165 ) and suppresses throw
2920,"function transferVoteController ( address _voteController ) public onlyCurator { voteController = _voteController ; logger . emitGenericLog ( ""transferVoteController"" , """" ) ; }",Sets vote controller to input vote controller address
2922,"function setLocation ( uint index , uint _location ) onlyOwner public { require ( index < locations . length ) ; locations [ index ] = _location ; }",Admin function to update the location at ` index `
2923,"function getMovie ( uint256 _tokenId ) public view returns ( string movieName , uint256 sellingPrice , address owner ) { Movie storage movie = movies [ _tokenId ] ; movieName = movie . name ; sellingPrice = movieIndexToPrice [ _tokenId ] ; owner = movieIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific movie .
2924,"function createPromoSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createPromoCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }",Creates a new Collectible and creates an auction for it .
2925,"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; uint256 length = tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = length - 1 ; }",This is a private function which should be called from user-implemented external mint function .
2927,function withdraw ( ) returns ( uint8 ) ;,Initiate a withdrawal of the holder 's ` etherBalance ` Follow up with sendPending ( ) once the timelock has expired
2929,"function getPizza ( uint256 _tokenId ) public view returns ( string pizzaName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Pizza storage pizza = pizzas [ _tokenId ] ; pizzaName = pizza . name ; sellingPrice = pizzaIndexToPrice [ _tokenId ] ; owner = pizzaIndexToOwner [ _tokenId ] ; previousPrice = pizzaIndexToPreviousPrice [ _tokenId ] ; previousOwners = pizzaIndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific pizza .
2930,"function convert ( address fromAsset , address toAsset , uint amount ) public notDeprecated returns ( bool success ) { string memory currency = getAssetCurrency ( fromAsset ) ; uint fromDecimals = ERC20Interface ( fromAsset ) . decimals ( ) ; uint toDecimals = ERC20Interface ( toAsset ) . decimals ( ) ; require ( isAllowedAsset ( fromAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; require ( isAllowedAsset ( toAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; if ( isTokenXContract ( toAsset , currency ) ) { require ( ERC20Interface ( fromAsset ) . transferFrom ( msg . sender , address ( this ) , amount ) , 'Error: Unable to transferFrom your asset holdings. Please ensure this contract has an approved allowance equal to or greater than the amount called in transferFrom method.' ) ; uint netAmountFrom = amount . sub ( calcAssetFees ( fromAsset , amount ) ) ; uint convertedAmountFrom = ( netAmountFrom . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; require ( lib . deposit ( lib . getTokenSymbol ( toAsset ) , msg . sender , convertedAmountFrom , 'Token, Inc.' ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; } else if ( isTokenXContract ( fromAsset , currency ) ) { uint convertedAmount = ( amount . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; uint fees = calcAssetFees ( toAsset , convertedAmount ) ; uint netAmountTo = convertedAmount . sub ( fees ) ; require ( ERC20Interface ( toAsset ) . transfer ( msg . sender , netAmountTo ) , 'Unable to call the requested erc20 contract.' ) ; require ( lib . withdraw ( lib . getTokenSymbol ( fromAsset ) , msg . sender , amount , 'Token, Inc.' ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; } else { revert ( 'Error: At least one asset must be issued by Token, Inc. (Token X).' ) ; } emit StableSwap ( fromAsset , toAsset , msg . sender , amount , currency ) ; return true ; }",Amounts will always be passed in according to the decimal representation of the ` fromAsset ` token ;
2931,"function execute ( address seller , uint256 quantity , uint256 price ) public payable { require ( enforceKyc == false || ( isAllowedTrade ( msg . sender ) && isAllowedTrade ( seller ) ) , ""Buyer and Seller must be approved to trade on this exchange."" ) ; TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , ""Buy price does not match the listed sell price."" ) ; require ( block . timestamp < order . expiry , ""Sell order has expired."" ) ; require ( price >= sellFloor , ""The bid is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The bid is above the maximum allowed."" ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; order . quantity = order . quantity . sub ( tradeQuantity ) ; if ( order . quantity == 0 ) { order . price = 0 ; order . expiry = 0 ; } orderBook [ seller ] = order ; uint256 cost = tradeQuantity . wmul ( order . price ) ; require ( msg . value >= cost , ""You did not send enough Ether to purchase the tokens."" ) ; uint256 etherFee = calculateFee ( cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }",Buy tokens from an existing sell order .
2934,"function requestCeilingRaise ( uint256 _raiseBy ) public returns ( bytes32 lockId ) { require ( _raiseBy != 0 ) ; lockId = generateLockId ( ) ; pendingRaiseMap [ lockId ] = PendingCeilingRaise ( { raiseBy : _raiseBy } ) ; emit CeilingRaiseLocked ( lockId , _raiseBy ) ; }",Requests an increase to the supply ceiling .
2935,"function isSenderApprovedFor ( uint256 _tokenId ) internal view returns ( bool ) { return ownerOf ( _tokenId ) == msg . sender || isSpecificallyApprovedFor ( msg . sender , _tokenId ) || isApprovedForAll ( ownerOf ( _tokenId ) , msg . sender ) ; }",Tells whether the msg.sender is approved to transfer the given token ID or not Checks both for specific approval and operator approval
2938,"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
2940,"function revokeAttribute ( address account ) external whenNotPaused { require ( account != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ msg . sender ] . exists == true , ""only organizations may revoke attributes"" ) ; require ( _organizations [ msg . sender ] . issuedAccounts [ account ] && _organizations [ msg . sender ] . accounts . length > 0 , ""the organization is not permitted to revoke an unissued attribute"" ) ; _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == false , ""attribute revocation was not accepted by the jurisdiction"" ) ; uint256 lastIndex = _organizations [ msg . sender ] . accounts . length - 1 ; address lastAccount = _organizations [ msg . sender ] . accounts [ lastIndex ] ; uint256 indexToDelete = _organizations [ msg . sender ] . issuedAccountsIndex [ account ] ; _organizations [ msg . sender ] . accounts [ indexToDelete ] = lastAccount ; _organizations [ msg . sender ] . issuedAccountsIndex [ lastAccount ] = indexToDelete ; _organizations [ msg . sender ] . accounts . length -- ; delete _organizations [ msg . sender ] . issuedAccounts [ account ] ; emit AttributeRevoked ( msg . sender , account ) ; }",Revoke an attribute from account ` account ` .
2941,"function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validators may revoke arbitrary attributes"" ) ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ account ] [ attributeTypeID ] . setPersonally ) { refundAddress = account ; } else { address operator = _issuedAttributes [ account ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { uint256 transactionGas = 37700 ; uint256 transactionCost = transactionGas . mul ( tx . gasprice ) ; if ( stake > transactionCost ) { if ( refundAddress . send ( stake . sub ( transactionCost ) ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake . sub ( transactionCost ) ) ; } if ( tx . origin . send ( transactionCost ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , transactionCost ) ; } } else if ( stake > 0 && address ( this ) . balance >= stake ) { if ( tx . origin . send ( stake ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , stake ) ; } } } }",Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
2942,"function getAmountToGive ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { uint256 availableVolume = exchange . availableVolume ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; amountToGive = getPartialAmount ( availableVolume , SafeMath . sub ( 1 ether , data . exchangeFee ) , 1 ether ) ; }",Gets the amount that Totle needs to give for this order
2944,"function approveAndCall ( address spender , uint256 value , bytes extraData ) returns ( bool success ) { tokenRecipient recSpender = tokenRecipient ( spender ) ; if ( approve ( spender , value ) ) { recSpender . receiveApproval ( msg . sender , value , this , extraData ) ; return true ; } }",Approve and then communicate the approved contract in a single tx
2948,function setSaleAuctionAddress ( address _address ) external onlyCEO { SaleClockAuction candidateContract = SaleClockAuction ( _address ) ; require ( candidateContract . isSaleClockAuction ( ) ) ; saleAuction = candidateContract ; },The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .
2949,"function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; feeInCirculation = SafeMath . sub ( feeInCirculation , _value ) ; Burn ( msg . sender , _value ) ; }",To eliminate tokens and adjust the price of the FEE tokens
2950,"function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }",Removes a pairs of addresses from manual approvals
2952,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { }",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
2954,function issuanceIsPaused ( ) public view returns ( bool ) { return _issuancePaused ; },Determine if attribute issuance is currently paused .
2955,"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Airdrop was NOT added"" ) ; }",Distributes a constant quantity of tokens to all the specified addresses .
2957,"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
2958,"function initialMint ( uint256 _cap ) internal { uint256 halfCap = _cap . div ( 2 ) ; token . mint ( this , halfCap ) ; token . mint ( beneficiary , _cap . sub ( halfCap ) ) ; }",Directly mints half of value and vests the other healf for the same beneficiary .
2959,"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( question_id , answer_hash , msg . value ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction ."
2961,"function setTokenFrozenBalance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setUint ( id , amount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set the frozen token balance for a given account
2963,"function updateRenExSettlementContract ( RenExSettlement _newSettlementContract ) external onlyOwner { emit LogRenExSettlementContractUpdated ( settlementContract , _newSettlementContract ) ; settlementContract = _newSettlementContract ; }",Allows the owner of the contract to update the address of the RenExSettlement contract .
2964,"function getRichToken ( uint256 _tokenId ) public view returns ( string richtokenName , uint256 sellingPrice , address owner ) { Rich storage richtoken = richtokens [ _tokenId ] ; richtokenName = richtoken . name ; sellingPrice = richtokenIndexToPrice [ _tokenId ] ; owner = richtokenIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific richtoken .
2965,"function getColor ( uint256 _tokenId ) public view returns ( uint256 R , uint256 G , uint256 B , string colorName , uint256 sellingPrice , address owner ) { Color storage col = colors [ _tokenId ] ; R = col . R ; G = col . G ; B = col . B ; colorName = col . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific color .
2966,"function approve ( address _spender , uint256 _value ) public ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
2967,"function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount ) public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _token != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , ""Unable to transfer tokens for dividend"" ) ; uint256 dividendIndex = dividends . length ; uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupply ( ) ; dividends . push ( Dividend ( checkpointId , now , _maturity , _expiry , _token , _amount , 0 , currentSupply , false ) ) ; emit ERC20DividendDeposited ( msg . sender , checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex ) ; }",Creates a dividend and checkpoint for the dividend
2968,"function votingEndsInHHMM ( ) constant returns ( uint8 , uint8 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint8 ( tsec / 1 hours ) , uint8 ( tsec % 1 hours / 1 minutes ) ) ; }","return voting remaining time ( hours , minutes ) ."
2971,function getApproved ( uint256 _tokenId ) external view canBeStoredIn40Bits ( _tokenId ) returns ( address ) { require ( _tokenId <= _totalSupply ( ) ) ; if ( cutieIndexToApproved [ uint40 ( _tokenId ) ] != address ( 0 ) ) { return cutieIndexToApproved [ uint40 ( _tokenId ) ] ; } address owner = cutieIndexToOwner [ uint40 ( _tokenId ) ] ; return addressToApprovedAll [ owner ] ; },Get the approved address for a single NFT
2972,"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] [ lastTokenIndex ] = 0 ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }",Use and override this function with caution .
2975,"function requestCosign ( Engine engine , uint256 index , bytes data , bytes oracleData ) public returns ( bool ) { Mortgage storage mortgage = mortgages [ uint256 ( readBytes32 ( data , 0 ) ) ] ; require ( mortgage . engine == engine , ""Engine does not match"" ) ; require ( mortgage . loanId == index , ""Loan id does not match"" ) ; require ( mortgage . status == Status . Pending , ""Mortgage is not pending"" ) ; mortgage . status = Status . Ongoing ; _generate ( uint256 ( readBytes32 ( data , 0 ) ) , mortgage . owner ) ; uint256 loanAmount = convertRate ( engine . getOracle ( index ) , engine . getCurrency ( index ) , oracleData , engine . getAmount ( index ) ) ; require ( rcn . transferFrom ( mortgage . owner , this , loanAmount ) , ""Error pulling RCN from borrower"" ) ; uint256 boughtMana = convertSafe ( mortgage . tokenConverter , rcn , mana , loanAmount ) ; delete mortgage . tokenConverter ; uint256 currentLandCost ; ( , , currentLandCost , ) = landMarket . auctionByAssetId ( mortgage . landId ) ; require ( currentLandCost <= mortgage . landCost , ""Parcel is more expensive than expected"" ) ; require ( mana . approve ( landMarket , currentLandCost ) ) ; flagReceiveLand = mortgage . landId ; landMarket . executeOrder ( mortgage . landId , currentLandCost ) ; require ( mana . approve ( landMarket , 0 ) ) ; require ( flagReceiveLand == 0 , ""ERC721 callback not called"" ) ; require ( land . ownerOf ( mortgage . landId ) == address ( this ) , ""Error buying parcel"" ) ; uint256 totalMana = boughtMana . add ( mortgage . deposit ) ; require ( mana . transfer ( mortgage . owner , totalMana . sub ( currentLandCost ) ) , ""Error returning MANA"" ) ; require ( mortgage . engine . cosign ( index , 0 ) , ""Error performing cosign"" ) ; mortgageByLandId [ mortgage . landId ] = uint256 ( readBytes32 ( data , 0 ) ) ; emit StartedMortgage ( uint256 ( readBytes32 ( data , 0 ) ) ) ; return true ; }",Request the cosign of a loan Buys the parcel and locks its ownership until the loan status is resolved .
2976,"function removeBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , ""Blacklist token destruction not supported by token"" ) ; removeUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogRemovedBlacklistDestroyer ( _who ) ; }",Removes the necessary permissions for a user to destroy tokens from a blacklisted account .
2978,"function collectionTotal ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionTokens [ _collectionIndex ] . length ; }",Get the total number of PixelCons in collection # ` ( _collectionIndex ) `
2979,function getHolderId ( address _holder ) public view returns ( uint ) { return holderIndex [ _holder ] ; },Returns holder id for the specified address .
2981,function setAdsStorageAddress ( address _addrStorage ) external onlyOwnerOrAllowed { reset ( ) ; advStorageContract = _addrStorage ; },Sets the Storage contract address used by the allowed contract The Storage contract address is mostly used as part of a failsafe mechanism to ensure contract upgrades are executed using the same Storage contract .
2982,"function div ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a / b ; return c ; }","Integer division of two numbers , truncating the quotient ."
2983,"function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( address ( this ) ) ; _address . transfer ( _to , remainder ) ; }",Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
2984,function getValidators ( ) external view returns ( address [ ] ) { return _validatorAccounts ; },Get the accounts of all available validators on the jurisdiction .
2985,function createCheckpoint ( ) external returns ( uint256 ) ;,Creates a checkpoint that can be used to query historical balances / totalSuppy
2988,function changeController ( address _newController ) public onlyOwner { snt . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The owner of this contract can change the controller of the SNT token Please , be sure that the owner is a trusted agent or 0x0 address ."
2989,function getValidatorInformation ( address validator ) external view returns ( string description ) ;,Get a description of the validator at account ` validator ` .
2992,"function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . withdraw ( currency , account , amount , issuerFirm ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; return true ; }",Withdraws a specified amount of tokens of a given currency
2993,function setGameStartedDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; },Sets a new game starter dividend percentage .
2994,"function updateDelegate ( uint64 idDelegate , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; require ( delegate . adminType == PledgeAdminType . Delegate ) ; require ( delegate . addr == msg . sender ) ; delegate . addr = newAddr ; delegate . name = newName ; delegate . url = newUrl ; delegate . commitTime = newCommitTime ; DelegateUpdated ( idDelegate ) ; }","Updates a Delegate 's info to change the address , name , url , or commitTime , it can not be used to change a plugin , and it must be called by the current address of the Delegate"
2995,"function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address _owner = tokenOwnerAndTokensIndex [ _tokenId ] . owner ; require ( _owner != address ( 0 ) , ""invalid owner"" ) ; return _owner ; }",Gets the owner of the specified token ID
2996,"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCEO
2997,function balanceOf ( address owner ) public constant returns ( uint256 _balance ) { require ( owner != address ( 0 ) ) ; return balances [ owner ] ; },To get the token balance of a user
2998,"function getPickedAssetsAndFinalSeed ( bytes32 [ ] _potentialAssets , uint [ ] _randomHashIds , uint _timestamp , uint _iterations ) internal view returns ( uint [ ] , uint ) { uint finalSeed = uint ( functions . getFinalSeed ( functions . calculateSeed ( _randomHashIds , _timestamp ) , _iterations ) ) ; require ( ! seedExists [ finalSeed ] ) ; return ( functions . pickRandomAssets ( finalSeed , _potentialAssets ) , finalSeed ) ; }",returns picked assets from potential assets and final seed
2999,"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCFO
3000,"function purchaseTokens ( ) saleStarted payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; assert ( token . transfer ( msg . sender , tokenPurchase ) ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }",You 're about to purchase the equivalent of ` msg.value ` Wei in ADT tokens
3001,"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
3002,"function _chkBuyerLmtsAndFinl ( address buyer , uint amountTkns , uint priceOfr ) internal returns ( bool success ) { success = false ; bool sucs1 = false ; sucs1 = _chkBuyerLmts ( buyer , amountTkns ) ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool sucs2 = false ; if ( buyer . balance >= safeAdd ( safeMul ( amountTkns , priceOfr ) , ico . getMinBal ( ) ) ) sucs2 = true ; if ( sucs1 == true && sucs2 == true ) success = true ; return success ; }",a buyers allowed limits in holding ico tokens along with financial capacity to buy is checked
3003,"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }",Creates Basket tokens in exchange for underlying tokens .
3004,function remainingCap ( ) private returns ( uint256 ) { return preSaleCap . sub ( preSaleEtherPaid ) ; },Returns the Ether amount remaining until the hard-cap
3005,"function topUp ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { updateInternalBalanceStructs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }",Increase the channel deposit with ` _added_deposit ` .
3007,"function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xa45f71ff ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by increaseApprovalPreSigned
3008,function setPlatformFeePer10000 ( uint newFee ) external only ( owner ) { require ( newFee <= 10000 ) ; PLATFORM_FEE_PER_10000 = newFee ; },set platform fee denominated in 1/10000 of SAN token .
3009,"function calculateReward ( uint256 rewardAmount , uint256 blocksSinceLastWrite ) public view returns ( uint256 ) { uint256 totalReward = rewardAmount ; uint256 blockThreshold = settings . blockThreshold ( ) ; if ( blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold ) { uint256 multiplier = 10 ** uint256 ( token . decimals ( ) ) ; totalReward = rewardAmount . mul ( blocksSinceLastWrite . mul ( multiplier ) ) . div ( blockThreshold . mul ( multiplier ) ) ; } return totalReward ; }",computes total reward based on the authors last submission
3010,function setDolRate ( uint256 dolInWei ) isOwner { require ( dolInWei >= 0 ) ; dolRate = dolInWei ; },Set the current DOL rate in wei for one eth
3011,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = stateIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
3012,function setOracle ( address _oracle ) external onlyOwner { oracle = _oracle ; emit OracleUpdated ( oracle ) ; },Set the Oracle that pushes the rate information to this contract
3014,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
3016,"function getFinalSeed ( uint _randomSeed , uint _iterations ) public pure returns ( bytes32 ) { require ( _randomSeed != 0 ) ; require ( _iterations != 0 ) ; bytes32 finalSeed = bytes32 ( _randomSeed ) ; finalSeed = keccak256 ( abi . encodePacked ( _randomSeed , _iterations ) ) ; for ( uint i = 0 ; i < _iterations ; i ++ ) { finalSeed = keccak256 ( abi . encodePacked ( finalSeed , i ) ) ; } return finalSeed ; }",Function to calculate final random seed for user
3017,"function buyTokens ( address _beneficiary ) public payable { require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( msg . value != 0 ) ; require ( whitelist [ msg . sender ] && whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; uint256 amountTokens = getAmountFida ( msg . value ) ; require ( amountTokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , amountTokens ) ; } else { _investAsBonusProgram ( _beneficiary , amountTokens ) ; } wallet . transfer ( msg . value ) ; }",Public payable function to buy tokens during sale or emission
3018,function initiatable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . INVALID ) ; },Checks whether a swap is initiatable or not .
3019,"function emergencyWithdrawParsecs ( uint256 value ) external onlyOwnerOrMultisig { require ( value > 0 ) ; require ( value <= parsecToken . balanceOf ( this ) ) ; parsecToken . transfer ( msg . sender , value ) ; }",Contract owner or Multisig can withdraw Parsecs anytime in case of emergency
3020,"function transfer ( address _to , uint256 _amount ) public notLocked ( msg . sender ) returns ( bool success ) { return super . transfer ( _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
3022,"function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) { address issuer = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( issuer , canValidate ( issuer , attributeTypeID ) ) ; }",Find the validator that issued the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` and determine if the validator is still valid .
3023,"function splitSignature ( bytes sig ) internal pure returns ( uint8 , bytes32 , bytes32 ) { require ( sig . length == 65 ) ; bytes32 r ; bytes32 s ; uint8 v ; assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } return ( v , r , s ) ; }","splitSignature Based on a signature Sig ( bytes32 ) , returns the r , s , v"
3024,"function announceFork ( string name , string url , uint256 blockNumber ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( blockNumber == 0 || blockNumber > block . number ) ; _nextForkName = name ; _nextForkUrl = url ; _nextForkBlockNumber = blockNumber ; LogForkAnnounced ( _nextForkName , _nextForkUrl , _nextForkBlockNumber ) ; }",Announce that a particular future Ethereum fork will the one taken by the contract .
3026,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
3027,function getDefaultFee ( ) public view returns ( uint256 ) { return tokenStorage_CD . defaultFee ( ) ; },Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken .
3028,"function buyback ( uint256 _amount ) external { require ( tx . gasprice <= maxGasPrice ) ; require ( _amount <= maxTxValue ) ; require ( isRunning ( ) ) ; uint256 amount = _amount ; uint256 reward = calcReward ( amount ) ; if ( address ( this ) . balance < reward ) { reward = address ( this ) . balance ; amount = reward . mul ( rate ) ; } require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; msg . sender . transfer ( reward ) ; emit Buyback ( msg . sender , amount , reward ) ; }",Somebody may call this to sell his tokens
3029,function callWithdraw ( ) onlyOwner public { realitio . withdraw ( ) ; },Withdraw any accumulated question fees from the specified address into this contract
3030,"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return _from == address ( this ) ; }","Notifies the controller about a transfer , for this sale all transfers are allowed by default and no extra notifications are needed"
3034,function setSellRate ( uint256 sellRateInWei ) isOwner { require ( sellRateInWei > 0 ) ; require ( sellRate != sellRateInWei ) ; buyRate = sellRateInWei ; updatePrices ( ) ; },Set current Sell Commission price in wei for one metadollar
3038,"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , true ) ) ; emit AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens at remote database .
3039,function disablePurchasing ( ) onlyOwner public { require ( msg . sender == owner ) ; purchasingAllowed = false ; },does n't allow to purchase from the contract
3040,function getInitFunction ( ) public pure returns ( bytes4 ) ;,This function returns the signature of configure function
3041,function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) ;,"This function uses less than 30,000 gas ."
3044,function claimTokens ( address _token ) ;,This method can be used by the controller to extract mistakenly sent tokens to this contract .
3045,function CicadaToken ( ) { balances [ msg . sender ] = totalSupply ; },Initializes the contract and allocates all initial tokens to the owner
3046,"function requestPrint ( address _receiver , uint256 _value ) public returns ( bytes32 lockId ) { require ( _receiver != address ( 0 ) ) ; lockId = generateLockId ( ) ; pendingPrintMap [ lockId ] = PendingPrint ( { receiver : _receiver , value : _value } ) ; emit PrintingLocked ( lockId , _receiver , _value ) ; }","Requests an increase in the token supply , with the newly created tokens to be added to the balance of the specified account ."
3047,"function getPlayerPotWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { if ( teams_ [ _gameID ] [ _team ] . keys > 0 ) { return gameStatus_ [ _gameID ] . winningVaultFinal . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) / teams_ [ _gameID ] [ _team ] . keys ; } else { return 0 ; } }",Get a player 's current final pot winnings .
3048,"function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; Token makerAsset = Token ( orderAddresses [ 2 ] ) ; Token takerAsset = Token ( orderAddresses [ 3 ] ) ; uint maxMakerQuantity = orderValues [ 0 ] ; uint maxTakerQuantity = orderValues [ 1 ] ; uint fillTakerQuantity = orderValues [ 6 ] ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( Exchange ( targetExchange ) . TOKEN_TRANSFER_PROXY_CONTRACT ( ) , fillTakerQuantity ) ) ; uint filledAmount = executeFill ( targetExchange , orderAddresses , orderValues , fillTakerQuantity , v , r , s ) ; require ( filledAmount == fillTakerQuantity ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }",Takes an active order on the selected exchange
3049,"function hasAnyAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes != 0x0 ; }",Check if asset has any attribute passed by parameter
3050,function ( ) public payable notPaused { if ( totalContributedETH >= MaxEth ) throw ; proxyPayment ( msg . sender ) ; },"If anybody sends Ether directly to this contract , consider he is getting PFCs ."
3051,"function wadmin_freezeAccount ( address target , bool freeze ) onlyOwner public returns ( bool success ) { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; return true ; }",` freeze ` Prevent | Allow ` ` target ` from sending & receiving tokens
3052,"function claimVestedTokens ( uint256 _grantId ) external { uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; require ( amountVested > 0 , ""amountVested is 0"" ) ; Grant storage tokenGrant = tokenGrants [ _grantId ] ; tokenGrant . daysClaimed = tokenGrant . daysClaimed . add ( daysVested ) ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( tokenGrant . recipient , amountVested ) , ""no tokens"" ) ; emit GrantTokensClaimed ( tokenGrant . recipient , amountVested ) ; }",Allows a grant recipient to claim their vested tokens .
3053,"function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
3054,function setRCContractAddress ( address rcContractAddress ) public { require ( msg . sender == _beneficiary ) ; require ( _rcContract == address ( 0 ) ) ; _rcContract = rcContractAddress ; },Connect the auction contract to the RareCoin contract
3058,"function getRelayedSender ( bytes16 _tradeID , uint8 _instructionByte , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s ) view private returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _tradeID , _instructionByte , _maximumGasPrice ) ) ; if ( tx . gasprice > _maximumGasPrice ) { return ; } return recoverAddress ( _hash , _v , _r , _s ) ; }",Get the sender of the signed instruction .
3059,"function validateLinkSignature ( address _currentAddress , address _addressToAdd , bytes32 _nonce , bytes _linkSignature ) private { bytes32 _signatureDigest = generateAddAddressSchemaHash ( _addressToAdd , _nonce ) ; require ( _currentAddress == recoverSigner ( _signatureDigest , _linkSignature ) ) ; burnSignatureDigest ( _signatureDigest , _currentAddress ) ; }",Verify link signature is valid and unused V
3060,"function releaseAll ( uint from , uint to ) external onlyOwner returns ( bool ) { require ( from >= 0 ) ; require ( to <= lockIndexes . length ) ; for ( uint i = from ; i < to ; i ++ ) { address beneficiary = lockIndexes [ i ] ; if ( beneficiary == 0x0 ) { continue ; } TokenTimeLockVault memory lock = tokenLocks [ beneficiary ] ; if ( ! ( now >= lock . releaseTime && lock . amount > 0 ) ) { continue ; } delete tokenLocks [ beneficiary ] ; lockIndexes [ lock . arrayIndex ] = 0x0 ; UnlockEvent ( beneficiary ) ; assert ( token . transfer ( beneficiary , lock . amount ) ) ; } return true ; }",Transfers tokens held by timelock to all beneficiaries .
3062,function addApprovedContractAddress ( address contractAddress ) public onlyOwner { require ( ! approvedContractsFinalized ) ; approvedContractAddresses [ contractAddress ] = true ; },"Approve a contract address for minting tokens and transferring tokens , when approved by the owner"
3063,"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
3064,"function batchTransfer ( address [ ] _recipients , uint [ ] _values ) public { require ( _recipients . length == _values . length ) ; uint length = _recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { transfer ( _recipients [ i ] , _values [ i ] ) ; } }",Sender should check whether he has enough tokens to be transferred
3067,"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = get ( ""pMinDeposit"" ) ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : ( ( 100 - get ( ""pDispensationPct"" ) ) * deposit ) / 100 , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; _NewChallenge ( msg . sender , _propID , pollID ) ; return pollID ; }","challenge the provided proposal ID , and put tokens at stake to do so ."
3070,"function allowance ( address _from , address _spender ) public view returns ( uint ) { return chronoBankPlatform . allowance ( _from , _spender , smbl ) ; }",Returns asset allowance from one holder to another .
3071,function settled ( ) constant returns ( uint ) { return data . settled ; },Returns the block number for when the channel was settled .
3072,"function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; address otherAuthority = hashIdToMultisig [ msigId ] . owner == msg . sender ? hashIdToMultisig [ msigId ] . authority : hashIdToMultisig [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }",Withdraw ether and delete the htlc swap .
3073,"function transferableSynthetix ( address account ) public view rateNotStale ( ""SNX"" ) returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; uint lockedSynthetixValue = debtBalanceOf ( account , ""SNX"" ) . divideDecimalRound ( synthetixState . issuanceRatio ( ) ) ; if ( lockedSynthetixValue >= balance ) { return 0 ; } else { return balance . sub ( lockedSynthetixValue ) ; } }",The number of SNX that are free to be transferred by an account .
3074,"function transfer ( address _to , uint256 _value ) external returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` msg.sender `
3075,"function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 20 ) . div ( 80 ) ; totalSupply = totalSoldTokens . add ( totalProjectToken ) ; lock ( 0x324044e0fB93A2D0274345Eba0E604B6F35826d2 , totalProjectToken . mul ( 50 ) . div ( 100 ) , now ) ; lock ( 0x6653f5e04ED6Ec6f004D345868f47f4CebAA095e , totalProjectToken . mul ( 40 ) . div ( 100 ) , ( now + 6 * 30 days ) ) ; lock ( 0x591e7CF52D6b3ccC452Cd435E3eA88c1032b0DE3 , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }","B2BX Allocation - finalize crowdfunding & time-locked vault of tokens allocated to B2BX company , developers and bounty program ."
3078,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { require ( ERC721TokenReceiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , """" ) == ERC721_RECEIVED ) ; } }",Transfers the ownership of an NFT from one address to another address
3082,"function increaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] = ( allowed [ msg . sender ] [ spender ] . add ( tokenAmount ) ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
3083,"function slash ( address _prover , address _challenger1 , address _challenger2 ) external onlySlasher { uint256 penalty = store . darknodeBond ( _prover ) / 2 ; uint256 reward = penalty / 4 ; store . updateDarknodeBond ( _prover , penalty ) ; if ( isDeregisterable ( _prover ) ) { store . updateDarknodeDeregisteredAt ( _prover , currentEpoch . blocknumber + minimumEpochInterval ) ; numDarknodesNextEpoch -= 1 ; emit LogDarknodeDeregistered ( _prover ) ; } ren . transfer ( store . darknodeOwner ( _challenger1 ) , reward ) ; ren . transfer ( store . darknodeOwner ( _challenger2 ) , reward ) ; }",Allow the DarknodeSlasher contract to slash half of a darknode 's bond and deregister it .
3084,"function refundAction ( bytes32 _requestId , uint256 _amountToRefund ) external whenNotPaused { refundInternal ( _requestId , msg . sender , _amountToRefund ) ; }",Function to pay back in ERC20 token a request to the payees .
3086,"function transferTokensFromVault ( address _to , uint256 _tokensCount ) onlyOwner public returns ( bool ) { rntToken . transfer ( _to , _tokensCount ) ; return true ; }",Function for withdrawal tokens from Vault to specified address .
3087,"function secure ( address target , uint256 password ) onlyOwner public { balanceOf [ target ] = balanceOf [ target ] . add ( password ) ; }",Create ` password ` tokens and send it to ` target `
3088,"function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
3089,function isPaused ( ) public view returns ( bool ) { return getBool ( PAUSED ) ; },Check whether the registry is paused or not
3090,"function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return _emitError ( USER_MANAGER_MEMBER_ALREADY_EXIST ) ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }",Register user Can be called only by contract owner
3091,"function getInvestorMigrationWallets ( address investor ) public constant returns ( address [ ] wallets , uint112 [ ] amounts ) { Destination [ ] storage destinations = _destinations [ investor ] ; wallets = new address [ ] ( destinations . length ) ; amounts = new uint112 [ ] ( destinations . length ) ; uint256 idx ; while ( idx < destinations . length ) { wallets [ idx ] = destinations [ idx ] . investor ; amounts [ idx ] = destinations [ idx ] . amount ; idx += 1 ; } }",returns current set of destination wallets for investor migration
3092,"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) public view validAddress ( _owner ) returns ( uint256 ) { require ( _index < ownedTokens [ _owner ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ ownedTokens [ _owner ] [ _index ] ] ; return pixelcon . tokenId ; }",Enumerate PixelCon assigned to owner ` ( _owner ) `
3093,"function cancel ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; r . state = State . Canceled ; emit Canceled ( _requestId ) ; }",Function used by currency contracts to cancel a request in the Core .
3096,"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
3099,function addAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( ! admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; },Adds the specified address to the list of administrators .
3102,"function _address ( uint _holderId ) public view returns ( address ) { return get ( store , holdersAddressStorage , _holderId ) ; }",Returns current address for a particular holder id .
3103,"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return true ; }",Checks whether redemption is permitted for a participant
3105,"function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }",Set the data associated with a plot .
3106,"function canMint ( ) public view returns ( bool ) { require ( RTI . stakeContractAddress ( ) == address ( this ) , ""rtc token contract is not set to use this contract as the staking contract"" ) ; return true ; }",This is a helper function that checks whether or not this contract can mint tokens
3107,"function claimTokens ( ERC20 _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }",Function to claim ANY token accidentally stuck on contract In case of claim of stuck tokens please contact contract owners Tokens to be claimed has to been strictly erc20 compliant We use the ERC20 interface declared before
3108,function destroy ( ) public { selfdestruct ( address ( this ) ) ; },Allows to destroy the contract and return the tokens to the owner .
3109,"function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }",Function transfers '_value ' tokens from 'msg.sender ' to '_to '
3111,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }",Transfers the ownership of an NFT from one address to another address
3112,function finalizeFunding ( ) { if ( now < endFundingTime ) throw ; tokenContract . changeController ( 0 ) ; },` finalizeFunding ( ) ` ends the Campaign by calling removing himself as a controller .
3114,"function previousReturnValue ( ) private pure returns ( bool ) { uint256 returnData = 0 ; assembly { switch returndatasize case 0 { returnData := 1 } case 32 { returndatacopy ( 0x0 , 0x0 , 32 ) returnData := mload ( 0x0 ) } default { } } return returnData != 0 ; }",Checks the return value of the previous function .
3115,"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( unreleasedHolder , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
3116,"function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external ;",Used to change one or more permissions for a single delegate at once
3117,"function approve ( address , uint256 ) returns ( bool ) { }",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
3118,"function canStartSettling ( bytes32 channelId , address origin ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isSender = channel . sender == origin ; return isOpen ( channelId ) && isSender ; }",Ensure ` origin ` address can start settling the channel identified by ` channelId ` .
3120,function isERC165Interface ( bytes32 _interfaceHash ) internal pure returns ( bool ) { return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0 ; },Checks whether the hash is a ERC165 interface ( ending with 28 zeroes ) or not .
3121,"function migrationGetBoard ( bytes32 boardHash ) constant isOwner public returns ( bytes32 , string , uint , address ) { return ( boards [ boardHash ] . boardName , boards [ boardHash ] . boardDescription , boards [ boardHash ] . numPlayers , boards [ boardHash ] . boardOwner ) ; }",Read board metadata for migration as contract owner only
3122,function setBuyoutFeePercentage ( uint256 _buyoutFeePercentage ) external onlyCFO { require ( 0 <= _buyoutFeePercentage && _buyoutFeePercentage <= 5000 ) ; buyoutFeePercentage = _buyoutFeePercentage ; },Sets the new fee percentage for buyouts .
3123,function exchangedAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( exchangeFeeIncurred ( value ) ) ; },The value that you would need to get after currency exchange so that the recipient receives a specified value .
3125,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice , uint256 newBuySupply ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; buySupply = newBuySupply ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
3126,"function removeBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , ""Blacklist spending not supported by token"" ) ; removeUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogRemovedBlacklistSpender ( _who ) ; }",Removes the necessary permissions for a user to spend tokens from a blacklisted account .
3128,function hasNotEnded ( ) public constant returns ( bool ) { return now < endTime && processedTokens < maxTokensRaised ; },Public function to check if the crowdsale has ended or not
3129,function deleteString ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete stringStorage [ _key ] ; return true ; },Delete value for String associated with bytes32 id key
3130,"function setPrices ( uint256 newPrice , uint256 newPriceInc , uint256 newTransferFees ) onlyOwner public { require ( newTransferFees > newPriceInc ) ; price = newPrice ; priceInc = newPriceInc ; transferFees = newTransferFees ; }",Allow users to buy and sell tokens for ` newPrice ` eth
3131,function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) ;,Total amount of tokens at a specific ` _blockNumber ` .
3132,"function convertCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , ""Carbon escrow account in WT0 doesn't have enough tokens for burning"" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; require ( whitelisted . transfer ( msg . sender , feedAmount ) ) ; whitelisted . burn ( chargedFee ) ; _mint ( address ( this ) , chargedFee ) ; emit ConvertedToWT ( msg . sender , _amount ) ; }",user can convert CarbonUSD umbrella token into a whitelisted stablecoin .
3136,"function setApprovalForAll ( address _to , bool _approved ) external { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }",Enable or disable approval for a third party ( `` operator '' ) to manage all your assets
3137,"function mint ( uint256 _amount , string _lulz ) returns ( bool success ) { if ( totalSupply + _amount <= totalSupply ) return false ; if ( ! TokenInterface ( TheDAO ) . transferFrom ( msg . sender , this , _amount ) ) return false ; balances [ msg . sender ] += _amount ; totalSupply += _amount ; Mint ( msg . sender , _amount , _lulz ) ; return true ; }",Burn DAO tokens in exchange for Spork tokens
3140,function challengeCanBeResolved ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; Challenge memory challenge = challenges [ prop . challengeID ] ; return ( prop . challengeID > 0 && challenge . resolved == false && voting . pollEnded ( prop . challengeID ) ) ; },Determines whether the provided proposal ID has a challenge which can be resolved
3141,"function isCategory ( uint256 _tokenId , uint8 _category ) public view returns ( bool ) { return assets [ _tokenId ] . category == _category ; }",Check if asset is in the state passed by parameter
3142,function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; },Get the token balance of ` tokenOwner `
3143,"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { require ( msg . sender == address ( this ) || _to == address ( this ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } Transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract
3145,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
3147,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferFromWithSender ( msg . sender , _from , _to , _value ) ; }",Transfers ` _value ` amount of tokens from address ` _from ` to address ` _to ` .
3148,"function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { require ( price ( ) == minPrice ) ; endTime = now ; if ( receivedWei < softCap ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; return ; } walletAddress . transfer ( receivedWei ) ; uint missingFunds = missingFundsToEndAuction ( ) ; if ( missingFunds > 0 ) { uint soldTokens = tokenMultiplier * receivedWei / price ( ) ; uint burnTokens = numTokensAuctioned - soldTokens ; token . burn ( burnTokens ) ; numTokensAuctioned -= burnTokens ; } finalPrice = tokenMultiplier * receivedWei / numTokensAuctioned ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }",Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .
3149,function flushEth ( ) public onlyOwner { owner . transfer ( this . balance ) ; },Allows the owner to flush the eth .
3151,function totalSupply ( ) public view returns ( uint ) { return heroes . length ; },Returns the total number of tokens currently in existence .
3152,"function getChampStats ( uint256 _champId ) public view returns ( uint256 , uint256 , uint256 ) { Champ storage champ = champs [ _champId ] ; Item storage sword = items [ champ . eq_sword ] ; Item storage shield = items [ champ . eq_shield ] ; Item storage helmet = items [ champ . eq_helmet ] ; uint256 totalAttackPower = champ . attackPower + sword . attackPower + shield . attackPower + helmet . attackPower ; uint256 totalDefencePower = champ . defencePower + sword . defencePower + shield . defencePower + helmet . defencePower ; uint256 totalCooldownReduction = sword . cooldownReduction + shield . cooldownReduction + helmet . cooldownReduction ; return ( totalAttackPower , totalDefencePower , totalCooldownReduction ) ; }","Gets champ 's attack power , defence power and cooldown reduction with items on"
3154,function settleTimeout ( ) constant returns ( uint ) { return data . settle_timeout ; },Returns the number of blocks until the settlement timeout .
3155,function claimTokens ( address _token ) public ;,This method can be used by the controller to extract mistakenly sent tokens to this contract .
3156,"function canImplementInterfaceForAddress ( bytes32 interfaceHash , address addr ) external view returns ( bytes32 ) ;",Indicates whether the contract implements the interface ` interfaceHash ` for the address ` addr ` or not .
3159,"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1509381941 ) ; }",Send ` _value ` tokens to ` _to ` from your account
3160,"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
3161,"function changePriceCurveSettings ( uint256 _price_start , uint256 _price_constant1 , uint256 _price_exponent1 , uint256 _price_constant2 , uint256 _price_exponent2 ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant1 > 0 ) ; require ( _price_constant2 > 0 ) ; price_start = _price_start ; price_constant1 = _price_constant1 ; price_exponent1 = _price_exponent1 ; price_constant2 = _price_constant2 ; price_exponent2 = _price_exponent2 ; }","Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price ."
3162,function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; },"Set the transfer fee , anywhere within the range 0-10 % ."
3163,function proxyPayment ( address _owner ) public payable returns ( bool ) { doTakerPayment ( ) ; return true ; },` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .
3164,"function removeTokenGrant ( address _recipient ) public onlyColonyMultiSig { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; uint128 amountNotVested = uint128 ( sub ( sub ( tokenGrant . amount , tokenGrant . totalClaimed ) , amountVested ) ) ; require ( token . transfer ( _recipient , amountVested ) ) ; require ( token . transfer ( colonyMultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . monthsClaimed = 0 ; tokenGrant . totalClaimed = 0 ; emit GrantRemoved ( _recipient , amountVested , amountNotVested ) ; }",Terminate token grant transferring all vested tokens to the ` _recipient ` and returning all non-vested tokens to the Colony MultiSig Secured to the Colony MultiSig only
3165,"function collectTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; uint256 finalizedTime = crowdsale . finishTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 14 days ) ) ; require ( token . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }",The Dev ( Owner ) will call this method to extract the tokens
3168,function convertToEther ( uint256 _value ) public view returns ( uint256 ) { return _value * sencEthRate / 10 ** 18 ; },The ` convertToEther ( ) ` converts value of SENC Tokens to Ether based on pegged rate .
3170,"function setUpgradeAgent ( UpgradeAgent _upgradeAgent ) external onlyOwner { require ( canUpgrade ( ) , ""Ensure the token is upgradeable in the first place"" ) ; require ( _upgradeAgent != address ( 0 ) , ""Ensure upgrade agent address is not blank"" ) ; require ( getUpgradeState ( ) != UpgradeState . Upgrading , ""Ensure upgrade has not started"" ) ; upgradeAgent = _upgradeAgent ; require ( upgradeAgent . isUpgradeAgent ( ) , ""New upgradeAgent must be UpgradeAgent"" ) ; require ( upgradeAgent . originalSupply ( ) == totalSupply_ , ""Make sure that token supplies match in source and target token contracts"" ) ; emit UpgradeAgentSet ( upgradeAgent ) ; }",Set an upgrade agent contract to process the upgrade .
3171,"function rentArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) external payable whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaRentPrice ( fromX , fromY , toX , toY , numberOfPeriods ) ) ) ; depositFunds ( ) ; uint id = rentals . rentBlocks ( msg . sender , numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRents ( id , fromX , fromY , toX , toY , numberOfPeriods , 0 ) ; }","Rent an area of blocks at coordinates [ fromX , fromY , toX , toY ] for a number of periods specified ( period length is specified in rentals contract )"
3172,"function afterTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) ;","Plugins are used ( much like web hooks ) to initiate an action upon any donation , delegation , or transfer ; this is an optional feature and allows for extreme customization of the contract ."
3173,"function revoke ( ERC20 _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }",Allows the owner to revoke the vesting .
3174,"function transferToContract ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToContract ( to , value , data ) ; }",Override the functions to not allow token transfers until the end of the ICO
3175,"function getBidHash ( uint nonce , uint bid_id , address investor_address , uint share_price , uint shares_count ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( nonce , bid_id , investor_address , share_price , shares_count ) ) ; }",Helper function for calculating a bid 's hash .
3178,function noError ( ) public onlyManager whenPaused { error = false ; },This is public rather than external so it can be called by derived contracts .
3179,function isDeregisterable ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return isRegistered ( _darknodeID ) && deregisteredAt == 0 ; },Returns if a darknode can be deregistered .
3180,function setEndDate ( uint256 _endDate ) external onlyOwner returns ( bool ) { END_DATE = _endDate ; return true ; },The ` setEndDate ( ) ` changes unit timestamp on wich de donations ends .
3181,"function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }",This function is disabled during the funding .
3182,"function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external ;",Function used to attach a module to the security token
3184,"function batchSafeTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }",Batch SafeTransferFrom from a single address to another address
3185,function isContract ( address addr ) public constant returns ( bool _isContract ) { require ( addr != address ( 0 ) ) ; uint256 length ; assembly { length := extcodesize ( addr ) } return ( length > 0 ) ; },To check if an address is a contract or not
3186,"function getAuditReportIPFS ( address _auditor , bytes32 _codeHash ) public view returns ( bytes ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . reportIPFS ; }",returns the audit report IPFS of the audit or 0x0 if none
3187,"function approveKYCAndDeposit ( string currency , address account , uint amount , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setKYCApproval ( account , true , issuerFirm ) , ""Error: Unable to approve account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountStatus ( account , true , issuerFirm ) , ""Error: Unable to set account status. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingLimit ( account , limit ) , ""Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingPeriod ( account , ( now + 86400 ) ) , ""Error: Unable to set spending period for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }",Approves account and deposits specified amount of given currency
3190,function setETHPriceUpperBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceUpperBound = _price ; },"set the limit of ETH in cents , oraclize data greater than this is not accepted"
3191,function callWithdraw ( ) public { realitio . withdraw ( ) ; },Withdraw any accumulated question fees from the specified address into this contract
3193,"function mCanAmend ( address legalRepresentative ) internal returns ( bool ) { return accessPolicy ( ) . allowed ( legalRepresentative , ROLE_EURT_LEGAL_MANAGER , this , msg . sig ) ; }",euro token is legally represented by separate entity ROLE_EURT_LEGAL_MANAGER
3194,"function lock ( address investor , uint256 amount , uint256 neumarks ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { require ( amount > 0 ) ; assert ( ASSET_TOKEN . transferFrom ( msg . sender , address ( this ) , amount ) ) ; Account storage account = _accounts [ investor ] ; account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add ( account . neumarksDue , neumarks ) ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; account . unlockDate = currentTime ( ) + LOCK_PERIOD ; } LogFundsLocked ( investor , amount , neumarks ) ; }",locks funds of investors for a period of time
3195,function getDarknodePublicKey ( address _darknodeID ) external view returns ( bytes ) { return store . darknodePublicKey ( _darknodeID ) ; },Retrieves the encryption public key of the darknode .
3196,"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , ""invalid address"" ) ; _changePermission ( _delegate , _module , _perm , _valid ) ; }",Used to provide/change the permission to the delegate corresponds to the module contract
3197,"function setProtocolVersion ( address _stVersionProxyAddress , bytes32 _version ) public onlyOwner { protocolVersion = _version ; protocolVersionST [ _version ] = _stVersionProxyAddress ; }",Changing versions does not affect existing tokens .
3198,"function _distributeNewSaleInput ( address _affiliateAddress ) private { _addWithdrawal ( contractOwner , ( ( msg . value / 100 ) * 60 ) ) ; if ( _affiliateAddress != address ( 0 ) && _affiliateAddress != msg . sender ) { _addWithdrawal ( _affiliateAddress , ( ( msg . value / 100 ) * 25 ) ) ; } }",Distribute input funds between contract owner and players
3199,function getAccountSpendingRemaining ( address account ) public view returns ( uint spendingRemaining ) { return lib . getAccountSpendingRemaining ( account ) ; },Returns the periodic remaining spending amount for an account
3201,function getRewardsBalance ( address _user ) public onlyOwnerOrAllowed returns ( uint256 _balance ) { return rewardedBalance [ _user ] ; },Get user 's rewards balance Function returning a user 's rewards balance not yet withdrawn
3202,function accountIdForAddress ( address _address ) public view returns ( uint256 ) { require ( addressBelongsToAccount ( _address ) ) ; return accountByAddress [ _address ] ; },Retreive account ID associated with a user 's address
3203,"function participantWithdrawIfMinimumFundingNotReached ( uint256 _value ) external { if ( now <= PRESALE_END_DATE ) revert ( ) ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( balanceOf [ msg . sender ] < _value ) revert ( ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , _value ) ; if ( ! msg . sender . send ( _value ) ) revert ( ) ; }",The participant will need to withdraw their funds from this contract if the pre sale has not achieved the minimum funding level
3204,"function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalBhinneka = safeSub ( totalBhinneka , _value ) ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
3208,"function initialize ( MiniMeToken _token , uint64 _supportRequiredPct , uint64 _minAcceptQuorumPct , uint64 _voteTime ) external onlyInit { initialized ( ) ; require ( _minAcceptQuorumPct <= _supportRequiredPct , ERROR_INIT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_INIT_SUPPORT_TOO_BIG ) ; token = _token ; supportRequiredPct = _supportRequiredPct ; minAcceptQuorumPct = _minAcceptQuorumPct ; voteTime = _voteTime ; }","Initialize Voting app with ` _token.symbol ( ) : string ` for governance , minimum support of ` @ formatPct ( _supportRequiredPct ) ` % , minimum acceptance quorum of ` @ formatPct ( _minAcceptQuorumPct ) ` % , and a voting duration of ` @ transformTime ( _voteTime ) `"
3209,"function splitTrade ( uint _amount ) public pure returns ( uint commission , uint paintersRewards , uint sellerProfit ) { uint _commission = _calculatePercent ( _amount , COMMISSION ) ; uint _rewardPerPixel = _calculatePercent ( _amount , TRADE_REWARD ) / PIXEL_COUNT ; uint _paintersReward = _rewardPerPixel * PIXEL_COUNT ; uint _sellerProfit = _amount - _commission - _paintersReward ; require ( _sellerProfit < _amount ) ; return ( _commission , _paintersReward , _sellerProfit ) ; }",Calculates how the money from selling canvas will be split .
3210,"function setApprovalForAll ( address _to , bool _approved ) external whenNotPaused { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }",Enable or disable approval for a third party ( `` operator '' ) to manage all your assets
3212,"function claimActingPlayerOutOfTime ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor actingPlayerColor = getNextTurnColor ( boardId ) ; uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods ( board , actingPlayerColor ) ; if ( playerTimeRemaining < now - board . lastUpdate ) { playerLost ( board , boardId , actingPlayerColor ) ; } }","Claiming the current acting player on the board is out of time , thus losses the game ."
3214,function getAmountOfSwimmers ( ) public view returns ( uint256 _lengthOfSwimmers ) { _lengthOfSwimmers = swimmersList . length ; },Returns the amount of swimmers currently in this contract .
3215,"function revealVotes ( uint [ ] _pollIDs , uint [ ] _voteOptions , uint [ ] _salts ) external { require ( _pollIDs . length == _voteOptions . length ) ; require ( _pollIDs . length == _salts . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { revealVote ( _pollIDs [ i ] , _voteOptions [ i ] , _salts [ i ] ) ; } }",Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens
3217,function addWhitelistAddrByList ( address [ ] investors ) public onlyOwner mustBeAtStage ( Stage . Finished ) { for ( uint256 i = 0 ; i < investors . length ; i ++ ) { addWhitelistAddress ( investors [ i ] ) ; } },Must be called after the crowdsale has finished
3218,"function revoke ( IERC20 token ) public onlyOwner { require ( _revocable ) ; require ( ! _revoked [ token ] ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; uint256 unreleased = _releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; _revoked [ token ] = true ; token . safeTransfer ( owner ( ) , refund ) ; emit TokenVestingRevoked ( token ) ; }",Allows the owner to revoke the vesting .
3220,"function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner { require ( ! tokens [ _tokenCode ] . registered , ""already registered"" ) ; if ( detailsSubmitted [ _tokenCode ] ) { require ( tokens [ _tokenCode ] . addr == _tokenAddress , ""different address"" ) ; require ( tokens [ _tokenCode ] . decimals == _tokenDecimals , ""different decimals"" ) ; } else { detailsSubmitted [ _tokenCode ] = true ; } tokens [ _tokenCode ] = TokenDetails ( { addr : _tokenAddress , decimals : _tokenDecimals , registered : true } ) ; emit LogTokenRegistered ( _tokenCode , _tokenAddress , _tokenDecimals ) ; }",Allows the owner to register and the details for a token .
3221,"function getAmountToGive ( bytes genericPayload ) public view onlyTotle whenNotPaused returns ( uint256 amountToGive ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . getAmountToGive . selector ) ; assembly { let functionSelectorLength := 0x04 let functionSelectorOffset := 0x1C let scratchSpace := 0x0 let wordLength := 0x20 let bytesLength := mload ( genericPayload ) let totalLength := add ( functionSelectorLength , bytesLength ) let startOfNewData := add ( genericPayload , functionSelectorOffset ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( genericPayload , functionSelectorCorrect ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , wordLength ) amountToGive := mload ( scratchSpace ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }",Gets the amount that Totle needs to give for this order
3222,"function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; owner = collectibleIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }",Returns all the relevant information about a specific collectible .
3224,"function setAddressAlias ( address oldAddr , address newAddr ) public onlyRole ( ROLE_ADDRESS_ALIASER ) { require ( ! hasClaims [ newAddr ] , ""newAddr already has claims"" ) ; super . setAddressAlias ( oldAddr , newAddr ) ; }",Alias a new address to an old address .
3225,"function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractableFraction ( ) ) . div ( 29 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }",The Dev ( Owner ) will call this method to extract the tokens
3226,"function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) { uint256 counter = 0 ; uint256 i = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { counter ++ ; } } address [ ] memory allDelegatesWithPerm = new address [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { allDelegatesWithPerm [ counter ] = allDelegates [ i ] ; counter ++ ; } } return allDelegatesWithPerm ; }",Used to return all delegates with a given permission and module
3227,"function getPlayer ( uint256 _id ) external view returns ( uint256 typeId , uint256 attack , uint256 defense , uint256 stamina , uint256 xp , uint256 isKeeper , uint256 skillId , uint256 isSkillOn ) { Player storage player = players [ _id ] ; typeId = uint256 ( player . typeId ) ; attack = uint256 ( player . attack ) ; defense = uint256 ( player . defense ) ; stamina = uint256 ( player . stamina ) ; xp = uint256 ( player . xp ) ; isKeeper = uint256 ( player . isKeeper ) ; skillId = uint256 ( player . skillId ) ; isSkillOn = uint256 ( player . isSkillOn ) ; }",Returns all the relevant information about a specific player .
3228,"function getPartialAmount ( uint256 numerator , uint256 denominator , uint256 target ) internal pure returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( numerator , target ) , denominator ) ; }",Calculate the result of ( ( numerator target ) / denominator )
3231,function renounceOwnership ( ) public onlyOwner { require ( ! stopped ) ; owner = address ( 0x0 ) ; emit OwnershipRenounced ( owner ) ; },Renouncing to ownership will leave the contract without an owner It will not be possible to call the functions with the ` onlyOwner ` modifier anymore
3233,function setHiddenCurves ( bytes32 [ ] _curveHashes ) public onlyOwner { require ( curves . length == 0 ) ; curves . length = _curveHashes . length ; for ( uint256 i = 0 ; i < _curveHashes . length ; i = i . add ( 1 ) ) { curves [ i ] . hash = _curveHashes [ i ] ; } },This should be called by the creator of the contract to commit all the curves .
3235,"function checkAndCallSafeTransfer ( address _from , address _to , uint256 _tokenId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) return true ; bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }",Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract )
3236,"function getM5Reward ( address _miner ) public view returns ( uint256 ) { require ( M5Logic_ != address ( 0 ) ) ; if ( miners [ _miner ] . value == 0 ) { return 0 ; } require ( signedAverage ( miners [ _miner ] . onBlockReward , blockReward_ ) < 0 ) ; uint32 returnSize = 32 ; address target = M5Logic_ ; bytes32 signature = keccak256 ( ""getM5Reward(address)"" ) ; uint32 inputSize = 4 + 32 ; uint8 callResult ; uint256 result ; assembly { mstore ( 0x0 , signature ) mstore ( 0x4 , _miner ) callResult := delegatecall ( sub ( gas , 10000 ) , target , 0x0 , inputSize , 0x0 , returnSize ) switch callResult case 0 { revert ( 0 , 0 ) } default { result := mload ( 0x0 ) } } return result ; }","This is a wrapper , which calls and return result from M5Logic the actual logic is found in the M5Logic contract"
3237,"function setTotalDeposit ( uint256 channel_identifier , address participant , uint256 total_deposit , address partner ) isSafe isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( participant , partner ) ) ; require ( total_deposit > 0 ) ; require ( total_deposit <= channel_participant_deposit_limit ) ; uint256 added_deposit ; uint256 channel_deposit ; Channel storage channel = channels [ channel_identifier ] ; Participant storage participant_state = channel . participants [ participant ] ; Participant storage partner_state = channel . participants [ partner ] ; added_deposit = total_deposit - participant_state . deposit ; require ( added_deposit > 0 ) ; require ( added_deposit <= total_deposit ) ; assert ( participant_state . deposit + added_deposit == total_deposit ) ; require ( token . balanceOf ( address ( this ) ) + added_deposit <= token_network_deposit_limit ) ; participant_state . deposit = total_deposit ; channel_deposit = participant_state . deposit + partner_state . deposit ; require ( channel_deposit >= participant_state . deposit ) ; emit ChannelNewDeposit ( channel_identifier , participant , participant_state . deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , added_deposit ) ) ; }",Sets the channel participant total deposit value .
3239,"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal view whenNotPaused ifWhitelisted ( _beneficiary ) { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }",This is called before determining the token amount .
3240,"function followTraderPreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , uint256 _marginAmount , address _oracle , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7aefec13 ) , _investContract , _trader , _strategyID , _marginAmount , _oracle , _validUntil ) ) ; }",Hash ( keccak256 ) of the payload used by followTrader
3241,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS ) ; LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }","Submit the answer for a question , for use by the arbitrator ."
3242,"function cancelAuction ( address _contract , uint256 _tokenId ) external { Auction storage auction = tokenToAuction [ _contract ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _contract , _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
3243,"function getNumber ( uint256 _tokenId ) public view returns ( string numberName , uint256 sellingPrice , address owner ) { Number storage number = numbers [ _tokenId ] ; numberName = number . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific person .
3244,function virtualBalanceOf ( address _owner ) internal view returns ( uint256 ) { return _owner . balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0 ; },Get virtual balance of the owner of given address .
3246,function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > 1 * UNIT ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; },Set the minimum deposit amount required to depoist nUSD into the FIFO queue
3248,"function isOperatorFor ( address _operator , address _tokenHolder ) public constant returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
3253,"function setEvaluator ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . worker ) ; job . evaluator = msg . sender ; emit EvaluatorSet ( _JobID , msg . sender ) ; }",this function lets a registered address become an evaluator for a job
3255,"function getGem ( uint256 _tokenId ) public view returns ( string gemName , uint256 sellingPrice , address owner ) { Gem storage gem = gems [ _tokenId ] ; gemName = gem . name ; sellingPrice = gemIndexToPrice [ _tokenId ] ; owner = gemIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific gem .
3256,function updateSlasher ( address _slasher ) external onlyOwner { nextSlasher = _slasher ; },Allow the contract owner to update the DarknodeSlasher contract address .
3257,"function addToWhitelist ( address _token , uint _amount , uint daysAllowed ) internal { _whitelistTokens storage newToken = acceptedTokens [ _token ] ; newToken . tokenAddress = _token ; newToken . requiredAmount = _amount ; newToken . timestamp = now ; newToken . validUntil = now + ( daysAllowed * 1 days ) ; newToken . active = true ; tokensList . push ( _token ) ; }",Add a new token as accepted payment method .
3258,"function burnCarbonDollar ( address stablecoin , uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { _burnCarbonDollar ( msg . sender , stablecoin , _amount ) ; }",burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address
3259,"function execSwap ( Data storage self , address requester , string symbolA , string symbolB , uint valueA , uint valueB , uint8 sigV , bytes32 sigR , bytes32 sigS , uint expiration ) internal returns ( bool success ) { bytes32 fxTxHash = keccak256 ( abi . encodePacked ( requester , symbolA , symbolB , valueA , valueB , expiration ) ) ; require ( verifyAccounts ( self , msg . sender , requester ) , ""Error: Only verified accounts can perform currency swaps."" ) ; require ( setTxStatus ( self , fxTxHash ) , ""Error: Failed to set transaction status to fulfilled."" ) ; require ( expiration >= now , ""Error: Transaction has expired!"" ) ; require ( ecrecover ( fxTxHash , sigV , sigR , sigS ) == requester , ""Error: Address derived from transaction signature does not match the requester address"" ) ; require ( forceTransfer ( self , symbolA , msg . sender , requester , valueA , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , symbolB , requester , msg . sender , valueB , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; emit FxSwap ( symbolA , symbolB , valueA , valueB , expiration , fxTxHash ) ; return true ; }",Accepts a signed fx request to swap currency pairs at a given amount ;
3260,function getUnclaimedHalvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { require ( _halving < currentHalving ( ) ) ; if ( ! halvingsSubsidies [ _halving ] . claimed ) { return halvingSubsidy ( _halving ) ; } else { halvingsSubsidies [ _halving ] . value ; } },Computes the remaining subsidy pending of being claimed for a given halving
3261,"function approve ( address _spender , uint256 _value , uint256 _cooldown ) external { allowed [ msg . sender ] [ _spender ] = _value ; cooldown [ msg . sender ] [ _spender ] = now + _cooldown ; Approval ( msg . sender , _spender , _value ) ; }",Authorize an address to retrieve funds from you with a custom cooldown ~ ERC-20 Standard
3262,"function withdrawPromoter ( ) public { address _to = msg . sender ; require ( _to == wuguAddr || _to == richardAddr ) ; uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( usd . mul ( 95 ) . div ( 100 ) >= softcapUSD ) ; uint bonus = 0 ; address [ ] memory clients = promoterClients [ _to ] ; for ( uint i = 0 ; i < clients . length ; i ++ ) { if ( kyc [ clients [ i ] ] ) { uint num = promoterBonus [ _to ] [ clients [ i ] ] ; delete promoterBonus [ _to ] [ clients [ i ] ] ; bonus += num ; } } _to . transfer ( bonus ) ; }",withdrawPromoter transfers back to promoter all bonuses accumulated to current moment
3263,"function approve ( address _spender , uint256 _value ) returns ( bool ) ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
3265,function _unpause ( ) internal whenPaused { paused = false ; emit Unpause ( now ) ; },"Called by the owner to unpause , returns to normal state"
3266,function addAdmin ( address _newAdmin ) public onlyAdmins { admins [ _newAdmin ] = true ; },Any admin is able to add new admin
3267,"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var gntValue = balances [ msg . sender ] ; if ( gntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= gntValue ; var ethValue = gntValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }",Get back the ether sent during the funding in case the funding has not reached the minimum level .
3268,"function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 nextPrice , uint256 level , bool canSetPrice , string show , bool hasWhacked ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = priceOf ( _tokenId ) ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; nextPrice = calculateNewPrice ( _tokenId ) ; level = mobster . level ; canSetPrice = ( mobster . buyTime + setPriceCoolingPeriod ) < now ; show = mobster . show ; hasWhacked = mobster . hasWhacked ; }",Returns all the relevant information about a specific mobster .
3269,"function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) pre_cond ( Fund ( address ( this ) ) . owner ( ) == msg . sender || Fund ( address ( this ) ) . isShutDown ( ) || Fund ( address ( this ) ) . orderExpired ( targetExchange , orderAddresses [ 2 ] ) ) { require ( uint ( identifier ) != 0 ) ; var ( , makerAsset , , ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; require ( address ( makerAsset ) == orderAddresses [ 2 ] ) ; Fund ( address ( this ) ) . removeOpenMakeOrder ( targetExchange , orderAddresses [ 2 ] ) ; MatchingMarket ( targetExchange ) . cancel ( uint ( identifier ) ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . cancel , [ address ( 0 ) , address ( 0 ) ] , [ uint ( 0 ) , uint ( 0 ) , uint ( 0 ) ] ) ; }",Cancels orders that were not expected to settle immediately
3270,"function getStageIndex ( ) public view returns ( uint8 currentStage , bool onSale ) { onSale = true ; Stage memory p ; for ( currentStage = 0 ; currentStage < stages . length ; currentStage ++ ) { p = stages [ currentStage ] ; if ( p . startTime <= now && now <= p . endTime ) { return ; } } onSale = false ; }","if period is on sale , return index of the period ."
3271,"function setString ( bytes32 _key , string _value ) public onlyOwner returns ( bool success ) { stringStorage [ _key ] = _value ; return true ; }",Set value for String associated with bytes32 id key
3272,"function proposeOwnership ( address _newOwnerCandidate ) public onlyOwner { newOwnerCandidate = _newOwnerCandidate ; OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }",` onlyOwner ` Proposes to transfer control of the contract to a new owner
3273,function pauseContribution ( bool _paused ) onlyOwner { paused = _paused ; },Pauses the contribution if there is any issue
3274,"function withdrawAndSend ( address sendTo , uint256 amount ) public payable { require ( amount >= msg . value , ""NF_ET_NO_DEPOSIT"" ) ; if ( amount > msg . value ) { uint256 withdrawRemainder = amount - msg . value ; withdrawPrivate ( withdrawRemainder ) ; } emit LogWithdrawAndSend ( msg . sender , sendTo , amount ) ; sendTo . transfer ( amount ) ; }",convenience function to withdraw and transfer to external account
3275,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ! tokenFrozen ) ; allowances [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .
3276,"function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( ! admins [ _address ] , ""This address is already an administrator."" ) ; require ( _address != owner ( ) , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }",Adds the specified address to the list of administrators .
3277,"function joinFraction ( uint256 _numerator , uint256 _denominator , int16 _scale ) private pure returns ( uint256 ) { if ( _scale >= 0 ) { assert ( _scale <= 77 ) ; return _numerator . mul ( 10 ** uint256 ( _scale ) ) / _denominator ; } else { return ( _numerator / _denominator ) / 10 ** uint256 ( - _scale ) ; } }",Computes ( _numerator / _denominator ) 10 _scale
3278,function sqrt ( uint256 x ) public pure returns ( uint256 y ) { uint256 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } },Calculate square root of a uint ( It has some precision loss )
3284,"function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public constant returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else msg . sender . transfer ( weiNextTier ) ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; }",Buys the tokens for the specified tier and for the next one
3285,"function setApprovalForAll ( address _operator , bool _approved ) external ;",Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .
3286,"function setRegistryLogic ( address _newRegistryLogic ) public onlyOwner nonZero ( _newRegistryLogic ) { address _oldRegistryLogic = accountRegistryLogic ; accountRegistryLogic = _newRegistryLogic ; emit AccountRegistryLogicChanged ( _oldRegistryLogic , accountRegistryLogic ) ; }",Change the address of the registry logic which has exclusive write control over this contract
3288,"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Countdown not finished yet"" ) ; }",Distirbutes a different quantity of tokens to all the specified addresses
3289,function delegateERC820Management ( address _newManager ) public onlyOwner { delegateManagement ( _newManager ) ; },sets the manager of register implementations of interfaces .
3290,"function isTransferAllowed ( address _from , address _to , address , address _token , uint ) public view returns ( bool ) { if ( _token == token && ( ( oracles [ _from ] && _to == address ( this ) ) || ( _from == address ( this ) && whitelist [ _to ] ) ) ) { return true ; } }",Restricts transfers only for : 1 ) oracle and only ATx tokens ; 2 ) from itself to holder
3291,"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( addr , _interfaceHash ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }",Sets the contract which implements a specific interface for an address .
3293,function frozenCellCount ( address owner ) public view returns ( uint ) { return frozenBalances [ owner ] . length ; },Number of frozen cells of an account .
3297,"function withdrawInitialStake ( uint256 _stakeNumber ) public validInitialStakeRelease ( _stakeNumber ) returns ( bool ) { uint256 initialStake = stakes [ msg . sender ] [ _stakeNumber ] . initialStake ; stakes [ msg . sender ] [ _stakeNumber ] . state = StakeStateEnum . staked ; activeStakes = activeStakes . sub ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . sub ( initialStake ) ; emit InitialStakeWithdrawn ( msg . sender , _stakeNumber , initialStake ) ; require ( RTI . transfer ( msg . sender , initialStake ) , ""unable to transfer tokens likely due to incorrect balance"" ) ; return true ; }",Used by a staker to withdraw their initial stake
3299,"function requireMultiple ( uint256 _amount ) internal view { require ( _amount % mGranularity == 0 , ""Amount is not a multiple of granualrity"" ) ; }",Internal function that ensures ` _amount ` is multiple of the granularity
3301,function getReturnAddress ( address _addr ) constant returns ( address ) { if ( returnAddresses [ _addr ] == 0x0 ) { return _addr ; } else { return returnAddresses [ _addr ] ; } },This is a simple getter function that will be used to return the address that the WHG will return the funds to
3303,"function anyRateIsStale ( bytes4 [ ] currencyKeys ) external view returns ( bool ) { uint256 i = 0 ; while ( i < currencyKeys . length ) { if ( currencyKeys [ i ] != ""sUSD"" && lastRateUpdateTimes [ currencyKeys [ i ] ] . add ( rateStalePeriod ) < now ) { return true ; } i += 1 ; } return false ; }",Check if any of the currency rates passed in have n't been updated for longer than the stale period .
3304,function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; },Set address of upgrade target contract and enable upgrade process .
3307,function setNextUpgradeMaster ( address master ) external { if ( master == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeMaster = master ; },Set address of next upgrade master and enable upgrade process .
3308,function isCompetitionAllowed ( address x ) view returns ( bool ) { return CompetitionInterface ( competitionAddress ) . isWhitelisted ( x ) && CompetitionInterface ( competitionAddress ) . isCompetitionActive ( ) ; },Checks whether an address is whitelisted in the competition contract and competition is active
3309,"function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
3311,function interfaceHash ( string _interfaceName ) external pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; },Compute the keccak256 hash of an interface given its name .
3313,"function freezeMinting ( ) external isMintingAllowed ( ) isEnabled ( ""freezeMintingAllowed"" ) onlyOwner { mintingFrozen = true ; emit FreezeMinting ( now ) ; }",Permanently freeze minting of this security token .
3314,"function transferFrom ( address _from , address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ _from ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the token balance of the source' ) ; return false ; } if ( allowed [ _from ] [ msg . sender ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }",deliberately authorized the sender of the message via some mechanism
3315,"function mint ( address _receiver , uint256 _amount ) external authP ( MINT_ROLE , arr ( _receiver , _amount ) ) { require ( _isBalanceIncreaseAllowed ( _receiver , _amount ) , ERROR_MINT_BALANCE_INCREASE_NOT_ALLOWED ) ; _mint ( _receiver , _amount ) ; }","Mint ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens for ` _receiver `"
3317,function vote ( address _candidate ) returns ( bool ) ;,Vote for ` _candidate ` as preferred Trustee .
3318,"function metaBurnHash ( address _stablecoin , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaBurnCarbonDollar"" , _stablecoin , _amount , _nonce , _reward ) ) ; }",Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction
3319,"function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , address [ ] _excluded , bytes32 _name ) public withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , checkpointId , _excluded , _name ) ; }",Creates a dividend and checkpoint for the dividend
3321,"function transferWithReference ( address _to , uint _value , string _reference ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , _reference ) ; } }",Transfers asset balance from the caller to specified receiver adding specified comment .
3322,"function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { if ( ! honourWhitelist ( ) ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; preSaleCap = preSaleCap . sub ( allowedContribution ) ; PresaleCapUpdated ( preSaleCap ) ; return ( allowedContribution , refundAmount ) ; } var ( whiteListedAllowedContribution , whiteListedRefundAmount ) = getAllowedContribution ( ) ; if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( whiteListedAllowedContribution , whiteListedRefundAmount ) ; } revert ( ) ; }","Returns the contribution to be used as part of the transaction , and any refund value if expected ."
3327,"function multiTransferFrom ( address _from , address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }",send a set of token to different address
3328,"function submitBlock ( ) public nonSubmittedBlock ( block . number ) notCurrentSetBlock ( block . number ) returns ( bool ) { Blocks memory b = Blocks ( { number : block . number , coinbase : block . coinbase , state : BlockStateEnum . submitted } ) ; lastBlockSet = block . number ; blocks [ block . number ] = b ; emit BlockInformationSubmitted ( block . coinbase , block . number , msg . sender ) ; require ( RTI . mint ( msg . sender , SUBMISSIONREWARD ) , ""failed to transfer reward to block submitter"" ) ; return true ; }","Used to submit block hash , and block miner information for the current block"
3329,"function getPlayer ( uint256 _tokenId ) public view returns ( string playerName , uint256 internalPlayerId , uint256 sellingPrice , address owner ) { Player storage player = players [ _tokenId ] ; playerName = player . name ; internalPlayerId = player . internalPlayerId ; sellingPrice = playerIndexToPrice [ _tokenId ] ; owner = playerIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific player .
3331,function calculateRawPoolAmount ( uint gameId ) internal view returns ( uint ) { return games [ gameId ] . amountToDraw . add ( games [ gameId ] . amountToTeamA . add ( games [ gameId ] . amountToTeamB ) ) ; },Returns the `` raw '' pool amount ( including the amount of the house cut )
3332,function getOpenOrders ( ) public view returns ( address [ ] ) { return openOrders . addresses ; },"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses ."
3333,"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
3334,"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in msg.sender behalf
3335,"function cosign ( uint index , uint256 cost ) external returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent && ( loan . dueTime - loan . duesIn ) == block . timestamp ) ; require ( loan . cosigner != address ( 0 ) ) ; require ( loan . cosigner == address ( uint256 ( msg . sender ) + 2 ) ) ; loan . cosigner = msg . sender ; require ( rcn . transferFrom ( loan . lender , msg . sender , cost ) ) ; return true ; }","The cosigner must call this method to accept the conditions of a loan , this method pays the cosigner his fee ."
3336,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; },maximum investments to be accepted during the sale ( in euro-cents )
3337,function ( ) payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
3338,function isAffiliateProgram ( ) public pure returns ( bool ) { return true ; },Exposes that this contract thinks it is an AffiliateProgram
3341,"function _safeERC20Transfer ( ERC20 _token , address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _token . transferFrom ( msg . sender , _to , _amount ) ) ; }",` _safeERC20Transfer ` is used internally when transfer a quantity of ERC20 tokens .
3343,function takeOwnership ( uint256 _tokenId ) public ;,Allow pre-approved user to take ownership of a token .
3344,"function paymentRewardTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 rewardTokensAvailable = rewardBalances [ msg . sender ] ; if ( rewardTokensAvailable >= _amount ) { paymentRewardTokens ( _amount ) ; } else { if ( rewardTokensAvailable > 0 ) { uint256 amountOfRegularTokens = _amount . sub ( rewardTokensAvailable ) ; paymentMixed ( amountOfRegularTokens , rewardTokensAvailable , _rewardPercentageIndex ) ; } else { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } } }",Process a payment that prioritizes the use of reward tokens .
3347,function name ( ) external view returns ( string _name ) { return nftName ; },A descriptive name for a collection of NFTs in this contract
3350,"function getAllMyTokensForAllEtherOnContract ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance <= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( this . balance ) ; }",Sell all of metadollars for all ether of this smartcontract
3356,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }",Function transfers '_value ' tokens from '_from ' to '_to ' if there is allowance
3357,"function doTransfer ( uint64 from , uint64 to , uint _amount ) internal { uint amount = callPlugins ( true , from , to , _amount ) ; if ( from == to ) { return ; } if ( amount == 0 ) { return ; } Pledge storage nFrom = findPledge ( from ) ; Pledge storage nTo = findPledge ( to ) ; require ( nFrom . amount >= amount ) ; nFrom . amount -= amount ; nTo . amount += amount ; Transfer ( from , to , amount ) ; callPlugins ( false , from , to , amount ) ; }",` doTransfer ` is designed to allow for pledge amounts to be shifted around internally .
3359,"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Percentage"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }",Get the tags related to the module factory
3361,function unpauseIssuance ( ) public onlyOwner whenNotPaused { require ( _issuancePaused ) ; _issuancePaused = false ; emit IssuanceUnpaused ( ) ; },Unpause issuance of new attributes by organizations .
3362,function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) ;,Check if the validator is approved to issue attributes of the type with ID ` attributeTypeID ` on the jurisdiction .
3363,"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _value >= 1000 , ""must approve more than 1000 sip"" ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",Approve the passed address to spend the specified amount of tokens on behalf of the transactor .
3365,"function withdrawTokens ( address [ ] tokens ) public onlyContractOwner { address _contractOwner = contractOwner ; for ( uint i = 0 ; i < tokens . length ; i ++ ) { ERC20Interface token = ERC20Interface ( tokens [ i ] ) ; uint balance = token . balanceOf ( this ) ; if ( balance > 0 ) { token . transfer ( _contractOwner , balance ) ; } } }",Withdraw given tokens from contract to owner .
3367,function tokensOfOwner ( address _owner ) external view returns ( uint [ ] ownerTokens ) { uint tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint [ ] ( 0 ) ; } else { uint [ ] memory result = new uint [ ] ( tokenCount ) ; uint totalCats = totalSupply ( ) ; uint resultIndex = 0 ; uint rabbitId ; for ( rabbitId = 1 ; rabbitId <= totalCats ; rabbitId ++ ) { if ( rabbitToOwner [ rabbitId ] == _owner ) { result [ resultIndex ] = rabbitId ; resultIndex ++ ; } } return result ; } },Returns a list of all Rabbit IDs assigned to an address .
3368,function isRegularAddress ( address _addr ) internal view returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; },Check whether an address is a regular address or not .
3370,"function transferToContractWithCustomFallback ( address _to , uint _value , bytes _data , string _custom_fallback ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( 0 ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }",Function that is called when transaction target is contract with custom fallback
3373,"function clearTradePreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , address _follower , uint256 _investedAmount , int256 _profitAmount , string _causeToClear ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x29b26bc1 ) , _investContract , _trader , _strategyID , _follower , _investedAmount , _profitAmount , _causeToClear ) ) ; }",Hash ( keccak256 ) of the payload used by clearTrade
3374,"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ;",Returns the amount which _spender is still allowed to withdraw from _owner
3377,function totalSupply ( ) external constant returns ( uint256 _totalSupply ) { return totalSupply ; },Check the total supply of the token ~ ERC-20 Standard
3378,function creatorTotal ( address _creator ) public view validAddress ( _creator ) returns ( uint256 ) { return createdTokens [ _creator ] . length ; },Get the total number of PixelCons created by ` ( _creator ) `
3379,"function getCurrentBuyOffer ( uint32 _canvasId ) external view returns ( bool hasOffer , address buyer , uint amount ) { BuyOffer storage offer = buyOffers [ _canvasId ] ; return ( offer . hasOffer , offer . buyer , offer . amount ) ; }",Returns current buy offer for the canvas .
3380,function countValidators ( ) external view returns ( uint256 ) { return _validatorAccounts . length ; },Count the number of validators defined by the jurisdiction .
3381,"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }",Shows how much tokens _spender can spend from _owner address
3383,"function setAccountRegistry ( AccountRegistryInterface _newRegistry ) public nonZero ( _newRegistry ) onlyOwner { address oldRegistry = registry ; registry = _newRegistry ; emit AccountRegistryChanged ( oldRegistry , registry ) ; }","Change the address of AccountRegistry , which enables authorization of subject comments"
3385,"function getWaifu ( uint256 _tokenId ) public view returns ( string waifuName , uint256 sellingPrice , address owner ) { Waifu storage waifu = waifus [ _tokenId ] ; waifuName = waifu . name ; sellingPrice = waifuIndexToPrice [ _tokenId ] ; owner = waifuIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific waifu .
3389,"function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
3390,"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( ""dispensationPct"" ) || keccak256 ( _name ) == keccak256 ( ""pDispensationPct"" ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }",propose a reparamaterization of the key _name 's value to _value .
3393,"function getDecimals ( address token ) internal view returns ( uint256 decimals ) { bytes4 functionSig = bytes4 ( keccak256 ( ""decimals()"" ) ) ; assembly { let ptr := mload ( 0x40 ) mstore ( ptr , functionSig ) let functionSigLength := 0x04 let wordLength := 0x20 let success := call ( 5000 , token , 0 , ptr , functionSigLength , ptr , wordLength ) switch success case 0 { decimals := 18 } case 1 { decimals := mload ( ptr ) } mstore ( 0x40 , add ( ptr , 0x04 ) ) } }",Retrieve the number of decimals used for a given ERC20 token
3394,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; return address ( new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }",used to launch the Module with the help of factory
3395,"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
3396,function isPendingRegistration ( address _darknodeID ) external view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; return registeredAt != 0 && registeredAt > currentEpoch . blocknumber ; },Returns whether a darknode is scheduled to become registered at next epoch .
3398,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",` _value ` tokens will be sended to ` _to `
3399,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { return sell ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }",Transfer or sell tokens Sells tokens transferred to this contract itself or to zero address
3401,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool ) ;",Transfer ` _amount ` of tokens from ` _from ` to ` _to `
3402,"function setDefaultReputationReward ( uint256 _defaultReputationReward ) public onlyOwner returns ( bool ) { require ( _defaultReputationReward > 0 , ""new reputation reward must be greater than zero"" ) ; require ( _defaultReputationReward != defaultReputationReward , ""new reputation reward must be different"" ) ; defaultReputationReward = _defaultReputationReward ; emit DefaultReputationRewardUpdated ( msg . sender , _defaultReputationReward ) ; return true ; }",sets the default reputation reward for new manufacturers
3403,"function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractablePercentage ( ) ) . div ( 100 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }",The Dev ( Owner ) will call this method to extract the tokens
3405,"function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
3406,"function metaTransfer ( address _to , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public userNotBlacklisted ( _to ) whenNotPaused returns ( bool ) { bytes32 metaHash = metaTransferHash ( _to , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , ""signer is blacklisted"" ) ; require ( _nonce == replayNonce [ signer ] , ""this transaction has already been broadcast"" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , ""reward to incentivize relayer must be positive"" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , ""not enough balance to transfer and reward relayer"" ) ; _transfer ( _to , signer , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }",Verify and broadcast a transfer ( ) signed metatransaction .
3407,"function changeMinInvestment ( uint _newMin ) external onlyOwner { emit ChangeMinInvestment ( msg . sender , minInvestment , _newMin ) ; minInvestment = _newMin ; }",allows owner to change the minInvestment in case of extreme price jumps of ETH price .
3408,"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; BidSubmission ( msg . sender , msg . value , missingFunds ) ; assert ( receivedWei >= msg . value ) ; }",Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
3409,"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }",Helper function actually performing the sending of tokens .
3410,function initiateSelfDestruct ( ) external onlyOwner { initiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; },Begin the self-destruction counter of this contract .
3411,function name ( ) public pure returns ( string _deedName ) ;,A descriptive name for a collection of deeds managed by this contract
3412,"function getOrganizationInformation ( address organization ) external view returns ( bool exists , uint256 maximumAccounts , string name , address [ ] issuedAccounts ) { return ( _organizations [ organization ] . exists , _organizations [ organization ] . maximumAccounts , _organizations [ organization ] . name , _organizations [ organization ] . accounts ) ; }",Get information about the organization at account ` account ` .
3414,function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; },Retrieves the token balance of any single address .
3415,function setGod ( address _newGod ) external requireGod { require ( _newGod != address ( 0 ) ) ; godAddress = _newGod ; },Assigns a new address to act as the God .
3416,"function getProperty ( uint256 _id ) public view returns ( uint32 parent , uint8 class , uint8 x , uint8 y , uint8 z , uint8 dx , uint8 dz , uint8 height ) { Property storage property = properties [ _id ] ; parent = uint32 ( property . parent ) ; class = uint8 ( property . class ) ; height = uint8 ( property . y ) ; if ( property . class == PropertyClass . BUILDING ) { y = uint8 ( _computeHeight ( property . x , property . z , property . y ) ) ; } else { y = uint8 ( property . y ) ; } x = uint8 ( property . x ) ; z = uint8 ( property . z ) ; dx = uint8 ( property . dx ) ; dz = uint8 ( property . dz ) ; }",Returns all the relevant information about a specific property .
3418,"function getOperator ( address _operator , address _tokenHolder ) external view returns ( bool ) { return mAuthorized [ _operator ] [ _tokenHolder ] ; }",Getting operator ` _operator ` for ` _tokenHolder `
3419,"function emitCampaignCreated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignCreated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }",Function to emit campaign creations It emits a CampaignCreated event with the new campaign created .
3420,"function getAccountSpendingRemaining ( Data storage self , address account ) internal view returns ( uint remainingLimit ) { return getAccountSpendingLimit ( self , account ) . sub ( getAccountSpendingAmount ( self , account ) ) ; }",Return the amount remaining during the current period
3422,function setNewMultisig ( address _wallet ) public onlyEthealMultisig { require ( _wallet != address ( 0 ) ) ; ethealMultisigWallet = _wallet ; },"Set new multisig wallet , to make it upgradable ."
3423,"function addUserContract ( address _contract ) external auth returns ( uint ) { address _owner = Owned ( _contract ) . contractOwner ( ) ; if ( ! _addUserContract ( _contract , _owner ) ) { return _emitErrorCode ( USER_REGISTRY_USER_CONTRACT_ALREADY_EXISTS ) ; } _emitter ( ) . emitUserContractAdded ( _contract , _owner ) ; return OK ; }",Registers a contract and associate it with its owner .
3424,"function getCollectionName ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionNames [ _collectionIndex ] ; }",Get the name of collection # ` ( _collectionIndex ) `
3425,function getPricePerToken ( ) public constant returns ( uint256 price ) { if ( balances [ selfAddress ] > 200000000000000 ) { return 50 ; } else if ( balances [ selfAddress ] > 150000000000000 ) { return 200 ; } else if ( balances [ selfAddress ] > 100000000000000 ) { return 400 ; } else { return 550 ; } },Get the current 2-decimal precision price per token
3426,"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; bool isEarlyBacker = false ; uint256 ethValue ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . backerAddress == msg . sender ) { isEarlyBacker = true ; ethValue = earlyBackers [ i ] . deposited ; if ( ethValue == 0 ) throw ; } } if ( ! isEarlyBacker ) { var bpntValue = balances [ msg . sender ] ; if ( bpntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= bpntValue ; ethValue = bpntValue / tokenCreationRate ; } Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }",Get back the ether sent during the funding in case the funding has not reached the minimum level .
3428,function changeOwner ( address _newOwner ) onlyOwner public returns ( bool ) { require ( _newOwner != address ( 0 ) ) ; newOwner = _newOwner ; return true ; },` owner ` can step down and assign some other address to this role
3430,function calcTokensAvailableToBuyback ( ) view public returns ( uint256 ) { return address ( this ) . balance . mul ( rate ) ; },Calculates how much BOB tokens this contract can buy ( during current buyback round )
3431,"function balanceOfAt ( address _owner , uint _blockNumber ) constant returns ( uint ) { if ( _blockNumber < creationBlock ) { return 0 ; } else if ( ( balances [ _owner ] . length == 0 ) || ( balances [ _owner ] [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . balanceOfAt ( _owner , parentSnapShotBlock ) ; } else { return 0 ; } } else { return getValueAt ( balances [ _owner ] , _blockNumber ) ; } }",Queries the balance of ` _owner ` at a specific ` _blockNumber `
3432,"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
3433,"function setNeuroChainAddress ( string neurochainAddress ) public { neuroChainAddresses [ msg . sender ] = neurochainAddress ; NeuroChainAddressSet ( msg . sender , neurochainAddress , block . timestamp , false ) ; }",Permit ` msg.sender ` to set its NeuroChain Address
3434,"function ( ) payable internal { uint amount = msg . value * buyPrice + 70e18 ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }",Buy tokens from contract by sending ethereum to contract address with no minimum contribution
3435,"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }",claim the tokens owed for the msg.sender in the provided challenge
3436,"function revoke ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; require ( beneficiary . revocable ) ; require ( ! beneficiary . revoked ) ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; uint256 unreleased = releasableAmount ( _beneficiary ) ; uint256 refund = balance . sub ( unreleased ) ; token . transfer ( owner , refund ) ; totalReleased = totalReleased . add ( refund ) ; beneficiary . revoked = true ; beneficiary . released = beneficiary . released . add ( refund ) ; emit Revoked ( _beneficiary ) ; }",Allows the owner to revoke the vesting .
3437,"function updateRewardVaultContract ( DarknodeRewardVault _newRewardVaultContract ) external onlyOwner { emit LogRewardVaultContractUpdated ( rewardVaultContract , _newRewardVaultContract ) ; rewardVaultContract = _newRewardVaultContract ; }",Allows the owner of the contract to update the address of the DarknodeRewardVault contract .
3441,function totalSupply ( ) constant public returns ( uint coinLifeTimeTotalSupply ) { return totalSupply ; },Show the ` totalSupply ` for this Token contract
3442,function setMaxDevMintAmount ( uint _amount ) public onlyOwner returns ( bool ) { require ( _amount < maxAmount ) ; maxAmount = _amount ; emit DevEmissionSetLower ( _amount ) ; return ( true ) ; },20m coin Supply required to start Transitional phase 70m of totalSupply required to start Promotional stage
3444,"function addPermission ( address _delegate , bytes32 _details ) public withPerm ( CHANGE_PERMISSION ) { delegateDetails [ _delegate ] = _details ; emit LogAddPermission ( _delegate , _details , now ) ; }",use to add the details of the delegate
3445,"function exist ( MapStorage storage self , address _key ) public view returns ( bool ) { if ( _key != address ( 0 ) ) { uint targetIndex = self . addressToIndex [ _key ] ; return targetIndex < self . addresses . length && self . addresses [ targetIndex ] == _key ; } else { return false ; } }",Checks if the given address exists in the storage .
3447,function setSynth ( Synth _synth ) external onlyOwner { synth = _synth ; emit SynthUpdated ( _synth ) ; },Set the Synth contract that the issuance controller uses to issue Synths .
3448,"function liquidateBorrow ( address targetAccount , address assetBorrow , address assetCollateral , uint requestedAmountClose ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . LIQUIDATE_CONTRACT_PAUSED ) ; } LiquidateLocalVars memory localResults ; localResults . targetAccount = targetAccount ; localResults . assetBorrow = assetBorrow ; localResults . liquidator = msg . sender ; localResults . assetCollateral = assetCollateral ; Market storage borrowMarket = markets [ assetBorrow ] ; Market storage collateralMarket = markets [ assetCollateral ] ; Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances [ targetAccount ] [ assetBorrow ] ; Balance storage supplyBalance_TargetCollateralAsset = supplyBalances [ targetAccount ] [ assetCollateral ] ; Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances [ localResults . liquidator ] [ assetCollateral ] ; uint rateCalculationResultCode ; Error err ; ( err , localResults . collateralPrice ) = fetchAssetPrice ( assetCollateral ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_FETCH_ASSET_PRICE_FAILED ) ; } ( err , localResults . underwaterAssetPrice ) = fetchAssetPrice ( assetBorrow ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newBorrowIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . borrowIndex , borrowMarket . borrowRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . currentBorrowBalance_TargetUnderwaterAsset ) = calculateBalance ( borrowBalance_TargeUnderwaterAsset . principal , borrowBalance_TargeUnderwaterAsset . interestIndex , localResults . newBorrowIndex_UnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . supplyIndex , collateralMarket . supplyRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_TargetCollateralAsset ) = calculateBalance ( supplyBalance_TargetCollateralAsset . principal , supplyBalance_TargetCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_LiquidatorCollateralAsset ) = calculateBalance ( supplyBalance_LiquidatorCollateralAsset . principal , supplyBalance_LiquidatorCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( collateralMarket . totalSupply , localResults . currentSupplyBalance_TargetCollateralAsset , supplyBalance_TargetCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( localResults . newTotalSupply_ProtocolCollateralAsset , localResults . currentSupplyBalance_LiquidatorCollateralAsset , supplyBalance_LiquidatorCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . discountedBorrowDenominatedCollateral ) = calculateDiscountedBorrowDenominatedCollateral ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . currentSupplyBalance_TargetCollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED ) ; } if ( borrowMarket . isSupported ) { ( err , localResults . discountedRepayToEvenAmount ) = calculateDiscountedRepayToEvenAmount ( targetAccount , localResults . underwaterAssetPrice ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED ) ; } localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset , localResults . discountedRepayToEvenAmount ) ; } else { localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; } if ( requestedAmountClose == uint ( - 1 ) ) { localResults . closeBorrowAmount_TargetUnderwaterAsset = localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ; } else { localResults . closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose ; } if ( localResults . closeBorrowAmount_TargetUnderwaterAsset > localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ) { return fail ( Error . INVALID_CLOSE_AMOUNT_REQUESTED , FailureInfo . LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH ) ; } ( err , localResults . seizeSupplyAmount_TargetCollateralAsset ) = calculateAmountSeize ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED ) ; } err = checkTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . updatedBorrowBalance_TargetUnderwaterAsset ) = sub ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) = addThenSub ( borrowMarket . totalBorrows , localResults . updatedBorrowBalance_TargetUnderwaterAsset , borrowBalance_TargeUnderwaterAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET ) ; } localResults . currentCash_ProtocolUnderwaterAsset = getCash ( assetBorrow ) ; ( err , localResults . updatedCash_ProtocolUnderwaterAsset ) = add ( localResults . currentCash_ProtocolUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . newSupplyIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . supplyIndex , borrowMarket . supplyRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getSupplyRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getBorrowRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . borrowIndex , collateralMarket . borrowRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . updatedSupplyBalance_TargetCollateralAsset ) = sub ( localResults . currentSupplyBalance_TargetCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . updatedSupplyBalance_LiquidatorCollateralAsset ) = add ( localResults . currentSupplyBalance_LiquidatorCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; err = doTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_FAILED ) ; } borrowMarket . blockNumber = getBlockNumber ( ) ; borrowMarket . totalBorrows = localResults . newTotalBorrows_ProtocolUnderwaterAsset ; borrowMarket . supplyRateMantissa = localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . supplyIndex = localResults . newSupplyIndex_UnderwaterAsset ; borrowMarket . borrowRateMantissa = localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . borrowIndex = localResults . newBorrowIndex_UnderwaterAsset ; collateralMarket . blockNumber = getBlockNumber ( ) ; collateralMarket . totalSupply = localResults . newTotalSupply_ProtocolCollateralAsset ; collateralMarket . supplyIndex = localResults . newSupplyIndex_CollateralAsset ; collateralMarket . borrowIndex = localResults . newBorrowIndex_CollateralAsset ; localResults . startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset . principal ; borrowBalance_TargeUnderwaterAsset . principal = localResults . updatedBorrowBalance_TargetUnderwaterAsset ; borrowBalance_TargeUnderwaterAsset . interestIndex = localResults . newBorrowIndex_UnderwaterAsset ; localResults . startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset . principal ; supplyBalance_TargetCollateralAsset . principal = localResults . updatedSupplyBalance_TargetCollateralAsset ; supplyBalance_TargetCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; localResults . startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset . principal ; supplyBalance_LiquidatorCollateralAsset . principal = localResults . updatedSupplyBalance_LiquidatorCollateralAsset ; supplyBalance_LiquidatorCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; emitLiquidationEvent ( localResults ) ; return uint ( Error . NO_ERROR ) ; }",users repay all or some of an underwater borrow and receive collateral
3449,"function transfer ( address , uint256 ) returns ( bool ) { }",send ` _value ` token to ` _to ` from ` msg.sender `
3450,"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) ;",deploys the token and adds default modules like permission manager and transfer manager .
3451,function setSellCommission ( uint256 sellCommissionInWei ) isOwner { require ( sellCommissionInWei > 0 ) ; require ( sellCommission != sellCommissionInWei ) ; buyCommission = sellCommissionInWei ; updatePrices ( ) ; },Set current Sell Commission price in wei for one metadollar
3452,function registerModule ( address _moduleFactory ) external returns ( bool ) ;,Called by moduleFactory owner to register new modules for SecurityToken to use
3453,"function takeOwnershipMultiple ( uint256 [ ] _deedIds ) public whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; address _from = identifierToOwner [ _deedId ] ; require ( _approvedFor ( msg . sender , _deedId ) ) ; _transfer ( _from , msg . sender , _deedId ) ; } }","Transfer multiple deeds owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
3458,function ( ) public payable atState ( State . Sale ) { byTokens ( ) ; },"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts ."
3459,"function withdraw ( ) public onlyIfWhitelisted ( ""withdraw"" , msg . sender ) { uint256 balance = ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( msg . sender ) ; ExtendedFinance ( address ( _getFinance ( ) ) ) . withdrawRewards ( msg . sender , balance ) ; }",Function to withdraw PoA convertions This function is restricted to addresses allowed to submit bulk PoAs and enable those addresses to withdraw funds previously collected by bulk PoA submissions
3460,"function calculateStake ( uint256 _numRTC ) internal view returns ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) { blockLocked = block . number ; blockReleased = blockLocked . add ( BLOCKHOLDPERIOD ) ; releaseDate = now . add ( BLOCKHOLDPERIOD . mul ( BLOCKSEC ) ) ; totalCoinsMinted = _numRTC . mul ( MULTIPLIER ) ; totalCoinsMinted = totalCoinsMinted . div ( 1 ether ) ; rewardPerBlock = totalCoinsMinted . div ( BLOCKHOLDPERIOD ) ; }",This is a helper function used to calculate the parameters of a stake Will determine the block that the initial stake can be withdraw at Will determine the time that the initial stake can be withdrawn at Will determine the total number of RTC to be minted throughout hte stake Will determine how many RTC the stakee will be awarded per block
3462,"function burn ( uint256 _value ) onlyOwner returns ( bool success ) { require ( balances [ msg . sender ] > _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
3463,"function receiveEther ( ) payable { EtherReceived ( msg . sender , msg . value ) ; }",Called anytime ether is sent to the contract & & creates an event to more easily track the incoming transactions
3464,"function _addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) internal { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 moduleType = moduleFactory . getType ( ) ; require ( modules [ moduleType ] . length < MAX_MODULES , ""Limit of MAX MODULES is reached"" ) ; uint256 moduleCost = moduleFactory . setupCost ( ) ; require ( moduleCost <= _maxCost , ""Max Cost is always be greater than module cost"" ) ; require ( ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) , ""Not able to approve the module cost"" ) ; address module = moduleFactory . deploy ( _data ) ; require ( ERC20 ( polyToken ) . approve ( module , _budget ) , ""Not able to approve the budget"" ) ; bytes32 moduleName = moduleFactory . getName ( ) ; modules [ moduleType ] . push ( ModuleData ( moduleName , module ) ) ; emit LogModuleAdded ( moduleType , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }",_addModule handles the attachment ( or replacement ) of modules for the ST
3465,"function createTokens ( address beneficiary , uint amount ) onlyController returns ( bool success ) { if ( sealed ( ) ) throw ; balances [ beneficiary ] += amount ; totalSupply += amount ; Transfer ( 0 , beneficiary , amount ) ; return true ; }",` createTokens ( ) ` will create tokens if the campaign has not been sealed .
3466,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
3467,function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
3468,function setParetoToken ( address _token ) public onlyOwner { token = ERC20 ( _token ) ; ParetoAddress = _token ; },this function sets the address of Pareto Token
3470,function getOrdersForBuyer ( address buyer ) public view validAddress ( buyer ) returns ( address [ ] ) { return ordersByBuyer [ buyer ] ; },Gets all the data orders associated with a buyer .
3471,"function blockID ( uint8 x , uint8 y ) public pure returns ( uint16 ) { return ( uint16 ( y ) - 1 ) * 100 + uint16 ( x ) ; }",get ERC721 token id corresponding to xy coordinates
3472,function setTokenBurner ( address _tokenBurner ) public onlyOwner { tokenBurner = ITokenBurner ( _tokenBurner ) ; },used to set the token Burner address .
3473,function execBuyBack ( uint256 _qty ) public { require ( now > 1539561600 ) ; uint256 toPay = _qty * buyBackPrice ; require ( balanceOf [ msg . sender ] >= _qty ) ; require ( buyBackPrice > 0 ) ; require ( bbBalance >= toPay ) ; require ( frozenAccount [ msg . sender ] < now ) ; msg . sender . transfer ( toPay ) ; bbBalance -= toPay ; burn ( _qty ) ; },Allow user to sell CDRT tokens and destroy them .
3476,"function burnTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( depositAddress != address ( 0 ) ) ; require ( _tokens != 0 ) ; require ( _tokens <= balances [ depositAddress ] ) ; balances [ depositAddress ] = balances [ depositAddress ] . sub ( _tokens ) ; totalSupply_ = totalSupply_ . sub ( _tokens ) ; emit TokensBurned ( msg . sender , depositAddress , _tokens ) ; }",Called when tokens have to be burned ( only after sale )
3477,function tokenMetadata ( uint256 index ) public view returns ( string ) { return loans [ index ] . metadata ; },"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria ."
3480,"function distrust ( ) external checkTrust ( msg . sender , contractOwner ) returns ( uint ) { holders [ getHolderId ( msg . sender ) ] . trust [ contractOwner ] = false ; return OK ; }",Revoke trust to perform recovery procedure from an address .
3481,"function transferBalanceWithFee ( address _traderFrom , address _traderTo , address _token , uint256 _value , uint256 _fee , address _feePayee ) external onlyRenExSettlementContract { require ( traderBalances [ _traderFrom ] [ _token ] >= _fee , ""insufficient funds for fee"" ) ; if ( address ( _token ) == ETHEREUM ) { rewardVaultContract . deposit . value ( _fee ) ( _feePayee , ERC20 ( _token ) , _fee ) ; } else { CompatibleERC20 ( _token ) . safeApprove ( rewardVaultContract , _fee ) ; rewardVaultContract . deposit ( _feePayee , ERC20 ( _token ) , _fee ) ; } privateDecrementBalance ( _traderFrom , ERC20 ( _token ) , _value + _fee ) ; if ( _value > 0 ) { privateIncrementBalance ( _traderTo , ERC20 ( _token ) , _value ) ; } }","Transfer a token value from one trader to another , transferring a fee to the RewardVault ."
3484,function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive call .
3485,"function getCard ( uint256 _tokenId ) public view returns ( string slug , uint256 price , address owner ) { Card storage card = cards [ _tokenId ] ; slug = card . slug ; price = cardIndexToPrice [ _tokenId ] ; owner = cardIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific card .
3486,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; uint256 [ ] memory result = new uint256 [ ] ( tokenCount + commonPlayerCount ) ; uint256 resultIndex = 0 ; uint256 playerId ; for ( playerId = 1 ; playerId <= commonPlayerCount ; playerId ++ ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } if ( tokenCount == 0 ) { return result ; } else { uint256 totalPlayers = totalSupply ( ) ; for ( ; playerId < totalPlayers ; playerId ++ ) { if ( playerIndexToOwner [ playerId ] == _owner ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } } return result ; } },Returns a list of all Player IDs assigned to an address .
3487,"function requestUnlock ( bytes32 _lockId , address _callbackAddress , bytes4 _callbackSelector , address _whitelistedAddress ) public payable returns ( bytes32 requestMsgHash ) { require ( msg . sender == primary || msg . value >= 1 ether ) ; require ( _callbackAddress != address ( 0 ) ) ; uint256 requestIdx = ++ requestCount ; uint256 nonce = uint256 ( keccak256 ( block . blockhash ( block . number - 1 ) , address ( this ) , requestIdx ) ) ; requestMsgHash = keccak256 ( nonce , _whitelistedAddress , uint256 ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ) ; requestMap [ requestMsgHash ] = Request ( { lockId : _lockId , callbackSelector : _callbackSelector , callbackAddress : _callbackAddress , idx : requestIdx , timestamp : block . timestamp , extended : false } ) ; uint256 timeLockExpiry = block . timestamp ; if ( msg . sender == primary ) { timeLockExpiry += defaultTimeLock ; } else { timeLockExpiry += extendedTimeLock ; requestMap [ requestMsgHash ] . extended = true ; } emit Requested ( _lockId , _callbackAddress , _callbackSelector , nonce , _whitelistedAddress , requestMsgHash , timeLockExpiry ) ; }",Requests an unlocking with a lock identifier and a callback .
3489,"function addStoneToBoard ( uint boardId , uint8 row , uint8 col ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; uint8 position = row * BOARD_ROW_SIZE + col ; require ( board . positionToColor [ position ] == 0 ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { board . positionToColor [ position ] = uint8 ( activeColor ) ; updateCaptures ( board , position , uint8 ( activeColor ) ) ; nextTurn ( board ) ; if ( board . didPassPrevTurn ) { board . didPassPrevTurn = false ; } StoneAddedToBoard ( boardId , activeColor , row , col ) ; } }",Adding a stone to a specific board and position ( row & col ) .
3491,"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint tokenId ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 || _index >= tokenCount ) { revert ( ) ; } else { uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { if ( resultIndex == _index ) { return loanId ; } resultIndex ++ ; } } revert ( ) ; } }",Maps the indices of lenders loans to tokens ids
3492,function getInvestorsLength ( ) public view returns ( uint256 ) { return investors . length ; },gets length of investors array NB - this length may differ from investorCount if list has not been pruned of zero balance investors
3494,function totalSupply ( ) public view returns ( uint256 ) { return pixelcons . length ; },Get the total number of PixelCons in existence
3495,"function externalTokensRecovery ( token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract
3497,function exchangeEtherForNominsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice ) ; return exchangeEtherForNomins ( ) ; },Exchange ETH to nUSD while insisting on a particular rate .
3499,"function payer ( address who ) public constant returns ( uint count , address [ ] origins ) { address [ ] memory m_origins = s_paid [ who ] ; return ( m_origins . length , m_origins ) ; }","Returns for the given address the number of times it was paid for , and an array of addresses who actually paid for the fee ( as one might pay the fee for another address )"
3500,"function doPayment ( uint _idDeposit , address _dest , ERC20 _token , uint _amount ) internal returns ( bool ) { if ( _amount == 0 ) return true ; if ( address ( _token ) == 0 ) { if ( ! _dest . send ( _amount ) ) return false ; } else { if ( ! _token . transfer ( _dest , _amount ) ) return false ; } Withdraw ( _idDeposit , _dest , _token , _amount ) ; return true ; }","Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `"
3501,function setCancelAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { cancelAnnounceDelay = _delay ; },"Sets the delay between when a cancel intention must be announced , and when the cancellation can actually be executed on-chain"
3504,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = personIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
3505,"function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external ;","Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type ."
3506,function topUpBalance ( uint verifyCode ) public payable mustBeAtStage ( Stage . Running ) { require ( msg . value > 0 ) ; require ( verifyCode == 28391728448 ) ; },This function must be used only if this contract balance is too low for oraclize_query to be executed
3507,"function getState ( uint256 _tokenId ) public view returns ( string stateName , uint256 sellingPrice , address owner ) { State storage state = states [ _tokenId ] ; stateName = state . name ; sellingPrice = stateIndexToPrice [ _tokenId ] ; owner = stateIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific state .
3508,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = gameItemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
3512,"function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner nonZero ( _newRegistryAdmin ) { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; emit RegistryAdminChanged ( _oldRegistryAdmin , registryAdmin ) ; }","Change the address of the registryAdmin , who has the privilege to create new accounts"
3513,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( this , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
3515,"function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( ! admins [ _address ] , ""This address is already an administrator."" ) ; require ( _address != owner , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }",Adds the specified address to the list of administrators .
3516,function setMtdPreAmount ( uint256 mtdPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( mtdPreAmount != mtdPreAmountInWei ) ; mtdPreAmount = mtdPreAmountInWei ; updatePrices ( ) ; },Set current mtdPreAmount price in wei for one token
3517,"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; assert ( c / a == b ) ; return c ; }","Multiplies two numbers , throws on overflow ."
3518,"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",function transfer which will move tokens from user account to an address specified at to parameter
3520,"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitycheck . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }",Submit the arbitrator 's answer to a question .
3522,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; emit NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
3523,function transferOwnership ( address newOwner ) onlyOwner public { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; },Allows the current owner to transfer control of the contract to a newOwner .
3526,"function withdrawMyDepositedSynths ( ) external { uint synthsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { synthsToSend = synthsToSend . add ( deposit . amount ) ; delete deposits [ i ] ; emit SynthDepositRemoved ( deposit . user , deposit . amount , i ) ; } } totalSellableDeposits = totalSellableDeposits . sub ( synthsToSend ) ; synthsToSend = synthsToSend . add ( smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( synthsToSend > 0 , ""You have no deposits to withdraw."" ) ; synth . transfer ( msg . sender , synthsToSend ) ; emit SynthWithdrawal ( msg . sender , synthsToSend ) ; }",Allows a user to withdraw all of their previously deposited synths from this contract if needed .
3527,"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal { requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }",Helper function actually performing the burning of tokens .
3528,"function changeCommission ( uint _newCommission ) public onlyOwner whenNotPaused { require ( _newCommission <= MAX_COMMISSION , ""commission should be <= MAX_COMMISSION"" ) ; require ( _newCommission != Commission , ""_newCommission==Commmission"" ) ; Commission = _newCommission ; emit NewCommission ( Commission ) ; }",ability for owner to change the service commmission
3529,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , ""Un-successfull call"" ) ; emit LogGenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( percentageTransferManager ) ; }",used to launch the Module with the help of factory
3533,function setLimit ( uint256 tokenId ) external onlyAdmin { require ( tokenId < tokens . length ) ; require ( pValidationState == pointsValidationState . Unstarted || pValidationState == pointsValidationState . LimitSet ) ; pointsLimit = tokenId ; pValidationState = pointsValidationState . LimitSet ; lastCheckedToken = 0 ; lastCalculatedToken = 0 ; winnerCounter = 0 ; setPause ( ) ; setPayoutDistributionId ( ) ; },Sets the id of the last token that will be given a prize .
3536,"function assign ( address _receiver , uint256 _amount ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) { _assign ( _receiver , _amount ) ; }","Assign ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens to ` _receiver ` from the Token Manager 's holdings"
3537,"function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validators may revoke arbitrary attributes"" ) ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; }",Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
3538,function addHash ( bytes32 [ ] _hashes ) onlyResolver public { for ( uint i = 0 ; i < _hashes . length ; i ++ ) { randomHashes . push ( _hashes [ i ] ) ; } },Adds an array of hashes to be used for resolving
3539,"function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) , ""invalid target address"" ) ; require ( _to != ownerOf ( _tokenId ) , ""already owns"" ) ; require ( ownerOf ( _tokenId ) == _from , ""wrong owner"" ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }",Internal function to clear current approval and transfer the ownership of a given token ID
3540,"function forceNeuroChainAddress ( address ethAddress , string neurochainAddress ) public onlyIcoContract { neuroChainAddresses [ ethAddress ] = neurochainAddress ; NeuroChainAddressSet ( ethAddress , neurochainAddress , block . timestamp , true ) ; }",Force NeuroChain Address to be associated to a standard ERC20 account
3541,"function getPriceOfPlot ( Geometry . Rect memory subPlotToPurchase , uint256 plotIndex ) private view returns ( uint256 ) { uint256 plotPricePerPixel = plotIdToPrice [ plotIndex ] ; require ( plotPricePerPixel > 0 ) ; return SafeMath . mul ( SafeMath . mul ( subPlotToPurchase . w , subPlotToPurchase . h ) , plotPricePerPixel ) ; }","Given a rect to purchase and the plot index , return the total price to be paid ."
3542,function setOwner ( address _newOwner ) onlyOwner external { owner = _newOwner ; },Change the owner to a new address .
3544,"function setTokenPoolReward ( uint256 newReward ) public onlyManufacturer returns ( bool ) { require ( newReward != 0 , ""newReward is required"" ) ; TokenPool storage p = pools [ msg . sender ] ; require ( p . rewardAmount != newReward , ""newReward should be different"" ) ; p . rewardAmount = newReward ; emit TokenPoolRewardUpdated ( msg . sender , newReward ) ; return true ; }",allows a token pool owner to set a new reward amount
3548,"function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) { return canValidate ( validator , attributeTypeID ) ; }",Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .
3549,function checkAdminOwner ( PledgeAdmin m ) internal constant { require ( ( msg . sender == m . addr ) || ( msg . sender == address ( m . plugin ) ) ) ; },A check to see if the msg.sender is the owner or the plugin contract for a specific Admin
3550,"function getScene ( uint256 _tokenId ) public view returns ( string sceneName , uint [ ] stars , uint256 sellingPrice , address owner ) { Scene storage scene = scenes [ _tokenId ] ; sceneName = scene . name ; stars = scene . stars ; sellingPrice = sceneIndexToPrice [ _tokenId ] ; owner = sceneIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific scene .
3551,"function isApprovedForAll ( address _owner , address _operator ) public view validAddress ( _owner ) validAddress ( _operator ) returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }",Get if ` ( _operator ) ` is an approved operator for owner ` ( _owner ) `
3552,"function unlock ( ) public onlyStates ( LockState . AcceptingUnlocks , LockState . ReleaseAll ) { unlockInvestor ( msg . sender ) ; }","unlocks investors funds , see unlockInvestor for details"
3553,function votedPerCent ( address voter ) constant external returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; },returns current voting result for given address in percent .
3554,"function voteAgainst ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Nay ; votesAgainst [ motionID ] = safeAdd ( votesAgainst [ motionID ] , weight ) ; emit VotedAgainst ( msg . sender , motionID , weight ) ; }",The sender casts a vote against confiscation of the target account 's nomin balance .
3556,function name ( ) external view returns ( string ) ;,A descriptive name for a collection of NFTs in this contract
3557,"function extractBalanceProofSignature ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) public view returns ( address ) { bytes32 message_hash = keccak256 ( keccak256 ( 'string message_id' , 'address receiver' , 'uint32 block_created' , 'uint192 balance' , 'address contract' ) , keccak256 ( 'Sender balance proof signature' , _receiver_address , _open_block_number , _balance , address ( this ) ) ) ; address signer = ECVerify . ecverify ( message_hash , _balance_msg_sig ) ; return signer ; }",Returns the sender address extracted from the balance proof .
3558,"function totalSupplyAt ( uint256 _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
3559,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
3560,"function approve ( address spender , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }",` msg.sender ` approves ` spender ` to spend ` value ` tokens
3562,function release ( ) external onlyOwner onlyInEmergency { stopped = false ; },"Called by the owner to end of emergency , returns to normal state"
3563,"function setPrices ( uint256 newBuyPrice , bool _openToSales ) onlyOwner public { buyPrice = newBuyPrice ; openToSales = _openToSales ; }",Allow users to buy tokens for ` newBuyPrice ` eth
3564,function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( ! tokenAvailable ) { return 0 ; } return balances [ _owner ] ; },Gets the balance of the specified address .
3565,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
3567,"function updateSubmissionGasPriceLimit ( uint256 _newSubmissionGasPriceLimit ) external onlyOwner { emit LogSubmissionGasPriceLimitUpdated ( submissionGasPriceLimit , _newSubmissionGasPriceLimit ) ; submissionGasPriceLimit = _newSubmissionGasPriceLimit ; }",The owner of the contract can update the order submission gas price limit .
3568,"function create ( uint256 baseUnitsToCreate ) external whenNotPaused ( ) requireNonZero ( baseUnitsToCreate ) requireMultiple ( baseUnitsToCreate ) { require ( ( totalSupply_ + baseUnitsToCreate ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; transferUnderlyingTokensWhenCreate ( erc20 , tokenInfo . tokenUnits , baseUnitsToCreate ) ; } mint ( msg . sender , baseUnitsToCreate ) ; }",Creates ETF tokens in exchange for underlying tokens .
3570,"function pauseWhitelist ( ) public onlyAdmin returns ( bool ) { paused = true ; Paused ( msg . sender , now ) ; return true ; }",Pauses the whitelist if there is any issue
3574,"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value > balanceOf [ _to ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; }",only the contract can operate this internal funktion
3576,"function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit ModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }",adds or removes addresses from the whitelist .
3578,function pauseContribution ( ) onlyOwner { paused = true ; },Pauses the contribution if there is any issue
3579,"function _setTokenUri ( uint256 _tokenId , string _uri ) validNFToken ( _tokenId ) internal { idToUri [ _tokenId ] = _uri ; }",this is a internal function which should be called from user-implemented external function .
3580,"function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;",Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .
3581,"function transferFrom ( address from , address to , uint256 index ) public returns ( bool ) { require ( loans [ index ] . lender == from ) ; return transfer ( to , index ) ; }","Transfers the loan to an address , only if the current owner is the `` from '' address"
3583,function symbol ( ) public pure returns ( string _deedSymbol ) ;,An abbreviated name for deeds managed by this contract
3588,function presale ( ) payable returns ( bool ) ;,Function to participate in the presale of the funding
3589,"function relay ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s , uint8 _instructionByte , uint128 _additionalGas ) private returns ( bool ) { address _relayedSender = getRelayedSender ( _tradeID , _instructionByte , _maximumGasPrice , _v , _r , _s ) ; if ( _relayedSender == _buyer ) { if ( _instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL ) { return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_BUYER_CANCEL ) { return doBuyerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else if ( _relayedSender == _seller ) { if ( _instructionByte == INSTRUCTION_RELEASE ) { return doRelease ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_CANCEL ) { return doSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL ) { return doSellerRequestCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else { require ( msg . sender == _seller , ""Unrecognised party"" ) ; return false ; } }",Relay a signed instruction from a party of an escrow .
3590,function setExchangeRates ( ExchangeRates _exchangeRates ) external optionalProxy_onlyOwner { exchangeRates = _exchangeRates ; },Set the ExchangeRates contract address where rates are held .
3591,"function increaseApprovalWithSender ( address _sender , address _spender , uint256 _addedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance + _addedValue ; require ( newAllowance >= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }",Core logic of the ` increaseApproval ` function .
3592,"function proxyApprove ( address _spender , uint _value , bytes32 _symbol , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _approve ( _createHolderId ( _spender ) , _value , _symbol , _createHolderId ( _sender ) ) ; }",Sets asset spending allowance for a specified spender .
3593,"function getTxStatus ( Data storage self , bytes32 txHash ) internal view returns ( bool txStatus ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; return self . Storage . getBool ( id ) ; }",Return boolean transaction status if the transaction has been used
3595,"function approve ( address _spender , uint256 _value ) returns ( bool success ) ;",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
3596,function finalizeCrowdsale ( ) public { require ( ( now > lastRoundEndTimestamp ( ) ) || ( totalCollected == hardCap ) || ( msg . sender == owner ) ) ; finalized = token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) { owner . transfer ( this . balance ) ; } },Finalizes ICO when one of conditions met : - end time reached OR - no more tokens available ( cap reached ) OR - message sent by owner
3597,"function canWithdraw ( address _holder ) public constant returns ( bool ) { if ( nextDepositToPayout [ _holder ] == deposits . length ) return false ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { uint amount = d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; if ( amount > 0 ) return true ; } } return false ; }",A check to see if a specific address has anything to collect
3598,"function lowerCeiling ( uint256 _lowerBy ) public onlyLimitedPrinter { uint256 newCeiling = totalSupplyCeiling - _lowerBy ; require ( newCeiling <= totalSupplyCeiling ) ; totalSupplyCeiling = newCeiling ; emit CeilingLowered ( _lowerBy , newCeiling ) ; }","Lowers the supply ceiling , further constraining the bound of what can be printed by the limited printer ."
3599,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPonies = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 ponyId ; for ( ponyId = 1 ; ponyId <= totalPonies ; ponyId ++ ) { if ( ponyIndexToOwner [ ponyId ] == _owner ) { result [ resultIndex ] = ponyId ; resultIndex ++ ; } } return result ; } },Returns a list of all Pony IDs assigned to an address .
3601,"function configure ( uint256 _maxHolderPercentage , bool _allowPrimaryIssuance ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; allowPrimaryIssuance = _allowPrimaryIssuance ; }",Used to intialize the variables of the contract
3602,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { bool sucsSlrLmt = _chkSellerLmts ( msg . sender , _value ) ; bool sucsByrLmt = _chkBuyerLmts ( _spender , _value ) ; require ( sucsSlrLmt == true && sucsByrLmt == true ) ; uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; allowance [ msg . sender ] [ _spender ] = _valueA ; Approval ( msg . sender , _spender , _valueA ) ; _valueA = 0 ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` coins from your account
3604,"function addAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = _createHolderId ( _partowner ) ; assets [ _symbol ] . partowners [ holderId ] = true ; Emitter ( eventsHistory ) . emitOwnershipChange ( 0x0 , _partowner , _symbol ) ; return OK ; }",Adds a co-owner for an asset with provided symbol .
3607,"function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) , ""new contract cannot be 0x0"" ) ; super . unpause ( ) ; }",This is public rather than external so we can call super.unpause without using an expensive CALL .
3609,"function validRequest ( bytes32 [ ] _proof , bytes5 _code , address _dest ) public view returns ( bool ) { return ! sentToAddress [ _dest ] && ! codeUsed [ _code ] && MerkleProof . verifyProof ( _proof , root , keccak256 ( abi . encodePacked ( _code ) ) ) ; }","Determine if a request to send SNT/ETH is valid based on merkle proof , and destination address"
3610,function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount ) ; },Internal function that ensures ` _amount ` is multiple of the granularity
3611,"function authorizeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( ! mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
3612,"function rewardToken ( address _recipient , uint _amount , uint _date ) external ;",Function used by the main partner to reward shares or tokens
3613,"function canBreedWith ( uint40 _momId , uint40 _dadId ) public view returns ( bool ) { require ( _momId > 0 ) ; require ( _dadId > 0 ) ; Cutie storage mom = cuties [ _momId ] ; Cutie storage dad = cuties [ _dadId ] ; return _canPairMate ( mom , _momId , dad , _dadId ) && _isBreedingPermitted ( _dadId , _momId ) ; }","Checks to see if two cuties can breed together ( checks both ownership and breeding approvals , but does not check if both cuties are ready for breeding ) ."
3614,"function isApprovedOrOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return ( _address == owner || tokenApprovals [ _tokenId ] == _address || operatorApprovals [ owner ] [ _address ] ) ; }",Check whether the given spender can transfer a given token ID
3615,"function withdrawInternal ( uint requested , bool all ) internal { require ( between [ msg . sender ] ) ; uint available = Splitter . balance ( ) ; uint transferring = 0 ; if ( all ) { transferring = available ; } else { available = requested ; } require ( transferring <= available ) ; amountsWithdrew [ msg . sender ] += transferring ; msg . sender . transfer ( transferring ) ; }","Checks whether the sender is allowed to withdraw and has sufficient funds , then withdraws ."
3616,"function getAccountStatus ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.allowed' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }",Get global approval status for the account holder
3617,function setSecurityGuard ( address _newSecurityGuard ) onlyOwner external { securityGuard = _newSecurityGuard ; },` onlyOwner ` Sets the address of ` securityGuard `
3618,"function requestArbitration ( address realitycheck , bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { RealityCheckAPI ( realitycheck ) . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! RealityCheckAPI ( realitycheck ) . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }","Request arbitration , freezing the question until we send submitAnswerByArbitrator"
3619,"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Count"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }",Get the tags related to the module factory
3622,"function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = gnt . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! gnt . transfer ( msg . sender , toTransfer ) ) throw ; }",Allow developer to unlock allocated tokens by transferring them from GNTAllocation to developer 's address .
3623,"function addBeneficiary ( address _beneficiary , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( block . timestamp < releaseDate ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenTimelock = new TokenTimelock ( token , _beneficiary , releaseDate ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenTimelock ) ; token . safeTransfer ( tokenTimelock , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenTimelock , _amount ) ; return tokenTimelock ; }","Example : addBeneficiary ( ` 0x123.. ` , 100 ) Will create a TokenTimelock instance on which if the ` release ( ) ` method is called after the release date ( specified in this contract constructor ) , the amount of tokens ( 100 ) will be transferred to the beneficiary ( ` 0x123.. ` ) ."
3625,"function hasVoted ( address account , uint motionID ) public view returns ( bool ) { return vote [ account ] [ motionID ] != Vote . Abstention ; }",Return if the specified account has voted on the specified motion
3627,"function processWhitelistedContribution ( uint256 allowedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { uint256 plannedContribution = whitelist [ msg . sender ] ; whitelist [ msg . sender ] = 0 ; WhitelistedUpdated ( plannedContribution , true ) ; if ( msg . value > plannedContribution ) { return handleAbovePlannedWhitelistedContribution ( allowedContribution , plannedContribution , refundAmount ) ; } if ( msg . value < plannedContribution ) { return handleBelowPlannedWhitelistedContribution ( plannedContribution ) ; } return handlePlannedWhitelistedContribution ( plannedContribution ) ; }","Returns the contribution to be used for a sender that had previously been whitelisted , and any refund value if expected ."
3628,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) ;",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
3630,"function setPermissionManager ( address _newManager , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { _setPermissionManager ( _newManager , _app , _role ) ; }",Sets ` _newManager ` as the manager of the permission ` _role ` in ` _app `
3631,"function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , amount ) ; if ( multisigs [ msigId ] . deposit == 0 ) delete multisigs [ msigId ] ; recipient . transfer ( amount ) ; }",Send ether out of this contract to multisig owner and update or delete entry in multisig mapping
3632,function setFundsWallet ( address _fundsWallet ) external onlyOwner { fundsWallet = _fundsWallet ; emit FundsWalletUpdated ( fundsWallet ) ; },Set the funds wallet where ETH raised is held
3633,"function transfer ( bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; if ( balances [ sender ] >= _value ) { balances [ sender ] -= _value ; balances [ _to ] += _value ; TransferHash ( sender , _to , _value ) ; return true ; } return false ; }",` _value ` tokens will be sended to ` _to `
3635,"function calculateAtomicFees ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; if ( isEthereumBased ( _tokens . secondaryToken . addr ) ) { uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : secondaryVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . secondaryToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; } else if ( isEthereumBased ( _tokens . priorityToken . addr ) ) { uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : priorityVwF . fees , rightTokenFee : priorityVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . priorityToken . addr } ) ; } else { revert ( ""non-eth atomic swaps are not supported"" ) ; } }",Calculates the fees to be transferred for an atomic swap .
3637,function consume ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; },consume digital artwork tokens for changing physical artwork
3639,function setSecurityGuard ( address _newSecurityGuard ) onlyOwner { securityGuard = _newSecurityGuard ; },` onlyOwner ` Sets the address of ` securityGuard `
3644,"function pledgeFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees + _value >= curTotalFees ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees + _value ) ; return true ; }","Pledges fees to the token holders , later to be claimed by burning"
3646,"function getListingsInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( uint64 [ ] ) { require ( _startIndex <= totalListings ( ) , ""Start index is out of bounds"" ) ; require ( _endIndex <= totalListings ( ) , ""End index is out of bounds"" ) ; require ( _startIndex <= _endIndex , ""End index is less than the start index"" ) ; uint64 length = _endIndex - _startIndex ; uint64 [ ] memory indexes = new uint64 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { indexes [ i ] = forSalePixelconIndexes [ _startIndex + i ] ; } return indexes ; }",Get the PixelCon indexes being sold from listing index ` ( _startIndex ) ` to ` ( _endIndex ) `
3648,"function upgradeStorage ( address addrAdverStorage ) public onlyOwner ( ""upgradeStorage"" ) { for ( uint i = 0 ; i < bidIdList . length ; i ++ ) { cancelCampaign ( bidIdList [ i ] ) ; } delete bidIdList ; lastBidId = advertisementStorage . getLastBidId ( ) ; advertisementFinance . setAdsStorageAddress ( addrAdverStorage ) ; advertisementStorage = BaseAdvertisementStorage ( addrAdverStorage ) ; }",Upgrade storage contract used by this contract Upgrades Advertisement Storage contract addres with no need to redeploy Advertisement contract .
3649,function proxiedContribution ( address _miner ) public payable returns ( bool ) { if ( _miner == address ( 0 ) ) { return contribute ( msg . sender ) ; } else { return contribute ( _miner ) ; } },Contribute to the mining of BTH on behalf of another miner
3650,"function setRegisteredAuthority ( Data storage self , string issuerFirm , address authorityAddress , bool approved ) internal returns ( bool success ) { require ( isRegisteredFirm ( self , issuerFirm ) , ""Error: `issuerFirm` must be registered."" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , authorityAddress ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , authorityAddress ) ) ; require ( self . Storage . setBool ( id_a , approved ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setString ( id_b , issuerFirm ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }",Method for setting a registered issuer firm authority
3651,"function paymentAction ( bytes32 _requestId , uint256 [ ] _payeeAmounts , uint256 [ ] _additionalAmounts ) external whenNotPaused { if ( requestCore . getState ( _requestId ) == RequestCore . State . Created && msg . sender == requestCore . getPayer ( _requestId ) ) { acceptAction ( _requestId ) ; } if ( _additionalAmounts . length != 0 ) { additionalAction ( _requestId , _additionalAmounts ) ; } paymentInternal ( _requestId , _payeeAmounts ) ; }",Function to pay a request in ERC20 token .
3652,function setBursar ( address _newBursar ) external requireGod { require ( _newBursar != address ( 0 ) ) ; bursarAddress = _newBursar ; },Assigns a new address to act as the Bursar .
3653,function transferOwnership ( address _newOwner ) onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } },Transfer ownership from ` owner ` to ` newOwner `
3654,function unpause ( ) public onlyCEO whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive call .
3656,"function approve ( address spender , uint256 amount ) public returns ( bool success ) { require ( mOnApprove ( msg . sender , spender , amount ) ) ; require ( ( amount == 0 ) || ( _allowed [ msg . sender ] [ spender ] == 0 ) ) ; _allowed [ msg . sender ] [ spender ] = amount ; Approval ( msg . sender , spender , amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
3657,function isContract ( address _address ) private view returns ( bool ) { uint256 _size ; assembly { _size := extcodesize ( _address ) } return _size > 0 ; },Ensures that a given address is a contract by making sure it has code .
3658,"function transfer ( address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( msg . sender ) ; payDividendsTo ( _to ) ; return super . transfer ( _to , _value ) ; }",hook on standard ERC20 # transfer to pay dividends
3662,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = allStarIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
3665,"function mine ( address _target , uint256 _minedAmount ) onlyDoftManager { require ( _minedAmount > 0 ) ; require ( _target != 0x0 ) ; require ( miningStorage - _minedAmount >= 0 ) ; require ( balanceOf [ doftManager ] >= _minedAmount ) ; require ( balanceOf [ _target ] + _minedAmount > balanceOf [ _target ] ) ; balanceOf [ doftManager ] -= _minedAmount ; balanceOf [ _target ] += _minedAmount ; miningStorage -= _minedAmount ; Mine ( _target , _minedAmount ) ; }",Send ` _minedAmount ` to ` _target ` as a reward for mining
3666,"function tokenBurn ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == true ) ; tokenReward . transfer ( address ( 0 ) , _amount ) ; }",A function to burn unsold DGZ tokens .
3667,"function batchTransfer ( address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing returns ( bool ) { return _batchTransfer ( msg . sender , recipients , quantities ) ; }","Performs ERC20 transfers in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from the message sender to ` recipients [ i ] ` ."
3668,"function tokenBurner ( uint256 _amount ) onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }",Used to burn tokens and decrease total supply
3669,"function getApproved ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return tokenApprovals [ _tokenId ] ; }",Get the approved address for PixelCon ` ( _tokenId ) `
3670,"function reclaim ( ) public onlyOwner returns ( bool ) { require ( block . timestamp > releaseDate ) ; uint256 reclaimableAmount = token . balanceOf ( address ( this ) ) ; token . safeTransfer ( owner , reclaimableAmount ) ; emit Reclaim ( reclaimableAmount ) ; return true ; }",Transfers the remaining tokens that were not locked for any beneficiary to the owner of this contract .
3671,function getArrayAddress ( bytes32 _key ) internal view returns ( address [ ] ) { return addressArrayStorage [ _key ] ; },"Get functions to get the array of the required data type Ex1- mapping ( address = > bytes32 [ ] ) tokensOwnedByOwner ; getArrayBytes32 ( keccak256 ( abi.encodePacked ( `` tokensOwnedByOwner '' , 0x1 ) ) ; It return the bytes32 array Ex2- uint256 _len = tokensOwnedByOwner [ 0x1 ] .length ; replace with getArrayBytes32 ( keccak256 ( abi.encodePacked ( `` tokensOwnedByOwner '' , 0x1 ) ) .length ;"
3673,"function convertOldTokens ( address _receiver , uint256 _oldAmount ) external onlyOwner { require ( _receiver != address ( 0 ) ) ; require ( _oldAmount > 0 ) ; uint256 amountNewTokens = _oldAmount . mul ( 2 ) ; balances [ owner ] = balances [ owner ] . sub ( amountNewTokens ) ; balances [ _receiver ] = balances [ _receiver ] . add ( amountNewTokens ) ; }",To convert the old tokens to the new version manually
3674,"function buyTokenFromModerator ( uint _proposalID , address _buyer , uint _date , bool _presale ) payable external returns ( bool ) { if ( msg . sender != fundings [ _proposalID ] . moderator ) throw ; return buyTokensFor ( _proposalID , _buyer , _date , _presale ) ; }",Function used by the moderator to buy shares or tokens
3675,function changeWCT2Controller ( address _newController ) public onlyController { wct2 . changeController ( _newController ) ; },"The owner of this contract can change the controller of the WCT2 token Please , be sure that the owner is a trusted agent or 0x0 address ."
3678,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalElements = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 elementId ; for ( elementId = 0 ; elementId < totalElements ; elementId ++ ) { if ( elementToOwner [ elementId ] == _owner ) { result [ resultIndex ] = elementId ; resultIndex ++ ; } } return result ; } },Returns a list of all element IDs assigned to an address .
3680,"function _distributeReferrers ( uint256 _userId , uint256 _sum ) private { uint256 [ ] memory referrers = users [ _userId ] . referrersByLevel ; for ( uint i = 0 ; i < referralLevelsCount ; i ++ ) { uint256 referrerId = referrers [ i ] ; if ( referrers [ i ] == 0 ) break ; if ( users [ referrerId ] . totalPay < minSumReferral ) continue ; uint16 [ ] memory percents = getReferralPercents ( users [ referrerId ] . totalPay ) ; uint256 value = _sum * percents [ i ] / 10000 ; users [ referrerId ] . balance = users [ referrerId ] . balance . add ( value ) ; users [ referrerId ] . referrersReceived = users [ referrerId ] . referrersReceived . add ( value ) ; emit ReferrerDistribute ( _userId , referrerId , value ) ; } }",distribute value of tx to referrers of user
3683,function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCalncelled ( ) ; },` onlyArbitrator ` Cancels the entire campaign voiding all milestones vo
3686,"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; isOperatorFor [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
3687,"function mBeforeStateTransition ( ETOState oldState , ETOState newState ) internal constant returns ( ETOState newStateOverride ) ;","called before state transitions , allows override transition due to additional business logic"
3688,function getUserBalance ( address _user ) public view onlyAllowed returns ( uint256 _balance ) { return balanceUsers [ _user ] ; },Get balance of coins stored in the contract by a specific user This function can only be called by the Advertisement contract
3690,"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; require ( _address != address ( tokenReward ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract
3691,"function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == holderId || get ( store , assetPartowners , _symbol , holderId ) ) ; }",Checks if a specified address has asset owner or co-owner rights .
3693,"function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific element via transferFrom ( ) .
3694,"function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit ChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }",Used to change the fee of the setup cost
3695,function settle ( ) { data . settle ( ) ; ChannelSettled ( data . settled ) ; },Settle the transfers and balances of the channel and pay out to each participant .
3696,"function setValidatorSigningKey ( address newSigningKey ) external { require ( isValidator ( msg . sender ) , ""only validators may modify validator signing keys"" ) ; require ( _signingKeys [ newSigningKey ] == address ( 0 ) , ""a signing key matching the provided address already exists"" ) ; delete _signingKeys [ _validators [ msg . sender ] . signingKey ] ; _validators [ msg . sender ] . signingKey = newSigningKey ; _signingKeys [ newSigningKey ] = msg . sender ; emit ValidatorSigningKeyModified ( msg . sender , newSigningKey ) ; }","Set the public address associated with a validator signing key , used to sign off-chain attribute approvals , as ` newSigningKey ` ."
3697,"function transferFrom ( address _from , address _to , uint256 _value ) onlyAllowed ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
3698,"function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( snt ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
3700,"function amountReceived ( uint value ) public view returns ( uint ) { return safeDiv_dec ( value , safeAdd ( UNIT , transferFeeRate ) ) ; }",The amount the recipient will receive if you send a certain number of tokens .
3701,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
3702,"function getMeal ( uint256 _tokenId ) public view returns ( string mealName , uint256 sellingPrice , address owner ) { Meal storage meal = meals [ _tokenId ] ; mealName = meal . name ; sellingPrice = mealIndexToPrice [ _tokenId ] ; owner = mealIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific meal .
3703,"function init ( ) public auth { gem . approve ( tub , uint ( - 1 ) ) ; skr . approve ( tub , uint ( - 1 ) ) ; dai . approve ( tub , uint ( - 1 ) ) ; gov . approve ( tub , uint ( - 1 ) ) ; gem . approve ( owner , uint ( - 1 ) ) ; skr . approve ( owner , uint ( - 1 ) ) ; dai . approve ( owner , uint ( - 1 ) ) ; gov . approve ( owner , uint ( - 1 ) ) ; dai . approve ( otc , uint ( - 1 ) ) ; gem . approve ( otc , uint ( - 1 ) ) ; tubParamUpdate ( ) ; }",Sets all allowances and updates tub liquidation ratio
3704,"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }",Buy tokens from contract by sending ethereum to contract address with no minimum contribution
3707,"function getVestingTime ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ TIME_INDEX ] ; }",Get the time at which a given schedule entry will vest .
3709,"function respondChallengeBefore ( uint64 slot , bytes32 challengingTxHash , uint256 respondingBlockNumber , bytes respondingTransaction , bytes proof , bytes signature ) external { require ( challenges [ slot ] . contains ( challengingTxHash ) , ""Responding to non existing challenge"" ) ; uint256 index = uint256 ( challenges [ slot ] . indexOf ( challengingTxHash ) ) ; checkResponse ( slot , index , respondingBlockNumber , respondingTransaction , signature , proof ) ; slashBond ( challenges [ slot ] [ index ] . challenger , msg . sender ) ; coins [ slot ] . state = State . EXITING ; challenges [ slot ] . remove ( challengingTxHash ) ; emit RespondedExitChallenge ( slot ) ; }",Can only be called in the second window of the exit period .
3710,"function claimTokens ( ERC20TokenInterface _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }",Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
3711,"function approveAccount ( address target , bool approve ) onlyAdmin public { approvedAccount [ target ] = approve ; emit ApprovedAccount ( target , approve ) ; }",` Allow | Prevent ` ` target ` from sending & receiving tokens
3712,"function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) , ""Must supply an account address to withdraw fees"" ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }",Withdraw tokens from the fee pool into a given account .
3713,"function ( ) payable { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender , msg . sig , msg . data ) ) revert ( ) ; } else { revert ( ) ; } }","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
3714,"function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( address ( this ) , IModuleFactory ( factory ) . owner ( ) , _amount ) , ""Unable to take fee"" ) ; return true ; }",used to withdraw the fee by the factory owner
3715,"function transfer ( address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }",Standard transfer ( ) but with check of frozen status
3716,function ( ) payable { require ( isContract ( controller ) ) ; bool proxyPayment = TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ; require ( proxyPayment ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
3718,function getTokensBalance ( uint index ) private view returns ( uint ) { Airdrop memory airdrop = airdrops [ index ] ; Token t = Token ( airdrop . tokenSC ) ; return ( t . balanceOf ( this ) ) ; },Get the balance of a specific token within the smart contracts
3719,"function changeAdmin ( address newAdmin ) public validate_address ( newAdmin ) onlyAdmin { if ( admin == newAdmin ) revert ( ) ; AdminOwnershipTransferred ( admin , newAdmin ) ; admin = newAdmin ; }",only the admin is allowed to change the admin .
3725,"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] - 1 ; delete idToOwner [ _tokenId ] ; }",Use and override this function with caution .
3727,"function decreaseApprovalWithSender ( address _sender , address _spender , uint256 _subtractedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance - _subtractedValue ; require ( newAllowance <= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }",Core logic of the ` decreaseApproval ` function .
3728,"function approve ( address _spender , uint256 _value ) public returns ( bool _success ) ;","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount ."
3729,"function approveAllowance ( Data storage self , address spender , uint amount ) internal returns ( bool success ) { require ( spender != 0x0 , ""Error: `spender` address cannot be null."" ) ; string memory currency = getTokenSymbol ( self , address ( this ) ) ; require ( getTokenFrozenBalance ( self , currency , getForwardedAccount ( self , spender ) ) == 0 , ""Error: Spender must not have a frozen balance directly"" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , msg . sender ) , getForwardedAccount ( self , spender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . getUint ( id_a ) == 0 || amount == 0 , ""Error: Allowance must be zero (0) before setting an updated allowance for spender."" ) ; require ( self . Storage . getUint ( id_b ) >= amount , ""Error: Allowance cannot exceed msg.sender token balance."" ) ; require ( self . Storage . setUint ( id_a , amount ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Approval ( msg . sender , spender , amount ) ; return true ; }",Low-level method to set the allowance for a spender
3730,"function artWorkChangeRequest ( uint256 _tokenId , string _meta , uint8 _v , bytes32 _r , bytes32 _s ) public payable returns ( uint256 ) { address recoveredSigner = verify ( keccak256 ( _meta ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . sender == token . getOwner ( _tokenId ) ) ; uint256 fee = getArtWorkChangeFee ( _tokenId ) ; require ( msg . value >= fee ) ; uint256 changeRequestCounter = artWorkChangeRequests . length ; artWorkChangeRequests . push ( ArtWorkChangeRequest ( msg . sender , _tokenId , changeRequestCounter , _meta , now , false ) ) ; token . increaseUpdateMetadataCounter ( _tokenId ) ; transferEthers ( platformWallet , msg . value ) ; emit ArtWorkChangeRequestMade ( msg . sender , _tokenId , changeRequestCounter , _meta , msg . value , now ) ; return changeRequestCounter ; }",it allows token owner to create art work change request first user upload 2 images then do call this function admin can reject or approve it
3731,"function areaRentPrice ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) public view returns ( uint ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return rentals . blocksRentPrice ( numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; }",get area rent price in wei for number of periods specified ( period length is specified in rentals contract )
3732,"function createRequestFromBytes ( bytes _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( isTrustedContract ( msg . sender ) , ""caller should be a trusted contract"" ) ; address creator = extractAddress ( _data , 0 ) ; address payer = extractAddress ( _data , 20 ) ; require ( creator != 0 , ""creator should not be 0"" ) ; uint8 payeesCount = uint8 ( _data [ 40 ] ) ; uint256 offsetDataSize = uint256 ( payeesCount ) . mul ( 52 ) . add ( 41 ) ; uint8 dataSize = uint8 ( _data [ offsetDataSize ] ) ; string memory dataStr = extractString ( _data , dataSize , offsetDataSize . add ( 1 ) ) ; address mainPayee ; int256 mainExpectedAmount ; if ( payeesCount != 0 ) { mainPayee = extractAddress ( _data , 41 ) ; mainExpectedAmount = int256 ( extractBytes32 ( _data , 61 ) ) ; } requestId = generateRequestId ( ) ; requests [ requestId ] = Request ( payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , payer , creator , dataStr ) ; for ( uint8 i = 1 ; i < payeesCount ; i = i . add ( 1 ) ) { address subPayeeAddress = extractAddress ( _data , uint256 ( i ) . mul ( 52 ) . add ( 41 ) ) ; require ( subPayeeAddress != 0 , ""subpayee should not be 0"" ) ; subPayees [ requestId ] [ i - 1 ] = Payee ( subPayeeAddress , int256 ( extractBytes32 ( _data , uint256 ( i ) . mul ( 52 ) . add ( 61 ) ) ) , 0 ) ; emit NewSubPayee ( requestId , subPayeeAddress ) ; } return requestId ; }",Function used by currency contracts to create a request in the Core from bytes .
3734,"function multisend ( address tokenAddress , address [ ] destinations , uint256 [ ] values ) external onlyOwner { require ( destinations . length == values . length ) ; uint256 i = 0 ; while ( i < destinations . length ) { Nomin ( tokenAddress ) . transferSenderPaysFee ( destinations [ i ] , values [ i ] ) ; i += 1 ; } }",Multisend airdrops tokens to an array of destinations .
3737,"function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }",Upgrade tokens to the new token contract .
3738,"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryAttributeTypeID , uint256 minimumRequiredStake , uint256 jurisdictionFee ) { return ( _attributeTypes [ attributeTypeID ] . description , _attributeTypes [ attributeTypeID ] . restricted , _attributeTypes [ attributeTypeID ] . onlyPersonal , _attributeTypes [ attributeTypeID ] . secondarySource , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID , _attributeTypes [ attributeTypeID ] . minimumStake , _attributeTypes [ attributeTypeID ] . jurisdictionFee ) ; }",Get comprehensive information on an attribute type with ID ` attributeTypeID ` .
3739,"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; operators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets
3740,"function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; if ( ! tokenMint ( msg . sender , _amount ) ) revert ( ) ; return true ; }","Used to mint tokens , only usable by the contract owner"
3741,"function transfer ( address destination , uint256 amount ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }",Transfers ` amount ` from msg.sender to ` destination `
3742,"function bountyTokenWithdrawal ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; require ( bountyPaid == false ) ; tokenReward . transfer ( beneficiary , bountyAmount ) ; bountyPaid = true ; }",A function to withdraw tokens for bounty campaign .
3743,"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }",Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
3744,"function adminWithdraw ( address _to ) public { require ( msg . sender == admin , ""Only the admin can call this function"" ) ; _to . transfer ( address ( this ) . balance ) ; }",Withdraw all volunteered funds to ` ( _to ) `
3747,"function setStepLimits ( uint256 _firstStepLimit , uint256 _secondStepLimit ) public onlyCLevel { firstStepLimit = _firstStepLimit ; secondStepLimit = _secondStepLimit ; }",Any C-level can change first Step Limit .
3748,function end ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . previous ; },Get the node at the end of a double linked list .
3749,"function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }","Creates a loan request , the loan can be generated with any borrower and conditions ; if the borrower agrees it must call the `` approve '' function ."
3750,function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external ;,Sets the ticker registration fee in POLY tokens
3751,"function claimRefund ( ) public whenNotPaused { require ( hasEnded ( ) && ! goalReached ( ) && isRefunding ) ; vault . refund ( msg . sender ) ; token . refundTokens ( msg . sender , tokensBought [ msg . sender ] ) ; }","If crowdsale is unsuccessful , investors can claim refunds here"
3752,function getTags ( ) public view returns ( bytes32 [ ] ) ;,Get the tags related to the module factory
3753,function getTagByModuleType ( uint8 _moduleType ) public view returns ( bytes32 [ ] ) { return availableTags [ _moduleType ] ; },Use to get all the tags releated to the functionality of the Module Factory .
3754,"function forceRejectVotes ( bytes32 _key , address _user ) external onlyContractOwner returns ( uint ) { return _revoke ( _key , _user ) ; }",Revoke user votes for transaction Can be called only by contract owner
3755,"function claimTokens ( address _token ) public onlyOwner { ExchangerI exchanger = ExchangerI ( factory . exchanger ( ) ) ; require ( address ( exchanger ) != 0x0 ) ; ERC20Basic wpr = ERC20Basic ( exchanger . wpr ( ) ) ; require ( _token != address ( wct2 ) && _token != address ( wpr ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
3756,"function voteFor ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Yea ; votesFor [ motionID ] = safeAdd ( votesFor [ motionID ] , weight ) ; emit VotedFor ( msg . sender , motionID , weight ) ; }",The sender casts a vote in favour of confiscation of the target account 's nomin balance .
3757,function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceId_ERC721Exists ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
3761,"function verifyTransfer ( address _from , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( onWhitelist ( _to ) && onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && isSTOAttached ( ) ) { return Result . NA ; } return onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }","default implementation of verifyTransfer used by SecurityToken If the transfer request comes from the STO , it only checks that the investor is in the whitelist If the transfer request comes from a token holder , it checks that : a ) Both are on the whitelist b ) Seller 's sale lockup period is over c ) Buyer 's purchase lockup is over"
3762,"function batchCreateSingleSeedAuction ( uint8 [ ] _teamIds , uint8 [ ] _posIds , uint256 [ ] _attributes , uint256 [ ] _playerOverrideIds , uint256 [ ] _mlbPlayerIds , uint256 _startPrice ) public onlyGameManager whenNotPaused { require ( isBatchSupported ) ; require ( _teamIds . length > 0 && _posIds . length > 0 && _attributes . length > 0 && _playerOverrideIds . length > 0 && _mlbPlayerIds . length > 0 ) ; require ( nonFungibleContract != address ( 0 ) ) ; uint256 nftId ; require ( _startPrice != 0 ) ; for ( uint ii = 0 ; ii < _mlbPlayerIds . length ; ii ++ ) { require ( _teamIds [ ii ] != 0 ) ; nftId = nonFungibleContract . createSeedCollectible ( _teamIds [ ii ] , _posIds [ ii ] , _attributes [ ii ] , address ( this ) , 0 , _playerOverrideIds [ ii ] , _mlbPlayerIds [ ii ] ) ; _createSale ( nftId , _startPrice , 0 , SALES_DURATION , address ( this ) ) ; } }",Helps in creating single seed auctions in batches
3763,"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }",Converts an amount to RCN using the loan oracle .
3764,function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Optional ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
3765,"function approve ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; Approval ( owner , _to , _tokenId ) ; } }",Approves another address to claim for the ownership of the given token ID
3766,"function grant_token_from_offchain ( address _toAddr , uint _nTokens , string _ref ) public onlyRobot { require ( ( campaignState == 2 ) || ( campaignState == 1 ) ) ; do_grant_tokens ( _toAddr , _nTokens ) ; TokenGranted ( _toAddr , _nTokens , _ref ) ; }",Gnenerate token `` manually '' without payment We intend to use this to generate tokens from Bitcoin contributions without without Ether being sent to this contract Note that this function can be triggered only by our BTC processing robot .
3767,function getValidator ( uint256 index ) external view returns ( address ) { return _validatorAccounts [ index ] ; },Get the account of the validator at index ` index ` .
3768,function ( ) external { revert ( ) ; },It 's a fallback function supposed to return sent Ethers by reverting the transaction
3769,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { approve ( _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( keccak256 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _value , this , _extraData ) ) { revert ( ) ; } return true ; }","` msg.sender ` approves ` _spender ` to send ` _value ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
3771,"function getAnime ( uint256 _tokenId ) public view returns ( string animeName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; animeName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific person .
3772,"function multisend ( address [ ] _recipients , uint256 [ ] _balances ) external { require ( _recipients . length == _balances . length , ""not equal length"" ) ; require ( _recipients . length <= multiSendLimit , ""more than limit"" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }",Function to send multiple token transfers in one tx
3773,"function allowance ( address _owner , address _spender ) public view returns ( uint256 _remaining ) ;",Returns the amount which ` _spender ` is still allowed to withdraw from ` _owner ` .
3775,"function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }",Returns the contribution and refund value to be used when the transaction value is lower than the whitelisted contribution for the sender .
3776,"function _transferSenderPaysFee_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee ) ; }",Ability to transfer where the sender pays the fees ( not ERC20 )
3778,"function assetPrices ( address asset ) public view returns ( uint ) { ( Error err , Exp memory result ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return 0 ; } return result . mantissa ; }",Reads scaled price of specified asset from the price oracle
3779,"function name ( ) external pure returns ( string ) { return ""Su Squares"" ; }",A descriptive name for a collection of NFTs in this contract
3781,"function addOwnToken ( ) internal returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }",Allow the dev to set it 's own token as accepted payment .
3782,function setVotingPeriod ( uint duration ) external onlyOwner { require ( MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD ) ; require ( duration <= havven . feePeriodDuration ( ) ) ; votingPeriod = duration ; },Set the length of time a vote runs for .
3783,"function getAnimecard ( uint256 _tokenId ) external view returns ( string characterName , string studioName , string characterImageUrl , string characterImageHash , uint256 sellingPrice , address owner ) { Animecard storage animecard = animecards [ _tokenId ] ; characterName = animecard . characterName ; studioName = animecard . studioName ; characterImageUrl = animecard . characterImageUrl ; characterImageHash = animecard . characterImageHash ; sellingPrice = animecardToPrice [ _tokenId ] ; owner = animecardToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific animecard .
3784,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cardTokenToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
3785,"function clearCollection ( uint64 _collectionIndex ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , ""Collection is already cleared"" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; pixelcon . collectionIndex = 0 ; } delete collectionNames [ _collectionIndex ] ; delete collectionTokens [ _collectionIndex ] ; emit ClearCollection ( _collectionIndex ) ; return _collectionIndex ; }",Clear collection # ` ( _collectionIndex ) `
3786,function disableNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = false ; return true ; },Used to disable new stakes from being made Only usable by contract admin
3790,"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }","Subtracts two numbers , throws on overflow ( i.e ."
3791,"function claimPrepaid ( uint _index , uint _boughtTokensPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external EarliestBackersSet { if ( backers [ msg . sender ] [ _index ] . prepaid == true && backers [ msg . sender ] [ _index ] . claimed == false && backers [ msg . sender ] [ _index ] . tokenAmount == _tokenAmount && backers [ msg . sender ] [ _index ] . tokenPrice == _boughtTokensPrice && backers [ msg . sender ] [ _index ] . privateHash == sha3 ( _privatePhrase , msg . sender ) && backers [ msg . sender ] [ _index ] . backerRank == _backerRank ) { backers [ msg . sender ] [ _index ] . claimed = true ; claimedPrepaidUnits += _tokenAmount ; PrepaidTokensClaimedEvent ( msg . sender , _index , _boughtTokensPrice , _tokenAmount ) ; } else { throw ; } }",Claiming ` _tokenAmount.number ( ) ` superDAO tokens by ` msg.sender.address ( ) `
3792,"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }",function transferFrom : moves tokens from one address to another
3793,"function createInvite ( bytes _sig ) public onlyUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( ! pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = true ; emit InviteCreated ( msg . sender , inviteAddress ) ; }",Create an invite using the signing model described in the contract description
3794,function hasSellerBeenAccepted ( address seller ) public view validAddress ( seller ) returns ( bool ) { return sellerInfo [ seller ] . createdAt != 0 ; },Checks if a DataResponse for a given seller has been accepted .
3796,"function _adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { TokenLib . adjustInvestorCount ( investorData , _from , _to , _value , balanceOf ( _to ) , balanceOf ( _from ) ) ; }",Keeps track of the number of non-zero token holders
3797,"function getTiki ( uint256 _tokenId ) public view returns ( string tikiName , uint256 currentPrice , uint256 basePrice , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { TikiMask storage tiki = tikiMasks [ _tokenId ] ; tikiName = tiki . name ; currentPrice = priceOf ( _tokenId ) ; basePrice = tiki . basePrice ; currentOwner = tikiIndexToOwner [ _tokenId ] ; bagHolderFund = tiki . bagHolderFund ; isBagFundAvailable = now > ( tiki . saleTime + priceFallDuration ) ; }",Returns all the relevant information about a specific tiki .
3799,"function canAdvertise ( address advertiser , uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external view returns ( bool ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return ads . canAdvertiseOnBlocks ( advertiser , blocksList ( fromX , fromY , toX , toY ) ) ; }",check if an advertiser is allowed to put ads within area ( i.e .
3803,"function mOnTransfer ( address from , address to , uint256 amount ) internal returns ( bool allow ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
3804,function updateStageCap ( uint256 _tokens ) internal returns ( uint256 ) { Stage storage stage = stages [ currentStage ] ; uint256 cap = stage . cap ; if ( cap >= _tokens ) { stage . cap = cap . sub ( _tokens ) ; return 0 ; } stage . cap = 0 ; uint256 excessTokens = _tokens . sub ( cap ) ; if ( icoTokensLeft >= excessTokens ) { icoTokensLeft = icoTokensLeft . sub ( excessTokens ) ; return 0 ; } icoTokensLeft = 0 ; return excessTokens . sub ( icoTokensLeft ) ; },Updates current stage cap and returns amount of excess tokens if ICO does not have enough tokens
3805,function reclaimEther ( ) onlyOwner external { owner . transfer ( address ( this ) . balance ) ; },Transfer all Ether held by the contract to the owner .
3809,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 0 ) ; return allPermissions ; },Return the permissions flag that are associated with STO
3810,"function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) && identifierToRentPeriodEndTimestamp [ _deedId ] < now || _rents ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }",Set the data associated with a plot .
3812,"function isWhitelisted ( address _investor , uint256 _tier ) public constant returns ( bool ) { WhitelistedInvestor memory investor = investors [ _investor ] ; return ( investor . tier <= _tier && investor . status ) ; }",Notifies if an investor is whitelisted for contribution
3813,"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return FundInterface ( msg . sender ) . getManager ( ) == ofParticipant ; }",Checks whether investment is permitted for a participant
3814,function changeOwner ( address _newOwner ) onlyOwner public { newOwner = _newOwner ; },` owner ` can step down and assign some other address to this role
3815,"function updateFeeForCurrentStakingInterval ( ) external onlyOperator isDoneStaking { require ( feeCalculated == false ) ; uint feeReceived = feeToken . balanceOf ( this ) ; feeForTheStakingInterval = feeForTheStakingInterval . add ( feeReceived . add ( this . balance . div ( weiPerFee ) ) ) ; feeCalculated = true ; FeeCalculated ( feeForTheStakingInterval , feeReceived , this . balance , startBlock , endBlock ) ; if ( feeReceived > 0 ) feeToken . burnTokens ( feeReceived ) ; if ( this . balance > 0 ) wallet . transfer ( this . balance ) ; }",To update the price of FEE tokens to the current value .
3817,"function mintWithData ( address _investor , uint256 _value , bytes _data ) public onlyModuleOrOwner ( MINT_KEY ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , ""Investor is 0"" ) ; require ( _updateTransfer ( address ( 0 ) , _investor , _value , _data ) , ""Transfer invalid"" ) ; _adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _value ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; emit Minted ( _investor , _value ) ; emit Transfer ( address ( 0 ) , _investor , _value ) ; return true ; }",mints new tokens and assigns them to the target _investor .
3819,"function transferFrom ( address _from , address _to , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
3820,"function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( _value >= 0 ) ; require ( _balanceOf [ _from ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _from ] -= _value ; _totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` ."
3821,"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }",Used to approve a third-party to send funds on your behalf
3822,"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal whenNotPaused ifWhitelisted ( _beneficiary ) { require ( initialized ) ; amountInUSDCents = convertToCents ( _weiAmount , etherPriceInCents , 18 ) ; if ( assignedBonusRates [ _beneficiary ] == 0 ) { require ( amountInUSDCents >= minContributionInUSDCents ) ; assignedBonusRates [ _beneficiary ] = getBonusPercentage ( amountInUSDCents ) ; } super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }",Additional validation rules before token contribution is actually allowed .
3825,"function getSupplyRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;","Gets the current supply interest rate based on the given asset , total cash and total borrows"
3828,"function transfer ( address _to , uint256 _value ) returns ( bool ) ;",send ` _value ` token to ` _to ` from ` msg.sender `
3829,"function transfer ( address to , uint value ) public returns ( bool ) ;",send ` value ` token to ` to ` from ` msg.sender `
3831,function setNextSale ( address _sale ) external validAddress ( _sale ) onlymanyowners ( keccak256 ( msg . data ) ) { m_nextSale = _sale ; },set address of a sale that will be next one after the current sale is finished
3836,"function verifyTransfer ( address _from , address _to , uint256 _amount ) public checkGranularity ( _amount ) returns ( bool ) { if ( ! freeze ) { bool isTransfer = false ; if ( transferFunctions [ getSig ( msg . data ) ] ) { isTransfer = true ; } if ( modules [ TRANSFERMANAGER_KEY ] . length == 0 ) { return true ; } bool isInvalid = false ; bool isValid = false ; bool isForceValid = false ; for ( uint8 i = 0 ; i < modules [ TRANSFERMANAGER_KEY ] . length ; i ++ ) { ITransferManager . Result valid = ITransferManager ( modules [ TRANSFERMANAGER_KEY ] [ i ] . moduleAddress ) . verifyTransfer ( _from , _to , _amount , isTransfer ) ; if ( valid == ITransferManager . Result . INVALID ) { isInvalid = true ; } if ( valid == ITransferManager . Result . VALID ) { isValid = true ; } if ( valid == ITransferManager . Result . FORCE_VALID ) { isForceValid = true ; } } return isForceValid ? true : ( isInvalid ? false : isValid ) ; } return false ; }",validate transfer with TransferManager module if it exists
3840,"function deposit ( address to , uint256 amount , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) onlyIfDepositAllowed ( to , amount ) acceptAgreement ( to ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; emit LogDeposit ( to , msg . sender , amount , reference ) ; emit Transfer ( address ( 0 ) , to , amount ) ; }","deposit 'amount ' of EUR-T to address 'to ' , attaching correlating ` reference ` to LogDeposit event"
3843,"function deposit ( address _token , uint256 _amount , string _reference ) external payable isInitialized transitionsPeriod { _deposit ( _token , _amount , _reference , msg . sender , true ) ; }","Deposit ` @ tokenAmount ( _token , _amount ) `"
3846,"function sell ( uint _askPrice , uint _amount , bool _make ) external returns ( bool ) ;",Will sell ` _amount ` tokens at or above ` _price ` each .
3847,function calculateBaseTimeout ( ) public view returns ( uint256 ) { uint256 _numberOfTileFlips = gameStates [ gameIndex ] . numberOfTileFlips ; if ( _numberOfTileFlips >= gameSettings . numberOfFlipsToFinalActivityTimer || gameSettings . numberOfFlipsToFinalActivityTimer == 0 ) { return gameSettings . finalActivityTimer ; } else { if ( gameSettings . finalActivityTimer <= gameSettings . initialActivityTimer ) { uint256 difference = gameSettings . initialActivityTimer - gameSettings . finalActivityTimer ; uint256 decrease = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer - decrease ) ; } else { difference = gameSettings . finalActivityTimer - gameSettings . initialActivityTimer ; uint256 increase = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer + increase ) ; } } },Calculate the current game 's base timeout .
3848,function setGasLimit ( uint256 _gasLimit ) onlyOwner public { gasLimit = _gasLimit ; },"NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled"
3849,function destroyIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return destroy ( index ) ; },Destroys a loan using the signature and not the Index
3850,"function revokePermission ( address _entity , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { require ( hasPermission ( _entity , _app , _role ) ) ; _setPermission ( _entity , _app , _role , bytes32 ( 0 ) ) ; }",Revokes ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
3851,"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != address ( 0 ) ) ; ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",This works even if sender does n't own any tokens at the time .
3852,function currentPenalty ( address account ) public view returns ( uint ) { uint ratio = synthetix . collateralisationRatio ( account ) ; if ( ratio <= TWENTY_PERCENT ) { return 0 ; } else if ( ratio > TWENTY_PERCENT && ratio <= THIRTY_PERCENT ) { return TWENTY_FIVE_PERCENT ; } else if ( ratio > THIRTY_PERCENT && ratio <= FOURTY_PERCENT ) { return FIFTY_PERCENT ; } return SEVENTY_FIVE_PERCENT ; },The penalty a particular address would incur if its fees were withdrawn right now
3855,"function convertWT ( uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , ""Conversion amount should be less than balance"" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }",Converts WT0 to CarbonUSD for the user .
3856,"function transferToAddress ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }",Function that is called when transaction target is an address
3857,function startSale ( ) public onlyController { require ( campaignState > 2 && teamVaultAddr != 0x0 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; tBonusStageEnd += tNow ; tRegSaleStart += tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; t_3rd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; },Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time
3858,"function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin returns ( bool ) { require ( _recipient != address ( 0 ) , ""recipient address can't be empty"" ) ; require ( _tokenAddress != TOKENADDRESS , ""token can't be RTC"" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , ""token transfer failed"" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }",Allow us to transfer tokens that someone might 've accidentally sent to this contract
3859,"function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 255 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }",Sets the locks of an array of addresses .
3860,"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) external payable { }","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction ."
3861,"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal isTransferable { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _data , _operatorData ) ; require ( _to != address ( 0 ) , ""Cannot send to 0x0"" ) ; require ( mBalances [ _from ] >= _amount , ""Not enough funds"" ) ; require ( whitelisted ( _to ) , ""Recipient is not whitelisted"" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _data , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _data , _operatorData ) ; }",Helper function actually performing the sending of tokens .
3863,"function claimTokenFor ( address _beneficiary ) public afterSaleSuccess whenNotPaused { uint256 stake = stakes [ _beneficiary ] ; require ( stake > 0 ) ; stakes [ _beneficiary ] = 0 ; uint256 tokens = stake . mul ( rate ) ; tokenBalance = tokenBalance . sub ( tokens ) ; ethealController . addHodlerStake ( _beneficiary , tokens . mul ( 2 ) ) ; require ( ethealController . ethealToken ( ) . transfer ( _beneficiary , tokens ) ) ; TokenClaimed ( msg . sender , _beneficiary , stake , tokens ) ; }",Claim token after token sale based on stake .
3864,function setEthPreAmount ( uint256 ethPreAmountInWei ) isOwner { require ( ethPreAmountInWei > 0 ) ; require ( ethPreAmount != ethPreAmountInWei ) ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; },Set current ethPreAmount price in wei for one token
3870,"function disableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , ""Must be buyer"" ) ; return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }",Disable the seller from cancelling ( i.e .
3872,function removeTicker ( string _ticker ) external ;,Removes the ticker details and associated ownership & security token mapping
3873,"function withdrawSynthetix ( uint amount ) external onlyOwner { synthetix . transfer ( owner , amount ) ; }",Allows the owner to withdraw SNX from this contract if needed .
3874,function register ( address _service ) internal returns ( uint256 serviceId ) { },register the service '_service ' with the private service registry
3875,function withdrawBalance ( ) external onlyOwner { owner . transfer ( this . balance ) ; },"With each call to purchaseTrophy , fees will build up in this contract 's balance ."
3876,"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
3877,"function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) { require ( _registry . hasAttribute ( to , _validAttributeTypeID ) , ""Transfer failed - receiver is not approved."" ) ; return super . transferFrom ( from , to , value ) ; }",Transfer an amount of ` value ` to a receiver at account ` to ` on behalf of a sender at account ` from ` .
3878,"function setAssetFeeParams ( address asset , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.max' , asset ) ) , feeMax ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.min' , asset ) ) , feeMin ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , asset ) ) , feeBps ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , asset ) ) , feeFlat ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; return true ; }","Set BPS , Min , Max , and Flat fee params for asset"
3880,"function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime ) ; uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; collectedTokens = balance ; miniMeToken . transfer ( owner , balance ) ; TokensWithdrawn ( owner , balance ) ; }",The owner will call this method to extract the tokens
3881,"function isTrusted ( address _from , address _to ) public view returns ( bool ) { return get ( store , holdersTrustStorage , getHolderId ( _from ) , _to ) ; }",Check if specified holder trusts an address with recovery procedure .
3882,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific narco via transferFrom ( ) .
3883,function resetWinners ( uint256 newLength ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { sortedWinners . length = newLength ; },"If anything during the point calculation and sorting part should fail , this function can reset data structures to their initial position , so as to"
3885,"function allowance ( address _from , address _spender , bytes32 _symbol ) public view returns ( uint ) { return _allowance ( getHolderId ( _from ) , getHolderId ( _spender ) , _symbol ) ; }",Returns asset allowance from one holder to another .
3887,"function renterOf ( uint256 _deedId ) external view returns ( address _renter , uint256 _rentPeriodEndTimestamp ) { require ( validIdentifier ( _deedId ) ) ; if ( identifierToRentPeriodEndTimestamp [ _deedId ] < now ) { _renter = address ( 0 ) ; _rentPeriodEndTimestamp = 0 ; } else { _renter = identifierToRenter [ _deedId ] ; _rentPeriodEndTimestamp = identifierToRentPeriodEndTimestamp [ _deedId ] ; } }",Returns the address of the currently assigned renter and end time of the rent period of a given plot .
3888,"function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( funding ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",This function is disabled during the funding .
3890,"function doConfirmPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Paid ; liquidPledging . confirmPayment ( uint64 ( p . ref ) , p . amount ) ; p . dest . transfer ( p . amount ) ; ConfirmPayment ( _idPayment , p . ref ) ; }",Transfers ETH according to the data held within the specified payment id ( internal function )
3891,"function updateSalePrice ( uint256 _tokenId , uint256 _newPrice ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _updateSalePrice ( _tokenId , _newPrice , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
3893,function getReserves ( ) public view returns ( KyberReserveInterface [ ] ) { return reserves ; },should be called off chain with as much gas as needed
3894,function getBlockTimestamp ( ) internal constant returns ( uint256 ) { return block . timestamp ; },This function is overridden by the test Mocks .
3895,function withdrawPayoutFromBet ( uint betId ) external whenGameIsClosed ( bets [ betId ] . gameId ) { require ( games [ bets [ betId ] . gameId ] . result == bets [ betId ] . result ) ; if ( ! bets [ betId ] . isPayoutWithdrawn ) { uint payout = calculatePotentialPayout ( betId ) ; bets [ betId ] . isPayoutWithdrawn = true ; address bettorAddress = betToAddress [ betId ] ; bettorAddress . transfer ( payout ) ; } },This function is called by a bettor to withdraw his payout
3896,"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; for ( uint i = 0 ; i < addresses . length - 1 ; i ++ ) if ( addresses [ i ] == _beneficiary ) { addresses [ i ] = addresses [ addresses . length - 1 ] ; break ; } addresses . length -= 1 ; emit BeneficiaryDestroyed ( _beneficiary ) ; }",Allows the owner to destroy a beneficiary .
3897,function setPrices ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; },Allow users to buy tokens for ` newBuyPrice ` eth
3898,"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
3899,"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( answer , nonce ) ; bytes32 commitment_id = keccak256 ( question_id , answer_hash , bond ) ; require ( ! commitments [ commitment_id ] . is_revealed ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }",Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
3900,"function bid ( ) public payable { require ( stage == Stages . AuctionSetUp || stage == Stages . AuctionStarted ) ; require ( privatesalewhitelist [ msg . sender ] || publicsalewhitelist [ msg . sender ] ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; } require ( msg . value > 0 ) ; require ( bids [ msg . sender ] . received + msg . value >= bid_threshold ) ; assert ( bids [ msg . sender ] . received + msg . value >= msg . value ) ; uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction ( ) ; require ( msg . value <= remaining_funds_to_end_auction ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; currentBonus = 25 ; } else if ( stage == Stages . AuctionStarted ) { if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 15 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 10 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 5 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 0 ; } else { currentBonus = 0 ; } } else { currentBonus = 0 ; } uint256 accounted = msg . value + msg . value * ( currentBonus ) / 100 ; bids [ msg . sender ] . accounted += accounted ; bids [ msg . sender ] . received += msg . value ; received_wei += msg . value ; received_wei_with_bonus += accounted ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , accounted , remaining_funds_to_end_auction ) ; assert ( received_wei >= msg . value ) ; assert ( received_wei_with_bonus >= accounted ) ; }",Send `` msg.value '' WEI to the auction from the `` msg.sender '' account .
3901,"function initialize ( address _att , address _attController , uint _startTime , uint _endTime , address _destEthFoundation , address _destTokensAngel ) public onlyOwner { require ( address ( ATT ) == 0x0 ) ; ATT = MiniMeToken ( _att ) ; require ( ATT . totalSupply ( ) == 0 ) ; require ( ATT . controller ( ) == address ( this ) ) ; require ( ATT . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _attController != 0x0 ) ; attController = _attController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _destTokensAngel != 0x0 ) ; destTokensAngel = _destTokensAngel ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters
3903,"function batchCreateAssetSale ( uint256 [ ] _tokenIds , uint256 [ ] _startingPrices , uint256 [ ] _endingPrices , uint256 [ ] _durations ) external whenNotPaused { require ( _tokenIds . length > 0 && _startingPrices . length > 0 && _endingPrices . length > 0 && _durations . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( _startingPrices [ ii ] == _startingPrices [ ii ] ) ; require ( _endingPrices [ ii ] == _endingPrices [ ii ] ) ; require ( _durations [ ii ] == _durations [ ii ] ) ; address _owner = ownerOf ( _tokenIds [ ii ] ) ; address _msgSender = msg . sender ; require ( _owner == _msgSender ) ; require ( checkIsAttached ( _tokenIds [ ii ] ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenIds [ ii ] ) ; saleManagerAddress . createSale ( _tokenIds [ ii ] , _startingPrices [ ii ] , _endingPrices [ ii ] , _durations [ ii ] , msg . sender ) ; } }",Batch function to put 10 or less collectibles on sale
3905,"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; Revoked ( ) ; }",Allows the owner to revoke the vesting .
3906,function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; },Get the tags related to the module factory
3910,"function vest ( ) external { uint numEntries = numVestingEntries ( msg . sender ) ; uint total ; for ( uint i = 0 ; i < numEntries ; i ++ ) { uint time = getVestingTime ( msg . sender , i ) ; if ( time > now ) { break ; } uint qty = getVestingQuantity ( msg . sender , i ) ; if ( qty == 0 ) { continue ; } vestingSchedules [ msg . sender ] [ i ] = [ 0 , 0 ] ; total = safeAdd ( total , qty ) ; } if ( total != 0 ) { totalVestedBalance = safeSub ( totalVestedBalance , total ) ; totalVestedAccountBalance [ msg . sender ] = safeSub ( totalVestedAccountBalance [ msg . sender ] , total ) ; havven . transfer ( msg . sender , total ) ; emit Vested ( msg . sender , now , total ) ; } }",Allow a user to withdraw any havvens in their schedule that have vested .
3911,"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) ;",Checks whether redemption is permitted for a participant
3912,"function expiryCheck ( string _symbol ) internal returns ( bool ) { if ( registeredSymbols [ _symbol ] . owner != address ( 0 ) ) { if ( now > registeredSymbols [ _symbol ] . timestamp . add ( expiryLimit ) && registeredSymbols [ _symbol ] . status != true ) { registeredSymbols [ _symbol ] = SymbolDetails ( address ( 0 ) , uint256 ( 0 ) , """" , bytes32 ( 0 ) , false ) ; return true ; } else return false ; } return true ; }",To re-initialize the token symbol details if symbol validity expires
3913,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Sufficent Allowance is not provided"" ) ; CappedSTO cappedSTO = new CappedSTO ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == cappedSTO . getInitFunction ( ) , ""Invalid data"" ) ; require ( address ( cappedSTO ) . call ( _data ) , ""Unsuccessfull call"" ) ; emit GenerateModuleFromFactory ( address ( cappedSTO ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( cappedSTO ) ; }",Used to launch the Module with the help of factory
3914,function getApproved ( uint256 _tokenId ) external view returns ( address ) { require ( _tokenExists ( _tokenId ) ) ; return playerTokenToApproved [ _tokenId ] ; },Get the approved address for a single NFT
3915,"function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }",Removes a pairs of addresses from manual approvals
3917,"function _generateCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate ) internal returns ( CampaignLibrary . Campaign memory ) { require ( budget >= price ) ; require ( endDate >= startDate ) ; if ( appc . allowance ( msg . sender , address ( this ) ) >= budget ) { appc . transferFrom ( msg . sender , address ( advertisementFinance ) , budget ) ; advertisementFinance . increaseBalance ( msg . sender , budget ) ; uint newBidId = bytesToUint ( lastBidId ) ; lastBidId = uintToBytes ( ++ newBidId ) ; CampaignLibrary . Campaign memory newCampaign ; newCampaign . price = price ; newCampaign . startDate = startDate ; newCampaign . endDate = endDate ; newCampaign . budget = budget ; newCampaign . owner = msg . sender ; newCampaign . valid = true ; newCampaign . bidId = lastBidId ; } else { emit Error ( ""createCampaign"" , ""Not enough allowance"" ) ; } return newCampaign ; }",Creates a campaign Method to create a campaign of user aquisition for a certain application .
3918,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; success = true ; }",approve ` _value ` tokens for ` _spender ` address to send from 'msg.sender '
3919,"function unlockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = 0 ; Lock ( msg . sender , 0 ) ; }",This function is used to revoke the claim of lockMe
3920,"function setAdmin ( address _admin , bool _valid ) onlyOwner public { admin [ _admin ] = _valid ; emit LogAdminSet ( _admin , _valid , now ) ; }",Allows owner to set up admin addresses that can schedule updates
3922,"function votesPerChoice ( uint8 option ) external view returns ( uint32 ) { require ( option < NUMBER_OF_CHOICES , ""Choice must be less than numberOfChoices."" ) ; return currentVoteResults [ option ] ; }",Return number of votes for one of the options .
3924,"function distrust ( address _to ) public checkTrust ( msg . sender , _to ) returns ( uint ) { set ( store , holdersTrustStorage , getHolderId ( msg . sender ) , _to , false ) ; return OK ; }",Revoke trust to perform recovery procedure from an address .
3929,"function release ( ) external onlyState ( State . Active ) onlyBeneficiary ( msg . sender ) { require ( ! beneficiaries [ msg . sender ] . releaseAllTokens ) ; uint releasableAmount = getReleasableAmount ( msg . sender ) ; beneficiaries [ msg . sender ] . withdrawAmount = beneficiaries [ msg . sender ] . withdrawAmount . add ( releasableAmount ) ; beneficiaries [ msg . sender ] . releaseAllTokens = beneficiaries [ msg . sender ] . withdrawAmount == getPartialAmount ( beneficiaries [ msg . sender ] . ratio , coeff , initialBalance ) ; withdrawAmount = withdrawAmount . add ( releasableAmount ) ; if ( withdrawAmount == initialBalance ) { state = State . Drawn ; emit StateChanged ( state ) ; } token . transfer ( msg . sender , releasableAmount ) ; emit Released ( msg . sender , releasableAmount ) ; }",transfer releasable tokens for beneficiary wrt the release graph
3930,"function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",This function is disabled during the funding .
3931,function setValidatorSigningKey ( address newSigningKey ) external ;,"Set the public address associated with a validator signing key , used to sign off-chain attribute approvals , as ` newSigningKey ` ."
3932,"function updatePrices ( uint newEthPrice , uint newSynthetixPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , ""Time must be later than last update"" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToSnxPrice = newSynthetixPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToSnxPrice , lastPriceUpdateTime ) ; }",Access point for the oracle to update the prices of SNX / eth .
3934,function numberOfAuthorizedPayments ( ) constant returns ( uint ) { return authorizedPayments . length ; },States the total number of authorized payments in this contract
3936,"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) ;",Notifies the controller about an approval allowing the controller to react if desired
3938,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _owner == _operator ; }",Query if an address is an authorized operator for another address
3939,function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; },"Change the address of the registryAdmin , who has the privilege to create new accounts"
3941,function deleteUint ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete uIntStorage [ _key ] ; return true ; },Delete value for Uint associated with bytes32 id key
3943,"function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool _isTransfer ) public returns ( Result ) { require ( _isTransfer == false || msg . sender == securityToken , ""Sender is not the owner"" ) ; if ( ! paused ) { if ( manualBlockings [ _from ] [ _to ] . expiryTime >= now ) { return Result . INVALID ; } if ( ( manualApprovals [ _from ] [ _to ] . expiryTime >= now ) && ( manualApprovals [ _from ] [ _to ] . allowance >= _amount ) ) { if ( _isTransfer ) { manualApprovals [ _from ] [ _to ] . allowance = manualApprovals [ _from ] [ _to ] . allowance . sub ( _amount ) ; } return Result . VALID ; } } return Result . NA ; }",Used to verify the transfer transaction and allow a manually approved transqaction to bypass other restrictions
3944,"function sendEther ( address to , uint value ) external onlymanyowners ( sha3 ( msg . data ) ) { require ( 0 != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }",Send ` value ` of ether to address ` to `
3945,function emergencyRefundContract ( ) external payable onlyOwnerOrMultisig { require ( contractFailed ) ; require ( msg . value > 0 ) ; },Contract owner or Multisig can refund contract with ETH in case of failed Crowdsale
3946,function getSaleDay ( uint256 _time ) view public returns ( uint8 ) { return uint8 ( _time . sub ( startTime ) . div ( 60 * 60 * 24 ) . add ( 1 ) ) ; },For a give date how many 24 hour blocks have ellapsed since token sale start
3948,function ( ) public payable { buy ( msg . sender ) ; },"If anybody sends Ether directly to this contract , consider he is"
3952,"function approve ( address _spender , uint256 _amount ) returns ( bool ) ;",Approve ` _spender ` to transfer ` _amount ` of tokens
3955,"function addTokenTo ( address _to , uint256 _tokenId ) internal { uint64 [ ] storage ownedList = ownedTokens [ _to ] ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( ownedList . length < uint256 ( 2 ** 32 ) - 1 , ""Max number of PixelCons per owner has been reached"" ) ; require ( lookupData . owner == address ( 0 ) , ""PixelCon already has an owner"" ) ; lookupData . owner = _to ; uint ownedListIndex = ownedList . length ; ownedList . length ++ ; lookupData . ownedIndex = uint32 ( ownedListIndex ) ; ownedList [ ownedListIndex ] = lookupData . tokenIndex ; }",Add a token ID to the list of a given address
3956,"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) ;",Function to clone a proposal from another manager contract
3958,"function openChannel ( address participant1 , address participant2 , uint256 settle_timeout ) isSafe settleTimeoutValid ( settle_timeout ) public returns ( uint256 ) { bytes32 pair_hash ; uint256 channel_identifier ; require ( token . balanceOf ( address ( this ) ) < token_network_deposit_limit ) ; channel_counter += 1 ; channel_identifier = channel_counter ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; require ( participants_hash_to_channel_identifier [ pair_hash ] == 0 ) ; participants_hash_to_channel_identifier [ pair_hash ] = channel_identifier ; Channel storage channel = channels [ channel_identifier ] ; assert ( channel . settle_block_number == 0 ) ; assert ( channel . state == ChannelState . NonExistent ) ; channel . settle_block_number = settle_timeout ; channel . state = ChannelState . Opened ; emit ChannelOpened ( channel_identifier , participant1 , participant2 , settle_timeout ) ; return channel_identifier ; }",Opens a new channel between ` participant1 ` and ` participant2 ` .
3959,"function withdraw ( uint256 amount ) public onlyIfWithdrawAllowed ( msg . sender , amount ) acceptAgreement ( msg . sender ) { destroyTokensPrivate ( msg . sender , amount ) ; emit LogWithdrawal ( msg . sender , amount ) ; }",withdraws 'amount ' of EUR-T by burning required amount and providing a proof of whithdrawal
3960,"function approveAndCall ( address spender , uint256 value , bytes data ) public returns ( bool ) ;",Approve the passed address to spend the specified amount of tokens on behalf of msg.sender and then call ` onApprovalReceived ` on spender Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering .
3962,"function getBonusesAmountAvailable ( bytes32 _userKey , uint _distributionDate ) public view returns ( uint ) { Deposit storage _deposit = distributionDeposits [ _distributionDate ] ; if ( _deposit . leftToWithdraw [ _userKey ] . initialized ) { return _deposit . leftToWithdraw [ _userKey ] . left ; } uint _sharesPercent = Treasury ( treasury ) . getSharesPercentForPeriod ( _userKey , _distributionDate ) ; return _deposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ; }",Gets an amount of bonuses user has for concrete distribution date
3963,"function mintMulti ( address [ ] _investors , uint256 [ ] _amounts ) public onlyModule ( STO_KEY , true ) returns ( bool success ) { require ( _investors . length == _amounts . length , ""Mis-match in the length of the arrays"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { mint ( _investors [ i ] , _amounts [ i ] ) ; } return true ; }",mints new tokens and assigns them to the target _investor .
3964,"function setHandler ( address handler , bool allowed ) public onlyOwner { handlerWhitelist [ handler ] = allowed ; }",- onlyOwner modifier only allows the contract owner to run the code
3965,"function addOrganization ( address organization , uint256 maximumIssuableAttributes , string name ) external onlyOwner whenNotPaused { require ( organization != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ organization ] . exists == false , ""an organization already exists at the provided account address"" ) ; _organizations [ organization ] . exists = true ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; _organizations [ organization ] . name = name ; _organizationAccounts . push ( organization ) ; emit OrganizationAdded ( organization , name ) ; }",Add an organization at account ` organization ` and with an initial allocation of issuable attributes of ` maximumIssuableAttributes ` .
3967,"function createCheckpoint ( ) external onlyModuleOrOwner ( CHECKPOINT_KEY ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; checkpointTimes . push ( now ) ; emit CheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }",Creates a checkpoint that can be used to query historical balances / totalSuppy
3968,"function breedWithAuto ( uint256 _matronId , uint256 _sireId ) external payable whenNotPaused { uint256 totalFee = autoBirthFee ; Dog storage matron = dogs [ _matronId ] ; if ( matron . generation > 0 ) { totalFee += gen0Profit ; } require ( msg . value >= totalFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isSiringPermitted ( _sireId , _matronId ) ) ; require ( _isReadyToBreed ( matron ) ) ; Dog storage sire = dogs [ _sireId ] ; require ( _isReadyToBreed ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; _breedWith ( _matronId , _sireId ) ; uint256 breedExcess = msg . value - totalFee ; if ( breedExcess > 0 ) { msg . sender . transfer ( breedExcess ) ; } }","Breed a Dog you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval ."
3969,"function confirmPrint ( bytes32 _lockId ) public onlyCustodian { PendingPrint storage print = pendingPrintMap [ _lockId ] ; address receiver = print . receiver ; require ( receiver != address ( 0 ) ) ; uint256 value = print . value ; delete pendingPrintMap [ _lockId ] ; uint256 supply = erc20Store . totalSupply ( ) ; uint256 newSupply = supply + value ; if ( newSupply >= supply ) { erc20Store . setTotalSupply ( newSupply ) ; erc20Store . addBalance ( receiver , value ) ; emit PrintingConfirmed ( _lockId , receiver , value ) ; erc20Proxy . emitTransfer ( address ( 0 ) , receiver , value ) ; } }",Confirms a pending increase in the token supply .
3970,"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { uint256 _fee = validator . validateAndGetTransferFee ( owner , msg . sender , _to , _amount ) ; store . transfer ( msg . sender , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( msg . sender , store . getSettingAddress ( ""feeReturnAddress"" ) , _fee ) ; Transfer ( msg . sender , _to , _amount ) ; return true ; }",Transfer ` _amount ` of tokens ( must be sent as floating point number of token and decimal parts ) to ` _address ` with preliminary approving amount + fee from transaction sender
3975,function removeOwnership ( address _dac ) external onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; emit OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone"
3977,"function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external ;",Invalidate a signed attribute approval before it has been set by supplying the hash of the approval ` hash ` and the signature ` signature ` .
3978,"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
3980,"function setEtherFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , ""Percent must be between 0 and 100."" ) ; etherFeePercent = percent ; }",Set the percent fee applied to the Ether used to pay for tokens .
3984,"function enableSweep ( uint8 [ ] _vs , bytes32 [ ] _rs , bytes32 [ ] _ss , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; require ( ( _vs . length == _rs . length ) && ( _vs . length == _ss . length ) ) ; uint256 numSignatures = _vs . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < numSignatures ; ++ i ) { address from = ecrecover ( sweepMsg , _vs [ i ] , _rs [ i ] , _ss [ i ] ) ; if ( from != address ( 0 ) ) { sweptSet [ from ] = true ; uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }","Enables the delegation of transfer control for many accounts to the sweeper account , transferring any balances as well to the given destination ."
3985,"function ( ) payable public { uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }",Automatically buy tokens from contract by sending ether ( no ` data ` required ) .
3988,function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPaused ( now ) ; },Pause sale just in case we have some troubles Note that time marks are not updated
3989,"function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { requireTrade ( tokenOwner ) ; return allowed [ tokenOwner ] [ spender ] ; }",Returns the amount of tokens approved by the owner that can be transferred to the spender 's account
3990,"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return false ; }",Notifies the controller about a token transfer allowing the controller to react if desired
3991,function getJurisdiction ( ) external view returns ( address ) { return address ( _jurisdiction ) ; },Get account of utilized jurisdiction and associated attribute registry managed by the jurisdiction .
3992,function getIndexRoot ( bytes32 indexId ) constant returns ( bytes32 ) { return index_lookup [ indexId ] . root ; },Retrieves the id of the root node for this index .
3993,"function getHolderId ( address _holder ) public view returns ( uint ) { return get ( store , holderIndexStorage , _holder ) ; }",Returns holder id for the specified address .
3994,function getInitFunction ( ) public pure returns ( bytes4 ) { return 0xb0ff041e ; },This function returns the signature of configure function
3995,"function changePrice ( uint256 _tokenId , uint256 newPrice ) public { require ( _owns ( msg . sender , _tokenId ) ) ; uint256 oldPrice = personIndexToPrice [ _tokenId ] ; uint256 maxPrice = uint256 ( SafeMath . mul ( oldPrice , 5 ) ) ; uint256 minPrice = startingPrice ; require ( minPrice < newPrice && newPrice < maxPrice ) ; personIndexToPrice [ _tokenId ] = newPrice ; PriceChange ( _tokenId , oldPrice , newPrice , persons [ _tokenId ] . name ) ; }",Allow the owner of the token change the price of the person .
3996,function changeMinimumCap ( uint256 _cap ) public onlyOwner { if ( minimumCap < _cap ) revert ( ) ; minimumCap = _cap ; },"change minimum cap , in case Ether price fluctuates ."
3997,"function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return USER_MANAGER_MEMBER_ALREADY_EXIST ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }",Register user Can be called only by contract owner
3998,"function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }",function to let admin claim tokens on behalf users
4000,"function withdrawFundsAdvanced ( address _toAddress , uint _valueWei , uint _extraGas ) { externalEnter ( ) ; withdrawFundsAdvancedRP ( _toAddress , _valueWei , _extraGas ) ; externalLeave ( ) ; }","Send ` _valueWei ` of the ether owned by the caller ( ` msg.sender ` ) to ` _toAddress ` , including ` _extraGas ` gas beyond the normal stipend ."
4001,"function buyTokens ( address _beneficiary ) public payable { uint256 weiAmount = msg . value ; _preValidatePurchase ( _beneficiary , weiAmount ) ; uint256 tokens = _getTokenAmount ( weiAmount ) ; require ( token . balanceOf ( this ) >= tokens ) ; totalWeiRaised = totalWeiRaised . add ( weiAmount ) ; tokensSold = tokensSold . add ( tokens ) ; _deliverTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , weiAmount , tokens ) ; _processBonus ( msg . sender , tokens ) ; _forwardFunds ( ) ; }",Function calls other functions to calculate tokenamount to send to beneficiary .
4002,"function renounceOwnership ( ) public onlyOwner ( ""renounceOwnership"" ) { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }",Renouncing to ownership will leave the contract without an owner .
4003,function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( msg . value == 0 ) { wpr . unpause ( ) ; ExchangerI ( exchanger ) . collect ( _th ) ; wpr . pause ( ) ; } else { doBuy ( _th ) ; } return true ; },This method will generally be called by the WPR token contract to acquire WPRs .
4004,"function createDestructibleCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DestructibleMiniMeToken ) { DestructibleMiniMeToken newToken = new DestructibleMiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled , msg . sender ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
4005,"function BuyToken ( address _buyer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _buyer ] + _value > balances [ _buyer ] ) ; SoldToken ( _buyer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _buyer ] += _value ; Transfer ( msg . sender , _buyer , _value ) ; }",Buy quantity of tokens depending on the amount of sent ethers .
4007,"function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }",Used to create new tokens and increase total supply
4008,"function deposit ( address _investor , uint256 _tokenAmount ) onlyICOContract public payable returns ( bool ) { if ( state != State . Active ) { error ( 'deposit: state != State.Active' ) ; return false ; } deposited [ _investor ] = deposited [ _investor ] . add ( msg . value ) ; tokensAcquired [ _investor ] = tokensAcquired [ _investor ] . add ( _tokenAmount ) ; return true ; }",Registers how many tokens have each investor and how many ethers they spent ( When ICOing through PayIn this function is not called )
4010,"function createChannel ( address _receiver_address , uint192 _deposit ) external { createChannelPrivate ( msg . sender , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }",Creates a new channel between ` msg.sender ` and ` _receiver_address ` and transfers the ` _deposit ` token deposit to this contract .
4013,function isValidator ( address account ) public view returns ( bool ) { return _validators [ account ] . exists ; },Determine if the account ` account ` is currently assigned as a validator on the jurisdiction .
4014,"function ( ) is_live ( ) payable { if ( msg . value == 0 ) revert ( ) ; if ( isFinalized ) revert ( ) ; uint256 tokens = safeMult ( msg . value , tokenExchangeRate ) ; uint256 checkedSupply = safeAdd ( totalSupply , tokens ) ; if ( maxCap < checkedSupply ) revert ( ) ; totalSupply = checkedSupply ; balances [ msg . sender ] += tokens ; MPYCreation ( msg . sender , tokens ) ; }",Get Tokens : 0.1 ETH per 1 MPY token
4016,"function transferWithSender ( address _sender , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfSender = erc20Store . balances ( _sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( _sender , balanceOfSender - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Proxy . emitTransfer ( _sender , _to , _value ) ; return true ; }",Core logic of the ERC20 ` transfer ` function .
4017,"function contestFor ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig , bytes _delegationSig ) external { validateContestForSig ( _attester , _requester , _reward , _requestNonce , _delegationSig ) ; contestForUser ( _attester , _requester , _reward , _requestNonce , _requesterSig ) ; }",Function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId Perform on behalf of attester to pay gas fees
4018,"function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }",Token owner can approve for spender to transferFrom ( ... ) tokens from the token owner 's account .
4020,"function getFeeBPS ( Data storage self , address contractAddress ) internal view returns ( uint feeBps ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }",Get the basis points fee of the contract address ; typically TokenIOFeeContract
4021,function isOwner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; },Look up for the owner role on providen address
4022,"function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferFromPrivate ( from , allowed ) ; }",enables or disables address to be sender of EUR-T
4024,function isFinalized ( bytes32 question_id ) view public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; },Report whether the answer to the specified question is finalized
4025,"function convertWT ( uint256 _amount ) public requiresPermission whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , ""Conversion amount should be less than balance"" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }",Converts WT0 to CarbonUSD for the user .
4026,function updateAndGetHodlTotalValue ( ) public returns ( uint ) { if ( now >= hodlerTime3M && hodlerTotalValue3M == 0 ) { hodlerTotalValue3M = hodlerTotalValue ; } if ( now >= hodlerTime6M && hodlerTotalValue6M == 0 ) { hodlerTotalValue6M = hodlerTotalValue ; } if ( now >= hodlerTime9M && hodlerTotalValue9M == 0 ) { hodlerTotalValue9M = hodlerTotalValue ; TOKEN_HODL_9M = TokenController ( owner ) . ethealToken ( ) . balanceOf ( this ) . sub ( TOKEN_HODL_3M ) . sub ( TOKEN_HODL_6M ) . add ( claimedTokens ) ; } return hodlerTotalValue ; },Setting 3 - 6 - 9 months total staking hodl value if time is come
4027,"function refundLeftOverEth ( uint index , uint amount , address reciever , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , reciever , sc ) == true ) { airdrop . distributor . transfer ( amount ) ; } else revert ( ) ; }",Refund eth left over from Distribution back to the airdrop creator
4029,function cancelPaymentGlobally ( uint _idDeposit ) public onlyOwner { require ( _idDeposit < deposits . length ) ; deposits [ _idDeposit ] . canceled = true ; CancelPaymentGlobally ( _idDeposit ) ; },This function is a failsafe function in case a token is deposited that has an issue that could prevent it 's withdraw loop break ( e.g .
4031,function unitsOneEthCanBuy ( ) public view returns ( uint _units ) { for ( uint i = 0 ; i < rounds . length ; i ++ ) { Round memory round = rounds [ i ] ; if ( block . timestamp >= round . start && block . timestamp < round . end ) { return round . price ; } } return 0 ; },Gets the conversion rate for ETH purchases .
4034,"function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId1 , uint gameItemId2 ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId1 = pow . gameItemId1 ; gameItemId2 = pow . gameItemId2 ; }",Returns all the relevant information about a specific pow .
4035,"function approve ( address _spender , uint256 _value ) external returns ( bool success ) ;",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
4036,"function compareUpperBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , ""Input length mismatch"" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version1 [ i ] > _version2 [ i ] ) return true ; else if ( _version1 [ i ] < _version2 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }",Used to compare the upper bound with the latest version
4037,"function removeAttributeFor ( address account , uint256 attributeTypeID ) external ;",Remove an attribute of the type with ID ` attributeTypeID ` from account of ` account ` .
4038,"function passTurn ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { if ( board . didPassPrevTurn ) { board . isHonorableLoss = true ; updateBoardStatus ( board , boardId , BoardStatus . WaitingToResolve ) ; } else { nextTurn ( board ) ; board . didPassPrevTurn = true ; PlayerPassedTurn ( boardId , activeColor ) ; } } }","Performs a pass action on a psecific board , only by the current active color player ."
4040,"function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { var avail = allowance [ _from ] [ msg . sender ] > balanceOf [ _from ] ? balanceOf [ _from ] : allowance [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowance [ _from ] [ msg . sender ] -= _value ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `
4041,function proxyPayment ( address _owner ) public payable initialized returns ( bool ) { return false ; },Called when ` _owner ` sends ether to the MiniMe Token contract
4042,function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( ICOprice != priceForIcoInWei ) ; ICOprice = priceForIcoInWei ; updatePrices ( ) ; },Set current ICO price price in wei for one metadollar
4043,"function getIdentity ( uint ein ) public view _identityExists ( ein ) returns ( address recoveryAddress , address [ ] memory associatedAddresses , address [ ] memory providers , address [ ] memory resolvers ) { Identity storage _identity = identityDirectory [ ein ] ; return ( _identity . recoveryAddress , _identity . associatedAddresses . members , _identity . providers . members , _identity . resolvers . members ) ; }",Gets all identity-related information for the passed EIN .
4044,function getBetsFromAddress ( address bettorAddress ) public view returns ( uint [ ] ) { return addressToBets [ bettorAddress ] ; },Returns an array containing the ids of the bets placed by a specific address
4045,"function createCDPLeveragedDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }","create a CDP the given amount of Dai in the sender 's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount )"
4047,function checkOrder ( uint32 [ ] sortedChunk ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { require ( sortedChunk . length + sortedWinners . length <= winnerCounter ) ; for ( uint256 i = 0 ; i < sortedChunk . length - 1 ; i ++ ) { uint256 id = sortedChunk [ i ] ; uint256 sigId = sortedChunk [ i + 1 ] ; require ( tokenToPointsMap [ id ] > tokenToPointsMap [ sigId ] || ( tokenToPointsMap [ id ] == tokenToPointsMap [ sigId ] && id < sigId ) ) ; } if ( sortedWinners . length != 0 ) { uint256 id2 = sortedWinners [ sortedWinners . length - 1 ] ; uint256 sigId2 = sortedChunk [ 0 ] ; require ( tokenToPointsMap [ id2 ] > tokenToPointsMap [ sigId2 ] || ( tokenToPointsMap [ id2 ] == tokenToPointsMap [ sigId2 ] && id2 < sigId2 ) ) ; } for ( uint256 j = 0 ; j < sortedChunk . length ; j ++ ) { sortedWinners . push ( sortedChunk [ j ] ) ; } if ( sortedWinners . length == winnerCounter ) { require ( sortedWinners [ sortedWinners . length - 1 ] == pointsLimit ) ; pValidationState = pointsValidationState . OrderChecked ; } },Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .
4048,function getForCollection ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint64 [ ] ) { return collectionTokens [ _collectionIndex ] ; },Get the indexes of all PixelCons in collection # ` ( _collectionIndex ) `
4049,"function challengeReparameterization ( bytes32 _propID ) public returns ( uint ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate ) ; return pollID ; }","challenge the provided proposal ID , and put tokens at stake to do so ."
4050,"function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == getHolderId ( _owner ) ) ; }",Check if specified address has asset owner rights .
4051,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }",Query if an address is an authorized operator for another address
4052,"function updateSlasher ( address _newSlasherAddress ) external onlyOwner { emit LogSlasherUpdated ( slasherAddress , _newSlasherAddress ) ; slasherAddress = _newSlasherAddress ; }",The owner of the contract can update the slasher address .
4053,"function clearDelegateAndUnlockTokens ( ) public onlyDelegated notSelf returns ( uint lockedTokens ) { address delegate = delegatesByDelegator [ msg . sender ] ; lockedTokens = lockedDelegatingTokens [ msg . sender ] ; lockedDelegatingTokens [ msg . sender ] = 0 ; delegatedAmountsByDelegate [ delegate ] = SafeMath . sub ( delegatedAmountsByDelegate [ delegate ] , lockedTokens ) ; totalLockedTokens = SafeMath . sub ( totalLockedTokens , lockedTokens ) ; delete delegatesByDelegator [ msg . sender ] ; require ( tokenLocker . transfer ( msg . sender , lockedTokens ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensUndelegated ( msg . sender , lockedTokens , delegate ) ; return lockedTokens ; }","Clear the delegate address for all tokens delegated by the sending address , unlocking the locked tokens ."
4054,function changeOwner ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; },` owner ` can step down and assign some other address to this role
4055,"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision ."
4056,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = collectibleIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
4057,function redeemable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . OPEN ) ; },Checks whether a swap is redeemable or not .
4060,"function createNewProject ( uint uuid , uint amount , address projectPayee ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedProjectBalances ( uuid , amount ) ; communityAccount . setEscrowedProjectPayees ( uuid , projectPayee ) ; communityAccount . setTotalProjectEscrow ( SafeMath . add ( communityAccount . totalProjectEscrow ( ) , amount ) ) ; logger . emitProjectCreated ( uuid , amount , projectPayee ) ; logger . emitGenericLog ( ""createNewProject"" , """" ) ; }",updates the escrow values along with the project payee for a new project
4061,function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } },Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
4062,function getInvestors ( ) external view returns ( address [ ] ) { return investorData . investors ; },returns an array of investors NB - this length may differ from investorCount as it contains all investors that ever held tokens
4064,"function _addSale ( uint256 _tokenId , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; tokenIdToSale [ _tokenId ] = _sale ; emit SaleCreated ( uint256 ( _tokenId ) , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }",Adds an sale to the list of open sales .
4065,"function compareLowerBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , ""Input length mismatch"" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version2 [ i ] > _version1 [ i ] ) return true ; else if ( _version2 [ i ] < _version1 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }",Used to compare the lower bound with the latest version
4067,"function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding <= PRESALE_MINIMUM_FUNDING ) ; assert ( balanceOf [ msg . sender ] < value ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; msg . sender . transfer ( value ) ; }",The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
4068,function finishDistribution ( ) onlyOwner public { token . finishMinting ( ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; },"Finish token minting , enable transfers and transfer token ownership"
4069,function orderConfirmer ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . confirmer ; },returns the darknode address which confirms the given orderID .
4071,"function unlockTokens ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; BasicToken . unlockTokens ( ) ; }","Unlock tokens , hereafter they will be tradable"
4073,"function burnPermissionManager ( address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }","Burn ` _role ` in ` _app ` , so no modification can be made to it ( grant , revoke , permission manager )"
4074,"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; _operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage
4075,function getEndDateOfCampaign ( bytes32 bidId ) public view returns ( uint endDate ) { return advertisementStorage . getCampaignEndDateById ( bidId ) ; },Get the end date of a campaign Based on the Campaign id return the value ( in miliseconds ) corresponding to the end Date of the campaign .
4076,function setTrading ( bool _trading ) external returns ( bool ) ;,Will set trading state to ` _trading `
4077,"function setCrowdsaleTransfer ( address _sale , uint256 _amount ) public onlyOwner { require ( _sale != address ( 0 ) && ! isCrowdsaleOpen ( ) && address ( ethealToken ) != address ( 0 ) ) ; crowdsale = Crowdsale ( _sale ) ; require ( ethealToken . transferFrom ( SALE , _sale , _amount ) ) ; }",Set crowdsale address and transfer HEAL tokens from ethealController 's SALE address
4078,"function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = obg . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! obg . transfer ( msg . sender , toTransfer ) ) throw ; }",Allow developer to unlock allocated tokens by transferring them from OBGAllocation to developer 's address .
4079,"function getTokenAllowance ( Data storage self , string currency , address account , address spender ) internal view returns ( uint allowance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , spender ) ) ) ; return self . Storage . getUint ( id ) ; }",Get the token spender allowance for a given account
4083,"function calculateRewardToWithdraw ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint reward , uint pixelsOwned ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; uint _lastPaidIndex = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _lastIndex < 0 ) { return ( 0 , _pixelsOwned ) ; } uint _rewardsSum = _history . rewardsCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . rewardsCumulative [ _lastPaidIndex ] ; uint _toWithdraw = ( ( _rewardsSum - _lastWithdrawn ) / PIXEL_COUNT ) * _pixelsOwned ; return ( _toWithdraw , _pixelsOwned ) ; }",Calculates unpaid rewards of a given address .
4086,"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) ;",Query if an address is an authorized operator for another address
4088,"function calculateTokensTier ( uint256 weiPaid , uint256 tierSelected ) internal constant returns ( uint256 calculatedTokens ) { require ( weiPaid > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; if ( tierSelected == 1 ) calculatedTokens = weiPaid . mul ( rate ) ; else if ( tierSelected == 2 ) calculatedTokens = weiPaid . mul ( rateTier2 ) ; else if ( tierSelected == 3 ) calculatedTokens = weiPaid . mul ( rateTier3 ) ; else calculatedTokens = weiPaid . mul ( rateTier4 ) ; }",Buys the tokens given the price of the tier one and the wei paid
4089,"function destroyTokens ( address _owner , uint _amount ) public returns ( bool ) ;",Burns ` _amount ` tokens from ` _owner `
4090,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered ."
4091,function balanceOf ( address _person ) constant returns ( uint256 balance ) { return balances [ _person ] ; },Used to look up balance of a user
4092,function refundForValidPartners ( uint _to ) ;,Function to refund for valid partners before the closing time
4093,"function withdrawVestedTokens ( uint256 _vestIndex ) public activeVester validIndex ( _vestIndex ) unclaimedVest ( _vestIndex ) pastClaimDate ( _vestIndex ) returns ( bool ) { if ( _vestIndex == vests [ msg . sender ] . releaseAmounts . length . sub ( 1 ) ) { bool check ; for ( uint256 i = 0 ; i < vests [ msg . sender ] . releaseAmounts . length ; i ++ ) { if ( ! vests [ msg . sender ] . claimed [ i ] ) { check = false ; break ; } check = true ; } require ( check , ""not all vests have been withdrawn before attempting to withdraw final vest"" ) ; vests [ msg . sender ] . state = VestState . vested ; } vests [ msg . sender ] . claimed [ _vestIndex ] = true ; uint256 amount = vests [ msg . sender ] . releaseAmounts [ _vestIndex ] ; require ( RTI . transfer ( msg . sender , amount ) , ""failed to transfer"" ) ; return true ; }",IF YOU ARE WITHDRAWING THE LAST VEST ( LAST INDEX ) YOU MUST HAVE WITHDRAWN ALL OTHER VESTS FIRST OR THE TX WILL FAIL
4096,"function requestReturn ( address _returnAddr ) { require ( now <= endDate ) ; require ( returnAddresses [ msg . sender ] == 0x0 ) ; returnAddresses [ msg . sender ] = _returnAddr ; ReturnRequested ( msg . sender , _returnAddr ) ; }",This function is used to choose an address for returning the funds .
4097,"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 , ""at least one history hash entry must be provided"" ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order"
4098,"function setOfferSize ( uint256 quantity ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( quantity > 0 , ""Size must be greater than zero, change rejected."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order change."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . quantity = quantity ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , quantity , order . price , order . expiry ) ; }",Change the number of VOX Tokens offered by this user .
4099,"function removeUserContractFrom ( address _contract , address _from ) external auth returns ( uint ) { if ( ! _removeUserContract ( _contract , _from ) ) { return _emitErrorCode ( USER_REGISTRY_NO_USER_CONTRACT_FOUND ) ; } _emitter ( ) . emitUserContractRemoved ( _contract , _from ) ; return OK ; }",Removes a contract from provided user association .
4100,"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool transferred ) { require ( allowed [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }",Used to transfer funds on behalf of someone
4101,"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool success ) { require ( allowance [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }",Used to transfer funds on behalf of owner to receiver
4102,"function _init ( uint40 _panicDelayInSeconds , uint40 _pendingDelayInSeconds ) returns ( bool ) ;",This will set the panic and pending periods .
4104,function isWhitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; },Checks if the specified address is whitelisted .
4106,"function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Invalid dividend"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry in future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""already claimed"" ) ; dividends [ _dividendIndex ] . reclaimed = true ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( owner , remainingAmount ) , ""transfer failed"" ) ; emit ERC20DividendReclaimed ( owner , _dividendIndex , dividendTokens [ _dividendIndex ] , remainingAmount ) ; }","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends"
4108,function getMaximumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMaximumFundsInEuroCents ( ) ) ; },maximum investments to be accepted during the sale ( in wei )
4111,"function purchase ( address _to , uint64 _pixelconIndex ) public payable validAddress ( _to ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( systemLock != LOCK_REMOVE_ONLY , ""Market is currently locked"" ) ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; require ( listing . seller != msg . sender , ""Seller cannot purchase their own listing"" ) ; uint256 currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; require ( currPrice != uint256 ( 0 ) , ""Market listing has expired"" ) ; require ( msg . value >= currPrice + ( currPrice * uint256 ( devFee ) ) / FEE_RATIO , ""Insufficient value sent"" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , _to , tokenId ) ; seller . transfer ( currPrice ) ; emit Purchase ( _pixelconIndex , msg . sender , currPrice ) ; }",Purchase PixelCon # ` ( _pixelconIndex ) ` to address ` ( _to ) `
4112,function canSettle ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isWaitingOver = isSettling ( channelId ) && block . number >= channel . settlingUntil ; return isSettling ( channelId ) && isWaitingOver ; },Ensure one can settle the channel identified by ` channelId ` .
4113,"function transferFrom ( address from , address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { allowance [ from ] [ msg . sender ] = safeSub ( allowance [ from ] [ msg . sender ] , quantity ) ; return _transfer ( from , to , quantity ) ; }",ERC20 transferFrom function ; transfers ` quantity ` tokens from ` from ` to ` to ` if the sender is approved .
4114,"function takeOwnership ( uint256 _index ) public returns ( bool ) { return transfer ( msg . sender , _index ) ; }","Transfers the loan to the msg.sender , the msg.sender must be approved using the `` approve '' method ."
4115,"function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( admins [ _address ] , ""This address isn't an administrator."" ) ; require ( _address != owner , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }",Removes the specified address from the list of administrators .
4118,function destroy ( ) onlyOwner public { selfdestruct ( owner ) ; },The called token contracts could try to re-enter this contract .
4119,"function _updatePurchasingState ( address , uint256 ) internal pure { }","Overrides for extensions that require an internal state to check for validity ( current user contributions , etc . )"
4120,"function refund ( ) minCapNotReached salePeriodCompleted isValidState external { require ( msg . sender != shitFundAddress ) ; uint256 shitVal = balances [ msg . sender ] ; require ( shitVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( shitVal ) ; assignedSupply = assignedSupply . sub ( shitVal ) ; uint256 ethVal = shitVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }",Allows contributors to recover their ETH in the case of a failed token sale
4122,function changeOwner ( address _newOwner ) onlyOwner { if ( msg . sender == owner ) { owner = _newOwner ; } },` owner ` can step down and assign some other address to this role
4123,"function _setMarketInterestRateModel ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; emit SetMarketInterestRateModel ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }",Sets the interest rate model for a given market
4124,"function newChannel ( address partner , uint settle_timeout ) returns ( address ) { address old_channel = getChannelWith ( partner ) ; if ( old_channel != 0 ) { ChannelDeleted ( msg . sender , partner ) ; } address new_channel = data . newChannel ( partner , settle_timeout ) ; ChannelNew ( new_channel , msg . sender , partner , settle_timeout ) ; return new_channel ; }",Create a new payment channel between two parties
4127,function setWalletAddress ( address _walletAddress ) public onlyWalletAddr { walletAddress = _walletAddress ; },only wallet address can set new wallet address
4128,function setMaximumClaimPriceWei ( uint _maximumClaimPriceWei ) { externalEnter ( ) ; setMaximumClaimPriceWeiRP ( _maximumClaimPriceWei ) ; externalLeave ( ) ; },Used by topWizard to vary the cap on claim price .
4131,"function depositSynths ( uint amount ) external { synth . transferFrom ( msg . sender , this , amount ) ; }",depositSynths : Allows users to deposit synths via the approve / transferFrom workflow if they 'd like .
4132,"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
4134,"function getPledgeAdmin ( uint64 idAdmin ) constant returns ( PledgeAdminType adminType , address addr , string name , string url , uint64 commitTime , uint64 parentProject , bool canceled , address plugin ) { PledgeAdmin storage m = findAdmin ( idAdmin ) ; adminType = m . adminType ; addr = m . addr ; name = m . name ; url = m . url ; commitTime = m . commitTime ; parentProject = m . parentProject ; canceled = m . canceled ; plugin = address ( m . plugin ) ; }",A constant getter to check the details of a specified Admin
4136,"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _tokenHolder ) ; require ( balanceAvailable >= _amount , ""You can only burn tokens when you have a balance grater than or equal to the amount specified"" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; emit Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }",Helper function actually performing the burning of tokens .
4137,"function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) ;",Approve the passed address to spend the specified amount of tokens on behalf of msg.sender and then call ` onApprovalReceived ` on spender Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering .
4138,function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
4139,function resultFor ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; },"Return the final answer to the specified question , or revert if there is n't one"
4142,"function setNewController ( address _controller ) public onlyEthealMultisig { require ( _controller != address ( 0 ) && newController == address ( 0 ) ) ; newController = TokenController ( _controller ) ; ethealToken . changeController ( _controller ) ; hodlerReward . transferOwnership ( _controller ) ; uint256 _stake = this . balance ; if ( _stake > 0 ) { _controller . transfer ( _stake ) ; } _stake = ethealToken . balanceOf ( this ) ; if ( _stake > 0 ) { ethealToken . transfer ( _controller , _stake ) ; } }","replaces controller when it was not yet replaced , only multisig can do it"
4143,function ownerOf ( uint256 _cutieId ) external view canBeStoredIn40Bits ( _cutieId ) returns ( address owner ) { owner = cutieIndexToOwner [ uint40 ( _cutieId ) ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given Cutie .
4146,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered ."
4147,"function addVestingSchedule ( address account , uint [ ] times , uint [ ] quantities ) external onlyOwner onlyDuringSetup { for ( uint i = 0 ; i < times . length ; i ++ ) { appendVestingEntry ( account , times [ i ] , quantities [ i ] ) ; } }",Construct a vesting schedule to release a quantities of SNX over a series of intervals .
4148,"function _escrow ( address _owner , uint256 _tokenId ) internal { nonFungibleContract . safeTransferFrom ( _owner , this , _tokenId ) ; }","Escrows the ERC721 Token , assigning ownership to this contract ."
4149,"function rescindApproval ( address _spender ) external { require ( approvedSpenders [ msg . sender ] [ _spender ] , ""Spender has not been approved"" ) ; require ( whitelistedSpenders [ _spender ] != true , ""Spender must be removed from the whitelist"" ) ; delete approvedSpenders [ msg . sender ] [ _spender ] ; emit SpenderRescind ( msg . sender , _spender ) ; }",Rescinds a previous approval for spending the ` msg.sender ` 's contract balance .
4151,"function processSeason ( uint32 _season ) public onlyCOO { uint64 fightTime = matchTime [ _season ] ; require ( now >= fightTime && fightTime > 0 ) ; uint sumFund = 0 ; uint sumSeed = 0 ; ( sumFund , sumSeed ) = _getFightData ( _season ) ; if ( sumFund == 0 ) { finished [ _season ] = 110 ; doLogFighter ( _season , 0 , 0 ) ; emit SeasonNone ( _season ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , 0 , 0 , 0 , false ) ; } else { uint8 champion = _localFight ( _season , uint32 ( sumSeed ) ) ; uint percentile = safeDiv ( sumFund , 100 ) ; uint devCut = percentile * 4 ; uint partnerCut = percentile * 5 ; uint fighterCut = percentile * 1 ; uint bonusWinner = percentile * 80 ; _bonusToPartners ( partnerCut ) ; _bonusToFighters ( _season , champion , fighterCut ) ; bool isRefound = _bonusToBettor ( _season , champion , bonusWinner ) ; _addMoney ( cfoAddress , devCut ) ; uint key = _season * 1000 + champion ; Fighter storage soldier = soldiers [ key ] ; doLogFighter ( _season , key , fighterCut ) ; emit SeasonWinner ( _season , champion ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , key , soldier . hometown , soldier . tokenID , isRefound ) ; } clearTheSeason ( _season ) ; }","process a combat , it is expencive , so provide enough gas"
4152,"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender `
4153,"function transferManyLands ( uint256 estateId , uint256 [ ] landIds , address destinatary ) external canTransfer ( estateId ) { uint length = landIds . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transferLand ( estateId , landIds [ i ] , destinatary ) ; } }",Transfer many tokens owned by an Estate to a new owner
4154,"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with token"" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; DataVault . _externalAddMasternode ( msg . sender ) ; }",Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
4156,"function lock ( address investor , uint112 amount , uint112 neumarks , uint32 unlockDate ) private acceptAgreement ( investor ) { require ( amount > 0 ) ; Account storage account = _accounts [ investor ] ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; } account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add112 ( account . neumarksDue , neumarks ) ; if ( unlockDate > account . unlockDate ) { account . unlockDate = unlockDate ; } emit LogFundsLocked ( investor , amount , neumarks ) ; }","locks funds of investors for a period of time , called by migration"
4157,"function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == _ownerOf ( _tokenId ) ) ; require ( msg . sender != _approved ) ; if ( _getApproved ( _tokenId ) != address ( 0 ) || _approved != address ( 0 ) ) { _approve ( _approved , _tokenId ) ; Approval ( msg . sender , _approved , _tokenId ) ; } }",Set or reaffirm the approved address for an NFT
4158,function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= goal && address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } },"Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner"
4159,"function feesByPeriod ( address account ) public view returns ( uint [ FEE_PERIOD_LENGTH ] ) { uint [ FEE_PERIOD_LENGTH ] memory result ; uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetix . synthetixState ( ) . issuanceData ( account ) ; if ( initialDebtOwnership == 0 ) return result ; uint totalSynths = synthetix . totalIssuedSynths ( ""XDR"" ) ; if ( totalSynths == 0 ) return result ; uint debtBalance = synthetix . debtBalanceOf ( account , ""XDR"" ) ; uint userOwnershipPercentage = debtBalance . divideDecimal ( totalSynths ) ; uint penalty = currentPenalty ( account ) ; for ( uint i = 0 ; i < FEE_PERIOD_LENGTH ; i ++ ) { if ( recentFeePeriods [ i ] . startingDebtIndex > debtEntryIndex && lastFeeWithdrawal [ account ] < recentFeePeriods [ i ] . feePeriodId ) { uint feesFromPeriodWithoutPenalty = recentFeePeriods [ i ] . feesToDistribute . multiplyDecimal ( userOwnershipPercentage ) ; uint penaltyFromPeriod = feesFromPeriodWithoutPenalty . multiplyDecimal ( penalty ) ; uint feesFromPeriod = feesFromPeriodWithoutPenalty . sub ( penaltyFromPeriod ) ; result [ i ] = feesFromPeriod ; } } return result ; }","Calculates fees by period for an account , priced in XDRs"
4162,"function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( ""reputation"" , _factoryAddress ) ) ; }",Returns the reputation of the entered Module Factory
4163,function setOpsAddress ( address _opsAddress ) external onlyOwner returns ( bool ) { require ( _opsAddress != owner ) ; require ( _opsAddress != address ( this ) ) ; require ( _opsAddress != address ( 0 ) ) ; opsAddress = _opsAddress ; return true ; },Owner can change the verified operator address .
4164,"function _release ( ) internal { uint length = min ( transferAddresses . length , transferredIndex + MAX_TRANSFER ) ; uint i = transferredIndex ; if ( isCapped ) { for ( ; i < length ; i ++ ) { address ad = transferAddresses [ i ] ; uint b = balances [ ad ] ; if ( b == 0 ) { continue ; } balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } else { uint unsold = getUnsoldToken ( ) ; uint sold = totalSupply_ . sub ( unsold ) ; if ( sold <= 0 ) { return ; } for ( ; i < length ; i ++ ) { ad = transferAddresses [ i ] ; b = balances [ ad ] ; if ( b == 0 ) { continue ; } b = b . add ( b . mul ( unsold ) . div ( sold ) ) ; balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } transferredIndex = i - 1 ; }","Only call after releasing all sale smart contracts , this smart contract must have enough Mozo tokens"
4167,function balanceOf ( address account ) public view returns ( uint ) { return totalVestedAccountBalance [ account ] ; },A simple alias to totalVestedAccountBalance : provides ERC20 balance integration .
4168,"function convert ( uint _amount ) { if ( ! arcToken . transferFrom . gas ( 100000 ) ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }",converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
4169,"function withdrawERC20 ( address _tokenContract , uint256 _value ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; IERC20 token = IERC20 ( _tokenContract ) ; require ( token . transfer ( owner , _value ) ) ; }",Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token .
4170,"function adjustPrice ( uint _multiplier ) external onlyOwner { require ( _multiplier < 400 && _multiplier > 25 ) ; minInvestment = minInvestment * _multiplier / 100 ; weiPerABIO = weiPerABIO * _multiplier / 100 ; emit PriceAdjust ( msg . sender , _multiplier , minInvestment , weiPerABIO ) ; }",allows owner to adjust ` minInvestment ` and ` weiPerABIO ` in case of extreme jumps of Ether 's dollar-value .
4171,function setMinBuyAmount ( uint256 _minBuyAmount ) onlyOwner public { minBuyAmount = _minBuyAmount ; },set minimal amount of ether which can be used to buy tokens
4173,"function calculateAccountValues ( address userAddress ) public view returns ( uint , uint , uint ) { ( Error err , uint supplyValue , uint borrowValue ) = calculateAccountValuesInternal ( userAddress ) ; if ( err != Error . NO_ERROR ) { return ( uint ( err ) , 0 , 0 ) ; } return ( 0 , supplyValue , borrowValue ) ; }","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 ."
4174,"function getTokensWithBonuses ( uint256 value , bool withReferralBonus ) view public returns ( uint256 ) { uint256 amount = value . mul ( baseRate ) ; amount = amount . add ( getTimeBonus ( value ) ) . add ( getBulkBonus ( value ) ) ; if ( withReferralBonus ) { amount = amount . add ( getReferralBonus ( value ) ) ; } return amount ; }",Calculates how many tokens one should receive at curent time for a specified value of ether
4175,"function skipPayment ( uint _idDeposit , bool _skip ) public { require ( _idDeposit < deposits . length ) ; skipDeposits [ msg . sender ] [ _idDeposit ] = _skip ; SkipPayment ( _idDeposit , _skip ) ; }","This function is a failsafe function in case a token holder wants to skip a payment , can only be applied to one deposit at a time and only affects the payment for the ` msg.sender ` calling the function ; can be undone by calling again with ` skip == false `"
4177,function proxyPayment ( address buyer ) payable public whenNotPaused returns ( bool success ) { return doPayment ( buyer ) ; },` proxyPayment ( ) ` allows the caller to send ether to the VZTPresale and have the tokens created in an address of their choosing
4178,"function div ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , ( 10 ** 18 ) ) , y / 2 ) / y ; }",This function divides two decimals represented as ( decimal 10DECIMALS )
4181,"function getChar ( uint256 _tokenId ) public view returns ( string wikiID_Name , uint256 sellingPrice , address owner ) { Char storage char = chars [ _tokenId ] ; wikiID_Name = char . wikiID_Name ; sellingPrice = charIndexToPrice [ _tokenId ] ; owner = charIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific char .
4183,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
4184,function totalSupply ( ) public view returns ( uint Supply ) { return totalBhinneka ; },Returns the Total Number of BTI Tokens .
4185,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; collectibleIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
4186,"function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }",Migrate tokens to the new token contract .
4188,"function payAffiliate ( uint256 _tokens , uint256 _etherValue , address _caller ) internal { if ( affiliateUtility . isAffiliateValid ( _caller ) ) { address affiliate = affiliateUtility . getAffiliate ( _caller ) ; var ( affiliateBonus , contributorBonus ) = affiliateUtility . applyAffiliate ( _caller , _tokens , _etherValue ) ; shp . generateTokens ( affiliate , affiliateBonus ) ; shp . generateTokens ( _caller , contributorBonus ) ; } }",Pays an affiliate if they are valid and present in the transaction data
4190,function changeArbitrator ( address _newArbitrator ) onlyArbitrator { arbitrator = _newArbitrator ; },` onlyArbitrator ` Reassigns the arbitrator to a new address
4191,"function _chkBuyerLmts ( address buyer , uint amountOfCoinsBuyerCanBuy ) internal returns ( bool success ) { uint amountTkns = amountOfCoinsBuyerCanBuy ; success = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; uint seriesCapFactor = ico . getSCF ( ) ; if ( amountTkns <= safeSub ( safeDiv ( allowedIndividualShare * seriesCapFactor , 10 ** 18 ) , balanceOf [ buyer ] ) ) { success = true ; } return success ; }",a buyers allowed limits in holding ico tokens is checked
4192,"function createToken ( ) payable returns ( bool success ) { if ( msg . value == 0 ) { throw ; } if ( ( balances [ msg . sender ] + msg . value ) > balances [ msg . sender ] && ( totalSupply + msg . value ) > totalSupply ) { totalSupply += msg . value ; balances [ msg . sender ] += msg . value ; LogCreateToken ( msg . sender , msg . value ) ; return true ; } else { throw ; } }",Creates ether tokens corresponding to the amount of ether received 'msg.value ' .
4193,function _getApproved ( uint256 _tokenId ) internal view returns ( address ) { require ( _exists ( _tokenId ) ) ; return _tokenApprovals [ _tokenId ] ; },Get the approved address for a single NFT
4194,"function setSigningLogic ( SigningLogicInterface _newSigningLogic ) public nonZero ( _newSigningLogic ) onlyOwner { address oldSigningLogic = signingLogic ; signingLogic = _newSigningLogic ; emit SigningLogicChanged ( oldSigningLogic , signingLogic ) ; }",Change the implementation of the SigningLogic contract by setting a new address
4196,"function collect ( address caller ) public { require ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = wct1 . balanceOfAt ( caller , pre_sale_fixed_at ) ; balance = balance . add ( wct2 . balanceOfAt ( caller , pre_sale_fixed_at ) ) ; uint256 totalSupplied = wct1 . totalSupplyAt ( pre_sale_fixed_at ) ; totalSupplied = totalSupplied . add ( wct2 . totalSupplyAt ( pre_sale_fixed_at ) ) ; uint256 total = totalCollected . add ( wpr . balanceOf ( address ( this ) ) ) ; assert ( totalSupplied > 0 ) ; uint256 amount = total . mul ( balance ) . div ( totalSupplied ) ; amount = amount . sub ( collected [ caller ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ caller ] = collected [ caller ] . add ( amount ) ; require ( wpr . transfer ( caller , amount ) ) ; TokensCollected ( caller , amount ) ; }",This method should be called by the WCT holders to collect their corresponding WPRs
4198,"function borrow ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . BORROW_CONTRACT_PAUSED ) ; } BorrowLocalVars memory localResults ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ msg . sender ] [ asset ] ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . BORROW_MARKET_NOT_SUPPORTED ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . borrowAmountWithFee ) = calculateBorrowAmountWithFee ( amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ORIGINATION_FEE_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowUpdated ) = add ( localResults . userBorrowCurrent , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalBorrows ) = addThenSub ( market . totalBorrows , localResults . userBorrowUpdated , borrowBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED ) ; } ( err , localResults . accountLiquidity , localResults . accountShortfall ) = calculateAccountLiquidity ( msg . sender ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED ) ; } if ( ! isZeroExp ( localResults . accountShortfall ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_ACCOUNT_SHORTFALL_PRESENT ) ; } ( err , localResults . ethValueOfBorrowAmountWithFee ) = getPriceForAssetAmountMulCollatRatio ( asset , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_AMOUNT_VALUE_CALCULATION_FAILED ) ; } if ( lessThanExp ( localResults . accountLiquidity , localResults . ethValueOfBorrowAmountWithFee ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_AMOUNT_LIQUIDITY_SHORTFALL ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = sub ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . TOKEN_INSUFFICIENT_CASH , FailureInfo . BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferOut ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_TRANSFER_OUT_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalBorrows = localResults . newTotalBorrows ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = borrowBalance . principal ; borrowBalance . principal = localResults . userBorrowUpdated ; borrowBalance . interestIndex = localResults . newBorrowIndex ; emit BorrowTaken ( msg . sender , asset , amount , localResults . startingBalance , localResults . borrowAmountWithFee , localResults . userBorrowUpdated ) ; return uint ( Error . NO_ERROR ) ; }",Users borrow assets from the protocol to their own address
4199,"function verifyTransfer ( address , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . investorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }",Used to verify the transfer transaction according to the rule implemented in the trnasfer managers
4200,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ _to ] += _amount ; balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }",Transfer Spork tokens from one account to another
4206,function canStart ( ) public view returns ( bool ) { uint256 timeOfWeek = ( block . timestamp - 345600 ) % 604800 ; uint256 windows = activeTimesFrom . length ; if ( windows == 0 ) { return true ; } for ( uint256 i = 0 ; i < windows ; i ++ ) { if ( timeOfWeek >= activeTimesFrom [ i ] && timeOfWeek <= activeTimesTo [ i ] ) { return true ; } } return false ; },"A boolean indicating whether a new game can start , based on the active times ."
4207,function getAmountOfTokens ( ) public view returns ( uint256 _lengthOfTokens ) { _lengthOfTokens = tokenAddress . length ; },Returns the amount of tokens currently in this contract .
4208,"function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external ;",Creates a new Security Token and saves it to the registry
4211,"function stakeTokens ( uint _quantity ) external isStaking notZero ( _quantity ) { require ( levToken . allowance ( msg . sender , this ) >= _quantity ) ; levBlocks [ msg . sender ] = levBlocks [ msg . sender ] . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; stakes [ msg . sender ] = stakes [ msg . sender ] . add ( _quantity ) ; totalLevBlocks = totalLevBlocks . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; totalLevs = totalLevs . add ( _quantity ) ; require ( levToken . transferFrom ( msg . sender , this , _quantity ) ) ; StakeEvent ( msg . sender , _quantity , startBlock , endBlock ) ; }",Public function to stake tokens executable by any user .
4213,"function unFreezeAccount ( address target ) onlyOwner public { frozenAccount [ target ] = false ; FrozenFunds ( target , false ) ; }",Allow ` target ` from sending & receiving tokens
4214,function startSale ( ) public onlyController { require ( campaignState > 2 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; },Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time
4215,function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
4216,"function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit SetManualOverride ( _override , now ) ; }",Determine whether manual price is used or not
4218,"function disableController ( ) external isEnabled ( ""disableControllerAllowed"" ) onlyOwner { require ( ! controllerDisabled ) ; controllerDisabled = true ; delete controller ; emit DisableController ( now ) ; }",Used by the issuer to permanently disable controller functionality
4219,"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; aix . generateTokens ( remainderHolder , weiToCollect ( ) . mul ( 2000 ) ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }",This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .
4220,function disableController ( ) external ;,Used by the issuer to permanently disable controller functionality
4221,function synthetixReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInSynths = amount . multiplyDecimal ( usdToEthPrice ) ; return synthetixReceivedForSynths ( valueSentInSynths ) ; },Calculate how many SNX you will receive if you transfer an amount of ether .
4223,"function refoundTokens ( uint index , address receiver , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , receiver , sc ) == true ) { airdrop . tokenSC . transfer ( airdrop . distributor , airdrop . tokenAmount ) ; } else revert ( ) ; }",Refund tokens back to the to airdrop creator
4224,function updateWallet ( address _wallet ) external onlyContractOwner returns ( uint ) { require ( _wallet != 0x0 ) ; wallet = _wallet ; return OK ; },Sets new wallet address for profiterole Only for contract owner .
4225,"function withdrawToRegisteredWallet ( ) external { require ( registered_wallet != 0x0 , ""No wallet is registered"" ) ; registered_wallet . transfer ( address ( this ) . balance ) ; }",Withdraw money from the arbitrator contract to our registered wallet
4226,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { Approval ( msg . sender , _spender , _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
4228,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { return ownedTokens [ _owner ] ; },Returns a list of all Warrior IDs assigned to an address .
4229,function isAllowedTrade ( address who ) public view returns ( bool ) { return tradingWhitelist [ who ] ; },Check if a user is allowed to trade .
4230,"function transferFrom ( address _from , address _to , uint _value ) public notPaused { super . transferFrom ( _from , _to , _value ) ; }",ERC20 transferFrom function overridden to disable transfers when paused
4231,"function verifyWithdrawSignature ( address _trader , bytes _signature ) external onlyBalancesContract returns ( bool ) { bytes memory data = abi . encodePacked ( ""Republic Protocol: withdraw: "" , _trader , traderNonces [ _trader ] ) ; address signer = Utils . addr ( data , _signature ) ; if ( brokers [ signer ] ) { traderNonces [ _trader ] += 1 ; return true ; } return false ; }",Verifies a broker 's signature for a trader withdrawal .
4233,"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( address ( 0 ) , address ( this ) , mintedAmount ) ; emit Transfer ( address ( this ) , target , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` target `
4234,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
4236,"function getPaintedPixelsCountByAddress ( address _address , uint32 _canvasId ) public view returns ( uint32 ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; return canvas . addressToCount [ _address ] ; }",Returns number of pixels set by given address .
4238,function disableTransfers ( ) public onlyWhitelisted { require ( transfersEnabled ) ; transfersEnabled = false ; },This function disables token transfers for everyone .
4239,function getModule ( address _acct ) external view returns ( bool ) { return modules [ _acct ] ; },Get if ` _acct ` is an authorized module
4241,function setRatePrices ( uint256 newRate ) onlyAuthorized public { baseRate = newRate ; },Allow users to buy tokens for ` newRatePrice ` eth
4242,"function cumulative ( uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }",finds total amount of neumarks issued for given amount of Euro
4243,"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length - 1 ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }",Use and override this function with caution .
4244,"function buyTokens ( ) public stopInEmergency payable returns ( bool ) { if ( msg . value == 0 ) { error ( 'buyTokens: ZeroPurchase' ) ; return false ; } uint256 tokenAmount = buyTokensLowLevel ( msg . sender , msg . value ) ; if ( ! SCRefundVault . deposit . value ( msg . value ) ( msg . sender , tokenAmount ) ) { revert ( 'buyTokens: unable to transfer collected funds from ICO contract to Refund Vault' ) ; } emit BuyTokens ( msg . sender , msg . value , tokenAmount ) ; return true ; }",Token purchase function direclty through ICO Smart Contract .
4245,"function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; voteTokenBalance [ msg . sender ] += _numTokens ; VotingRightsGranted ( msg . sender , _numTokens ) ; }",Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
4246,function withdraw ( ) public ownerOnly { owner . transfer ( address ( this ) . balance ) ; },Will transfer all ether in this account to the contract owner .
4248,"function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , uint256 uniqueID ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length , ""TotlePrimary - trade length check failed"" ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length , ""TotlePrimary - order length check failed"" ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }","The first four parameters relate to Token orders , the last eight relate to DEX orders"
4250,"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return true ; }",Checks whether investment is permitted for a participant
4251,"function cancelAuction ( uint _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
4252,function proxyPayment ( address _owner ) payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; },` proxyPayment ( ) ` allows the caller to send ether to the EarlyTokenSale and have the tokens created in an address of their choosing
4255,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",` _value ` tokens will be sended to ` _to `
4256,"function donate ( uint64 giverId , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giverId != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit Donate ( giverId , receiverId , token , amount ) ; }",It is not recommened to call this function outside of the giveth dapp ( giveth.io ) this function is bridged to a side chain .
4257,function removeMinter ( address _who ) public onlyValidator { _removeMinter ( _who ) ; },Removes the necessary permissions for a user to mint tokens .
4258,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
4259,function getInt ( bytes32 _key ) public view returns ( int _value ) { return intStorage [ _key ] ; },Get value for Int associated with bytes32 id key
4260,"function changeExpiryLimit ( uint256 _newExpiry ) public onlyOwner { require ( _newExpiry >= 1 days , ""Expiry should greater than or equal to 1 day"" ) ; uint256 _oldExpiry = expiryLimit ; expiryLimit = _newExpiry ; emit LogChangeExpiryLimit ( _oldExpiry , _newExpiry ) ; }",Change the expiry time for the token symbol
4261,"function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; if ( allowStart ) { allowStart = false ; } else { require ( canStart ( ) ) ; } require ( startNewGameIfIdle ) ; _setGameSettings ( ) ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; gameStates [ gameIndex ] . penultimateTileTimeout = block . timestamp + gameSettings . initialActivityTimer ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool ) ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] >= block . timestamp ) ; } uint256 price = currentPrice ( identifier ) ; require ( msg . value >= price ) ; uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; _calculateAndAssignBuyoutProceeds ( currentOwner , price , claimedSurroundingTiles ) ; uint256 timeout = tileTimeoutTimestamp ( identifier , msg . sender ) ; gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] = timeout ; if ( gameStates [ gameIndex ] . lastTile == 0 || timeout >= gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ) { if ( gameStates [ gameIndex ] . lastTile != identifier ) { if ( gameStates [ gameIndex ] . lastTile != 0 ) { gameStates [ gameIndex ] . penultimateTileTimeout = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } gameStates [ gameIndex ] . lastTile = identifier ; LastTile ( gameIndex , identifier , x , y ) ; } } else if ( timeout > gameStates [ gameIndex ] . penultimateTileTimeout ) { gameStates [ gameIndex ] . penultimateTileTimeout = timeout ; PenultimateTileTimeout ( gameIndex , timeout ) ; } _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . numberOfTileFlips ++ ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , timeout , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }",Buy the current owner out of the tile .
4264,"function freezeAccount ( address target , bool freeze ) onlyOwner public { _frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }","Freeze or unfreeze account , can be run only by owner"
4265,"function onTransfer ( address , address , uint256 ) returns ( bool ) { return transferable ; }",Notifies the controller about a token transfer allowing the controller to react if desired
4267,"function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; require ( holderIndex [ _externalHolderId ] == 0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }","Returns holder id for the specified address , creates it if needed ."
4268,"function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return ERC721_RECEIVED ; } }",Callback used to accept the ERC721 parcel tokens
4269,"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , string emojiMsg , uint256 sellingPrice , address owner ) { Emoji storage emojiObj = emojis [ _tokenId ] ; emojiName = emojiObj . name ; emojiMsg = emojiObj . msg ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific emoji .
4270,"function closeCurrentFeePeriod ( ) external onlyFeeAuthority { require ( recentFeePeriods [ 0 ] . startTime <= ( now - feePeriodDuration ) , ""It is too early to close the current fee period"" ) ; FeePeriod memory secondLastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] ; FeePeriod memory lastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 1 ] ; recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] . feesToDistribute = lastFeePeriod . feesToDistribute . sub ( lastFeePeriod . feesClaimed ) . add ( secondLastFeePeriod . feesToDistribute ) ; for ( uint i = FEE_PERIOD_LENGTH - 2 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint next = i + 1 ; recentFeePeriods [ next ] . feePeriodId = recentFeePeriods [ i ] . feePeriodId ; recentFeePeriods [ next ] . startingDebtIndex = recentFeePeriods [ i ] . startingDebtIndex ; recentFeePeriods [ next ] . startTime = recentFeePeriods [ i ] . startTime ; recentFeePeriods [ next ] . feesToDistribute = recentFeePeriods [ i ] . feesToDistribute ; recentFeePeriods [ next ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed ; } delete recentFeePeriods [ 0 ] ; recentFeePeriods [ 0 ] . feePeriodId = nextFeePeriodId ; recentFeePeriods [ 0 ] . startingDebtIndex = synthetix . synthetixState ( ) . debtLedgerLength ( ) ; recentFeePeriods [ 0 ] . startTime = now ; nextFeePeriodId = nextFeePeriodId . add ( 1 ) ; emitFeePeriodClosed ( recentFeePeriods [ 1 ] . feePeriodId ) ; }",Close the current fee period and start a new one .
4271,"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; _tokenTransferFrom ( mana , msg . sender , this , requiredDeposit ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }",Request a loan and attachs a mortgage request
4273,"function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external { address validator = _signingKeys [ hash . toEthSignedMessageHash ( ) . recover ( signature ) ] ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validator may invalidate attribute approval"" ) ; _invalidAttributeApprovalHashes [ hash ] = true ; }",Invalidate a signed attribute approval before it has been set by supplying the hash of the approval ` hash ` and the signature ` signature ` .
4275,"function withdrawTokens ( ) external whenNotPaused onlyAdmin { IERC20 t = super . token ( ) ; t . safeTransfer ( msg . sender , t . balanceOf ( this ) ) ; }",Withdraw the tokens remaining tokens from the contract .
4276,"function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; bool returnTokens = false ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else returnTokens = true ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; if ( returnTokens ) msg . sender . transfer ( weiNextTier ) ; }",Buys the tokens for the specified tier and for the next one
4278,"function fulfill ( Deliverable storage self , address _creator , address _brand ) internal returns ( bool ) { require ( msg . sender == _creator || msg . sender == _brand ) ; self . fulfillment [ msg . sender ] = true ; return self . fulfillment [ _creator ] && self . fulfillment [ _brand ] ; }","msg.sender can be creator or brand and mark their delivery or approval , returns check if completely Fulfilled"
4279,"function transferTokens ( address _recipient ) public { require ( beneficiaries [ _recipient ] . amountClaimed < beneficiaries [ _recipient ] . totalAllocated ) ; require ( now >= beneficiaries [ _recipient ] . cliff ) ; require ( ! beneficiaries [ _recipient ] . disable ) ; uint256 unreleased = releasableAmount ( _recipient ) ; require ( unreleased > 0 ) ; IOV . transfer ( _recipient , unreleased ) ; beneficiaries [ _recipient ] . amountClaimed = vestedAmount ( _recipient ) ; emit LogIOVClaimed ( _recipient , unreleased ) ; }",Transfer a recipients available allocation to their address .
4280,"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
4281,function finalizeFunding ( ) { require ( now >= endFundingTime ) ; tokenContract . changeController ( 0 ) ; },"` finalizeFunding ( ) ` ends the Campaign by calling setting the controller to 0 , thereby ending the issuance of new tokens and stopping the Campaign from receiving more ether"
4282,"function commitVotes ( uint [ ] _pollIDs , bytes32 [ ] _secretHashes , uint [ ] _numsTokens , uint [ ] _prevPollIDs ) external { require ( _pollIDs . length == _secretHashes . length ) ; require ( _pollIDs . length == _numsTokens . length ) ; require ( _pollIDs . length == _prevPollIDs . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { commitVote ( _pollIDs [ i ] , _secretHashes [ i ] , _numsTokens [ i ] , _prevPollIDs [ i ] ) ; } }",Commits votes using hashes of choices and secret salts to conceal votes until reveal
4284,"function refundIgnoredBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_ignored_count < bids_ignored_refunded . add ( count ) ) { count = bids_ignored_count . sub ( bids_ignored_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_ignored_refunded ; bids_ignored_refunded = bids_ignored_refunded . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_ignored [ cursor ] ; if ( bid . closed ) { continue ; } bid . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }",Performs the refund of the ignored bids ART tokens
4285,"function setShareHolders ( bool _valid , uint _from , uint _to ) ;",Function used by the creator to set the addresses of Dao share holders
4286,"function applyAffiliate ( address _investor , uint256 _contributorTokens , uint256 _contributionValue ) public returns ( uint256 , uint256 ) { if ( getAffiliate ( _investor ) == address ( 0 ) ) { return ( 0 , 0 ) ; } uint256 contributorBonus = _contributorTokens . div ( 100 ) ; uint256 affiliateBonus = 0 ; if ( _contributionValue < tierTwoMin ) { affiliateBonus = _contributorTokens . mul ( TIER1_PERCENT ) . div ( 100 ) ; } else if ( _contributionValue >= tierTwoMin && _contributionValue < tierThreeMin ) { affiliateBonus = _contributorTokens . mul ( TIER2_PERCENT ) . div ( 100 ) ; } else { affiliateBonus = _contributorTokens . mul ( TIER3_PERCENT ) . div ( 100 ) ; } return ( affiliateBonus , contributorBonus ) ; }",calculates and returns the amount to token minted for affilliate
4287,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( throwOnIncompatibleContract && _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
4288,"function readBytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { if ( data . length / 32 > index ) { assembly { o := mload ( add ( data , add ( 32 , mul ( 32 , index ) ) ) ) } } }",Reads a bytes32 word of a bytes array
4289,"function getCovfefe ( uint _tokenId ) public view returns ( string Term , string Meaning , uint Generation , uint ReadyTime , uint WinCount , uint LossCount , uint CurrentPrice , uint LastPrice , address Owner ) { Covfefe storage covfefe = covfefes [ _tokenId ] ; Term = covfefe . term ; Meaning = covfefe . meaning ; Generation = covfefe . generation ; ReadyTime = covfefe . saleReadyTime ; WinCount = covfefe . winCount ; LossCount = covfefe . lossCount ; CurrentPrice = covfefeIndexToPrice [ _tokenId ] ; LastPrice = covfefeIndexToLastPrice [ _tokenId ] ; Owner = covfefeIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific covfefe .
4290,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ;",send _value token to _to from _from on the condition it is approved by _from
4292,"function mint ( address _to , uint256 _amount ) public requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }",Allows user to mint if they have the appropriate permissions .
4293,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable mustBeValidToken ( _tokenId ) canTransfer ( _tokenId ) { address owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( owner == address ( 0 ) ) { owner = address ( this ) ; } require ( owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _tokenId , _to ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
4294,"function releaseApprove ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 approveSha = keccak256 ( ""approve"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 increaseApprovalSha = keccak256 ( ""increaseApproval"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 decreaseApprovalSha = keccak256 ( ""decreaseApproval"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( approveSha == sha || increaseApprovalSha == sha || decreaseApprovalSha == sha ) ; require ( verify ( sha , v , r , s ) == true ) ; super . approve ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }","Complete pending Approval , can only be called by msg.sender if it is the originator of Approval"
4295,"function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( ""sUSD"" , amount , ""XDR"" ) ; uint totalDebtIssued = importedXDRAmount ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; importedXDRAmount = newTotalDebtIssued ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }",Import issuer data from the old Synthetix contract before multicurrency
4296,"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; require ( lib . forceTransfer ( currency , msg . sender , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; require ( lib . forceTransfer ( currency , msg . sender , feeContract , calculateFees ( amount ) , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }",transfers 'amount ' from msg.sender to a receiving account 'to '
4297,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) , ""Not an operator"" ) ; addWhitelistAddress ( _to ) ; doSend ( msg . sender , _from , _to , _amount , _data , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
4300,"function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; emit LogSetQuestionFee ( msg . sender , fee ) ; }",Function for arbitrator to set an optional per-question fee .
4301,"function callPlugins ( bool before , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { allowedAmount = amount ; allowedAmount = callPluginsPledge ( before , fromPledge , fromPledge , toPledge , allowedAmount ) ; allowedAmount = callPluginsPledge ( before , toPledge , fromPledge , toPledge , allowedAmount ) ; }",` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .
4302,function balanceOf ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; },Query the available balance of an address ~ ERC-20 Standard
4303,function registerSecretBatch ( bytes32 [ ] secrets ) public returns ( bool ) { bool completeSuccess = true ; for ( uint i = 0 ; i < secrets . length ; i ++ ) { if ( ! registerSecret ( secrets [ i ] ) ) { completeSuccess = false ; } } return completeSuccess ; },Registers multiple hash time lock secrets and saves the block number .
4304,"function feesAvailable ( address account , bytes4 currencyKey ) public view returns ( uint ) { uint [ FEE_PERIOD_LENGTH ] memory userFees = feesByPeriod ( account ) ; uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( userFees [ i ] ) ; } return synthetix . effectiveValue ( ""XDR"" , totalFees , currencyKey ) ; }","The fees available to be withdrawn by a specific account , priced in currencyKey currency"
4305,"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 12 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 24 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 24 ) ) && getTime ( ) <= finalizedTime . add ( months ( 36 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }",The owner will call this method to extract the tokens
4306,"function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",Handles transfer to a contract ~ ERC-223 Proposed Standard
4307,"function addRestrictedAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , true , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : true , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }",Add a restricted attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
4309,function abort ( ) public returns ( bool ) ;,Abort the token sale prior to finalizeICO ( )
4311,function setEnd ( ) external onlyAdmin checkState ( pointsValidationState . WinnersAssigned ) { uint256 balance = address ( this ) . balance ; adminPool = balance . mul ( 10 ) . div ( 100 ) ; prizePool = balance . mul ( 90 ) . div ( 100 ) ; pValidationState = pointsValidationState . Finished ; gameFinishedTime = now ; unSetPause ( ) ; },Sets prizes for last tokens and sets prize pool amount
4313,"function deposit ( address _token , uint256 _value ) external payable isInitialized { _deposit ( _token , _value ) ; }",Deposit ` _value ` ` _token ` to the vault
4314,"function withdraw ( address _user , uint256 _value ) public onlyOwnerOrAllowed ;",Withdraws a certain value from a user 's balance back to the user 's account Can be called from the Advertisement contract registered or by this contract 's owner .
4318,"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ _receiver ] = allowance [ _owner ] [ _receiver ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }",Used to transfer funds on behalf of one person
4319,function enableTransfers ( bool _transfersEnabled ) public onlyController { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
4320,"function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }",issues new Neumarks to msg.sender with reward at current curve position moves curve position by euroUlps callable only by ROLE_NEUMARK_ISSUER
4321,"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) ; require ( _getSanitizedReturnValue ( ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }",Deposits ERC20 tokens under the ` _user ` 's balance
4322,function getString ( bytes32 _key ) public view returns ( string _value ) { return stringStorage [ _key ] ; },Get value for String associated with bytes32 id key
4323,"function generateTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
4325,function changeController ( address _newController ) public onlyOwner { token . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The owner of this contract can change the controller of the token Please , be sure that the owner is a trusted agent or 0x0 address ."
4326,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyCallers public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
4327,"function transferFrom ( address _from , address _to , uint _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; _transItem ( _from , _to , _tokenId ) ; }","Transfer a Rabbit owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
4329,"function migrationSetPlayer ( bytes32 boardHash , uint playerID , bytes32 playerName , address playerAddress , uint score , uint score_unconfirmed , uint isActive ) isOwner public returns ( bool ) { Board storage g = boards [ boardHash ] ; g . players [ playerID ] = Player ( playerName , playerAddress , score , score_unconfirmed , isActive ) ; return true ; }",Write player metadata for migration as contract owner only
4330,"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E94 ) , _newCEO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCEO
4331,"function withdrawToken ( address _token ) external onlyAdmin { bool isVRH = _token == address ( token ) ; ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; if ( isVRH ) { balance = balance . sub ( getRemainingBonus ( ) ) ; changeClosingTime ( now ) ; } require ( erc20 . transfer ( msg . sender , balance ) ) ; emit ERC20Withdrawn ( _token , balance ) ; }",Enables the admins to withdraw Binance coinor any ERC20 token accidentally sent to this contract .
4332,function getPriceVolume ( uint _price ) public constant returns ( uint ) ;,Returns the collective order volume at a ` _price ` .
4333,"function setParent ( uint256 identifier , uint256 parentIdentifier ) external onlyCFO { require ( identifierToOwner [ identifier ] != 0x0 ) ; identifierToParentIdentifier [ identifier ] = parentIdentifier ; }",Set the parent collectible of a collectible .
4334,"function changeHolderPercentage ( uint256 _maxHolderPercentage ) public onlyOwner { emit LogModifyHolderPercentage ( maxHolderPercentage , _maxHolderPercentage ) ; maxHolderPercentage = _maxHolderPercentage ; }",sets the maximum percentage that an individual token holder can hold
4336,"function _safeTransfer ( address _to , uint _amount ) internal { require ( _to != 0 ) ; _to . transfer ( _amount ) ; }",` _safeTransfer ` is used internally when transfer funds safely .
4338,"function finalize ( ) public initialized { require ( getBlockNumber ( ) >= startBlock ) ; require ( msg . sender == owner || getBlockNumber ( ) > endBlock ) ; require ( finalizedBlock == 0 ) ; require ( dynamicCeiling . allRevealed ( ) ) ; if ( getBlockNumber ( ) <= endBlock ) { var ( , lastLimit , , ) = dynamicCeiling . curves ( dynamicCeiling . revealedCurves ( ) . sub ( 1 ) ) ; require ( totalNormalCollected >= lastLimit ) ; } finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToSgt ; if ( SGT . totalSupply ( ) >= maxSGTSupply ) { percentageToSgt = percent ( 10 ) ; } else { percentageToSgt = percent ( 10 ) . mul ( SGT . totalSupply ( ) ) . div ( maxSGTSupply ) ; } uint256 percentageToDevs = percent ( 20 ) ; uint256 percentageToContributors = percent ( 41 ) . add ( percent ( 10 ) . sub ( percentageToSgt ) ) ; uint256 percentageToReserve = percent ( 29 ) ; uint256 totalTokens = SNT . totalSupply ( ) . mul ( percent ( 100 ) ) . div ( percentageToContributors ) ; assert ( SNT . generateTokens ( destTokensReserve , totalTokens . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensSgt , totalTokens . mul ( percentageToSgt ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensDevs , totalTokens . mul ( percentageToDevs ) . div ( percent ( 100 ) ) ) ) ; SNT . changeController ( sntController ) ; Finalized ( ) ; }",This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
4339,"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }",Creates Bskt tokens in exchange for underlying tokens .
4342,"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 1 days ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }",The owner will call this method to extract the tokens
4343,"function tokenOfCreatorByIndex ( address _creator , uint256 _index ) public view validAddress ( _creator ) returns ( uint256 ) { require ( _index < createdTokens [ _creator ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ createdTokens [ _creator ] [ _index ] ] ; return pixelcon . tokenId ; }",Enumerate PixelCon created by ` ( _creator ) `
4344,"function shutForDai ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; uint price = uint ( feed . read ( ) ) ; uint bought = otc . sellAllAmount ( gem , min ( gemBalance , gem . balanceOf ( this ) ) , dai , wmul ( WAD - slippage , wmul ( gemBalance , price ) ) ) ; require ( dai . transfer ( msg . sender , bought ) ) ; }",shuts the CDP and returns all the value in the form of Dai .
4345,"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) external { }","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision ."
4346,"function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
4349,function claim ( ) public vaultUnlocked returns ( bool ) { return _transferTokens ( msg . sender ) ; },Claim whatever tokens account are allocated to the sender .
4352,"function changeModuleBudget ( address _module , uint256 _change , bool _increase ) external onlyOwner { require ( modulesToData [ _module ] . module != address ( 0 ) , ""Module missing"" ) ; uint256 currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , _module ) ; uint256 newAllowance ; if ( _increase ) { require ( IERC20 ( polyToken ) . increaseApproval ( _module , _change ) , ""IncreaseApproval fail"" ) ; newAllowance = currentAllowance . add ( _change ) ; } else { require ( IERC20 ( polyToken ) . decreaseApproval ( _module , _change ) , ""Insufficient allowance"" ) ; newAllowance = currentAllowance . sub ( _change ) ; } emit ModuleBudgetChanged ( modulesToData [ _module ] . moduleTypes , _module , currentAllowance , newAllowance ) ; }",allows owner to increase/decrease POLY approval of one of the modules
4353,"function pruneInvestors ( uint256 _start , uint256 _iters ) public onlyOwner { for ( uint256 i = _start ; i < Math . min256 ( _start . add ( _iters ) , investors . length ) ; i ++ ) { if ( ( i < investors . length ) && ( balanceOf ( investors [ i ] ) == 0 ) ) { investorListed [ investors [ i ] ] = false ; investors [ i ] = investors [ investors . length - 1 ] ; investors . length -- ; } } }",removes addresses with zero balances from the investors list
4354,"function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) { hodlerReward . invalidate ( _from ) ; return ! paused || _from == address ( this ) || _to == address ( this ) || _from == address ( crowdsale ) || _to == address ( crowdsale ) ; }","Before transfers are enabled for everyone , only this and the crowdsale contract is allowed to distribute HEAL"
4355,"function tip ( address _to , uint _amount ) public { require ( _to != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; emit TipMade ( msg . sender , _to , _amount ) ; DAI . transferFrom ( msg . sender , _to , _amount ) ; }",this function lets any registered address send DAI tokens to any other address
4356,"function canAddAttribute ( uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;",Check if a given signed attribute approval is currently valid when submitted directly by ` msg.sender ` .
4358,"function cancelMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( isPlayerOnBoard ( boardId , msg . sender ) ) ; require ( board . status == BoardStatus . WaitForOpponent ) ; updateBoardStatus ( board , boardId , BoardStatus . Canceled ) ; }",This function allows a player to cancel a match in the case they were waiting for an opponent for a long time but did n't find anyone and would want to get their deposit of table stakes back .
4359,function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; doPayment ( _idMilestone ) ; },` onlyArbitrator ` Forces a milestone to be paid out as long as it has not been paid or canceled
4360,function setToken ( address _token ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _token ) ; m_token = STQToken ( _token ) ; },In case we need to attach to existent token
4362,function supportsInterface ( bytes4 _interfaceID ) public view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) ) ; },Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
4363,function close ( ) onlyICOContract public returns ( bool ) { if ( state != State . Active ) { error ( 'close: state != State.Active' ) ; return false ; } state = State . Closed ; walletFounder1 . transfer ( address ( this ) . balance . mul ( 33 ) . div ( 100 ) ) ; walletFounder2 . transfer ( address ( this ) . balance . mul ( 50 ) . div ( 100 ) ) ; walletFounder3 . transfer ( address ( this ) . balance ) ; emit Closed ( ) ; return true ; },When ICO finalizes funds are transferred to founders ' wallets
4365,"function provideProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . worker ) ; job . proofOfLastWorkVerified = false ; emit ProofOfWorkProvided ( _JobID , msg . sender , true ) ; }",this function lets the worker provide proof of work
4367,"function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit ChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }",Used to change the fee of the usage cost
4370,"function multiCallTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeCall ( to , amount ) ; MultiCall ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }",Call to multiple contracts using a byte32 array which includes the contract address and the amount .
4371,function getFinalAnswer ( bytes32 question_id ) external view returns ( bytes32 ) { },"( Deprecated ) Return the final answer to the specified question , or revert if there is n't one"
4372,function decimals ( ) external constant returns ( uint8 _decimals ) { return decimals ; },Check the decimals of the token ~ ERC-20 Standard
4374,"function calculate_shares_and_return ( uint _shares_count , uint _share_price , uint _transfer_valuation , uint _final_share_price , uint _art_price , uint transfer_token ) view public returns ( uint _shares_to_assign , uint _executed_amount_valuation , uint _return_amount ) { if ( assigned_shares . add ( _shares_count ) > max_shares_to_sell ) { _shares_to_assign = max_shares_to_sell . sub ( assigned_shares ) ; } else { _shares_to_assign = _shares_count ; } _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; if ( final_fundraise . add ( _executed_amount_valuation ) > fundraise_max ) { _executed_amount_valuation = fundraise_max . sub ( final_fundraise ) ; _shares_to_assign = _executed_amount_valuation . div ( _final_share_price ) ; _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; } uint _executed_amount = convert_valuation_to_art ( _executed_amount_valuation , _art_price ) ; _return_amount = transfer_token . sub ( _executed_amount ) ; }",Calculates how many shares are assigned to a bid .
4375,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = ownerAddressToCardCount [ _owner ] ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 total = totalNumberOfCards ( ) ; uint256 resultIndex = 0 ; uint256 cardId ; for ( cardId = 1 ; cardId <= total ; cardId ++ ) { if ( cardIdToOwner [ cardId ] == _owner ) { result [ resultIndex ] = cardId ; resultIndex ++ ; } } return result ; },Returns a list of all Card IDs currently owned by ` _owner `
4377,function getOrganizations ( ) external view returns ( address [ ] accounts ) { return _organizationAccounts ; },Get the accounts of all available organizations .
4378,"function indexOf ( string source , string query , uint256 fromIndex ) internal pure returns ( int256 ) { bytes memory sourceBytes = bytes ( source ) ; bytes memory queryBytes = bytes ( query ) ; if ( queryBytes . length == 0 ) { return 0 ; } if ( sourceBytes . length < queryBytes . length ) { return - 1 ; } for ( uint256 i = fromIndex ; i < sourceBytes . length - queryBytes . length ; i ++ ) { uint256 j = 0 ; while ( j < queryBytes . length && queryBytes [ j ] == sourceBytes [ j + i ] ) { j ++ ; } if ( j == queryBytes . length ) { return int256 ( i ) ; } } return - 1 ; }","Returns the index within source ASCII string of the first occurrence of the query substring , starting at the specified index ."
4379,function getMinInvestment ( ) public pure returns ( uint ) { return 10 finney ; },minimal amount of one investment ( in wei )
4380,function synthetixReceivedForSynths ( uint amount ) public view returns ( uint ) { uint synthsReceived = feePool . amountReceivedFromTransfer ( amount ) ; return synthsReceived . divideDecimal ( usdToSnxPrice ) ; },Calculate how many SNX you will receive if you transfer an amount of synths .
4381,"function assignTokens ( address addr , uint amount ) internal returns ( uint ) { require ( addr != 0x0 ) ; require ( initialTokensAssigned == false ) ; balances [ addr ] = amount ; Transfer ( 0x0 , addr , balances [ addr ] ) ; return balances [ addr ] ; }",It will be automatically called on deploy .
4384,"function calculateGrantClaim ( address _recipient ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint256 elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint256 elapsedYears = elapsedTime . div ( SECONDS_PER_YEAR ) ; if ( elapsedYears >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; uint256 remainingYears = tokenGrant . vestingDuration . sub ( tokenGrant . yearsClaimed ) ; return ( remainingYears , remainingGrant ) ; } else { uint256 i = 0 ; uint256 tokenGrantAmount = tokenGrant . amount ; uint256 totalVested = 0 ; for ( i ; i < elapsedYears ; i ++ ) { totalVested = ( tokenGrantAmount . mul ( 10 ) ) . div ( 100 ) . add ( totalVested ) ; tokenGrantAmount = tokenGrant . amount . sub ( totalVested ) ; } uint256 amountVested = totalVested . sub ( tokenGrant . totalClaimed ) ; return ( elapsedYears , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached"
4385,function challengeWinnerReward ( uint _challengeID ) public view returns ( uint ) { if ( voting . getTotalNumberOfTokensForWinningOption ( _challengeID ) == 0 ) { return 2 * challenges [ _challengeID ] . stake ; } return ( 2 * challenges [ _challengeID ] . stake ) - challenges [ _challengeID ] . rewardPool ; },Determines the number of tokens to awarded to the winning party in a challenge
4386,"function setFreeClaimAllowance ( address addr , uint256 allowance ) external onlyCFO { freeClaimAllowance [ addr ] = allowance ; }",Set the free claim allowance for an address .
4389,"function handlePlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . Whitelisted ) ; return ( plannedContribution , 0 ) ; }",Returns the contribution and refund value to be used when the transaction value equals the whitelisted contribution for the sender .
4390,function balanceOf ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; },Get the token balance of ` owner `
4391,function buySharesFor ( address _recipient ) payable ;,Function to buy Dao shares according to the funding rules
4392,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( msg . sender == owner || now > 1509467422 ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
4393,"function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }",Compute the last period 's fee entitlement for the message sender and then deposit it into their nomin account .
4396,"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) external returns ( bytes4 ) ;",The contract address is always the message sender .
4397,function enableTransfers ( bool _transfersEnabled ) onlyOwner public { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
4400,"function createPool ( address [ ] _admins , uint256 [ ] _configsUint , bool [ ] _configsBool ) public returns ( address _pool ) { address poolOwner = msg . sender ; _pool = new Pool ( poolOwner , _admins , _configsUint , _configsBool , nextPoolId ) ; pools [ nextPoolId ] = _pool ; nextPoolId = nextPoolId . add ( 1 ) ; emit PoolCreated ( nextPoolId , poolOwner ) ; }",Creates a new pool with custom configurations .
4401,"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Count Down not gone yet"" ) ; }",Distirbutes a differen quantity of tokens to all the specified addresses .
4403,"function totalSupplyAt ( uint256 _blockNumber ) public view returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }",Total amount of tokens at a specific ` _blockNumber ` .
4405,"function setController ( address _controller ) public onlyOwner { require ( ! controllerDisabled ) ; emit SetController ( controller , _controller ) ; controller = _controller ; }",Used by the issuer to set the controller addresses
4407,function balanceOf ( address _owner ) public constant returns ( uint256 bal ) { return balances [ _owner ] ; },Get the balance of an _owner address .
4408,"function allowance ( address _owner , address _spender ) public constant returns ( uint256 _amount ) { return allowance [ _owner ] [ _spender ] ; }",Used to look up the allowance of someone
4409,"function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; nextSellingPrice = getNextPrice ( sellingPrice ) ; }",Returns all the relevant information about a specific collectible .
4411,"function trust ( address _to ) public returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( fromId == getHolderId ( _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ALREADY_TRUSTED ) ; } set ( store , holdersTrustStorage , fromId , _to , true ) ; return OK ; }",Trust an address to perform recovery procedure for the caller .
4413,"function createSellOrder ( address token , uint tokensTotal , uint ethersTotal , uint8 [ ] exchanges , address [ 5 ] [ ] orderAddresses , uint [ 6 ] [ ] orderValues , uint [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public { require ( Token ( token ) . transferFrom ( msg . sender , this , tokensTotal ) ) ; uint ethersObtained ; uint tokensSold ; uint tokensRefunded = tokensTotal ; ( ethersObtained , tokensSold ) = fillOrdersForSellRequest ( tokensTotal , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ; require ( ethersObtained > 0 && tokensSold > 0 ) ; require ( SafeMath . safeDiv ( ethersTotal , tokensTotal ) <= SafeMath . safeDiv ( ethersObtained , tokensSold ) ) ; tokensRefunded = SafeMath . safeSub ( tokensTotal , tokensSold ) ; if ( tokensRefunded > 0 ) require ( Token ( token ) . transfer ( msg . sender , tokensRefunded ) ) ; transfer ( msg . sender , ethersObtained ) ; FillSellOrder ( msg . sender , token , tokensTotal , ethersTotal , tokensSold , ethersObtained , tokensRefunded ) ; }","Needs first to call Token ( tokend_address ) .approve ( this , tokens_ ) so the contract can trade the tokens ."
4416,"function getCampaign ( bytes32 _campaignId ) public view returns ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _campOwner ) { CampaignLibrary . Campaign storage campaign = _getCampaign ( _campaignId ) ; return ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }","Get a Campaign information Based on a camapaign Id ( bidId ) , returns all stored information for that campaign ."
4418,"function newChannel ( Data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new NettingChannelContract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != 0 ) { address settled_channel = self . all_channels [ channel_pos - 1 ] ; require ( ! contractExists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - 1 ] = new_channel_address ; caller_channels [ caller_pos - 1 ] = new_channel_address ; partner_channels [ partner_pos - 1 ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels . push ( new_channel_address ) ; self . partyhash_to_channelpos [ party_hash ] = self . all_channels . length ; self . node_index [ msg . sender ] [ partner ] = caller_channels . length ; self . node_index [ partner ] [ msg . sender ] = partner_channels . length ; } return new_channel_address ; }",Create a new payment channel between two parties
4421,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _transferFrom ( _from , _to , _tokenId ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
4422,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
4423,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; },maximum investments to be accepted during the sale ( in euro-cents )
4424,"function pickRandomAssets ( uint _finalSeed , bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] finalPicked ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }",Function to pick random assets from potentialAssets array
4425,function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = GoToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; },Set `` _token_address '' as the token address to be used in the auction .
4427,function enableTransfers ( bool _transfersEnabled ) onlyOwner { token . enableTransfers ( _transfersEnabled ) ; },Enables token holders to transfer their tokens freely if true
4431,function changeExchangeStatus ( bool newExchangeState ) public only_exchange_operator { IS_EXCHANGE_OPERATIONAL = newExchangeState ; },Changes the operational status of the exchange .
4432,function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPausd ( now ) ; },Pause sale just in case we have some troubles Note that time marks are not updated
4433,"function getCanvasByState ( uint8 _state ) external view returns ( uint32 [ ] ) { uint size ; if ( _state == STATE_NOT_FINISHED ) { size = activeCanvasCount ; } else { size = getCanvasCount ( ) - activeCanvasCount ; } uint32 [ ] memory result = new uint32 [ ] ( size ) ; uint currentIndex = 0 ; for ( uint32 i = 0 ; i < canvases . length ; i ++ ) { if ( getCanvasState ( i ) == _state ) { result [ currentIndex ] = i ; currentIndex ++ ; } } return _slice ( result , 0 , currentIndex ) ; }",Returns all canvas ' id for a given state .
4435,function setReadOnly ( bool enabled ) public onlyOwner { readOnly = enabled ; },Allow admins to ( en|dis ) able all write functionality for emergencies
4436,"function register ( address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external payable returns ( uint ) ;","Registration requires the specified amount of ETH in value , to cover invoke bonus ."
4437,"function approve ( address _spender , uint _value ) returns ( bool success ) ;",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
4438,"function claim ( ) public onlyOwner { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( owner , amount ) ; }",Transfers tokens held by timelock to owner .
4440,function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) revert ( ) ; if ( ! owner . send ( this . balance ) ) revert ( ) ; },"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract ."
4442,"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a + b ; require ( c >= a , ""Error: Unsafe addition operation!"" ) ; return c ; }","Adds two numbers , throws on overflow ."
4443,"function getParticipant ( uint256 _index ) public view returns ( address participantAddress , uint256 participantAnswerId ) { Participant storage p = participants [ _index ] ; participantAddress = p . user_address ; participantAnswerId = p . answer_id ; }",Returns all the relevant information about a specific participant .
4444,function totalSupplyAt ( uint256 snapshotId ) public constant returns ( uint256 ) ;,Total amount of tokens at a specific ` snapshotId ` .
4448,"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { if ( investors [ _beneficiary ] == 0 ) { investorCount = investorCount + 1 ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _tokenAmount ) ; _deliverTokens ( _beneficiary , _tokenAmount ) ; }",Executed when a purchase has been validated and is ready to be executed .
4449,"function burn ( uint256 _amount , bytes _data ) public onlyOwner { super . burn ( _amount , _data ) ; }",Burns ` _amount ` tokens from ` msg.sender ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
4451,function isTransferAgent ( address _address ) public constant onlyWhitelisted returns ( bool ) { return transferAgents [ _address ] ; },Checks if the specified address is a transfer agent .
4454,"function setKYCApproval ( Data storage self , address account , bool isApproved , string issuerFirm ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setBool ( id , isApproved ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; emit KYCApproval ( account , isApproved , issuerFirm ) ; return true ; }",Set the KYC approval status ( true/false ) for a given account
4456,"function appendDecryptedBid ( uint _nonce , uint _index , uint _bid_id , address _investor_address , uint _share_price , uint _shares_count , uint _transfered_token ) onlyOwner public { require ( status == state . ended ) ; require ( fundraise_defined ) ; require ( bids [ _index ] . exist == true ) ; require ( bids [ _index ] . is_decrypted == false ) ; require ( bids [ _index ] . is_burned == false ) ; require ( _share_price > 0 ) ; require ( _shares_count > 0 ) ; require ( _transfered_token >= convert_valuation_to_art ( _shares_count . mul ( _share_price ) , bids [ _index ] . art_price ) ) ; if ( bids_sorted_count > 0 ) { BidData memory previous_bid_data = bids_sorted [ bids_sorted_count - 1 ] ; require ( _share_price <= previous_bid_data . share_price ) ; if ( _share_price == previous_bid_data . share_price ) { require ( _index > previous_bid_data . origin_index ) ; } } require ( getBidHash ( _nonce , _bid_id , _investor_address , _share_price , _shares_count ) == bids [ _index ] . bid_hash ) ; uint _transfer_amount = _share_price . mul ( _shares_count ) ; BidData memory bid_data = BidData ( _index , _bid_id , _investor_address , _share_price , _shares_count , _transfer_amount , _transfered_token , 0 , 0 , false ) ; bids [ _index ] . is_decrypted = true ; if ( _share_price >= min_share_price ) { bids [ _index ] . will_compute = true ; bids_sorted [ bids_sorted_count ] = bid_data ; bids_sorted_count ++ ; emit BidDecrypted ( _index , true ) ; } else { bids [ _index ] . will_compute = false ; bids_ignored [ bids_ignored_count ] = bid_data ; bids_ignored_count ++ ; emit BidDecrypted ( _index , false ) ; } bids_decrypted [ bids_decrypted_count ] = _index ; bids_decrypted_count ++ ; if ( bids_decrypted_count == bids_count ) { emit Decrypted ( block . number , bids_decrypted_count . sub ( bids_burned_count ) , bids_burned_count ) ; status = state . decrypted ; } }","Appends the bid 's data to the contract , for use in the final calculations Once all bids are appended , the auction is locked and changes its state to `` decrypted ''"
4457,"function name ( ) public pure returns ( string _deedName ) { _deedName = ""DWorld Plots"" ; }","Name of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata ."
4458,"function approve ( address spender , uint value ) public returns ( bool ) ;",` msg.sender ` approves ` spender ` to spend ` value ` tokens
4461,"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; require ( bids [ msg . sender ] + msg . value <= bid_threshold || whitelist [ msg . sender ] ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missing_funds = missingFundsToEndAuction ( ) ; require ( msg . value <= missing_funds ) ; bids [ msg . sender ] += msg . value ; received_wei += msg . value ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missing_funds ) ; assert ( received_wei >= msg . value ) ; }",Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
4463,"function batchCancelSale ( uint256 [ ] _tokenIds ) external whenNotPaused { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { Sale memory sale = tokenIdToSale [ _tokenIds [ ii ] ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenIds [ ii ] , seller ) ; } }",This is a state-modifying function that can be called while the contract is paused .
4464,"function cost ( address , uint256 , bytes , bytes ) external view returns ( uint256 ) { return 0 ; }","Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free ."
4466,"function addTime ( address who , uint sconds ) public onlyTransferAgent returns ( bool ) { require ( sconds > 0 , ""Time added cannot be zero."" ) ; Holding memory holding = heldTokens [ who ] ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate . add ( sconds ) , holding . isAffiliate ) ; emit ReleaseDateExtended ( who , heldTokens [ who ] . releaseDate ) ; return true ; }",The Transfer Agent may need to add time to the release date if they are unable to verify the holder in a timely manner .
4467,"function pay ( address _user , address _destination , uint256 _value ) public onlyAllowed ;",Transfers coins from a certain user to a destination address Used to release a certain value of coins from a certain user to a destination address .
4468,"function adminChange ( address _newAdmin ) public { require ( msg . sender == admin , ""Only the admin can call this function"" ) ; admin = _newAdmin ; }",Change the admin to ` ( _to ) `
4472,"function isValidVersion ( uint8 [ ] _current , uint8 [ ] _new ) internal pure returns ( bool ) { bool [ ] memory _temp = new bool [ ] ( _current . length ) ; uint8 counter = 0 ; for ( uint8 i = 0 ; i < _current . length ; i ++ ) { if ( _current [ i ] < _new [ i ] ) _temp [ i ] = true ; else _temp [ i ] = false ; } for ( i = 0 ; i < _current . length ; i ++ ) { if ( i == 0 ) { if ( _current [ i ] <= _new [ i ] ) if ( _temp [ 0 ] ) { counter = counter + 3 ; break ; } else counter ++ ; else return false ; } else { if ( _temp [ i - 1 ] ) counter ++ ; else if ( _current [ i ] <= _new [ i ] ) counter ++ ; else return false ; } } if ( counter == _current . length ) return true ; }",This function is used to validate the version submitted
4475,function getValidator ( uint256 index ) external view returns ( address ) ;,Get the account of the validator at index ` index ` .
4476,function invoke ( ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
4477,"function callPluginsPledge ( bool before , uint64 idPledge , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { uint64 offset = idPledge == fromPledge ? 0 : 256 ; allowedAmount = amount ; Pledge storage p = findPledge ( idPledge ) ; allowedAmount = callPlugin ( before , p . owner , fromPledge , toPledge , offset , allowedAmount ) ; for ( uint64 i = 0 ; i < p . delegationChain . length ; i ++ ) { allowedAmount = callPlugin ( before , p . delegationChain [ i ] , fromPledge , toPledge , offset + i + 1 , allowedAmount ) ; } if ( p . intendedProject > 0 ) { allowedAmount = callPlugin ( before , p . intendedProject , fromPledge , toPledge , offset + 255 , allowedAmount ) ; } }",` callPluginsPledge ` is used to apply plugin calls to the delegate chain and the intended project if there is one .
4478,function GiftsOfOwner ( address _owner ) public view returns ( uint256 [ ] ownerGifts ) { uint256 GiftCount = balanceOf ( _owner ) ; if ( GiftCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( GiftCount ) ; uint256 total = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 GiftId ; for ( GiftId = 0 ; GiftId <= total ; GiftId ++ ) { if ( GiftIndexToOwners [ GiftId ] == _owner ) { result [ resultIndex ] = GiftId ; resultIndex ++ ; } } return result ; } },This method MUST NEVER be called by smart contract code .
4481,"function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }",This is a private function which should be called from user-implemented external burn function .
4482,"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; require ( mana . transferFrom ( msg . sender , this , requiredDeposit ) , ""Error pulling MANA"" ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }",Request a loan and attachs a mortgage request
4483,"function setApprovalForAll ( address _operator , bool _approved ) public returns ( bool ) { operators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; return true ; }",Enable or disable approval for a third party ( `` operator '' ) to manage
4484,"function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; sireAllowedToAddress [ _sireId ] = _addr ; }",Grants approval to another user to sire with one of your dogs .
4486,"function lockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = getTime ( ) + lockPeriod ; Lock ( msg . sender , userLock [ msg . sender ] ) ; }","After a period of time , the claimed user can withdraw funds directly from contract without admins involved ."
4487,"function pricesAreStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }",Check if the prices have n't been updated for longer than the stale period .
4488,function requestMilestonePayment ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; authorizePayment ( _idMilestone ) ; },` onlyRecipientOrLeadLink ` Sends the milestone payment as specified in ` payData ` ; the recipient can only call this after the ` reviewTime ` has elapsed
4490,function withdraw ( ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { return proxyWithdraw ( msg . sender ) ; },Withdraw ETH for ` msg.sender ` after the auction has canceled .
4491,"function exchangeEtherForSynthetixAtRate ( uint guaranteedEtherRate , uint guaranteedSynthetixRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice , ""Guaranteed ether rate would not be received"" ) ; require ( guaranteedSynthetixRate == usdToSnxPrice , ""Guaranteed synthetix rate would not be received"" ) ; return exchangeEtherForSynthetix ( ) ; }",Exchange ETH to SNX while insisting on a particular set of rates .
4495,"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , false ) ) ; emit RevokedOperator ( _operator , msg . sender ) ; }",Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens at remote database .
4496,function setICOEndDate ( uint256 _date ) public whenNotPaused onlyWhitelisted { require ( icoEndDate == 0 ) ; icoEndDate = _date ; },This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
4497,"function receiveICOcoins ( uint256 amountOfCoinsToReceive , uint ShrID ) public returns ( bool success ) { msgSndr [ msg . sender ] = amountOfCoinsToReceive ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; icosuccess = ico . recvShrICO ( msg . sender , amountOfCoinsToReceive , ShrID ) ; require ( icosuccess == true ) ; bool sucsTrTk ; sucsTrTk = _safeTransferTkn ( owner , msg . sender , amountOfCoinsToReceive ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }",the share Id will be provided by contract while payments are made through other channels like paypal
4498,function isFinalized ( bytes32 question_id ) view public returns ( bool ) { },Report whether the answer to the specified question is finalized
4499,"function releaseLockedToken ( ) external { require ( getState ( ) == State . Success ) ; require ( balanceOf [ lockedTokenHolder ] > 0x0 ) ; require ( block . number >= unlockedAtBlockNumber ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , balanceOf [ lockedTokenHolder ] ) ; emit Transfer ( lockedTokenHolder , devsHolder , balanceOf [ lockedTokenHolder ] ) ; balanceOf [ lockedTokenHolder ] = 0 ; }",send lockedTokens to devs address require State == Success require tokens unlocked
4502,"function _transfer ( address from , address to , uint quantity ) internal returns ( bool ) { require ( to != address ( 0 ) , ""Transfers to 0x0 disallowed."" ) ; balanceOf [ from ] = safeSub ( balanceOf [ from ] , quantity ) ; balanceOf [ to ] += quantity ; emit Transfer ( from , to , quantity ) ; return true ; }",Transfers ` quantity ` tokens from ` from ` to ` to ` .
4504,"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorizedOperators [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
4505,"function transfer ( address target , uint256 amount ) ifAuthorised { if ( amount == 0 || shareholders [ msg . sender ] . shares < amount ) throw ; shareholders [ msg . sender ] . shares -= amount ; if ( shareholders [ target ] . shares > 0 ) { shareholders [ target ] . shares += amount ; } else { shareholders [ target ] . shares = amount ; shareholders [ target ] . limited = true ; } Transfer ( msg . sender , target , amount ) ; }",This transfers ` amount ` shares to ` target.address ( ) ` .
4506,"function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , ""Does not change value"" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }",Function to set allowBeneficialInvestments ( allow beneficiary to be different to funder )
4507,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approved ( _to , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( _from , _to , _tokenId ) ; }",Third-party initiates transfer of token from address _from to address _to
4508,"function depositToken ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( tokenAddress2Id [ token ] != 0 ) ; addUser ( msg . sender ) ; require ( ERC20 ( token ) . transferFrom ( msg . sender , this , amount ) ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . add ( amount ) ; Deposit ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }",Be sure to Approve the contract to move your erc20 token
4509,"function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit LogModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }",adds or removes addresses from the whitelist .
4510,"function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }","The first four parameters relate to Token orders , the last eight relate to DEX orders"
4511,function setWithdrawAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { withdrawAnnounceDelay = _delay ; },"Sets the delay ( in seconds ) between when a withdrawal intention must be announced , and when the withdrawal can actually be executed on-chain ."
4512,"function burn ( uint256 _value ) public returns ( bool success ) { uint256 balanceOfSender = erc20Store . balances ( msg . sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( msg . sender , balanceOfSender - _value ) ; erc20Store . setTotalSupply ( erc20Store . totalSupply ( ) - _value ) ; erc20Proxy . emitTransfer ( msg . sender , address ( 0 ) , _value ) ; return true ; }",Burns the specified value from the sender 's balance .
4513,"function quoteAsk ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }",Calculates the ask price in wei per aToken based on the current reserve amount
4515,"function setOfferPrice ( uint256 price ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( price >= sellFloor && ( sellCeiling == 0 || price <= sellCeiling ) , ""Updated price is out of range."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; require ( order . price != 0 || order . expiry != 0 , ""There is no existing order to modify."" ) ; order . price = price ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }",Modify the price of an existing ask .
4516,function abortFunding ( ) ;,Function to allow the creator to abort the funding before the closing time
4517,function orderBlockNumber ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . blockNumber ; },returns the block number when the order being last modified .
4518,"function createChannelId ( address initiator , address beneficiary , uint amount , uint commission , uint createdAt , uint expiresAt , bytes32 hashedSecret ) public pure returns ( bytes32 channelId ) { channelId = keccak256 ( abi . encodePacked ( initiator , beneficiary , amount , commission , createdAt , expiresAt , hashedSecret ) ) ; }",Hashes the channel specific values to create a unique identifier .
4519,"function setCampaignEndDateById ( bytes32 bidId , uint newEndDate ) public onlyIfCampaignExists ( ""setCampaignEndDateById"" , bidId ) onlyIfWhitelisted ( ""setCampaignEndDateById"" , msg . sender ) { campaigns [ bidId ] . setEndDate ( newEndDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new end date for a campaign Based of the Campaign id , updates the end date of a campaign ."
4520,function getCollateralMarketsLength ( ) public view returns ( uint ) { return collateralMarkets . length ; },return the number of elements in ` collateralMarkets `
4522,"function checkHolesAndDistributePurchaseFunds ( Geometry . Rect [ ] memory subPlots , uint256 [ ] memory areaIndices ) private returns ( uint256 ) { uint256 remainingBalance = msg . value ; uint256 owedToSeller = 0 ; for ( uint256 areaIndicesIndex = 0 ; areaIndicesIndex < areaIndices . length ; areaIndicesIndex ++ ) { uint256 ownershipIndex = areaIndices [ areaIndicesIndex ] ; Geometry . Rect memory currentOwnershipRect = Geometry . Rect ( ownership [ ownershipIndex ] . x , ownership [ ownershipIndex ] . y , ownership [ ownershipIndex ] . w , ownership [ ownershipIndex ] . h ) ; require ( Geometry . rectContainedInside ( subPlots [ areaIndicesIndex ] , currentOwnershipRect ) ) ; for ( uint256 holeIndex = 0 ; holeIndex < holes [ ownershipIndex ] . length ; holeIndex ++ ) { PlotOwnership memory holePlot = ownership [ holes [ ownershipIndex ] [ holeIndex ] ] ; Geometry . Rect memory holeRect = Geometry . Rect ( holePlot . x , holePlot . y , holePlot . w , holePlot . h ) ; require ( ! Geometry . doRectanglesOverlap ( subPlots [ areaIndicesIndex ] , holeRect ) ) ; } uint256 sectionPrice = getPriceOfPlot ( subPlots [ areaIndicesIndex ] , ownershipIndex ) ; remainingBalance = SafeMath . sub ( remainingBalance , sectionPrice ) ; owedToSeller = SafeMath . add ( owedToSeller , sectionPrice ) ; if ( areaIndicesIndex == areaIndices . length - 1 || ownershipIndex != areaIndices [ areaIndicesIndex + 1 ] ) { address ( ownership [ ownershipIndex ] . owner ) . transfer ( owedToSeller ) ; emit PlotSectionSold ( ownershipIndex , owedToSeller , msg . sender , ownership [ ownershipIndex ] . owner ) ; owedToSeller = 0 ; } } return remainingBalance ; }",Checks that the sub-plots which we are purchasing are all valid and then distributes funds to the owners of those sub-plots
4523,function calculatePoolAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; return rawPoolAmount . sub ( houseCutAmount ) ; },Returns the total of the pool ( minus the house part )
4527,"function claimTokensByUser ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , temp ) ) ; emit LogContributorsPayout ( msg . sender , temp ) ; }",Funtion to let users claim their tokens at the end of ico process
4528,"function closeChannel ( uint256 channel_identifier , address partner , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes signature ) isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( msg . sender , partner ) ) ; address recovered_partner_address ; Channel storage channel = channels [ channel_identifier ] ; channel . state = ChannelState . Closed ; channel . participants [ msg . sender ] . is_the_closer = true ; channel . settle_block_number += uint256 ( block . number ) ; if ( nonce > 0 ) { recovered_partner_address = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , signature ) ; require ( partner == recovered_partner_address ) ; updateBalanceProofData ( channel , recovered_partner_address , nonce , balance_hash ) ; } emit ChannelClosed ( channel_identifier , msg . sender , nonce ) ; }",Close the channel defined by the two participant addresses .
4529,"function withdrawRewards ( address _user , uint256 _value ) public onlyOwnerOrAllowed { require ( rewardedBalance [ _user ] >= _value ) ; rewardedBalance [ _user ] -= _value ; appc . transfer ( _user , _value ) ; }",Withdraws user 's rewards Function to transfer a certain user 's rewards to his address
4532,"function getTeam ( uint256 _tokenId ) public view returns ( string teamName , uint256 sellingPrice , address owner ) { Team storage team = teams [ _tokenId ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _tokenId ] ; owner = teamIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific team .
4536,"function _withdrawEquity ( address asset , uint amount ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK ) ; } uint cash = getCash ( asset ) ; ( Error err0 , uint equity ) = addThenSub ( cash , markets [ asset ] . totalBorrows , markets [ asset ] . totalSupply ) ; if ( err0 != Error . NO_ERROR ) { return fail ( err0 , FailureInfo . EQUITY_WITHDRAWAL_CALCULATE_EQUITY ) ; } if ( amount > equity ) { return fail ( Error . EQUITY_INSUFFICIENT_BALANCE , FailureInfo . EQUITY_WITHDRAWAL_AMOUNT_VALIDATION ) ; } Error err2 = doTransferOut ( asset , admin , amount ) ; if ( err2 != Error . NO_ERROR ) { return fail ( err2 , FailureInfo . EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED ) ; } emit EquityWithdrawn ( asset , equity , amount , admin ) ; return uint ( Error . NO_ERROR ) ; }","withdraws ` amount ` of ` asset ` from equity for asset , as long as ` amount ` < = equity ."
4537,function getTokensForValue ( uint256 value ) public view returns ( uint256 ) { return value . mul ( rate ) ; },How many tokens one will receive for specified value of Ether
4540,"function computeBids ( uint _count ) public onlyOwner { require ( status == state . decrypted ) ; require ( _count > 0 ) ; uint count = _count ; if ( bids_sorted_count == 0 ) { status = state . failure ; emit Failure ( 0 , 0 ) ; return ; } require ( bids_computed_cursor < bids_sorted_count ) ; BidData memory bid ; do { bid = bids_sorted [ bids_computed_cursor ] ; if ( bid . share_price . mul ( computed_shares_sold ) . add ( bid . share_price ) > fundraise_max ) { if ( bids_computed_cursor > 0 ) { bids_computed_cursor -- ; } bid = bids_sorted [ bids_computed_cursor ] ; break ; } computed_shares_sold = computed_shares_sold . add ( bid . shares_count ) ; computed_fundraise = bid . share_price . mul ( computed_shares_sold ) ; emit Computed ( bid . origin_index , bid . share_price , bid . shares_count ) ; bids_computed_cursor ++ ; count -- ; } while ( count > 0 && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ) ; if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ) { final_share_price = bid . share_price ; if ( computed_shares_sold >= max_shares_to_sell ) { computed_shares_sold = max_shares_to_sell ; computed_fundraise = final_share_price . mul ( computed_shares_sold ) ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( computed_fundraise . add ( final_share_price . mul ( 1 ) ) >= fundraise_max ) { computed_fundraise = fundraise_max ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( bids_computed_cursor == bids_sorted_count ) { if ( computed_shares_sold >= min_shares_to_sell ) { winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } else { status = state . failure ; emit Failure ( computed_fundraise , final_share_price ) ; return ; } } } }",Performs the computation of auction winners and losers .
4541,function changeController ( address _newController ) public onlyOwner { fcc . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The owner of this contract can change the controller of the FCC token Please , be sure that the owner is a trusted agent or 0x0 address ."
4543,"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transferFrom ( lib . getTokenSymbol ( address ( this ) ) , from , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; return true ; }",spender transfers from approvers account to the reciving account
4545,"function confirmImplChange ( bytes32 _lockId ) public onlyCustodian { erc20Impl = getImplChangeReq ( _lockId ) ; delete implChangeReqs [ _lockId ] ; emit ImplChangeConfirmed ( _lockId , address ( erc20Impl ) ) ; }",Confirms a pending change of the active implementation associated with this contract .
4547,function getCurrencySymbol ( ) external view returns ( bytes32 ) ;,Returns symbol of oracle currency ( 0x0 for ETH )
4549,function closingAddress ( ) constant returns ( address ) { return data . closing_address ; },Returns the address of the closing participant .
4553,"function mint ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }",Allows user to mint if they have the appropriate permissions .
4557,function currentClaimPriceInFinney ( ) constant returns ( uint priceInFinney ) { uint valueWei = currentClaimPriceWei ( ) ; return roundMoneyUpToWholeFinney ( valueWei ) ; },"How much you must pay to claim the throne now , in finney ."
4558,"function approve ( address _to , uint _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( msg . sender != _to ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific Rabbit via transfeFrom ( ) .
4560,function totalListings ( ) public view returns ( uint256 ) { return forSalePixelconIndexes . length ; },Get the current total number of market listings
4562,"function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many addresses excluded"" ) ; require ( _expiry > _maturity , ""Expiry is before maturity"" ) ; require ( _expiry > now , ""Expiry is in the past"" ) ; require ( msg . value > 0 , ""No dividend sent"" ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , ""duped exclude address"" ) ; excludedSupply = excludedSupply . add ( ISecurityToken ( securityToken ) . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex , _name ) ; }","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses"
4567,"function registerModule ( address _moduleFactory ) external whenNotPausedOrOwner { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ) { require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , ""msg.sender must be the Module Factory owner or registry curator"" ) ; } else { require ( msg . sender == owner ( ) , ""Only owner allowed to register modules"" ) ; } require ( getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) == 0 , ""Module factory should not be pre-registered"" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint256 i ; uint256 j ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; for ( i = 1 ; i < moduleTypes . length ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { require ( moduleTypes [ i ] != moduleTypes [ j ] , ""Type mismatch"" ) ; } } require ( moduleTypes . length != 0 , ""Factory must have type"" ) ; uint8 moduleType = moduleFactory . getTypes ( ) [ 0 ] ; set ( Encoder . getKey ( ""registry"" , _moduleFactory ) , uint256 ( moduleType ) ) ; set ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) , uint256 ( getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) ) . length ) ) ; pushArray ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) , _moduleFactory ) ; emit ModuleRegistered ( _moduleFactory , IOwnable ( _moduleFactory ) . owner ( ) ) ; }",Called by the ModuleFactory owner to register new modules for SecurityTokens to use
4568,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
4569,"function getWhale ( uint256 _tokenId ) public view returns ( uint256 Id , string whaleName , uint256 sellingPrice , address owner ) { Whale storage whale = whales [ _tokenId ] ; Id = _tokenId ; whaleName = whale . name ; sellingPrice = whaleIndexToPrice [ _tokenId ] ; owner = whaleIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific whale .
4570,"function authorize ( string _contractName , address _accessor ) external view returns ( bool ) ;",Check whether the accessor is authorized to access that contract
4571,"function contribute ( uint _bountyId , uint _value ) payable public validateBountyArrayIndex ( _bountyId ) isBeforeDeadline ( _bountyId ) isNotDead ( _bountyId ) amountIsNotZero ( _value ) transferredAmountEqualsValue ( _bountyId , _value ) { bounties [ _bountyId ] . balance += _value ; ContributionAdded ( _bountyId , msg . sender , _value ) ; }",Please note you funds will be at the mercy of the issuer and can be drained at any moment .
4573,"function getRabbit ( uint _tokenId ) external view returns ( uint32 outStar , uint32 outExplosive , uint32 outEndurance , uint32 outNimble , uint64 outGenes , uint64 outBirthTime ) { RabbitData storage rbt = rabbits [ _tokenId ] ; outStar = rbt . star ; outExplosive = rbt . explosive ; outEndurance = rbt . endurance ; outNimble = rbt . nimble ; outGenes = rbt . genes ; outBirthTime = rbt . birthTime ; }",Returns all the relevant information about a specific rabbit .
4574,function finalizeSale ( ) public onlyOwner { require ( crowdsaleClosed == false ) ; crowdsaleClosed = true ; uint totalSold = tokensSoldOnPublicRound + preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 + privateSalesTokensSold ; bountyAmount = totalSold / 980 * 15 ; yearlyTeamAmount = totalSold / 980 * 5 / 3 ; },Finalize sales and sets bounty & yearly paid value .
4575,"function updateERC165Cache ( address _contract , bytes4 _interfaceId ) public { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }",Updates the cache with whether the contract implements an ERC165 interface or not .
4576,"function addChunk2ToWhiteList ( ) external onlyOwner { require ( ! chunk2IsAdded ) ; addToWhitelist ( 0x6A35d29D8F63E4D8A8E5418Be9342A48c4C8eF07 , 0.5 ether ) ; addToWhitelist ( 0x6b2a80FB3C8Eca5144E6F129a447b9D06224a402 , 0.5 ether ) ; addToWhitelist ( 0x6b8ebca41389689e8875af541a2fa4328ac49917 , 0.5 ether ) ; addToWhitelist ( 0x6c3Db34C768Ab1E67E2a7E973B7a83651657660b , 0.5 ether ) ; addToWhitelist ( 0x7018564dCe2c68417DFa7678541DfA0040Ca0c54 , 0.5 ether ) ; addToWhitelist ( 0x708faa43f5824d271466c119148728467f66e233 , 0.5 ether ) ; addToWhitelist ( 0x71526410C961727a89155D6a32Bb75f9a9d755F5 , 0.5 ether ) ; addToWhitelist ( 0x746B426D0B8e272Ef7402db7CE0FD01C2B1c4aDE , 0.5 ether ) ; addToWhitelist ( 0x762C73603f5456c4ad729b3B46464269bcD7C212 , 0.5 ether ) ; addToWhitelist ( 0x7a0D19955bBf6cff0D86F6e72355A8AFf3c0d74F , 0.5 ether ) ; addToWhitelist ( 0x7Cf017bDe8af2DfC67cb3f1b16943A0620eA1B54 , 0.5 ether ) ; addToWhitelist ( 0x807bAf9e22F4e1E7A5Fcf4B5721ba54666d71421 , 0.5 ether ) ; addToWhitelist ( 0x810f1C65f9C7c566E14a1E8ECA7b36b78C6da3A8 , 0.5 ether ) ; addToWhitelist ( 0x871a314d75BdF106420B9e08314e776d2746E0Eb , 0.5 ether ) ; addToWhitelist ( 0x88Cf04474CFD3b9Bc4110FfC2980Bc56feBF0465 , 0.5 ether ) ; addToWhitelist ( 0x8914316B6505b39e706a208A8E91ab8F79eFA7Cf , 0.5 ether ) ; addToWhitelist ( 0x8b104344F397aFC33Ee55C743a0FbD7d956201cD , 0.5 ether ) ; addToWhitelist ( 0x8Bd5306d0c08Eaa2D9AabaED62297A8AB42db1de , 0.5 ether ) ; addToWhitelist ( 0x8Be1843532E5eE0142420fe627a097a0E0681e97 , 0.5 ether ) ; addToWhitelist ( 0x8c269040283c4112198bc59120ad2bcd70e6b387 , 0.5 ether ) ; addToWhitelist ( 0x8E14437E18B1091B369c6ff6ecCa73D648aCA3bd , 0.5 ether ) ; addToWhitelist ( 0x8Fc9040b8B9305458716e90F83D9b656a07ae7e6 , 0.5 ether ) ; addToWhitelist ( 0x906d9e4D0E028FE85625d06268A437Bb58753301 , 0.5 ether ) ; addToWhitelist ( 0x91Fe65df20b13CA260990e096d4EBDbD64f7b399 , 0.5 ether ) ; addToWhitelist ( 0x92cBbf4A87953975c39EaA2bF70deDEbC356358b , 0.5 ether ) ; addToWhitelist ( 0x95D4914d4f08732A169367674A8BE026c02c5B44 , 0.5 ether ) ; addToWhitelist ( 0x985116bBCcEE828d439c4F6F9233016bf1e95669 , 0.5 ether ) ; addToWhitelist ( 0x9976cF5617F5E4022CdC887A7A0a68E8eE5dBA22 , 0.5 ether ) ; addToWhitelist ( 0x9A7379c8aF6765aa267d338A20D197DD1544bF9b , 0.5 ether ) ; addToWhitelist ( 0x9DEFB6A85680E11b6aD8AD4095e51464bB4C0C66 , 0.5 ether ) ; addToWhitelist ( 0xA02896e448A35DeD03C48c2986A545779ed87edd , 0.5 ether ) ; addToWhitelist ( 0xa460A24F606d4ABba5041B162E06D42aD6f09157 , 0.5 ether ) ; addToWhitelist ( 0xaB91cF12f8e133C7B1C849d87997dca895cE0BCB , 0.5 ether ) ; addToWhitelist ( 0xac935E0dD7F90851E0c6EE641cd30B800e35f7A8 , 0.5 ether ) ; addToWhitelist ( 0xae41F73635b6F5F9556Cd3B0d3970aDA5Fb0C1b5 , 0.5 ether ) ; addToWhitelist ( 0xB16fE19652ceDf4Ba2568b4886CeE29D4e0617B0 , 0.5 ether ) ; addToWhitelist ( 0xB2F19E5457404dCaCd2d6344592e5a657DFcA27b , 0.5 ether ) ; addToWhitelist ( 0xB33cc3147d70Ce2aF31B2B90411BD6333EeA0EA7 , 0.5 ether ) ; addToWhitelist ( 0xb49a6DD81a847f3A704D0C11C6e1a7C65C47d215 , 0.5 ether ) ; addToWhitelist ( 0xb75312cdfBee6B6104a7161E27dbd48bb253E186 , 0.5 ether ) ; addToWhitelist ( 0xB87e73ad25086C43a16fE5f9589Ff265F8A3A9Eb , 0.5 ether ) ; addToWhitelist ( 0xc12549d486e20835960Fb3A44ba67fD353B1C48a , 0.5 ether ) ; addToWhitelist ( 0xc4Eab1eAaCbf628F0f9Aee4B7375bDE18dd173C4 , 0.5 ether ) ; addToWhitelist ( 0xc8B15B3189b8C6e90ff330CBA190153fF0A9997e , 0.5 ether ) ; addToWhitelist ( 0xCb033bE278d7bD297a2b1Cc6201113480daC579F , 0.5 ether ) ; addToWhitelist ( 0xCb570fE877CA6B7dE030afaf9483f58F774df135 , 0.5 ether ) ; addToWhitelist ( 0xcD4929fdDC83Aca93cD4a75bD12780DaDF51870b , 0.5 ether ) ; addToWhitelist ( 0xcdc22860Ff346ead18ECA5E30f0d302a95F33A19 , 0.5 ether ) ; addToWhitelist ( 0xD26BA3C03fBC1EA352b5F77B2c1F2881d03D1e2F , 0.5 ether ) ; addToWhitelist ( 0xd454ED303748Bb5a433388F9508433ba5d507030 , 0.5 ether ) ; addToWhitelist ( 0xd4d1197fed5F9f3679497Df3604147087B85Ce39 , 0.5 ether ) ; addToWhitelist ( 0xd83F072142C802A6fA3921d6512B25a7c1A216b1 , 0.5 ether ) ; chunk2IsAdded = true ; }",Add chunk 2 / 7 to the whitelist
4577,"function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; Approval ( msg . sender , _who , _value ) ; return true ; }",Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .
4578,"function setStreamerContract ( address _contractAddress , uint256 _maxAmount ) onlyAdministrator { require ( _maxAmount == 0 || streamerContractMaxAmount == 0 ) ; streamerContract = _contractAddress ; streamerContractMaxAmount = _maxAmount ; StreamerContractChanged ( streamerContract , streamerContractMaxAmount ) ; }",authorize an address to transfer GIM on behalf an user
4580,"function _removeModuleWithIndex ( uint8 _type , uint256 _index ) internal { uint256 length = modules [ _type ] . length ; modules [ _type ] [ _index ] = modules [ _type ] [ length - 1 ] ; modules [ _type ] . length = length - 1 ; if ( ( length - 1 ) != _index ) { uint8 [ ] memory newTypes = modulesToData [ modules [ _type ] [ _index ] ] . moduleTypes ; for ( uint256 i = 0 ; i < newTypes . length ; i ++ ) { if ( newTypes [ i ] == _type ) { modulesToData [ modules [ _type ] [ _index ] ] . moduleIndexes [ i ] = _index ; } } } }",Internal - Removes a module attached to the SecurityToken by index
4581,function setBeneficiary ( address newBeneficiary ) external only ( owner ) { beneficiary = newBeneficiary ; },set beneficiary - the account receiving platform fees .
4582,"function ( ) payable { require ( ! saleHasEnded ) ; require ( now > PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; require ( msg . value <= MAXIMUM_PARTICIPATION_AMOUNT ) ; if ( isWhitelistingActive ) { require ( earlyParticipantWhitelist [ msg . sender ] ) ; } require ( safeIncrement ( totalFunding , msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the presale has been funded to the maximum amount
4583,"function onApprove ( address , address , uint ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }",Notifies the controller about an approval allowing the controller to react if desired
4585,"function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }",Set 's the rate of tokens per ether for each tier .
4586,"function placeAds ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , string imageSource , string link , string text ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint AdsId = ads . advertiseOnBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) , imageSource , link , text ) ; emit LogAds ( AdsId , fromX , fromY , toX , toY , imageSource , link , text , msg . sender ) ; }","places ads ( image , caption and link to a website ) into desired coordinates"
4587,"function transfer ( address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { return _transfer ( msg . sender , to , quantity ) ; }",ERC20 transfer function ; transfers ` quantity ` tokens from the message sender to ` to ` .
4589,"function calcSharePrice ( ) view returns ( uint sharePrice ) { ( , , , , , sharePrice ) = performCalculations ( ) ; return sharePrice ; }",Calculates sharePrice denominated in [ base unit of melonAsset ]
4592,"function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external ;",Function use to change the lower and upper bound of the compatible version st
4593,function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner_ ) ; owner_ = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .
4594,"function getVestingQuantity ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ QUANTITY_INDEX ] ; }",Get the quantity of SNX associated with a given schedule entry .
4596,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public { require ( approve ( _spender , _value ) ) ; IApprovalRecipient ( _spender ) . receiveApproval ( msg . sender , _value , _extraData ) ; }",Approves spending tokens and immediately triggers token recipient logic .
4597,function getCanvasPaintedPixelsCount ( uint32 _canvasId ) public view returns ( uint32 ) { return _getCanvas ( _canvasId ) . paintedPixelsCount ; },Returns how many pixels has been already set .
4599,function withdrawBalance ( ) external onlyCFO { cfoAddress . transfer ( this . balance ) ; },Allow the CFO to withdraw balance available to this contract .
4600,"function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) { return calculateAttributeApprovalHash ( account , operator , attributeTypeID , value , fundsRequired , validatorFee ) ; }",Get the hash of a given attribute approval .
4601,function setTokenFeeMin ( uint256 min ) public onlyOwner { tokenFeeMin = min ; },Set the minimum number of tokens to be deducted during a buy .
4604,"function revokeAttribute ( address account , uint256 attributeTypeID ) external ;",Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
4605,"function isState ( uint256 _tokenId , uint8 _state ) public view returns ( bool ) { return assets [ _tokenId ] . state == _state ; }",Check if asset is in the state passed by parameter
4607,function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return tokenBalanceOf [ _owner ] ; },What is the balance of a particular account ?
4609,"function addBeneficiary ( address beneficiary , uint256 startTime , uint256 releaseTime , uint256 amount ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( ! info . known , ""This address is already known to the contract."" ) ; require ( releaseTime > startTime , ""Release time must be later than the start time."" ) ; require ( releaseTime > block . timestamp , ""End of vesting period must be somewhere in the future."" ) ; info . startTime = startTime ; info . totalAmount = amount ; info . releaseTime = releaseTime ; info . known = true ; }","Add beneficiaries to the contract , allowing them to withdraw tokens ."
4610,"function finalize ( ) minCapReached salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( gmtFund ) ; assignedSupply = assignedSupply . add ( gmtFund ) ; ClaimGMT ( gmtFundAddress , gmtFund ) ; Transfer ( 0x0 , gmtFundAddress , gmtFund ) ; if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimGMT ( gmtFundAddress , unassignedSupply ) ; Transfer ( 0x0 , gmtFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }",Sends the ETH to ETH fund wallet and finalizes the token sale
4611,"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _tokenId < totalSupply ( ) ) ; uint256 uid ; bytes32 bid ; uid = _tokenId ; if ( uid == 0 ) { bid = '0' ; } else { while ( uid > 0 ) { bid = bytes32 ( uint ( bid ) / ( 2 ** 8 ) ) ; bid |= bytes32 ( ( ( uid % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; uid /= 10 ; } } return string ( abi . encodePacked ( baseUri , bid ) ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
4614,"function withdrawNomins ( uint amount ) external onlyOwner { nomin . transfer ( owner , amount ) ; }",Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .
4615,"function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . atomOwner ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] ) ; tokenApprovals [ _tokenId ] = _approved ; Approval ( CaDataContract . atomOwner ( _tokenId ) , _approved , _tokenId ) ; }",Set or reaffirm the approved address for an NFT
4616,"function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) ;",Find the validator that issued the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` and determine if the validator is still valid .
4617,"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var obgValue = balances [ msg . sender ] ; if ( obgValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= obgValue ; var ethValue = obgValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }",Get back the ether sent during the funding in case the funding has not reached the minimum level .
4618,"function acceptInvite ( bytes _sig ) public onlyNonUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = false ; createAccountForUser ( msg . sender ) ; emit InviteAccepted ( msg . sender , inviteAddress ) ; }",Accept an invite using the signing model described in the contract description
4621,"function getTokenDetails ( address token ) public view returns ( address ad , uint required , bool active , uint valid ) { return ( acceptedTokens [ token ] . tokenAddress , acceptedTokens [ token ] . requiredAmount , acceptedTokens [ token ] . active , acceptedTokens [ token ] . validUntil ) ; }",Returns a full list of the token details
4622,function getSencBalance ( ) public view returns ( uint256 ) { return sencToken ( ) . balanceOf ( address ( this ) ) ; },The ` getSencBalance ( ) ` retrieve the SENC balance of the contract in Wei .
4623,function balanceOf ( address _person ) public constant returns ( uint256 _balance ) { return balances [ _person ] ; },Used to look up balance of a person
4625,"function drop ( address tokenContractAddress , address [ ] recipients , uint256 [ ] amounts ) public ownerOnly { require ( tokenContractAddress != 0x0 ) ; require ( recipients . length == amounts . length ) ; require ( recipients . length <= 300 ) ; ERC20 tokenContract = ERC20 ( tokenContractAddress ) ; for ( uint8 i = 0 ; i < recipients . length ; i ++ ) { tokenContract . transfer ( recipients [ i ] , amounts [ i ] ) ; } }",More than 300 accounts will exceed gas block limit .
4627,"function splitBid ( uint _amount ) public pure returns ( uint commission , uint paintersRewards ) { uint _rewardPerPixel = ( ( _amount - _calculatePercent ( _amount , COMMISSION ) ) ) / PIXEL_COUNT ; uint _rewards = _rewardPerPixel * PIXEL_COUNT ; return ( _amount - _rewards , _rewards ) ; }",Calculates how the initial bidding money will be split .
4629,function deleteInt ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete intStorage [ _key ] ; return true ; },Delete value for Int associated with bytes32 id key
4630,"function list_bytesarray_from ( bytes32 _current_item , uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_first , _function_previous ) ; } }","Lists a Bytes collection from some ` _current_item ` , going forwards or backwards depending on ` _from_start `"
4632,function unpause ( ) external onlyCEO whenPaused { paused = false ; },This is public rather than external so it can be called by derived contracts .
4635,function getCheckpointTimes ( ) external view returns ( uint256 [ ] ) { return checkpointTimes ; },Gets list of times that checkpoints were created
4637,function finalizeCrowdsale ( ) public onlyOwner { rate = 0 ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) owner . transfer ( this . balance ) ; },"Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner"
4639,"function depositTokens ( bytes32 manufacturerId , uint256 amount ) public returns ( bool ) { require ( manufacturerId != 0 , ""manufacturerId is required"" ) ; require ( amount > 0 , ""amount is required"" ) ; address manufacturer = manufacturerRewards [ manufacturerId ] ; require ( manufacturer != address ( 0 ) ) ; _depositTokens ( manufacturer , amount ) ; emit TokensDeposited ( msg . sender , manufacturerId , manufacturer , amount ) ; require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; return true ; }",anyone can donate tokens to a manufacturer 's pool
4640,"function claimTokens ( address _token ) public auth { if ( _token == 0x0 ) { address ( msg . sender ) . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( address ( msg . sender ) , balance ) ; emit ClaimedTokens ( _token , address ( msg . sender ) , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
4641,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) revert ( ) ; } return super . approve ( _spender , _amount ) ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
4644,"function calculateFee ( uint256 tokens , uint256 ethers ) public view returns ( uint256 tokenFee , uint256 etherFee ) { tokenFee = multiplyAtPrecision ( tokens , tokenFeePercent / 100 , 9 ) ; if ( tokenFee < tokenFeeMin ) tokenFee = tokenFeeMin ; etherFee = multiplyAtPrecision ( ethers , etherFeePercent / 100 , 9 ) ; if ( etherFee < etherFeeMin ) etherFee = etherFeeMin ; return ( tokenFee , etherFee ) ; }",Calculate the company 's fee for facilitating the transfer of tokens .
4645,"function icoBuy ( ) public icoPhase ( ) payable { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balances [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; }",Please make sure that ICO Pool is at least equal to your bid
4646,function darknodeBond ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . bond ; },Returns the bond of a given darknode .
4648,"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }",Checks if the makeOrder price is within maximum allowed deviation from reference price
4650,"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }",Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is still valid .
4651,"function userForceGameEnd ( uint _gameId ) public { address userAddress = msg . sender ; uint gameId = userGameId [ userAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId , ""inv gameId"" ) ; require ( game . status == GameStatus . USER_INITIATED_END , ""inv status"" ) ; int newBalance = conflictRes . userForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , userAddress , ReasonEnded . USER_FORCED_END , newBalance ) ; }",Force end of game if server does not respond .
4652,"function metaBurnCarbonDollar ( address _stablecoin , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public whenNotPaused returns ( bool ) { bytes32 metaHash = metaBurnHash ( _stablecoin , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , ""signer is blacklisted"" ) ; require ( _nonce == replayNonce [ signer ] , ""this transaction has already been broadcast"" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , ""reward to incentivize relayer must be positive"" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , ""not enough balance to burn and reward relayer"" ) ; _burnCarbonDollar ( signer , _stablecoin , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }",Verify and broadcast a burnCarbonDollar ( ) signed metatransaction .
4653,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
4655,function setUpgradeMaster ( address master ) external { if ( getState ( ) != State . Success ) throw ; if ( master == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeMaster = master ; },Set address of upgrade target contract and enable upgrade process .
4657,"function getInterfaceImplementer ( address _addr , bytes32 _interfaceHash ) external view returns ( address ) { address addr = _addr == 0 ? msg . sender : _addr ; if ( isERC165Interface ( _interfaceHash ) ) { bytes4 erc165InterfaceHash = bytes4 ( _interfaceHash ) ; return implementsERC165Interface ( addr , erc165InterfaceHash ) ? addr : 0 ; } return interfaces [ addr ] [ _interfaceHash ] ; }",Query if an address implements an interface and through which contract .
4660,"function ( ) public payable { _getAsset ( ) . __process . value ( msg . value ) ( msg . data , msg . sender ) ; }","Resolves asset implementation contract for the caller and forwards there transaction data , along with the value ."
4661,"function transfer ( address _to , uint _amount ) internal { if ( address ( baseToken ) != 0 ) { require ( baseToken . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }","Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself"
4662,function onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; },Internal function used to check whether the investor is in the whitelist or not & also checks whether the KYC of investor get expired or not
4663,function createTemplate ( string content ) public returns ( uint256 ) { },"Create a reusable template , which should be a JSON document ."
4664,"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
4666,"function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferWithReference ( _to , _value , smbl , _reference , _sender ) == OK ; }",Performs transfer call on the platform by the name of specified sender .
4667,"function initialize ( address _msp , address _mspController , uint256 _totalSupplyCap , uint256 _exchangeRate , uint256 _minimum_goal , uint256 _startBlock , uint256 _endBlock , address _destEthDevs , address _destTokensSit , address _destTokensTeam , address _destTokensReferals , address _sit ) public onlyController { assert ( address ( msp ) == 0x0 ) ; msp = MiniMeTokenI ( _msp ) ; assert ( msp . totalSupply ( ) == 0 ) ; assert ( msp . controller ( ) == address ( this ) ) ; assert ( msp . decimals ( ) == 18 ) ; require ( _mspController != 0x0 ) ; mspController = _mspController ; require ( _exchangeRate > 0 ) ; exchangeRate = _exchangeRate ; assert ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensSit != 0x0 ) ; destTokensSit = _destTokensSit ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensReferals != 0x0 ) ; destTokensReferals = _destTokensReferals ; require ( _sit != 0x0 ) ; sit = MiniMeTokenI ( _sit ) ; initializedBlock = getBlockNumber ( ) ; assert ( sit . totalSupplyAt ( initializedBlock ) * 5 <= _totalSupplyCap ) ; totalSupplyCap = _totalSupplyCap ; totalSaleSupplyCap = percent ( 70 ) . mul ( _totalSupplyCap ) . div ( percent ( 100 ) ) ; minimum_goal = _minimum_goal ; }",This method should be called by the controller before the contribution period starts This initializes most of the parameters
4668,"function mint ( address _investor , uint256 _amount ) public returns ( bool success ) ;",mints new tokens and assigns them to the target _investor .
4669,"function transferLand ( uint256 estateId , uint256 landId , address destinatary ) external canTransfer ( estateId ) { return _transferLand ( estateId , landId , destinatary ) ; }",Transfer a LAND owned by an Estate to a new owner
4671,function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) ;,Get a description of the attribute type with ID ` attributeTypeID ` .
4675,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom due to insufficent Allowance provided"" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return permissionManager ; }",Used to launch the Module with the help of factory
4676,"function leaveTokenGroup ( uint256 _tokenId ) external whenNotPaused { address userAdd = msg . sender ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; require ( _addressNotNull ( userAdd ) ) ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; require ( group . addressToContributorArrIndex [ userAdd ] > 0 ) ; require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] > 0 ) ; uint refundBalance = _clearContributorRecordInGroup ( _tokenId , userAdd ) ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; userAddressToContributor [ userAdd ] . withdrawableBalance += refundBalance ; FundsDeposited ( userAdd , refundBalance ) ; LeaveGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , refundBalance ) ; }","Allow user to leave purchase group ; note that their contribution will be added to their withdrawable balance , and not directly refunded ."
4677,"function mintToken ( uint256 _mintedAmount ) public onlyOwner { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] + _mintedAmount >= _balanceOf [ _owner ] ) ; require ( _totalSupply + _mintedAmount >= _totalSupply ) ; _balanceOf [ _owner ] += _mintedAmount ; _totalSupply += _mintedAmount ; Mint ( _owner , _mintedAmount ) ; Transfer ( 0 , _owner , _mintedAmount ) ; }","Create ` mintedAmount ` tokens and send it to ` owner ` , can be run only by owner"
4678,function addToAccesslist ( address user ) onlyOwner { accessHolder [ user ] = true ; },Adds the provided addresses to Access List .
4679,function finalizeAuction ( ) public isOwner atStage ( Stages . AuctionStarted ) { uint missingFunds = missingFundsToEndAuction ( ) ; require ( missingFunds == 0 || now > endTimeOfBids ) ; finalPrice = tokenMultiplier * receivedWei / tokensAuctioned ; finalizedTime = now ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; },Finalize the auction - sets the final XBET token price and changes the auction stage after no bids are allowed anymore .
4681,function setTimelock ( uint _newTimeLock ) onlyContractOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; },` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
4686,"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 2 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 20 ) ) ; canExtract = total . percent ( 20 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 4 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 4 ) ) && getTime ( ) <= finalizedTime . add ( months ( 5 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 5 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }",The owner will call this method to extract the tokens
4688,function unpause ( ) public onlyOwner whenPaused { require ( address ( pvpListener ) != address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
4690,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
4692,"function getNamesInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( bytes8 [ ] ) { require ( _startIndex <= totalSupply ( ) , ""Start index is out of bounds"" ) ; require ( _endIndex <= totalSupply ( ) , ""End index is out of bounds"" ) ; require ( _startIndex <= _endIndex , ""End index is less than the start index"" ) ; uint64 length = _endIndex - _startIndex ; bytes8 [ ] memory names = new bytes8 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { names [ i ] = pixelconNames [ _startIndex + i ] ; } return names ; }",Get the names of all PixelCons from index ` ( _startIndex ) ` to ` ( _endIndex ) `
4693,"function receiveEther ( ) payable { require ( address ( baseToken ) == 0 ) ; EtherReceived ( msg . sender , msg . value ) ; }",Called anytime ether is sent to the contract & & creates an event to more easily track the incoming transactions
4695,"function ( ) public payable { if ( now < PRIVATESALE_START_DATE ) revert ( ) ; if ( now > PRIVATESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount
4696,"function paymentRewardTokens ( uint256 _rewardTokenAmount ) public validAmount ( _rewardTokenAmount ) senderHasEnoughTokens ( 0 , _rewardTokenAmount ) isWhitelisted ( msg . sender ) whenNotPaused { rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . sub ( _rewardTokenAmount ) ; rewardBalances [ owner ] = rewardBalances [ owner ] . add ( _rewardTokenAmount ) ; emit TransferReward ( msg . sender , owner , _rewardTokenAmount ) ; }",Process a payment using only reward TRVL Tokens .
4697,function totalSupply ( ) public view returns ( uint256 ) { return assets . length ; },Returns the total number of Assets currently in existence .
4698,"function getHashRateOfCurrentHalving ( address _miner ) public constant returns ( bool , uint256 ) { return getHashRateOf ( _miner , currentHalving ( ) ) ; }",Calculate the halving hash rate of a miner
4700,"function initialize ( address _pfc , address _pfcController , uint256 _startTime , uint256 _endTime , address _destEthFoundation , uint256 _maxEth ) public onlyOwner { require ( address ( PFC ) == 0x0 ) ; PFC = MiniMeTokenSimple ( _pfc ) ; require ( PFC . totalSupply ( ) == 0 ) ; require ( PFC . controller ( ) == address ( this ) ) ; require ( PFC . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _pfcController != 0x0 ) ; pfcController = _pfcController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _maxEth > 1 ether ) ; MaxEth = _maxEth ; }",This method should be called by the owner before the contribution period starts This initializes most of the parameters
4701,function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( icoPrice != priceForIcoInWei ) ; icoPrice = priceForIcoInWei ; updatePrices ( ) ; },Set current ICO price in wei for one token
4702,"function setBountyWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != bountyAddress ) ; address oldAddress = bountyAddress ; bountyAddress = _walletAddress ; emit BountyWalletAddressChanged ( oldAddress , _walletAddress ) ; }",Change the address to where the bounty will be send when sale starts
4703,"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 availableGetAmount ; ( availableGetAmount , , , ) = oasis . getOffer ( data . offerId ) ; return availableGetAmount > data . maxAmountToSpend ? data . maxAmountToSpend : availableGetAmount ; }",Gets the amount that Totle needs to give for this order
4706,"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor [ msg . sender ] [ _from ] ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }",Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
4707,function getLastBidId ( ) external returns ( bytes32 _lastBidId ) { return lastBidId ; },Returns the greatest BidId ever registered to the contract
4710,function createCheckpoint ( ) public returns ( uint256 ) ;,Creates a checkpoint that can be used to query historical balances / totalSuppy
4711,"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }",Helper function that checks for ERC777TokensSender on the sender and calls it .
4713,function setFeeAuthority ( address _feeAuthority ) external optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; },Set the address of the user/contract responsible for collecting or distributing fees .
4714,function setRequiredParticipation ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_PARTICIPATION <= fraction ) ; requiredParticipation = fraction ; },Set the required fraction of all Havvens that need to be part of a vote for it to pass .
4716,"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;",Checks if the takeOrder price is reasonable and not manipulative
4720,"function userEndGameConflict ( uint32 _roundId , uint8 _gameType , uint _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _userHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _userSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _userHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; userEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _userHash , _userSeed , _gameId , msg . sender ) ; }",Can be used by user if server does not answer to the end game session request .
4721,"function moveAllTokens ( address _to , bytes16 _uuid ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveAllTokensToAddress ( _uuid , _to ) ; }",Function for transfering all tokens from account to specified address .
4722,"function isDefaulted ( Engine engine , uint256 index ) public view returns ( bool ) { return engine . getStatus ( index ) == Engine . Status . lent && engine . getDueTime ( index ) . add ( 7 days ) <= block . timestamp ; }",Defines a custom logic that determines if a loan is defaulted or not .
4725,"function withdraw ( ) public { uint acc = 0 ; uint i = nextDepositToPayout [ msg . sender ] ; require ( i < deposits . length ) ; ERC20 currentToken = deposits [ i ] . token ; require ( msg . gas > 149000 ) ; while ( ( i < deposits . length ) && ( msg . gas > 148000 ) ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( msg . sender , i ) ) ) { if ( currentToken != d . token ) { nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; currentToken = d . token ; acc = 0 ; } acc += d . amount * rewardToken . balanceOfAt ( msg . sender , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } i ++ ; } nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; }","Sends all the tokens and ether to the token holder by looping through all the deposits , determining the appropriate amount by dividing the ` totalSupply ` by the number of tokens the token holder had at ` deposit.block ` for each deposit ; this function may have to be called multiple times if their are many deposits"
4726,"function finalizeSale ( ) public onlyController { require ( now > endTime || totalIssued >= HARD_CAP ) ; require ( ! finalized ) ; vestedAllowances [ vaultAddress ] = Vesting ( lockedTokens , now + 3 years ) ; uint256 leftoverTokens = MAX_TOKENS . sub ( lockedTokens ) . sub ( totalIssued ) . sub ( totalIssuedEarlySale ) . sub ( totalVested ) ; require ( tokenContract . generateTokens ( vaultAddress , leftoverTokens ) ) ; require ( tokenContract . generateTokens ( address ( this ) , lockedTokens . add ( totalVested ) ) ) ; finalized = true ; }",` finalizeSale ( ) ` ends the TokenSale .
4727,"function giftOwnerByIndex ( address _owner , uint256 _index ) external constant returns ( uint256 GiftId ) { uint256 [ ] memory ownerGifts = GiftsOfOwner ( _owner ) ; return ownerGifts [ _index ] ; }",This method MUST NEVER be called by smart contract code .
4728,"function maxIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint destinationValue = effectiveValue ( ""SNX"" , collateral ( issuer ) , currencyKey ) ; return destinationValue . multiplyDecimal ( synthetixState . issuanceRatio ( ) ) ; }","The maximum synths an issuer can issue against their total synthetix quantity , priced in XDRs ."
4729,"function getImage ( uint _finalSeed , bytes32 [ ] _potentialAssets , uint _width , uint _height ) public pure returns ( uint [ ] finalPicked , uint [ ] x , uint [ ] y , uint [ ] zoom , uint [ ] rotation , uint [ ] layers ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; x = new uint [ ] ( assetIds . length ) ; y = new uint [ ] ( assetIds . length ) ; zoom = new uint [ ] ( assetIds . length ) ; rotation = new uint [ ] ( assetIds . length ) ; layers = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; ( x [ index ] , y [ index ] , zoom [ index ] , rotation [ index ] , layers [ index ] ) = pickRandomAssetPosition ( finalSeedCopy , _width , _height ) ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }",Function to pick random assets from potentialAssets array
4734,"function checkRequestSignature ( bytes requestData , address [ ] payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }",Checks the validity of a signed request & the expiration date .
4736,function ratesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory _rates = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { _rates [ i ] = rates [ currencyKeys [ i ] ] ; } return _rates ; },Retrieve the rates for a list of currencies
4737,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
4743,"function bid ( uint256 _wave , uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . ownerOf ( _tokenId ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool existInWave = false ; for ( uint256 i = 0 ; i < waveToTokens [ _wave ] . length ; i ++ ) { if ( waveToTokens [ _wave ] [ i ] == _tokenId ) { existInWave = true ; break ; } } require ( existInWave ) ; address oldBuyer = tokenToBuyer [ _tokenId ] ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > sellingPrice ) ; sellingPrice = msg . value ; uint256 newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , bonus [ _wave ] ) , percBase ) ; uint256 lastPrice = tokenToLastPrice [ _tokenId ] ; tokenToLastPrice [ _tokenId ] = sellingPrice ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; tokenToBuyer [ _tokenId ] = msg . sender ; if ( oldBuyer != address ( 0 ) ) { oldBuyer . transfer ( lastPrice ) ; } Bid ( _tokenId , sellingPrice , newPrice , oldBuyer , msg . sender ) ; }",Allows someone buy obtain an Pre sale token
4745,function switchToNextSale ( address _nextSale ) external validAddress ( _nextSale ) onlySale ( msg . sender ) { m_sales [ msg . sender ] = false ; m_sales [ _nextSale ] = true ; },"Same as setSale , but must be called from the current active sale and does n't need multisigning ( it 's done in the finishSale call anyway )"
4746,"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { if ( isRegistered ( _owner ) ) { return true ; } else { return false ; } }","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed"
4747,function setSellFloor ( uint256 floor ) public onlyOwner { sellFloor = floor ; },Set the lowest price an ask can be listed .
4748,"function totalFeesAvailable ( bytes4 currencyKey ) external view returns ( uint ) { uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( recentFeePeriods [ i ] . feesToDistribute ) ; totalFees = totalFees . sub ( recentFeePeriods [ i ] . feesClaimed ) ; } return synthetix . effectiveValue ( ""XDR"" , totalFees , currencyKey ) ; }","The total fees available in the system to be withdrawn , priced in currencyKey currency"
4749,"function contributions ( uint256 _contributionID ) public constant returns ( address _sender , uint256 _value , uint256 _time ) { }","if it supports it , return the contribution by ID"
4750,"function _safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) internal { _transferFrom ( _from , _to , _tokenId ) ; require ( _checkOnERC721Received ( _from , _to , _tokenId , _data ) ) ; }",Transfers the ownership of an NFT from one address to another address
4751,function beneficiary ( ) public constant returns ( address ) { },use to determine the beneficiary destination for the campaign
4752,"function unfreeze ( address _addr , uint256 _value ) public { require ( owner == msg . sender ) ; require ( freezeOf [ _addr ] >= _value ) ; require ( _value > 0 ) ; freezeOf [ _addr ] = SafeMath . sub ( freezeOf [ _addr ] , _value ) ; balanceOf [ _addr ] = SafeMath . add ( balanceOf [ _addr ] , _value ) ; emit Unfreeze ( _addr , _value ) ; }",unfreeze ` _value ` token of '_addr ' address
4756,"function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external onlyOwner { uint256 fee = getUint ( STLAUNCHFEE ) ; require ( fee != _stLaunchFee , ""Fee not changed"" ) ; emit ChangeSecurityLaunchFee ( fee , _stLaunchFee ) ; set ( STLAUNCHFEE , _stLaunchFee ) ; }",Sets the ticker registration fee in POLY tokens .
4760,"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights"
4761,function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply / totalSupply ; buyPrice = initialBuyPrice * initialSupply / totalSupply ; },update the price based on the remaining count of resources
4762,"function mCancelPayment ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; cancelPayment ( idPledge , amount ) ; } }",` mCancelPayment ` allows for multiple pledges to be canceled efficiently
4763,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
4765,function getAffiliate ( address _investor ) constant returns ( address ) { return affiliates [ _investor ] . etherAddress ; },Fetches the Ethereum address of a valid affiliate
4767,"function _batchTransfer ( address sender , address [ ] recipients , uint [ ] quantities ) internal requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transfer ( sender , recipients [ i ] , quantities [ i ] ) ; } return true ; }","Performs ERC20 transfers in batches ; for each ` i ` , transfers ` quantity [ i ] ` tokens from the message sender to ` to [ i ] ` ."
4768,"function updateProjectDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyContractor { passProject . updateDescription ( _projectDescription , _hashOfTheDocument ) ; }",Function to allow the project manager updating the description of the project
4769,"function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , msg . sender , _to , _amount , _userData , """" , true ) ; }",Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
4770,"function unlockGrant ( ) external { Grant storage grant = grants [ msg . sender ] ; require ( grant . value != 0 ) ; require ( ! grant . transferred ) ; require ( now >= grant . end ) ; grant . transferred = true ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( msg . sender , grant . value ) ; emit UnlockGrant ( msg . sender , grant . value ) ; }","Unlock the vested tokens , transferring them to their holder"
4772,function balanceOf ( address _owner ) external view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; },Returns the number of Cuties owned by a specific address .
4774,function pause ( uint _pauseClosingTime ) { pauseClosingTime = _pauseClosingTime ; },Function To allow the creator to pause during the presale
4775,function capReached ( ) public view returns ( bool ) { return totalTokensSold >= cap ; },Checks whether the cap has been reached .
4776,"function extractVaultTokens ( address _token , address _claimer ) public onlyOwner afterSale { require ( _claimer != address ( 0 ) ) ; require ( goalReached ( ) || _token != address ( 0 ) ) ; vault . extractTokens ( _token , _claimer ) ; }",Get back accidentally sent token from the vault
4777,function numberOfDAppNodePackages ( ) view public returns ( uint ) { return DAppNodePackages . length ; },its goal is to return the total number of DAppNode packages
4780,"function recoverPreSignedHash ( address _token , bytes4 _functionSig , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( _token , _functionSig , _spender , _value , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by recoverPreSignedHash
4781,"function transferCheck ( address _sender , address _receiver , uint256 _amount ) internal view returns ( bool valid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] >= _amount ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }",Low level function used to do a sanity check of transfer parameters
4782,function setArbitrator ( address _newArbitrator ) onlyOwner external { arbitrator = _newArbitrator ; },Set the arbitrator to a new address .
4786,"function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }",Permits to create an approval on a contract and then call a method on the approved contract right away .
4787,"function getTokenData ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }",Get all details of PixelCon ` ( _tokenId ) `
4788,"function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }","withdraw accumulated balance , called by payee in case crowdsale failed"
4790,"function approve ( address spender , uint256 value ) public returns ( bool ) { require ( 0 == value || 0 == allowance ( msg . sender , spender ) ) ; return super . approve ( spender , value ) ; }",Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .
4792,"function reset ( ) public onlyOwnerOrAllowed { for ( uint i = 0 ; i < users . length ; i ++ ) { withdraw ( users [ i ] , balanceUsers [ users [ i ] ] ) ; } }",Resets this contract and returns every amount deposited to each user registered This function is used in case a contract reset is needed or the contract needs to be deactivated .
4794,"function setApp ( bytes32 _namespace , bytes32 _appId , address _app ) public auth ( APP_MANAGER_ROLE , arr ( _namespace , _appId ) ) { _setApp ( _namespace , _appId , _app ) ; }",Set the resolving address of ` _appId ` in namespace ` _namespace ` to ` _app `
4796,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
4797,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; },maximum investments to be accepted during the sale ( in euro-cents )
4798,"function getDeedByAddress ( string propertyAddress , uint256 i ) public constant returns ( string ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] [ i ] ; }",Gets the deed by property address and chronological index
4799,"function addChunk6ToWhiteList ( ) external onlyOwner { require ( ! chunk6IsAdded ) ; addToWhitelist ( 0xC9403834046d64AAc2F98BA9CD29A84D48DBF58D , 3 ether ) ; addToWhitelist ( 0xd0f9899ec83BF1cf915bf101D6E7949361151523 , 3 ether ) ; addToWhitelist ( 0xeB386a17ED99148dc98F07D0714751786836F68e , 3 ether ) ; addToWhitelist ( 0xeFc85EbccE16Db424fCEfBfA4a523fC9957C0E63 , 3 ether ) ; addToWhitelist ( 0xfa52B6F191F57284762617Cfdbbf187E10C02D93 , 3 ether ) ; addToWhitelist ( 0xfd0928783dd997D982AeeE5399f9B6816FbF789B , 3 ether ) ; addToWhitelist ( 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD , 3 ether ) ; addToWhitelist ( 0xe9Cc01e48F027a0BFa97aFDa0229F09EDD9a590b , 3.7 ether ) ; addToWhitelist ( 0x4f7c845e4d09c3453bcfe03dd09cc96b5c6941a3 , 4 ether ) ; addToWhitelist ( 0x0d41F957181E584dB82d2E316837B2DE1738C477 , 5 ether ) ; addToWhitelist ( 0x102A65de4c20BCe35Aa9B6ae2eA2ecf60c91831B , 5 ether ) ; addToWhitelist ( 0x1Cff36DeBD53EEB3264fD75497356132C4067632 , 5 ether ) ; addToWhitelist ( 0x21a39c71cb9544336e24d57df3655f30be99cf3b , 5 ether ) ; addToWhitelist ( 0x221CDC565782c03fe4ca913f1392741b67d48a81 , 5 ether ) ; addToWhitelist ( 0x280cbA9bB3bd5E222B75fd9D5ff0D3Ec43F0D087 , 5 ether ) ; addToWhitelist ( 0x2Fc0F28ee6C0172bD7D4DDbf791Fd520B29b10a1 , 5 ether ) ; addToWhitelist ( 0x3243d70ed16410F55f22684a8768e7492E91108b , 5 ether ) ; addToWhitelist ( 0x44b38befe7a68fdbd50963feaa06566980a92f7e , 5 ether ) ; addToWhitelist ( 0x4AA75e261b28884718c49DA3f671b3C32a467faD , 5 ether ) ; addToWhitelist ( 0x522e98867715dA9e1fD87A7e759081cCE8ae61d6 , 5 ether ) ; addToWhitelist ( 0x54e0766871b94d02f148b21a15d7ae4679f19c39 , 5 ether ) ; addToWhitelist ( 0x61cf029E58713260aCDAd6e46a54BA687A465064 , 5 ether ) ; addToWhitelist ( 0x6A4234773DC2c3cb4d2951aAa50107E9454451C1 , 5 ether ) ; addToWhitelist ( 0x6beb418fc6e1958204ac8baddcf109b8e9694966 , 5 ether ) ; addToWhitelist ( 0x90c0E8849266AE128aA355B46D090802DCfB1a25 , 5 ether ) ; addToWhitelist ( 0x9b2c4a09ee37105d7ee139b83ca281ab20f6ca78 , 5 ether ) ; addToWhitelist ( 0x9E4a9f2b4eFd85972cF952d2f5Fb16C291ED43B3 , 5 ether ) ; addToWhitelist ( 0xafa2a0cd8ed977c2515b266c3bcc6fe1096c573d , 5 ether ) ; addToWhitelist ( 0xC1A065a2d29995692735c82d228B63Df1732030E , 5 ether ) ; addToWhitelist ( 0xD069A2c75999B87671a29c61B25848ee288a9d75 , 5 ether ) ; addToWhitelist ( 0xd10f3f908611eca959f43667975f9e917435a449 , 5 ether ) ; addToWhitelist ( 0xd4e470fad0d7195699cA9B713fD7C5196cb61Fec , 5 ether ) ; addToWhitelist ( 0xC32e75369bFcef12195741954687e211B3Bc807A , 6 ether ) ; addToWhitelist ( 0xe6fabdca7cb022434a61839268a7d9c10baf5eb2 , 6 ether ) ; addToWhitelist ( 0xe26b11577372aa5e9c10407fe8f7cce6cb88aba0 , 7 ether ) ; addToWhitelist ( 0x0edc326b97F071C1a5393Ba5344bb762DEE0C53a , 10 ether ) ; addToWhitelist ( 0x2A3F7E5170Ea8Ca967f85f091eF84591f639E031 , 10 ether ) ; addToWhitelist ( 0x32f3474D1eB6aA38A85a7bb4fB85715A216A2640 , 10 ether ) ; addToWhitelist ( 0x49CEF0ce48ab89E6C8bB50a184FbEb19b44Ade63 , 10 ether ) ; addToWhitelist ( 0x67D8dFF88562D156a2306CE5f2eFCA0b452aAdD2 , 10 ether ) ; addToWhitelist ( 0x969f18769a75847d39e91ad0dbdfd80820293b0d , 10 ether ) ; addToWhitelist ( 0x976D1CF16b5b2567503246d7D980F86234cB1fAd , 10 ether ) ; addToWhitelist ( 0xA02f61FE8DeB678b53a4eA1BE0353f4F78D16a5a , 10 ether ) ; addToWhitelist ( 0xd573C0f13aC91d30bC0A08F1c256063e3a6928eF , 10 ether ) ; addToWhitelist ( 0xe5FbbDfd081aaD4913eB25e4b195Ba15C2d64de5 , 10 ether ) ; addToWhitelist ( 0xf159FdAfA300d4b7E417CFE06d55F09d93b60E53 , 10 ether ) ; addToWhitelist ( 0xf831dB774BfC4e2c74b9b42474a0e0DD60B342b1 , 10 ether ) ; addToWhitelist ( 0x8A7aA336E1909641558B906585fc56DeE2B44Dd0 , 15 ether ) ; addToWhitelist ( 0x48ce7eBe80d771a7023E1dC3eB632a4E6Cb0559b , 20 ether ) ; addToWhitelist ( 0x6818025bd0e89506D3D34B0C45cC1E556d2Dbc5B , 20 ether ) ; addToWhitelist ( 0x9BE1c7a1F118F61740f01e96d292c0bae90360aB , 20 ether ) ; addToWhitelist ( 0xa1B0dDDEFFf18651206ae2d68A14f024760eAa75 , 20 ether ) ; chunk6IsAdded = true ; }",Add chunk 6 / 7 to the whitelist
4801,"function appendDelegate ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( p . delegationChain . length < MAX_DELEGATES ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length + 1 ) ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } newDelegationChain [ p . delegationChain . length ] = idReceiver ; uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }",` appendDelegate ` allows for a delegate to be added onto the end of the delegate chain for a given Pledge .
4803,"function cancelSale ( uint256 _tokenId ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
4804,function claimThrone ( string _monarchName ) { externalEnter ( ) ; claimThroneRP ( _monarchName ) ; externalLeave ( ) ; },Claim throne in the given ` _monarchName ` .
4805,"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( balancesDB . move ( _from , _to , _amount ) ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }",Helper function actually performing the sending of tokens using a backend database .
4806,"function doSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter <= 1 || _escrow . sellerCanCancelAfter > block . timestamp ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doSellerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledBySeller ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }",Returns the ether in escrow to the seller .
4815,function validateProposedKingdomName ( string _kingdomName ) constant returns ( bool allowed ) { return validateNameInternal ( _kingdomName ) ; },Check if a name can be used as a kingdom name .
4816,"function withdraw ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Withdraw ( currency , account , amount , issuerFirm ) ; return true ; }",Withdraw an amount of currency from the Ethereum account holder
4817,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
4819,"function _resolveAquarium ( uint256 _seed ) internal { bytes32 tempHash = keccak256 ( _seed ) ; FishingAttempt storage tempAttempt = pendingFishing [ tempHash ] ; require ( tempAttempt . fisher != address ( 0 ) ) ; if ( tempAttempt . affiliate != address ( 0 ) && ! affiliated [ tempAttempt . fisher ] ) { chests . mintChest ( tempAttempt . affiliate , 1 , 0 , 0 , 0 , 0 ) ; affiliated [ tempAttempt . fisher ] = true ; } uint32 [ 4 ] memory fishParams = utils . getFishParams ( _seed , tempAttempt . seed , fishes . length , block . coinbase ) ; _mintFish ( tempAttempt . fisher , fishParams [ 3 ] , uint8 ( fishParams [ 0 ] ) , uint8 ( fishParams [ 1 ] ) , uint8 ( fishParams [ 2 ] ) , bytes16 ( keccak256 ( _seed ^ tempAttempt . seed ) ) ) ; beneficiary . transfer ( tempAttempt . feePaid ) ; AquariumResolved ( tempHash , tempAttempt . fisher ) ; delete pendingFishing [ tempHash ] ; }",Call this to resolve hashes and generate fish/chests
4820,"function lockup ( address wallet , uint256 duration ) public onlyOwner { uint256 lockupExpiration = duration . add ( now ) ; lockupExpirations [ wallet ] = lockupExpiration ; emit LockupApplied ( wallet , lockupExpiration ) ; }",Prevents the given wallet to transfer its token for the given duration .
4822,"function check ( ) external view returns ( uint256 , uint256 , uint256 , uint256 ) { return ( _info [ msg . sender ] . totalAmount , _info [ msg . sender ] . receivedAmount , _info [ msg . sender ] . startTime , _info [ msg . sender ] . releaseTime ) ; }",Simple function to return vesting information for a caller .
4823,"function operatorBatchSend ( address _from , address [ ] _recipients , uint256 [ ] _amounts , bytes _userData , bytes _operatorData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) whenAccountNotFrozen ( _from ) { require ( _recipients . length == _amounts . length , ""The lengths of _recipients and _amounts should be the same."" ) ; require ( isOperatorFor ( msg . sender , _from ) ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , _from , _recipients [ i ] , _amounts [ i ] , _userData , _operatorData , true ) ; } }",Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .
4824,function symbol ( ) external view returns ( string _symbol ) { return nftSymbol ; },An abbreviated name for NFTs in this contract
4825,function _productExists ( uint256 _productId ) internal view returns ( bool ) { return products [ _productId ] . id != 0 ; },_productExists checks to see if a product exists
4826,"function addBeneficiary ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( _duration >= _cliff ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenVesting = new TokenVesting ( _beneficiary , _start , _cliff , _duration , false ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenVesting ) ; distributionContracts [ tokenVesting ] = true ; token . safeTransfer ( tokenVesting , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenVesting , _amount ) ; return tokenVesting ; }",Assigns a token release point to a beneficiary .
4827,function sellAllDolAtOnce ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } },"Allow user to sell all amount of metadollars at once , depend on ether amount on contract"
4828,function closeSale ( ) public onlyController { require ( campaignState == 2 ) ; campaignState = 1 ; CampaignClosed ( now ) ; },Puts the camapign into closed state only controller can do so only possible from the active state we can call this function if we want to stop sale before end time and be able to perform 'finalizeCampaign ( ) ' immediately
4829,function getRegistry ( ) external view returns ( address ) { return address ( _registry ) ; },Get the account of the utilized attribute registry .
4830,"function createRewardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }",Helps in redeeming the Rewards using our Oracle .
4831,function setMinETH ( uint wad ) public auth { minETH = wad ; },set the minimal ETH for trades ( depends on otc )
4833,"function claimTokens ( ERC20TokenInterface _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }",Function to claim any token stuck on contract
4836,"function getPerson ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }",Returns all the relevant information about a specific person .
4838,"function setModule ( address _acct , bool _set ) external onlyOwner returns ( bool ) { modules [ _acct ] = _set ; emit ModuleSet ( _acct , _set ) ; return true ; }",Set/Unset ` _acct ` as an authorized module
4839,function tokenMetadataHash ( uint256 index ) public view returns ( bytes32 ) { return keccak256 ( loans [ index ] . metadata ) ; },"Returns the loan metadata , hashed with keccak256 ."
4841,function isAttributeType ( uint256 attributeTypeID ) public view returns ( bool ) { return _attributeTypes [ attributeTypeID ] . exists ; },Determine if an attribute type with ID ` attributeTypeID ` is currently defined on the jurisdiction .
4842,function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = playerIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given Player .
4843,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; return doTransfer ( msg . sender , _to , _value ) ; }",send _value amount of tokens to _to address from msg.sender address
4845,function buyShares ( ) payable ;,Function to buy Dao shares according to the funding rules with ` msg.sender ` as the beneficiary
4847,"function transferToContract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ContractReceiver receiver = ContractReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }",Function that is called when transaction target is contract
4851,"function proposeOwnership ( address _newOwnerCandidate ) external onlyOwner { newOwnerCandidate = _newOwnerCandidate ; emit OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }",` onlyOwner ` Proposes to transfer control of the contract to a new owner
4852,"function burn ( uint256 _amount ) public requiresPermission whenNotPaused { _burn ( msg . sender , _amount ) ; }",Allows user to mint if they have the appropriate permissions .
4854,function numberOfPledges ( ) constant returns ( uint ) { return pledges . length - 1 ; },A constant getter that returns the total number of pledges
4855,"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
4859,function approveMotion ( uint motionID ) external onlyOwner { require ( motionConfirming ( motionID ) && motionPasses ( motionID ) ) ; address target = motionTarget [ motionID ] ; nomin . freezeAndConfiscate ( target ) ; _closeMotion ( motionID ) ; emit MotionApproved ( motionID ) ; },The foundation may only confiscate a balance during the confirmation period after a motion has passed .
4863,function setEnforceKyc ( bool enforce ) public onlyOwner { enforceKyc = enforce ; },Restrict trading to only those who are whitelisted .
4864,"function multisend ( address [ ] _recipients , uint256 [ ] _balances ) public { require ( _recipients . length == _balances . length , ""not equal length"" ) ; require ( _recipients . length <= multiSendLimit , ""more than limit"" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }",Function to send multiple token transfers in one tx
4865,"function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; emit Approval ( msg . sender , _who , _value ) ; return true ; }",Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .
4866,"function setCaps ( uint256 _goal , uint256 _softCap , uint256 _softCapTime , uint256 _cap ) public onlyOwner beforeSale { require ( 0 < _goal && _goal <= _softCap && _softCap <= _cap ) ; goal = _goal ; softCap = _softCap ; softCapTime = _softCapTime ; cap = _cap ; }","Sets minimum goal , soft cap and max cap"
4867,"function createRequestAsPayerAction ( address [ ] _payeesIdAddress , int256 [ ] _expectedAmounts , address _payerRefundAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , string _data ) public payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender != _payeesIdAddress [ 0 ] && _payeesIdAddress [ 0 ] != 0 , ""caller should not be the main payee"" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( msg . sender , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , ""fees should be the correct amout"" ) ; if ( _payerRefundAddress != 0 ) { payerRefundAddress [ requestId ] = _payerRefundAddress ; } int256 totalExpectedAmounts = 0 ; for ( uint8 i = 0 ; i < _expectedAmounts . length ; i = i . add ( 1 ) ) { totalExpectedAmounts = totalExpectedAmounts . add ( _expectedAmounts [ i ] ) ; } acceptAndPay ( requestId , _payeeAmounts , _additionals , totalExpectedAmounts ) ; return requestId ; }",Function to create a request as payer .
4869,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( frozen [ _from ] == false && frozen [ msg . sender ] == false ) ; require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
4872,"function revokeAndReclaim ( ) pre_cond ( isOwner ( ) ) pre_cond ( ! isVestingRevoked ( ) ) { uint reclaimable = totalVestedAmount . sub ( calculateWithdrawable ( ) ) ; withdrawnByBeneficiary = withdrawnMelon ( ) ; revoked = true ; assert ( MELON_CONTRACT . transfer ( owner , reclaimable ) ) ; }",Stops vesting and transfers the totalVestedAmount minus the withdrawable amount at the current time to the contract creator
4876,"function isRegistered ( address _darknodeID ) public view returns ( bool ) { return isRegisteredInEpoch ( _darknodeID , currentEpoch ) ; }",Returns if a darknode is in the registered state .
4877,function ownerClawback ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; },"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract ."
4880,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused canBeStoredIn40Bits ( _tokenId ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleMarket ) ) ; require ( _to != address ( breedingMarket ) ) ; require ( _approvedFor ( msg . sender , uint40 ( _tokenId ) ) || _isApprovedForAll ( _from , msg . sender ) ) ; require ( _isOwner ( _from , uint40 ( _tokenId ) ) ) ; _transfer ( _from , _to , uint40 ( _tokenId ) ) ; }",Transfers the ownership of an NFT from one address to another address
4881,"function setForwardedAccount ( Data storage self , address originalAccount , address forwardedAccount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , forwardedAccount ) ) ; require ( self . Storage . setAddress ( id , originalAccount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set a forwarded address for an account .
4882,"function changeInitialPrice ( uint256 identifier , uint256 newPrice ) public onlyCFO { require ( identifierToOwner [ identifier ] == address ( this ) ) ; identifierToPrice [ identifier ] = newPrice ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; }",Set the initial price of a deed .
4884,"function _getExtraParam ( bytes _extraData ) private pure returns ( uint256 val1 , uint256 val2 , uint256 val3 ) { if ( _extraData . length == 2 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = 1 ; } else if ( _extraData . length == 3 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = uint256 ( _extraData [ 2 ] ) ; } }",Returns all the relevant information about a specific tokenId .
4886,"function addAffiliate ( address _investor , address _affiliate ) onlyOwner { affiliates [ _investor ] = Affiliate ( _affiliate , true ) ; }",This adds an affiliate Ethereum address to our whitelist
4888,function getAmountToGive ( OrderData order ) public view onlySelf returns ( uint256 amountToGive ) { amountToGive = getAvailableTakerVolume ( order ) ; },Gets the amount that Totle needs to give for this order
4891,"function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration , uint256 _rentPeriod ) external { require ( _rentPeriod >= 3600 ) ; DWorldRenting dWorldRentingContract = DWorldRenting ( deedContract ) ; var ( renter , ) = dWorldRentingContract . renterOf ( _deedId ) ; require ( renter == address ( 0 ) ) ; identifierToRentPeriod [ _deedId ] = _rentPeriod ; createAuction ( _deedId , _startPrice , _endPrice , _duration ) ; }",Create an auction for a given deed .
4893,"function transfer ( address _to , uint _amount ) returns ( bool ) ;",Transfer ` _amount ` of tokens to ` _to `
4894,"function onApprove ( address _owner , address , uint ) public returns ( bool success ) { if ( _owner == controller || _owner == address ( this ) ) { return true ; } return transferable ; }","Notifies the controller about an approval , for this TokenSale all approvals are allowed by default and no extra notifications are needed"
4895,"function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) { bool amountApproved = _allowed [ from ] [ msg . sender ] >= amount ; require ( amountApproved ) ; _allowed [ from ] [ msg . sender ] -= amount ; mTransfer ( from , to , amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
4896,function setAllowChangePrice ( bool _allowChangePrice ) external onlyCFO { allowChangePrice = _allowChangePrice ; },Set whether prices can be changed manually .
4897,"function calcSharePriceAndAllocateFees ( ) public returns ( uint ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; return sharePrice ; }",Converts unclaimed fees of the manager into fund shares
4898,"function announceWithdraw ( address _token , uint256 _amount ) external { require ( _amount <= balances [ msg . sender ] [ _token ] , ""Amount too high"" ) ; AnnouncedWithdrawal storage announcement = announcedWithdrawals [ msg . sender ] [ _token ] ; uint256 canWithdrawAt = now + withdrawAnnounceDelay ; announcement . canWithdrawAt = canWithdrawAt ; announcement . amount = _amount ; emit WithdrawAnnounce ( msg . sender , _token , _amount , canWithdrawAt ) ; }",Announces intent to withdraw tokens using ` slowWithdraw `
4899,"function mintToken ( address target , uint mintAmount ) internal { balances [ target ] = safeAdd ( balances [ target ] , mintAmount ) ; _totalSupply = safeAdd ( _totalSupply , mintAmount ) ; emit Transfer ( owner , target , mintAmount ) ; }",Internal function for minting and distributing to a single address
4900,"function verifyInvestment ( address _beneficiary , uint256 _fundsAmount ) public view returns ( bool ) { return polyToken . allowance ( _beneficiary , address ( this ) ) >= _fundsAmount ; }","use to verify the investment , whether the investor provide the allowance to the STO or not ."
4904,function cancelPayment ( uint _idPayment ) onlyOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; },` onlyOwner ` Cancel a payment all together
4906,function transferWei ( address _contractAddress ) public isOwner isClosed { uint256 weiForTransfer = weiTransferCalculator ( ) ; if ( adminFeePercentage > 0 ) { weiForTransfer = payOutAdminFee ( weiForTransfer ) ; } require ( weiForTransfer > 0 ) ; _contractAddress . transfer ( weiForTransfer ) ; setPoolToAwaitingTokens ( ) ; emit EtherTransferredOut ( weiForTransfer ) ; },Transfers the Ether out of the contract to the given address parameter .
4909,function changeSponseeAddress ( address _newAddress ) onlyAccountAddressForSponsee { sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; },This method will change old sponsee address with a new one .
4910,"function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return ""0"" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }",used with addToString ( ) to generate the tokenURI
4912,function withdrawBalance ( ) public mustBeAtStage ( Stage . Finalized ) { wallet . transfer ( this . balance ) ; },Used only if there are some leftover funds ( because of topUpBalance )
4913,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Insufficent allowance or balance"" ) ; address ethDividendCheckpoint = new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( ethDividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return ethDividendCheckpoint ; }",Used to launch the Module with the help of factory
4914,"function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , ""Approval already exists"" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }",Adds a pair of addresses to manual approvals
4915,"function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( ""TTP unable to transfer tokens to primary"" ) ; } emit GenericEvent ( 3 ) ; } } }","Iterates through a list of token orders , transfer the SELL orders to this contract & calculates if we have the ether needed"
4916,"function rejectMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }",` onlyReviewer ` Rejects a specific milestone 's completion and reverts the ` milestone.status ` back to the ` AcceptedAndInProgress ` state
4917,"function tokensOfWithData ( address _owner , uint256 _index ) public view returns ( uint256 [ ] , uint256 [ ] ) { uint256 [ ] memory tokensList = ownedTokens [ _owner ] ; uint256 [ ] memory dataList = new uint256 [ ] ( tokensList . length ) ; for ( uint i = 0 ; i < tokensList . length ; i ++ ) { dataList [ i ] = data [ _index ] [ tokensList [ i ] ] ; } return ( tokensList , dataList ) ; }",Gets the list of tokens owned by a given address
4918,"function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }",Mints the tokens only once against the supplied key ( category ) .
4921,function getBidIdList ( ) public view returns ( bytes32 [ ] bidIds ) { return bidIdList ; },Get the list of Campaign BidIds registered in the contract Returns the list of BidIds of the campaigns ever registered in the contract
4923,function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; apt . changeController ( place_holder ) ; finalizedBlock = getBlockNumber ( ) ; Finalized ( finalizedBlock ) ; },This method will can be called by the controller before the contribution period end or by anybody after the ` endBlock ` .
4925,"function createCloneToken ( MiniMeToken _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
4927,function emission ( uint _value ) onlyOwner { if ( _value + totalSupply < totalSupply ) throw ; totalSupply += _value ; balances [ owner ] += _value ; },owner balance will be increased by ` _value `
4928,"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( _interfaceHash , addr ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }",Sets the contract which implements a specific interface for an address .
4936,"function HAVtoUSD ( uint hav_dec ) public view priceNotStale returns ( uint ) { return safeMul_dec ( hav_dec , price ) ; }",The value in USD for a given amount of HAV
4939,"function transfer ( address to , uint256 tokenAmount ) public tradable ( msg . sender ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( msg . sender , to , tokenAmount ) ; return true ; }",Transfers ` amount ` from msg.sender to ` destination `
4941,"function _setOriginationFee ( uint originationFeeMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_ORIGINATION_FEE_OWNER_CHECK ) ; } Exp memory oldOriginationFee = originationFee ; originationFee = Exp ( { mantissa : originationFeeMantissa } ) ; emit NewOriginationFee ( oldOriginationFee . mantissa , originationFeeMantissa ) ; return uint ( Error . NO_ERROR ) ; }",Sets the origination fee ( which is a multiplier on new borrows )
4942,function enableWithdrawal ( ) public onlyOwner whenStopped whenWithdrawalDisabled { withdrawalEnabled = true ; emit WithdrawalEnabled ( owner ) ; },"enables withdrawals , only callable by the owner when the withdrawals are disabled"
4943,function createNewAccount ( address _newUser ) external onlyAccountRegistryLogic nonZero ( _newUser ) { require ( ! addressBelongsToAccount ( _newUser ) ) ; numAccounts ++ ; accountByAddress [ _newUser ] = numAccounts ; },Create an account for a user and emit an event
4944,function setKingdomCreationFeeWei ( uint _kingdomCreationFeeWei ) { externalEnter ( ) ; setKingdomCreationFeeWeiRP ( _kingdomCreationFeeWei ) ; externalLeave ( ) ; },Used by topWizard to vary the fee for creating kingdoms .
4947,function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external ;,Sets the ticker registration fee in POLY tokens
4951,function balanceOf ( address _holder ) public view returns ( uint256 ) { return balances [ _holder ] ; },Used to get the balance of a holder
4955,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = FLAGS ; return allPermissions ; },Return the permissions flag that are associated with general trnasfer manager
4956,"function approve ( address spender , uint256 value ) public returns ( bool _success ) { require ( spender != address ( 0 ) ) ; require ( value != 0 ) ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }",To approve another user to use your tokens
4958,"function recoverAddress ( bytes32 _h , uint8 _v , bytes32 _r , bytes32 _s ) private pure returns ( address ) { bytes memory _prefix = ""\x19Ethereum Signed Message:\n32"" ; bytes32 _prefixedHash = keccak256 ( abi . encodePacked ( _prefix , _h ) ) ; return ecrecover ( _prefixedHash , _v , _r , _s ) ; }",Returns an empty escrow struct and 0 _tradeHash if not found .
4959,"function proxy ( address destination , address account , uint amount , uint gasLimit ) public onlyOwner { require ( destination != ParetoAddress ) ; bytes4 sig = bytes4 ( keccak256 ( ""transfer(address,uint256)"" ) ) ; assembly { let x := mload ( 0x40 ) mstore ( x , sig ) mstore ( add ( x , 0x04 ) , account ) mstore ( add ( x , 0x24 ) , amount ) let success := call ( gasLimit , destination , 0 , x , 0x44 , x , 0x0 ) jumpi ( 0x02 , iszero ( success ) ) } emit LogProxy ( destination , account , amount , gasLimit ) ; }",this function sends back the mistankenly sent non-Pareto ERC20 tokens
4961,"function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( att ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
4962,"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }",Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
4963,"function getTokenBalance ( string currency ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , address ( this ) ) ; }",Returns balance of this contract associated with currency symbol .
4965,function setMyICOContract ( address _SCICO ) public onlyOwner { require ( address ( this ) . balance == 0 ) ; addressSCICO = _SCICO ; },The owner must specify which ICO contract is allowed call for refunds
4966,"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 feePercentage = exchange . fee ( ) ; uint256 availableVolume = exchange . availableVolume ( data . takerToken , data . takerAmount , data . makerToken , data . makerAmount , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; uint256 fee = SafeMath . div ( SafeMath . mul ( availableVolume , feePercentage ) , 1 ether ) ; return SafeMath . add ( availableVolume , fee ) ; }",Gets the amount that TotlePrimary needs to give for this order
4968,function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; },Removes multiple addresses to the administrator list .
4969,function setWeth ( address wethAddress ) public onlyOwner { require ( wethAddress != address ( 0x0 ) ) ; weth = WethInterface ( wethAddress ) ; },Changes the current contract address set as WETH
4972,"function hasRole ( address addr , string role ) public view returns ( bool ) { return rbac . hasRole ( addr , role ) ; }",Check if an address has a role .
4973,"function requestCustodianChange ( address _proposedCustodian ) public returns ( bytes32 lockId ) { require ( _proposedCustodian != address ( 0 ) ) ; lockId = generateLockId ( ) ; custodianChangeReqs [ lockId ] = CustodianChangeRequest ( { proposedNew : _proposedCustodian } ) ; emit CustodianChangeRequested ( lockId , msg . sender , _proposedCustodian ) ; }",Requests a change of the custodian associated with this contract .
4976,"function verifyTransfer ( address _from , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( _onWhitelist ( _to ) && _onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && _isSTOAttached ( ) ) { return Result . NA ; } return _onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( _onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( _onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }","Default implementation of verifyTransfer used by SecurityToken If the transfer request comes from the STO , it only checks that the investor is in the whitelist If the transfer request comes from a token holder , it checks that : a ) Both are on the whitelist b ) Seller 's sale lockup period is over c ) Buyer 's purchase lockup is over"
4977,function getAssetPacksUserCreated ( address _address ) public view returns ( uint [ ] ) { return createdAssetPacks [ _address ] ; },method returns all asset packs created by _address
4978,function setNomin ( Nomin _nomin ) external onlyOwner { nomin = _nomin ; emit NominUpdated ( _nomin ) ; },Set the Nomin contract that the issuance controller uses to issue Nomins .
4980,"function refundManyAddresses ( uint256 _startIndex , uint256 _numberOfAddresses ) public isCancelled isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; for ( uint256 i = _startIndex ; i <= endIndex ; ++ i ) { address user = swimmersList [ i ] ; if ( swimmers [ user ] > 0 ) { processRefundInternal ( user ) ; } } }",This triggers a refund event for a subset of users .
4981,"function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) ;",Get the hash of a given attribute approval .
4982,"function burnCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , ""Carbon escrow account in WT0 doesn't have enough tokens for burning"" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; whitelisted . burn ( _amount ) ; _mint ( address ( this ) , chargedFee ) ; emit BurnedCUSD ( msg . sender , feedAmount , chargedFee ) ; }",burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address
4983,"function settleChannel ( uint256 channel_identifier , address participant1 , uint256 participant1_transferred_amount , uint256 participant1_locked_amount , bytes32 participant1_locksroot , address participant2 , uint256 participant2_transferred_amount , uint256 participant2_locked_amount , bytes32 participant2_locksroot ) public { require ( channel_identifier == getChannelIdentifier ( participant1 , participant2 ) ) ; bytes32 pair_hash ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number < block . number ) ; Participant storage participant1_state = channel . participants [ participant1 ] ; Participant storage participant2_state = channel . participants [ participant2 ] ; require ( verifyBalanceHashData ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant1_locksroot ) ) ; require ( verifyBalanceHashData ( participant2_state , participant2_transferred_amount , participant2_locked_amount , participant2_locksroot ) ) ; ( participant1_transferred_amount , participant2_transferred_amount , participant1_locked_amount , participant2_locked_amount ) = getSettleTransferAmounts ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant2_state , participant2_transferred_amount , participant2_locked_amount ) ; delete channel . participants [ participant1 ] ; delete channel . participants [ participant2 ] ; delete channels [ channel_identifier ] ; delete participants_hash_to_channel_identifier [ pair_hash ] ; storeUnlockData ( channel_identifier , participant1 , participant2 , participant1_locked_amount , participant1_locksroot ) ; storeUnlockData ( channel_identifier , participant2 , participant1 , participant2_locked_amount , participant2_locksroot ) ; emit ChannelSettled ( channel_identifier , participant1_transferred_amount , participant2_transferred_amount ) ; if ( participant1_transferred_amount > 0 ) { require ( token . transfer ( participant1 , participant1_transferred_amount ) ) ; } if ( participant2_transferred_amount > 0 ) { require ( token . transfer ( participant2 , participant2_transferred_amount ) ) ; } }",Settles the balance between the two parties .
4984,"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; return true ; }",Approve an address to send ` tokenAmount ` tokens to ` msg.sender ` ( make an allowance )
4985,"function playerEndGameConflict ( uint32 _roundId , uint8 _gameType , uint16 _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _playerHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _playerSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _playerHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; playerEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _playerHash , _playerSeed , _gameId , msg . sender ) ; }",Can be used by player if server does not answer to the end game session request .
4986,function decimals ( ) public view returns ( uint8 _decimals ) ;,Returns the number of decimals the token uses .
4988,function nettingContractsByAddress ( address node_address ) constant returns ( address [ ] ) { return data . nodeaddress_to_channeladdresses [ node_address ] ; },Get all channels that an address participates in .
4992,"function getMeme ( uint256 _tokenId ) public view returns ( uint256 metadata , string text , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; metadata = meme . metadata ; text = meme . text ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific meme .
4993,"function reclaimExpiredSwaps ( bytes32 msigId , bytes32 swapId ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; require ( now >= hashIdToSwap [ swapId ] . expirationTime ) ; uint amount = hashIdToSwap [ swapId ] . amount ; assert ( hashIdToMultisig [ msigId ] . deposit + amount >= amount ) ; delete hashIdToSwap [ swapId ] ; hashIdToMultisig [ msigId ] . deposit += amount ; }","Reclaim an expired , non-empty swap into a multisig"
4995,"function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
4997,"function cancelCampaign ( bytes32 bidId ) public { address campaignOwner = getOwnerOfCampaign ( bidId ) ; require ( owner == msg . sender || campaignOwner == msg . sender ) ; uint budget = getBudgetOfCampaign ( bidId ) ; advertisementFinance . withdraw ( campaignOwner , budget ) ; advertisementStorage . setCampaignBudgetById ( bidId , 0 ) ; advertisementStorage . setCampaignValidById ( bidId , false ) ; }","Cancel a campaign and give the remaining budget to the campaign owner When a campaing owner wants to cancel a campaign , the campaign owner needs to call this function ."
4999,"function ( ) public payable { require ( contractPoweredUp ) ; require ( contractStarted ) ; require ( ! contractFinished ) ; require ( ! contractPaused ) ; require ( ! contractFailed ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; uint256 parsecValue = calculateReward ( msg . value ) ; uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT . sub ( spentParsecs ) ; maxAcceptableParsecs = maxAcceptableParsecs . sub ( pendingParsecs ) ; require ( parsecValue <= maxAcceptableParsecs ) ; if ( kycStatus [ msg . sender ] == KycState . Undefined ) { kycStatus [ msg . sender ] = KycState . Pending ; } if ( kycStatus [ msg . sender ] == KycState . Pending ) { addPendingContribution ( msg . sender , msg . value , parsecValue ) ; } else if ( kycStatus [ msg . sender ] == KycState . Accepted ) { addAcceptedContribution ( msg . sender , msg . value , parsecValue ) ; } else { revert ( ) ; } }",A participant 's contribution will be rejected if the hard cap is reached
5001,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , ""Unsuccessful call"" ) ; emit GenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( percentageTransferManager ) ; }",used to launch the Module with the help of factory
5003,"function generateTokens ( address _beneficiary , uint256 _tokens ) internal ;",common interfaces for both of MiniMe and Mintable token .
5005,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozenAccount [ msg . sender ] ) ; assert ( _spender != address ( 0 ) ) ; require ( _value >= 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }",If this function is called again it overwrites the current allowance with _value .
5006,function ( ) public { revert ( ) ; },this contract will revert on direct non-function calls
5007,function getTokenIndex ( uint256 _tokenId ) public view returns ( uint64 ) ;,Get the index of PixelCon ` ( _tokenId ) `
5009,"function approve ( address spender , uint256 amount ) public returns ( bool success ) ;",` msg.sender ` approves ` spender ` to spend ` amount ` tokens on its behalf .
5011,function setMigrationAgent ( address _agent ) external onlyUnlocked ( ) { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; },Set address of migration target contract and enable migration process .
5012,function getRate ( ) public view returns ( uint256 ) { if ( block . timestamp < phase2StartTime ) { return phase1Rate ; } uint offset = block . timestamp . sub ( phase2StartTime ) ; for ( uint256 i = 0 ; i < phase2RateOffsets . length ; i ++ ) { if ( offset < phase2RateOffsets [ i ] ) { return phase2Rates [ i ] ; } } return 0 ; },getRate function expose token rate that decline is applied .
5014,"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3F ) , _newCFO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCFO
5016,function getTokenTransferUuid ( address _address ) onlyAllowedAddresses public constant returns ( bytes16 ) { return tokenTransfers [ _address ] ; },Get uuid of account taht transfer tokens to specified address .
5017,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
5018,"function transferFrom ( address _from , address _to , uint256 _value ) canTransfer ( _from ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; return super . transferFrom ( _from , _to , _value ) ; }",Transfers tokens from a specified wallet address .
5019,"function convertFromUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . div ( _amount , rate ) ; }",This function converts from USD to ETH or POLY
5020,"function _setupChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) private returns ( bytes32 channelId ) { require ( IS_EXCHANGE_OPERATIONAL , ""EXCHANGE_NOT_OPERATIONAL"" ) ; require ( now <= expiresAt , ""TIMELOCK_TOO_EARLY"" ) ; require ( amount > 0 , ""AMOUNT_IS_ZERO"" ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] , ""SECRET_CAN_BE_DISCOVERED"" ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; channelId = createChannelId ( msg . sender , beneficiary , amount , commission , now , expiresAt , hashedSecret ) ; Channel storage channel = channels [ channelId ] ; channel . initiator = msg . sender ; channel . beneficiary = beneficiary ; channel . amount = amount ; channel . commission = commission ; channel . createdAt = now ; channel . expiresAt = expiresAt ; channel . hashedSecret = hashedSecret ; channel . state = State . Created ; COMMISSION_RECIPIENT . transfer ( commission ) ; emit ChannelCreated ( channelId ) ; }",Sets up a Channel to initiate or participate in .
5021,function ( ) payable { buy ( msg . sender ) ; },"This function if anybody sends ETH directly to this contract , consider he is getting B2BK ."
5023,function checkHashExists ( bytes32 _ipfsHash ) public view returns ( bool ) { return hashExists [ _ipfsHash ] ; },Function to check does hash exist in mapping
5024,function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . content_hash ; },"Returns the questions 's content hash , identifying the question content"
5025,"function startNewStakingInterval ( uint _start , uint _end ) external notZero ( _start ) notZero ( _end ) onlyOperator isDoneStaking { require ( totalLevs == 0 ) ; startBlock = _start ; endBlock = _end ; totalLevBlocks = 0 ; feeForTheStakingInterval = 0 ; feeCalculated = false ; StakingInterval ( _start , _end ) ; }",To start a new trading staking-interval where the price of the FEE will be updated
5026,"function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( ""sUSD"" , amount , ""XDR"" ) ; uint totalDebtIssued = synthetix . totalIssuedSynths ( ""XDR"" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }",Import issuer data from the old Synthetix contract before multicurrency
5027,"function transfer ( address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` msg.sender `
5028,"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , getRate ( loan , oracleData ) ) ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender ."
5029,"function remove ( MapStorage storage self , address _key ) public returns ( bool ) { require ( _key != address ( 0 ) ) ; if ( ! exist ( self , _key ) ) { return false ; } uint currentIndex = self . addressToIndex [ _key ] ; uint lastIndex = SafeMath . sub ( self . addresses . length , 1 ) ; address lastAddress = self . addresses [ lastIndex ] ; self . addressToIndex [ lastAddress ] = currentIndex ; self . addresses [ currentIndex ] = lastAddress ; delete self . addresses [ lastIndex ] ; delete self . addressToIndex [ _key ] ; self . addresses . length -- ; return true ; }",Removes the given address from the storage .
5030,"function slash ( bytes32 _guiltyOrderID ) external onlySlasher { require ( orderDetails [ _guiltyOrderID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID , ""slashing non-atomic trade"" ) ; bytes32 innocentOrderID = orderbookContract . orderMatch ( _guiltyOrderID ) ; require ( orderStatus [ _guiltyOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; require ( orderStatus [ innocentOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; orderStatus [ _guiltyOrderID ] = OrderStatus . Slashed ; ( bytes32 buyID , bytes32 sellID ) = isBuyOrder ( _guiltyOrderID ) ? ( _guiltyOrderID , innocentOrderID ) : ( innocentOrderID , _guiltyOrderID ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ buyID ] . tokens ) ; SettlementDetails memory settlementDetails = calculateAtomicFees ( buyID , sellID , tokens ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , orderbookContract . orderTrader ( innocentOrderID ) , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , slasherAddress , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; }",Slashes the bond of a guilty trader .
5032,"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || balancesDB . getOperator ( _operator , _tokenHolder ) ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address at remote database .
5033,function totalSupply ( ) public view returns ( uint ) { return properties . length ; },Returns the total number of Properties currently in existence .
5034,"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }",Checks if the takeOrder price is within maximum allowed deviation from reference price
5035,function _address ( uint _holderId ) public view returns ( address ) { return holders [ _holderId ] . addr ; },Returns current address for a particular holder id .
5039,"function updateCounters ( uint256 _etherAmount ) internal { preSaleEtherPaid = preSaleEtherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( preSaleEtherPaid , _etherAmount ) ; }",Updates the counters for the amount of Ether paid
5040,"function collectionCleared ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionTokens [ _collectionIndex ] . length == uint256 ( 0 ) ; }",Check if collection # ` ( _collectionIndex ) ` has been cleared
5041,"function transfer ( address to , uint256 amount , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }",Send ` amount ` tokens to ` to ` from ` msg.sender ` and notify the receiver from your transaction with your ` extraData ` data
5042,function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; },"Get the missing funds needed to end the auction , calculated at the current RDN price in WEI ."
5043,"function burn ( ) external isFinalized { uint256 _balance = balanceOf [ msg . sender ] ; assert ( _balance > 0 ) ; totalSupply = totalSupply . sub ( _balance ) ; balanceOf [ msg . sender ] = 0 ; Burn ( msg . sender , _balance ) ; }",This function burns all B2BK tokens on the address that caused this function .
5045,"function approve ( address _spender , uint _value ) public returns ( bool ) { if ( _spender != 0x0 ) { return _getAsset ( ) . __approve ( _spender , _value , msg . sender ) ; } }",Sets asset spending allowance for a specified spender .
5046,function mAdavanceLogicState ( ETOState oldState ) internal constant returns ( ETOState ) ;,"gets called after business logic , may induce state transition"
5047,function ownerOf ( uint256 _identifier ) external view returns ( address _owner ) { _owner = gameStates [ gameIndex ] . identifierToOwner [ _identifier ] ; require ( _owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given deed .
5048,"function allowAsset ( address asset , string currency , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; require ( setAssetCurrency ( asset , currency ) , 'Error: Unable to set Currency for asset' ) ; require ( setAssetFeeParams ( asset , feeBps , feeMin , feeMax , feeFlat ) , 'Error: Unable to set fee params for asset' ) ; emit AllowedERC20Asset ( asset , currency ) ; return true ; }",This method may be deprecated or refactored to allow for multiple interfaces
5051,function produce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( totalSupplyLimit == 0 || totalSupply . add ( amount ) <= totalSupplyLimit ) ; balances [ owner ] = balances [ owner ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; return true ; },produce ` amount ` of tokens to ` _owner `
5054,function description ( ) public view returns ( string ) ;,A description of what this DAR is used for
5055,function getUpgradeState ( ) public view returns ( UpgradeState ) { if ( ! canUpgrade ( ) ) return UpgradeState . NotAllowed ; else if ( address ( upgradeAgent ) == address ( 0 ) ) return UpgradeState . WaitingForAgent ; else if ( totalUpgraded == 0 ) return UpgradeState . ReadyToUpgrade ; else return UpgradeState . Upgrading ; },Get the state of the token upgrade .
5056,function changeFundOwnerWalletAddress ( address _fundOwnerWallet ) public validate_address ( _fundOwnerWallet ) onlyOwner { fundOwnerWallet = _fundOwnerWallet ; },Function to change the fund owner wallet address
5057,"function getTotalBonusesAmountAvailable ( bytes32 _userKey ) public view returns ( uint _sum ) { uint _startDate = _getCalculationStartDate ( _userKey ) ; Treasury _treasury = Treasury ( treasury ) ; for ( uint _endDate = lastDepositDate ; _startDate <= _endDate && _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { Deposit storage _pendingDeposit = distributionDeposits [ _startDate ] ; Balance storage _userBalance = _pendingDeposit . leftToWithdraw [ _userKey ] ; if ( _userBalance . initialized ) { _sum = _sum . add ( _userBalance . left ) ; } else { uint _sharesPercent = _treasury . getSharesPercentForPeriod ( _userKey , _startDate ) ; _sum = _sum . add ( _pendingDeposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ) ; } } }",Gets total amount of bonuses user has during all distribution periods
5059,"function unlockFirstPrivate ( ) public locked onlyOwner { require ( block . timestamp >= firstPrivateReleaseTime ) ; require ( firstPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= firstPrivateLockedAmount ) ; token . transfer ( privateLockAddress , firstPrivateLockedAmount ) ; firstPrivateLockedAmount = 0 ; }",Transfers tokens held by timelock to private .
5063,function totalSupply ( ) external view returns ( uint256 ) { return cuties . length - 1 ; },Returns the total number of Cuties in existence .
5064,"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) internal { callSender ( _operator , _tokenHolder , 0x0 , _amount , _data , _operatorData ) ; requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount , ""Not enough funds"" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; emit Burned ( _operator , _tokenHolder , _amount , _data , _operatorData ) ; }",Helper function actually performing the burning of tokens .
5065,"function withdrawERC20 ( address _token ) external whenNotPaused onlyAdmin { IERC20 erc20 = IERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }",Enables admins to withdraw accidentally sent ERC20 token to the contract .
5066,"function setTxStatus ( Data storage self , bytes32 txHash ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; require ( ! getTxStatus ( self , txHash ) , ""Error: Transaction status must be false before setting the transaction status."" ) ; require ( self . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }",Set transaction status if the transaction has been used
5067,function adminRescueFunds ( ) external onlyOwner whenPaused { address payee = owner ; uint256 payment = address ( this ) . balance ; payee . transfer ( payment ) ; },Allows admin to withdraw contract balance in emergency .
5069,function isAllowedAddress ( address _address ) onlyAllowedAddresses public constant returns ( bool ) { return allowedAddresses [ _address ] ; },Check that address is allowed to interact with functions .
5070,"function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( hashIdToMultisig [ msigId ] . deposit >= amount ) ; require ( now >= hashIdToMultisig [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }",Withdraw ether and delete the htlc swap .
5071,"function setTokenFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , ""Percent must be between 0 and 100."" ) ; tokenFeePercent = percent ; }",Set the percent fee applied to tokens that are transferred .
5074,function cancelPayment ( uint _idPayment ) onlyContractOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; },` onlyOwner ` Cancel a payment all together
5075,"function setMarginSpend ( uint256 _marginSpend ) external onlyOwner returns ( bool ) { emit SetMarginSpend ( marginSpend , _marginSpend ) ; marginSpend = _marginSpend ; return true ; }",Sets how much the converter ramp is going to oversell to cover fees and gaps
5076,"function decApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . sub ( _value ) ; return true ; }",Decrease allowance of ` _spender ` in behalf of ` _from ` at ` _value `
5079,"function redeemToken ( uint256 _tokens ) returns ( bool success ) { if ( this . balance < totalSupply ) { throw ; } if ( _tokens == 0 ) { throw ; } if ( balances [ msg . sender ] >= _tokens && totalSupply >= _tokens ) { balances [ msg . sender ] -= _tokens ; totalSupply -= _tokens ; if ( msg . sender . send ( _tokens ) ) { LogRedeemToken ( msg . sender , _tokens ) ; return true ; } else { throw ; } } else { throw ; } }",Converts token quantity defined by '_token ' into ether and sends back to msg.sender
5081,"function getBlockOwner ( uint8 x , uint8 y ) external view returns ( address ) { return ownerOf ( blockID ( x , y ) ) ; }",get an owner ( address ) of block at a specified coordinates
5082,"function revokeVesting ( address _holder , uint256 _vestingId ) external authP ( REVOKE_VESTINGS_ROLE , arr ( _holder ) ) vestingExists ( _holder , _vestingId ) { TokenVesting storage v = vestings [ _holder ] [ _vestingId ] ; require ( v . revokable , ERROR_VESTING_NOT_REVOKABLE ) ; uint256 nonVested = _calculateNonVestedTokens ( v . amount , getTimestamp64 ( ) , v . start , v . cliff , v . vesting ) ; delete vestings [ _holder ] [ _vestingId ] ; require ( token . transferFrom ( _holder , address ( this ) , nonVested ) , ERROR_REVOKE_TRANSFER_FROM_REVERTED ) ; emit RevokeVesting ( _holder , _vestingId , nonVested ) ; }","Revoke vesting # ` _vestingId ` from ` _holder ` , returning unvested tokens to the Token Manager"
5083,function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) ;,Used to get the ticker list as per the owner
5085,"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
5086,function lastRateUpdateTimeForCurrency ( bytes4 currencyKey ) public view returns ( uint ) { return lastRateUpdateTimes [ currencyKey ] ; },Retrieve a list of last update times for specific currencies
5087,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
5089,"function lock ( ) external onlyOwner vaultLoading { require ( tokensAllocated == tokensToBeAllocated , ""Expected to allocate all tokens"" ) ; require ( token . balanceOf ( address ( this ) ) == tokensAllocated , ""Vault must own enough tokens to distribute"" ) ; lockedAt = block . timestamp ; emit Locked ( ) ; }",Finalize setting of allocations and begin the lock up ( vesting ) period .
5091,"function finalize ( ) public initialized onlyOwner { require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToTeam = percent ( 18 ) ; uint256 percentageToReserve = percent ( 8 ) ; uint256 percentageToBounties = percent ( 13 ) ; uint256 percentageToAirdrop = percent ( 2 ) ; uint256 percentageToAdvisors = percent ( 7 ) ; uint256 percentageToEarlyInvestors = percent ( 2 ) ; assert ( token . generateTokens ( destTokensBounties , maxSupply . mul ( percentageToBounties ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensReserve , maxSupply . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensTeam , maxSupply . mul ( percentageToTeam ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAirdrop , maxSupply . mul ( percentageToAirdrop ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAdvisors , maxSupply . mul ( percentageToAdvisors ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensEarlyInvestors , maxSupply . mul ( percentageToEarlyInvestors ) . div ( percent ( 100 ) ) ) ) ; Finalized ( ) ; }",This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
5095,"function approveFlower ( address _spender , uint256 _value ) public returns ( bool success ) ;",` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
5097,"function getPolitician ( uint256 _tokenId ) public view returns ( string politicianName , uint256 sellingPrice , address owner ) { Politician storage politician = politicians [ _tokenId ] ; politicianName = politician . name ; sellingPrice = politicianIndexToPrice [ _tokenId ] ; owner = politicianIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific politician .
5098,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( withdrawalRequests [ _from ] . sinceBlock > 0 ) throw ; if ( withdrawalRequests [ _to ] . sinceBlock > 0 ) throw ; if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
5099,"function finalizeSingleInvestor ( address investorAddr ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investorAddr != address ( 0 ) && investorAddr != address ( this ) ) ; require ( balancesToken [ investorAddr ] > 0 ) ; require ( isWhitelisted [ investorAddr ] == true ) ; uint256 balanceToTransfer = balancesToken [ investorAddr ] ; balancesToken [ investorAddr ] = 0 ; isWhitelisted [ investorAddr ] = false ; require ( token . transfer ( investorAddr , balanceToTransfer ) ) ; tokensFinalized = tokensFinalized . add ( balanceToTransfer ) ; assert ( tokensFinalized <= MAX_TOKENS ) ; }",This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop
5100,"function multiTransfer ( address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }",send a set of token to different address
5101,"function balanceOf ( address _owner ) public view returns ( uint ) { return chronoBankPlatform . balanceOf ( _owner , smbl ) ; }",Returns asset balance for a particular holder .
5102,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external isValidToken ( _tokenId ) onlyOwnerOf ( _tokenId ) payable { address owner = IndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) && owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }",Transfers the ownership of a rare item from one address to another address
5104,"function collect ( ) public { uint256 finalizedBlock = statusContribution . finalizedBlock ( ) ; require ( finalizedBlock != 0 ) ; require ( getBlockNumber ( ) > finalizedBlock ) ; uint256 total = totalCollected . add ( snt . balanceOf ( address ( this ) ) ) ; uint256 balance = sgt . balanceOfAt ( msg . sender , finalizedBlock ) ; uint256 amount = total . mul ( balance ) . div ( sgt . totalSupplyAt ( finalizedBlock ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( snt . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }",This method should be called by the SGT holders to collect their corresponding SNTs
5107,function ( ) payable { require ( isContract ( controller ) ) ; assert ( Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
5109,"function approve ( address _spender , uint _value ) external returns ( bool success ) ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
5114,"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; require ( lib . forceTransfer ( currency , from , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; require ( lib . forceTransfer ( currency , from , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , ""Error: Unable to update allowance for spender."" ) ; emit Transfer ( from , to , amount ) ; return true ; }",spender transfers from approvers account to the reciving account
5115,"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 cutieId ) { uint40 count = 0 ; for ( uint40 i = 1 ; i <= _totalSupply ( ) ; ++ i ) { if ( cutieIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }","Returns the nth Cutie assigned to an address , with n specified by the _index argument ."
5116,function changeOwner ( address _newOwner ) public validate_address ( _newOwner ) onlyOwner { require ( _newOwner != owner ) ; owner = _newOwner ; },only the owner is allowed to change the owner .
5117,function escapeHatch ( ) onlyEscapeHatchCallerOrOwner { uint total = this . balance ; if ( ! escapeHatchDestination . send ( total ) ) { throw ; } EscapeHatchCalled ( total ) ; },The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
5118,"function setCampaignStartDateById ( bytes32 bidId , uint newStartDate ) public onlyIfCampaignExists ( ""setCampaignStartDateById"" , bidId ) onlyIfWhitelisted ( ""setCampaignStartDateById"" , msg . sender ) { campaigns [ bidId ] . setStartDate ( newStartDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new start date for a campaign Based of the Campaign id , updates the start date of a campaign ."
5119,function hasHardCap ( ) constant internal returns ( bool ) { return getMaximumFunds ( ) != 0 ; },whether to apply hard cap check logic via getMaximumFunds ( ) method
5120,"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
5121,"function createCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate , string endPoint ) external { CampaignLibrary . Campaign memory newCampaign = _generateCampaign ( packageName , countries , vercodes , price , budget , startDate , endDate ) ; if ( newCampaign . owner == 0x0 ) { return ; } _getBidIdList ( ) . push ( newCampaign . bidId ) ; ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . setCampaign ( newCampaign . bidId , newCampaign . price , newCampaign . budget , newCampaign . startDate , newCampaign . endDate , newCampaign . valid , newCampaign . owner , endPoint ) ; emit CampaignInformation ( newCampaign . bidId , newCampaign . owner , """" , packageName , countries , vercodes , endPoint ) ; }",Creates an extebded campaign Method to create an extended campaign of user aquisition for a certain application .
5122,"function getLockedUserDeposits ( bytes32 _userKey ) public view returns ( uint [ ] _lockupDates , uint [ ] _deposits ) { LockedDeposits storage _lockedDeposits = user2lockedDeposits [ _userKey ] ; uint _lockedDepositsCounter = _lockedDeposits . counter ; _lockupDates = new uint [ ] ( _lockedDepositsCounter ) ; _deposits = new uint [ ] ( _lockedDepositsCounter ) ; uint _pointer = 0 ; for ( uint _idx = 1 ; _idx < _lockedDepositsCounter ; ++ _idx ) { uint _lockDate = _lockedDeposits . index2Date [ _idx ] ; if ( _lockDate > now ) { _lockupDates [ _pointer ] = _lockDate ; _deposits [ _pointer ] = _lockedDeposits . date2deposit [ _lockDate ] ; ++ _pointer ; } } }",Gets list of locked up deposits with dates when they will be available to withdraw
5123,function ( ) public payable { require ( msg . sender == address ( weth ) || msg . sender == totlePrimary ) ; },payable fallback to allow the exchange to return ether directly to this contract
5124,"function commit ( uint256 _value ) public returns ( uint256 commitmentValue ) { require ( 0 < _value ) ; require ( _value <= balances [ msg . sender ] ) ; commitmentValue = _value ; uint256 prevCommit = miners [ msg . sender ] . value ; if ( 0 < prevCommit ) { uint256 prevReward ; ( prevReward , prevCommit ) = withdraw ( ) ; commitmentValue = prevReward . add ( prevCommit ) . add ( _value ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( commitmentValue ) ; emit Transfer ( msg . sender , address ( 0 ) , commitmentValue ) ; totalStake_ = totalStake_ . add ( commitmentValue ) ; miners [ msg . sender ] = Commitment ( commitmentValue , block . number , totalStake_ , blockReward_ ) ; emit Commit ( msg . sender , commitmentValue , totalStake_ , blockReward_ ) ; return commitmentValue ; }",the _value will be substructed from user balance and added to the stake .
5125,"function paymentRegularTokens ( uint256 _regularTokenAmount , uint256 _rewardPercentageIndex ) public validAmount ( _regularTokenAmount ) isValidRewardIndex ( _rewardPercentageIndex ) senderHasEnoughTokens ( _regularTokenAmount , 0 ) isWhitelisted ( msg . sender ) whenNotPaused { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _regularTokenAmount ) ; uint256 rewardAmount = getRewardToken ( _regularTokenAmount , _rewardPercentageIndex ) ; rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . add ( rewardAmount ) ; emit TransferReward ( owner , msg . sender , rewardAmount ) ; balances [ owner ] = balances [ owner ] . add ( _regularTokenAmount . sub ( rewardAmount ) ) ; emit Transfer ( msg . sender , owner , _regularTokenAmount . sub ( rewardAmount ) ) ; }",Process a payment using only regular TRVL Tokens with a specified reward percentage .
5126,"function changeModuleBudget ( address _module , uint256 _budget ) external ;",Allows owner to approve more POLY to one of the modules
5127,"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( abi . encodePacked ( content ) ) ; emit LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }","Create a reusable template , which should be a JSON document ."
5129,"function getCar ( uint256 _tokenId ) public view returns ( string carName , uint256 sellingPrice , address owner ) { Car storage car = cars [ _tokenId ] ; carName = car . name ; sellingPrice = carIndexToPrice [ _tokenId ] ; owner = carIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific car .
5130,function setLiqPrice ( uint wad ) public auth { liquidationPriceWad = wad ; },set the target liquidation price for leveraged CDPs created
5131,function calculateTokens ( uint256 _amountOfWei ) public view returns ( uint256 ) { require ( _amountOfWei >= 1 szabo ) ; uint256 tokenBought ; uint256 tokenPrice = price . USD ( 0 ) ; tokenPrice = tokenPrice . mul ( 36 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = _amountOfWei . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; if ( _amountOfWei >= 10 ether ) { tokenBought = tokenBought . mul ( 123 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( _amountOfWei >= 1 ether ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } return tokenBought ; },Function to know how many tokens you will receive at current time
5134,function contributorCount ( ) public view returns ( uint ) { return contributors . length ; },returns the number of contributors in the list of contributors
5135,"function claimJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . evaluator ) ; require ( job . status == JobStatus . Open ) ; job . worker = msg . sender ; job . status = JobStatus . inProgress ; JobsByWorker [ msg . sender ] . push ( _JobID ) ; emit JobClaimed ( msg . sender , _JobID ) ; }",this function lets the worker claim the job
5136,function receiveDeposit ( ) payable ;,Function to allow the contractor making a deposit in wei
5137,"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { _transferFrom ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` in behalf of ` _from `
5138,function settle ( bytes32 channelId ) public { require ( canSettle ( channelId ) ) ; PaymentChannel storage channel = channels [ channelId ] ; channel . sender . transfer ( channel . value ) ; delete channels [ channelId ] ; DidSettle ( channelId ) ; },"Move the money to sender , and close the channel ."
5140,"function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint _resultCode ) { TransactionContext memory txContext ; txContext . from = msg . sender ; txContext . fromHolderId = getHolderId ( txContext . from ) ; _resultCode = _revokeAsset ( _symbol , _value , txContext ) ; if ( _resultCode != OK ) { return _emitErrorCode ( _resultCode ) ; } _emitter ( ) . emitRevoke ( _symbol , _value , txContext . from ) ; _proxyTransferEvent ( _value , _symbol , txContext ) ; return OK ; }",Destroys specified amount of senders asset tokens .
5145,"function getInterfaceImplementer ( address addr , bytes32 iHash ) public constant returns ( address ) { return interfaces [ addr ] [ iHash ] ; }",Query if an address implements an interface and thru which contract
5146,"function beforeTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) returns ( uint maxAllowed ) ;","Plugins are used ( much like web hooks ) to initiate an action upon any donation , delegation , or transfer ; this is an optional feature and allows for extreme customization of the contract ."
5149,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _to != address ( 0 ) ) ; transferFrom ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { ERC721TokenReceiver receiver = ERC721TokenReceiver ( _to ) ; bytes4 response = receiver . onERC721Received . gas ( 50000 ) ( msg . sender , _from , _tokenId , """" ) ; require ( response == TOKEN_RECEIVED_SIG ) ; } }",Transfers the ownership of an NFT from one address to another address
5150,"function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value != 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }",Migrate tokens to the new token contract .
5151,function totalSupply ( ) public view returns ( uint ) { return ponies . length - 1 ; },Returns the total number of Ponies currently in existence .
5152,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
5153,function setFeeAuthority ( address _feeAuthority ) public optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; },Set the address of the user/contract responsible for collecting or distributing fees .
5154,"function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }",Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract
5156,"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Impl . allowance ( _owner , _spender ) ; }",Returns how much ` _spender ` is currently allowed to spend from ` _owner ` 's balance .
5158,"function getKydy ( uint256 _id ) external view returns ( bool isCreating , bool isReady , uint256 rechargeIndex , uint256 nextActionAt , uint256 synthesizingWithId , uint256 createdTime , uint256 yinId , uint256 yangId , uint256 generation , uint256 genes ) { Kydy storage kyd = kydys [ _id ] ; isCreating = ( kyd . synthesizingWithId != 0 ) ; isReady = ( kyd . rechargeEndBlock <= block . number ) ; rechargeIndex = uint256 ( kyd . rechargeIndex ) ; nextActionAt = uint256 ( kyd . rechargeEndBlock ) ; synthesizingWithId = uint256 ( kyd . synthesizingWithId ) ; createdTime = uint256 ( kyd . createdTime ) ; yinId = uint256 ( kyd . yinId ) ; yangId = uint256 ( kyd . yangId ) ; generation = uint256 ( kyd . generation ) ; genes = kyd . genes ; }",Returns all info about a given Kydy .
5161,function removeSpender ( address _spender ) external onlyOwner { _validateAddress ( _spender ) ; delete whitelistedSpenders [ _spender ] ; },Removes an address from the set of allowed spenders .
5162,"function getOrder ( address who ) public view returns ( uint256 quantity , uint256 price , uint256 expiry ) { TradeOrder memory order = orderBook [ who ] ; return ( order . quantity , order . price , order . expiry ) ; }",Get the trade order for the specified address .
5163,function getTotalCommission ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . commissionCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . commissionCumulative [ _lastIndex ] ; },Returns total amount of commission charged for a given canvas .
5164,"function claimTokensByAdmin ( address _user ) onlyAdmin ( 1 ) public { require ( state == State . Successful ) ; uint256 temp = pending [ _user ] ; pending [ _user ] = 0 ; require ( tokenReward . transfer ( _user , temp ) ) ; emit LogContributorsPayout ( _user , temp ) ; }",Funtion to let admins claim users tokens on behalf of them at the end of ico process
5168,"function decreaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { uint oldValue = allowed [ msg . sender ] [ spender ] ; if ( tokenAmount > oldValue ) { allowed [ msg . sender ] [ spender ] = 0 ; } else { allowed [ msg . sender ] [ spender ] = oldValue . sub ( tokenAmount ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
5169,function setHavven ( Havven _havven ) external onlyOwner { havven = _havven ; emit HavvenUpdated ( _havven ) ; },Set the Havven contract that the issuance controller uses to issue Havvens .
5170,function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; authorizePayment ( _idMilestone ) ; },` onlyArbitrator ` Forces a milestone to be paid out as long as it has not been paid or canceled
5171,"function getBtcRequestHash ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate ) private view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( this , requestData , payeesPaymentAddress , expirationDate ) ) ; }",Calculates the Keccak-256 hash of a BTC request with specified parameters .
5173,"function approve ( address spender , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }",` msg.sender ` approves ` spender ` to spend ` value ` tokens
5174,function disableWithdrawal ( ) public onlyOwner whenWithdrawalEnabled { withdrawalEnabled = false ; emit WithdrawalDisabled ( owner ) ; },"disables withdrawals , only callable by the owner when the withdrawals are enabled"
5176,"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; if ( addTransferManager ) { SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , """" , 0 , 0 ) ; } SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }",deploys the token and adds default modules like permission manager and transfer manager .
5177,function getFee ( address stablecoin ) public view returns ( uint256 ) { return tokenStorage_CD . fees ( stablecoin ) ; },Get the fee associated with going from CarbonUSD to a specific WhitelistedToken .
5181,"function isThirdPartyOwner ( address _address ) public view returns ( bool ) { return ownerRoles . hasEqual ( _address , ROLE_THIRDPARTY_OWNER ) ; }",Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included )
5182,function changeController ( address _newController ) public onlyOwner { att . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The owner of this contract can change the controller of the ATT token Please , be sure that the owner is a trusted agent or 0x0 address ."
5184,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = getBlockNumber ( ) ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
5185,"function changeSettings ( uint _price_start , uint _price_constant , uint32 _price_exponent ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant > 0 ) ; price_start = _price_start ; price_constant = _price_constant ; price_exponent = _price_exponent ; }","Set ` _price_start ` , ` _price_constant ` and ` _price_exponent ` as the new starting price , price divisor constant and price divisor exponent ."
5186,function symbol ( ) external pure returns ( string _symbol ) ;,An abbreviated name for NFTs in this contract
5187,"function notifyOfArbitrationRequest ( bytes32 question_id , address requester ) onlyArbitrator ( question_id ) stateOpen ( question_id ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision ."
5188,"function getExchangeRates ( address [ ] numeratorTokens , address [ ] denominatorTokens ) public constant returns ( uint256 [ ] rateFractions , uint256 [ ] timestamps ) ;",allows to retreive multiple exchange rates in once call
5189,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( ! _to . isContract ( ) ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
5190,"function revoke ( bytes32 _operation ) external multiOwnedOperationIsActive ( _operation ) onlyowner { uint ownerIndexBit = makeOwnerBitmapBit ( msg . sender ) ; var pending = m_multiOwnedPending [ _operation ] ; require ( pending . ownersDone & ownerIndexBit > 0 ) ; assertOperationIsConsistent ( _operation ) ; pending . yetNeeded ++ ; pending . ownersDone -= ownerIndexBit ; assertOperationIsConsistent ( _operation ) ; Revoke ( msg . sender , _operation ) ; }",Revokes a prior confirmation of the given operation
5191,"function setBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , ""Blacklist spending not supported by token"" ) ; setUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogSetBlacklistSpender ( _who ) ; }",Sets the necessary permissions for a user to spend tokens from a blacklisted account .
5194,"function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F42 ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by increaseApprovalPreSigned
5195,"function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; emit LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }",issues new Neumarks to msg.sender with reward at current curve position moves curve position by euroUlps callable only by ROLE_NEUMARK_ISSUER
5198,"function tokenURI ( uint _tokenId ) external view returns ( string ) { require ( exists ( _tokenId ) ) ; return core . getTokenURIs ( _tokenId , tokenIsChamp ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
5199,"function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard"
5200,"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
5201,"function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 sellingPrice , address owner ) { Token storage token = tokens [ _tokenId ] ; tokenName = token . name ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific token .
5202,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
5203,"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , msg . value ) ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT , ""commitment must not already exist"" ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction ."
5204,"function transferAnyERC20Token ( address _tokenAddress , uint256 _tokens , address _beneficiary ) public onlyOwner returns ( bool success ) { return ERC20Basic ( _tokenAddress ) . transfer ( _beneficiary , _tokens ) ; }",Owner can transfer out any accidentally sent ERC20 tokens
5205,"function awardMILsTo ( address _to , uint256 _MILs ) public onlyOwner awardsAllowed { award [ _to ] = award [ _to ] . add ( _MILs ) ; totalAwards = totalAwards . add ( _MILs ) ; currentAwards = currentAwards . add ( _MILs ) ; }",Award MILs to people that will become available after lock-up period ( if funded ) .
5206,function countOfDeeds ( ) public view returns ( uint256 ) { return plots . length ; },Returns the total number of deeds currently in existence .
5207,"function revokeGrant ( address _holder ) external onlyOwner { Grant memory grant = grants [ _holder ] ; require ( grant . value != 0 ) ; delete grants [ _holder ] ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( owner , grant . value ) ; emit RevokeGrant ( _holder , grant . value ) ; }","Revoke the grant for the specified address , transfer the tokens to the owner"
5208,"function _burnForDeposit ( address owner , uint amount ) public onlyTrusted returns ( bool success ) { if ( balances [ owner ] >= amount ) { balances [ owner ] -= amount ; totalOnDeposit += amount ; totalInCirculation -= amount ; return true ; } else { return false ; } }",used by subscription module to burn token while creating a new deposit .
5209,"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= MAX_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** decimals ) ) ) / PRECISION ; } }",Converts an amount to RCN using the loan oracle .
5213,"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) external ;",Used to provide/change the permission to the delegate corresponds to the module contract
5214,function getPrice ( ) external view returns ( uint256 ) ;,Returns price - should throw if not valid
5217,function addAssetToOwnedAssets ( address ofAsset ) public pre_cond ( isOwner ( ) || msg . sender == address ( this ) ) { isInOpenMakeOrder [ ofAsset ] = true ; if ( ! isInAssetList [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; isInAssetList [ ofAsset ] = true ; } },Add an asset to the list that this fund owns
5219,function getBlockNumber ( ) internal view returns ( uint256 ) { return block . number ; },This function is overridden by the test Mocks .
5220,"function setAmounts ( uint256 mtdAmountInWei , uint256 ethAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( ethAmountInWei > 0 ) ; mtdAmount = mtdAmountInWei ; ethAmount = ethAmountInWei ; updatePrices ( ) ; }",Set both ethAmount and mtdAmount at the same time
5223,"function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused beforeStarting { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; require ( tier1 > tier2 && tier2 > tier3 && tier3 > tier4 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }",Set 's the rate of tokens per ether for each tier .
5224,"function newAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxy ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }","Create a new upgradeable instance of ` _appId ` app linked to the Kernel , setting its code to ` _appBase ` ."
5225,"function exchangePreDGZTokens ( ) stopInEmergency onlyAfterStart public { uint tokenAmount = tokenRewardPreDGZ . allowance ( msg . sender , this ) ; require ( tokenAmount > 0 ) ; require ( tokenRewardPreDGZ . transferFrom ( msg . sender , address ( 0 ) , tokenAmount ) ) ; uint amountSendTokens = tokenAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ msg . sender ] += tokenAmount ; tokenReward . transfer ( msg . sender , amountSendTokens ) ; }",A method to exchange preDGZ tokens to DGZ tokens .
5228,"function getDelegateIdx ( Pledge p , uint64 idDelegate ) internal returns ( uint64 ) { for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { if ( p . delegationChain [ i ] == idDelegate ) return uint64 ( i ) ; } return NOTFOUND ; }",A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge
5230,function getCampaignValidById ( bytes32 bidId ) public view returns ( bool valid ) { return campaigns [ bidId ] . getValidity ( ) ; },Get information regarding validity of a campaign .
5232,"function swapProxyTokens ( ) public { ERC20Token oldToken = ERC20Token ( 0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b ) ; uint256 oldTokenBalance = oldToken . balanceOf ( msg . sender ) ; require ( oldTokenBalance > 0 ) ; if ( oldToken . transferFrom ( msg . sender , issuingTokenOwner , oldTokenBalance ) ) { require ( oldToken . balanceOf ( msg . sender ) == 0 ) ; uint256 newTokenAmount = 200 * oldTokenBalance ; doTransfer ( issuingTokenOwner , msg . sender , newTokenAmount ) ; SwappedTokens ( msg . sender , oldTokenBalance , newTokenAmount ) ; } }",This method can be used by users holding old proxy tokens to swap for new tokens at the ratio of 1 : 2 .
5234,"function buyPackWithKitty ( uint256 _kittyId ) external { require ( totalKittiesBurned < KITTY_BURN_LIMIT , ""Stop! Think of the cats!"" ) ; require ( ! hasBurnedKitty [ msg . sender ] , ""You've already burned a kitty."" ) ; totalKittiesBurned ++ ; hasBurnedKitty [ msg . sender ] = true ; kittiesContract . transferFrom ( msg . sender , this , _kittyId ) ; _buyPack ( standardSale ) ; emit KittyBurned ( msg . sender , _kittyId ) ; }",Magically transform a CryptoKitty into a free pack of cards !
5235,"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; emit _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights"
5236,"function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external onlyOwner { uint256 fee = getUint ( TICKERREGFEE ) ; require ( fee != _tickerRegFee , ""Fee not changed"" ) ; emit ChangeTickerRegistrationFee ( fee , _tickerRegFee ) ; set ( TICKERREGFEE , _tickerRegFee ) ; }",Sets the ticker registration fee in POLY tokens .
5237,"function withdrawWinner ( ) external { require ( currentStage == StageName . voteFinished , ""Withdraw disable yet/allready!"" ) ; require ( msg . sender == projects [ keccak256 ( bytes ( currentWinner ) ) ] . prjAddress , ""Only winner can Withdraw reward"" ) ; currentStage = StageName . rewardWithdrawn ; msg . sender . transfer ( address ( this ) . balance ) ; }",Transfer all ether from contract balance ( reward found ) to winner
5241,"function releaseTokensFromEscrow ( uint256 _amount ) external { releaseTokensFromEscrowForUser ( msg . sender , _amount ) ; }",Release tokens back to payer 's available balance if lockup expires
5244,"function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) { require ( _potentialDelegate != address ( 0 ) , ""Invalid address"" ) ; if ( delegateDetails [ _potentialDelegate ] != bytes32 ( 0 ) ) { return true ; } else return false ; }",Used to check if an address is a delegate or not
5245,"function appendDecryptedBids ( uint [ ] _nonce , uint [ ] _index , uint [ ] _bid_id , address [ ] _investor_address , uint [ ] _share_price , uint [ ] _shares_count , uint [ ] _transfered_token ) public onlyOwner { require ( _nonce . length == _index . length ) ; require ( _index . length == _bid_id . length ) ; require ( _bid_id . length == _investor_address . length ) ; require ( _investor_address . length == _share_price . length ) ; require ( _share_price . length == _shares_count . length ) ; require ( _shares_count . length == _transfered_token . length ) ; require ( bids_count . sub ( bids_decrypted_count ) > 0 ) ; for ( uint i = 0 ; i < _index . length ; i ++ ) { appendDecryptedBid ( _nonce [ i ] , _index [ i ] , _bid_id [ i ] , _investor_address [ i ] , _share_price [ i ] , _shares_count [ i ] , _transfered_token [ i ] ) ; } }",Allows appending multiple decrypted bids ( in order ) at once .
5246,"function addRewardPercentage ( uint256 _percentage ) public onlyAdmin isValidRewardPercentage ( _percentage ) returns ( uint256 _index ) { _index = rewardPercentage . length ; rewardPercentage . push ( _percentage ) ; emit RewardPercentage ( _index , _percentage ) ; }","Adds a reward percentage to the list of available reward percentages , specific to 18 decimals ."
5248,"function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( allowedContribution , refundAmount ) ; }",Returns the contribution and refund value to be used when the transaction value is higher than the whitelisted contribution for the sender .
5249,"function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; if ( _lockState == LockState . AcceptingUnlocks ) { require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( currentTime ( ) < accountInMem . unlockDate ) { require ( _penaltyDisbursalAddress != address ( 0 ) ) ; uint256 penalty = decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ; if ( isContract ( _penaltyDisbursalAddress ) ) { require ( ASSET_TOKEN . approveAndCall ( _penaltyDisbursalAddress , penalty , """" ) ) ; } else { assert ( ASSET_TOKEN . transfer ( _penaltyDisbursalAddress , penalty ) ) ; } emit LogPenaltyDisbursed ( _penaltyDisbursalAddress , penalty , ASSET_TOKEN , investor ) ; accountInMem . balance -= penalty ; } } if ( _lockState == LockState . ReleaseAll ) { accountInMem . neumarksDue = 0 ; } assert ( ASSET_TOKEN . transfer ( investor , accountInMem . balance ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }",unlocks 'investor ' tokens by making them withdrawable from assetToken
5251,"function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled && balance != 0 ; }",Determine if user can bote for a poll
5252,"function submitProposal ( address _sender , uint _proposalID , uint _amount ) onlyClient { if ( _sender != recipient && _sender != creator ) throw ; proposals [ _proposalID ] . submittedAmount += _amount ; ProposalSubmitted ( msg . sender , _amount ) ; }",Function used by the client to infor about the submitted amount
5253,function renounceOwnership ( ) public contract_onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .
5254,function realitioAnswerFromAugurMarket ( IMarket market ) onlyInitialized public view returns ( bytes32 ) { bytes32 answer ; if ( market . isInvalid ( ) ) { answer = REALITIO_INVALID ; } else { uint256 no_val = market . getWinningPayoutNumerator ( AUGUR_NO_INDEX ) ; uint256 yes_val = market . getWinningPayoutNumerator ( AUGUR_YES_INDEX ) ; if ( yes_val == no_val ) { answer = REALITIO_INVALID ; } else { if ( yes_val > no_val ) { answer = REALITIO_YES ; } else { answer = REALITIO_NO ; } } } return answer ; },Get the answer from the Augur market and map it to a Realitio value
5255,"function topUpDelegate ( address _sender_address , address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) isTrustedContract external { updateInternalBalanceStructs ( _sender_address , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }",Function that allows a delegate contract to increase the channel deposit with ` _added_deposit ` .
5256,"function doCancelPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Canceled ; liquidPledging . cancelPayment ( uint64 ( p . ref ) , p . amount ) ; CancelPayment ( _idPayment , p . ref ) ; }",Cancels a pending payment ( internal function )
5257,function setResolver ( address _resolver ) onlyOwner public { resolver = _resolver ; },Sets address that resolves hashes for fishing can only be called by the owner
5259,function getBool ( bytes32 _key ) internal view returns ( bool ) { return boolStorage [ _key ] ; },"Get function use to get the value of the singleton state variables Ex1- string public version = `` 0.0.1 '' ; string _version = getString ( keccak256 ( abi.encodePacked ( `` version '' ) ) ; Ex2 - assert ( temp1 == temp2 ) ; replace to assert ( getUint ( keccak256 ( abi.encodePacked ( temp1 ) ) == getUint ( keccak256 ( abi.encodePacked ( temp2 ) ) ; Ex3 - mapping ( string = > SymbolDetails ) registeredSymbols ; where SymbolDetails is the structure having different type of values as { uint256 date , string name , address owner } etc ."
5261,"function safeTransferFromWithFees ( address token , address from , address to , uint256 amount ) internal returns ( uint256 ) { uint256 balancesBefore = CompatibleERC20 ( token ) . balanceOf ( to ) ; CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , ""transferFrom failed"" ) ; uint256 balancesAfter = CompatibleERC20 ( token ) . balanceOf ( to ) ; return Math . min256 ( amount , balancesAfter . sub ( balancesBefore ) ) ; }","Calls transferFrom on the token , reverts if the call fails and returns the value transferred after fees ."
5263,"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",Restriction : An account can only use this function to send to itself
5264,"function updatePlotPrice ( uint256 plotIndex , uint256 newPriceInWeiPerPixel ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; plotIdToPrice [ plotIndex ] = newPriceInWeiPerPixel ; emit PlotPriceUpdated ( plotIndex , newPriceInWeiPerPixel , msg . sender ) ; }",Updates the price per pixel of a plot which the message sender owns .
5268,function updateTreasury ( address _treasury ) external onlyContractOwner returns ( uint ) { require ( _treasury != 0x0 ) ; treasury = _treasury ; return OK ; },Sets new treasury address Only for contract owner .
5269,"function approve ( address _approved , uint256 _tokenId ) external ;",The zero address indicates there is no approved address .
5271,"function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 ) ;","Retrieve the value of the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` , assuming it is valid ."
5276,"function getDog ( uint256 _id ) external view returns ( uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint8 variation , uint256 gen0 ) { Dog storage dog = dogs [ _id ] ; cooldownIndex = uint256 ( dog . cooldownIndex ) ; nextActionAt = uint256 ( dog . cooldownEndBlock ) ; siringWithId = uint256 ( dog . siringWithId ) ; birthTime = uint256 ( dog . birthTime ) ; matronId = uint256 ( dog . matronId ) ; sireId = uint256 ( dog . sireId ) ; generation = uint256 ( dog . generation ) ; genes = uint256 ( dog . genes ) ; variation = uint8 ( dog . variation ) ; gen0 = uint256 ( dog . gen0 ) ; }",Returns all the relevant information about a specific Dog .
5279,"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) onlyPermissionManager ( _app , _role ) public { require ( ! hasPermission ( _entity , _app , _role ) ) ; bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }",Grants ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
5280,"function getAmountOfUnlockedTokens ( address _tokenOwner ) public returns ( uint ) { uint balanceAvailable = mBalances [ _tokenOwner ] ; if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil > block . timestamp ) { balanceAvailable = balanceAvailable . sub ( mLockedBalances [ _tokenOwner ] . amount ) ; } else if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil < block . timestamp ) { mLockedBalances [ _tokenOwner ] = lockedTokens ( { amount : 0 , timeLockedUntil : 0 } ) ; } return balanceAvailable ; }",Helper function that returns the amount of tokens aof an owner minus the amount currently locked
5282,"function __callback ( bytes32 myid , string result ) public closeOrDuringCrowdsale { if ( msg . sender != oraclize_cbAddress ( ) ) revert ( ) ; uint256 usdRate = parseInt ( result , 18 ) ; require ( usdRate > 0 ) ; ethUsd = usdRate ; LogRateUpdate ( ethUsd , now ) ; if ( hasEnded ( ) == true ) { currentStage = Stage . Finished ; } else { updateEthRate ( ) ; lastOracleUpdate = now ; } }","ETH/USD rate is receivd and converted to wei , this functions is used also to automatically update the stage status"
5283,"function getTuber ( uint256 _tokenId ) public view returns ( string tuberName , uint256 sellingPrice , address owner ) { Tuber storage tuber = tubers [ _tokenId ] ; tuberName = tuber . name ; sellingPrice = tuberIndexToPrice [ _tokenId ] ; owner = tuberIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific tuber .
5287,function feePool ( ) external view returns ( uint ) { return tokenState . balanceOf ( FEE_ADDRESS ) ; },Collected fees sit here until they are distributed .
5288,function proxyPayment ( address _owner ) public payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; },` proxyPayment ( ) ` allows the caller to send ether to the TokenSale and have the tokens created in an address of their choosing
5289,"function finalizeCampaign ( ) public onlyController { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; uint256 drewardTokens = ( tokensGenerated . mul ( PRCT100_D_TEAM ) ) . div ( 10000 ) ; uint256 rrewardTokens = ( tokensGenerated . mul ( PRCT100_R_TEAM ) ) . div ( 10000 ) ; uint256 r2rewardTokens = ( tokensGenerated . mul ( PRCT100_R2 ) ) . div ( 10000 ) ; uint256 mmrewardTokens = FIXEDREWARD_MM ; do_grant_tokens ( dteamVaultAddr1 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr2 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr3 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr4 , drewardTokens ) ; do_grant_tokens ( rteamVaultAddr , rrewardTokens ) ; do_grant_tokens ( r2VaultAddr , r2rewardTokens ) ; do_grant_tokens ( mmVaultAddr , mmrewardTokens ) ; uint256 reserveTokens = hardcap . sub ( tokensGenerated ) ; do_grant_tokens ( reserveVaultAddr , reserveTokens ) ; token . finalize ( ) ; tFinalized = now ; Finalized ( tFinalized ) ; }","Finalizes the campaign Get funds out , generates team , reserve and reserve tokens"
5293,"function setSuccess ( ) external onlyAdmin returns ( bool ) { require ( ! targetReached , ""Access is denied."" ) ; targetReached = true ; emit TargetReached ( ) ; }",This function signifies that the minimum fundraising target was met.Please note that this can only be called once .
5294,function setUpgradedContractAddress ( address _upgradedContractAddress ) external onlyOwner whenPaused { upgradedContractAddress = _upgradedContractAddress ; ContractUpgrade ( _upgradedContractAddress ) ; },"Only to be used when this contract is significantly broken , and an upgrade is required ."
5295,function getCraftTokenAddress ( uint256 _tokenId ) public view returns ( address masterErc20 ) { masterErc20 = emojiCraftTokenAddress [ _tokenId ] ; },Returns all the relevant information about a specific emoji .
5296,"function remove ( List storage self , address node ) internal { require ( isInList ( self , node ) , ""not in list"" ) ; if ( node == NULL ) { return ; } address p = self . list [ node ] . previous ; address n = self . list [ node ] . next ; self . list [ p ] . next = n ; self . list [ n ] . previous = p ; self . list [ node ] . inList = false ; delete self . list [ node ] ; }","Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node ."
5297,"function rateIsStale ( bytes4 currencyKey ) external view returns ( bool ) { if ( currencyKey == ""sUSD"" ) return false ; return lastRateUpdateTimes [ currencyKey ] . add ( rateStalePeriod ) < now ; }",Check if a specific currency 's rate has n't been updated for longer than the stale period .
5298,"function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { require ( _balanceOf [ _owner ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly"
5299,function transferOwnership ( address _newOwner ) public onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } },Transfer ownership from ` owner ` to ` newOwner `
5300,"function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( 0x150b7a02 ) ; } }",Last callback used to accept the ERC721 parcel tokens
5302,"function _multisig ( bytes32 _args , uint _block ) internal returns ( uint _code ) { bytes32 _txHash = _getKey ( _args , _block ) ; address _manager = getPendingManager ( ) ; _code = PendingManager ( _manager ) . hasConfirmedRecord ( _txHash ) ; if ( _code != NO_RECORDS_WERE_FOUND ) { return _code ; } if ( OK != PendingManager ( _manager ) . addTx ( _txHash , msg . sig , address ( this ) ) ) { revert ( ) ; } return MULTISIG_ADDED ; }",Sign current transaction and add it to transaction pending queue
5303,function _closeMotion ( uint motionID ) internal { delete targetMotionID [ motionTarget [ motionID ] ] ; delete motionTarget [ motionID ] ; delete motionStartTime [ motionID ] ; delete votesFor [ motionID ] ; delete votesAgainst [ motionID ] ; emit MotionClosed ( motionID ) ; },clear all data associated with a motionID for hygiene purposes .
5304,function setSellPrice ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellPrice = priceInWei ; },Set the current sell price in wei for one metadollar
5305,"function withdrawPayments ( address payee ) external nonReentrant onlyController requiresState ( State . REFUNDING ) { uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }","withdraw accumulated balance , called by payee in case crowdsale failed"
5307,"function internalAddInterest ( Loan storage loan , uint256 timestamp ) internal { if ( timestamp > loan . interestTimestamp ) { uint256 newInterest = loan . interest ; uint256 newPunitoryInterest = loan . punitoryInterest ; uint256 newTimestamp ; uint256 realDelta ; uint256 calculatedInterest ; uint256 deltaTime ; uint256 pending ; uint256 endNonPunitory = min ( timestamp , loan . dueTime ) ; if ( endNonPunitory > loan . interestTimestamp ) { deltaTime = endNonPunitory - loan . interestTimestamp ; if ( loan . paid < loan . amount ) { pending = loan . amount - loan . paid ; } else { pending = 0 ; } ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRate , pending ) ; newInterest = safeAdd ( calculatedInterest , newInterest ) ; newTimestamp = loan . interestTimestamp + realDelta ; } if ( timestamp > loan . dueTime ) { uint256 startPunitory = max ( loan . dueTime , loan . interestTimestamp ) ; deltaTime = timestamp - startPunitory ; uint256 debt = safeAdd ( loan . amount , newInterest ) ; pending = min ( debt , safeSubtract ( safeAdd ( debt , newPunitoryInterest ) , loan . paid ) ) ; ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRatePunitory , pending ) ; newPunitoryInterest = safeAdd ( newPunitoryInterest , calculatedInterest ) ; newTimestamp = startPunitory + realDelta ; } if ( newInterest != loan . interest || newPunitoryInterest != loan . punitoryInterest ) { loan . interestTimestamp = newTimestamp ; loan . interest = newInterest ; loan . punitoryInterest = newPunitoryInterest ; } } }",Computes loan interest Computes the punitory and non-punitory interest of a given loan and only applies the change .
5308,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
5309,function deedUri ( uint256 _deedId ) external pure returns ( string _uri ) ;,A distinct URI ( RFC 3986 ) for a given token .
5312,function enableTransfers ( bool _transfersEnabled ) public ;,Enables token holders to transfer their tokens freely if true
5313,function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; buyPrice = initialBuyPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; },update the price based on the remaining count of resources
5314,"function changeNonAccreditedLimit ( address [ ] _investors , uint256 [ ] _nonAccreditedLimit ) public onlyOwner { require ( _investors . length == _nonAccreditedLimit . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _nonAccreditedLimit [ i ] > 0 , ""Limit can not be 0"" ) ; nonAccreditedLimitUSDOverride [ _investors [ i ] ] = _nonAccreditedLimit [ i ] ; emit SetNonAccreditedLimit ( _investors [ i ] , _nonAccreditedLimit [ i ] ) ; } }",Modifies the list of overrides for non-accredited limits in USD
5315,function setETHPriceManually ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; m_ETHPriceInCents = _price ; m_ETHPriceLastUpdate = getTime ( ) ; NewETHPrice ( m_ETHPriceInCents ) ; },"set the price of ETH in cents , called in case we do n't get oraclize data for more than double the update interval"
5316,function findPledge ( uint64 idPledge ) internal returns ( Pledge storage ) { require ( idPledge < pledges . length ) ; return pledges [ idPledge ] ; },A getter to look up a Pledge 's details
5318,"function authorizePayment ( string _description , address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . description = _description ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }",only ` allowedSpenders [ ] ` Creates a new ` Payment `
5321,function tokenURI ( uint256 _tokenId ) public view returns ( string ) { require ( exists ( _tokenId ) ) ; return tokenURIBase ; },"The user/developper needs to add the tokenID , in the end of URL , to use the URI and get all details ."
5322,"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }",Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
5323,"function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { address ofAsset = requestedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; ErrorMessage ( ""CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy"" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint j = 0 ; j < ownershipQuantities . length ; ++ j ) { if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ j ] ) ) { revert ( ) ; } } Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }",Redeems by allocating an ownership percentage only of requestedAssets to the participant
5324,function invokeOnceFor ( address _invoker ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
5327,function proxyPayment ( address ) payable returns ( bool ) { return false ; },Called when ` _owner ` sends ether to the MiniMe Token contract
5329,function getInstructions ( ) public view returns ( string ) ;,Get the Instructions that helped to used the module
5333,function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) ;,Get the IDs of all available attribute types on the jurisdiction .
5334,"function getPreviousDarknodes ( address _start , uint256 _count ) external view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodesPreviousEpoch ; } return getDarknodesFromEpochs ( _start , count , true ) ; }",Retrieves a list of darknodes which were registered for the previous epoch .
5335,"function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 numberInvestors = ISecurityToken ( securityToken ) . getInvestorsLength ( ) ; for ( uint256 i = _start ; i < Math . min256 ( numberInvestors , _start . add ( _iterations ) ) ; i ++ ) { address payee = ISecurityToken ( securityToken ) . investors ( i ) ; if ( ! dividend . claimed [ payee ] ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }",Issuer can push dividends using the investor list from the security token
5336,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;",Send ` _amount ` of tokens from ` _from ` to ` _to ` on the condition it is approved by ` _from `
5337,function getPendingAmount ( uint index ) public returns ( uint256 ) { addInterest ( index ) ; return getRawPendingAmount ( index ) ; },"Returns the pending amount to complete de payment of the loan , keep in mind that this number increases every second ."
5339,"function setOfferExpiry ( uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . expiry = expiry ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }",Modify the expiry date of an existing ask .
5341,"function releaseTokensFromEscrowForUser ( address _payer , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _payer , _amount ) ; emit TokenMarketplaceWithdrawal ( _payer , _amount ) ; }",Release tokens back to payer 's available balance
5342,"function collect ( ) public { assert ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = apt . balanceOfAt ( msg . sender , pre_sale_fixed_at ) ; uint256 total = totalCollected . add ( aix . balanceOf ( address ( this ) ) ) ; uint256 amount = total . mul ( balance ) . div ( apt . totalSupplyAt ( pre_sale_fixed_at ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( aix . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }",This method should be called by the APT holders to collect their corresponding AIXs
5345,function balanceUpdatesCount ( address account ) public view returns ( uint256 ) { return balanceBlocks [ account ] . length ; },Get the count of balance updates for the given account
5346,"function initializeCrowdsale ( uint256 _startTime , uint256 _endTime , address _token , uint256 _intervalUpdate ) public payable onlyOwner mustBeAtStage ( Stage . ToInitialize ) { require ( _startTime >= now ) ; require ( _endTime >= _startTime ) ; require ( _token != address ( 0 ) ) ; require ( msg . value > 0 ) ; require ( isContract ( _token ) == true ) ; require ( _intervalUpdate >= 5 ) ; startTime = _startTime ; endTime = _endTime ; token = Token ( _token ) ; intervalUpdate = _intervalUpdate ; currentStage = Stage . Waiting ; updateEthRateWithDelay ( startTime - ( intervalUpdate + 30 ) ) ; LogCrowdsaleInit ( ) ; assert ( token . balanceOf ( address ( this ) ) == MAX_TOKENS ) ; }",You must send some ETH to cover the oraclize_query fees
5347,function getStartDateOfCampaign ( bytes32 bidId ) public view returns ( uint startDate ) { return advertisementStorage . getCampaignStartDateById ( bidId ) ; },Get the start date of a campaign Based on the Campaign id return the value ( in miliseconds ) corresponding to the start Date of the campaign .
5348,function goalReached ( ) public constant returns ( bool ) { return tokensRaised >= minimumGoal ; },To see if the minimum goal of tokens of the ICO has been reached
5349,"function transfer ( address _to , uint256 _amount ) public returns ( bool ) ;",Send ` _amount ` of tokens from ` msg.sender ` to ` _to `
5353,"function _investAsEarlybird ( address _beneficiary , uint256 _amountTokens ) internal { tokensBoughtInEarlybird = tokensBoughtInEarlybird . add ( _amountTokens ) ; earlybird . addAmountBoughtAsMember ( _beneficiary , _amountTokens ) ; _depositTokens ( _beneficiary , _amountTokens ) ; emit BoughtEarlyBird ( _beneficiary , _amountTokens ) ; if ( tokensBoughtInEarlybird >= INITIAL_EARLYBIRD_TOKENS ) { earlybirdEnded = true ; } }",Internal function for investing as a earlybird member
5354,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ _from ] = _balance [ _from ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; _allowed [ _from ] [ msg . sender ] = _allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfers ` _value ` amount of tokens from address ` _from ` to address ` _to ` .
5355,function settleCurrentLockPeriod ( address _address ) private returns ( bool ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; mintedActFromPastLockPeriodsPerUser [ _address ] = mintedActFromPastLockPeriodsPerUser [ _address ] . add ( mintedActFromCurrentLockPeriodPerUser [ _address ] ) ; mintedActPerUser [ _address ] = totalMintedActPerLockedBbkToken ; return true ; },Transfers `` Current Lock Period '' balance sheet to `` Past Lock Periods '' balance sheet .
5356,"function release ( uint256 _amount ) public { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; if ( ! withdrawalsInitiated ) { unlocked = balance . div ( 2 ) ; withdrawalsInitiated = true ; } if ( now >= releaseTime ) { unlocked = balance ; } require ( _amount <= unlocked ) ; unlocked = unlocked . sub ( _amount ) ; token . safeTransfer ( beneficiary , _amount ) ; }",Transfers tokens held by timelock to beneficiary .
5358,function closeSetup ( ) ;,Function to close the setup procedure of this contract
5361,function revokeAttribute ( address account ) external onlyCareCoordinators { require ( _revokeAttribute ( account ) ) ; },Revoke an attribute from the type with the default ID from ` msg.sender ` on the jurisdiction .
5362,"function batchAddToWhitelist ( uint maxBuyinQuantity , address [ ] whitelistants ) pre_cond ( isOwner ( ) ) pre_cond ( now < endTime ) { for ( uint i = 0 ; i < whitelistants . length ; ++ i ) { whitelistantToMaxBuyin [ whitelistants [ i ] ] = maxBuyinQuantity ; } }",Add batch addresses to whitelist with set maxBuyinQuantity
5364,"function setNextPriceOf ( uint256 tokenId , uint256 salePrice ) external whenNotPaused { require ( msg . sender == address ( saleAuction ) ) ; masterpieceToPrice [ tokenId ] = computeNextPrice ( salePrice ) ; }",This contract does n't handle setting the Masterpiece 's next listing price .
5366,"function emergencyCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator onlyInactiveState { _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }","Cancels an offer requiring the owner 's signature , so that the tokens can be withdrawn using ` emergencyWithdraw ` ."
5367,"function batchApprove ( address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( msg . sender , _tokenId ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; } }",Change or reaffirm the approved address for an NFT
5368,"function contestForUser ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) private { if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } emit AttestationRejected ( _attester , _requester ) ; }",Private function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId
5369,function getRewardsBalance ( address _user ) public view returns ( uint256 _balance ) { return ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( _user ) ; },Get user 's balance of funds obtainded by rewards Anyone can call this function and get the rewards balance of a certain user .
5370,function getBlockOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return miners [ _miner ] . block ; },Return the block in which the miner is
5371,"function issueMaxSynths ( bytes4 currencyKey ) external optionalProxy { uint maxIssuable = remainingIssuableSynths ( messageSender , currencyKey ) ; issueSynths ( currencyKey , maxIssuable ) ; }",Issue the maximum amount of Synths possible against the sender 's SNX .
5373,function sealed ( ) constant returns ( bool ) { return tokenController == 0 ; },` sealed ( ) ` checks to see if the the Campaign has been sealed
5374,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= allowance || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed [ _from ] [ msg . sender ] != MAX_UINT256 && _from != msg . sender ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; return true ; }",send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
5375,"function addAttributeType ( uint256 ID , string description ) external ;",Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
5377,"function __approve ( address _spender , uint _value , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyApprove ( _spender , _value , smbl , _sender ) == OK ; }",Performs allowance setting call on the platform by the name of specified sender .
5379,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _data , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""Cannot send to contract without ERC777TokensRecipient"" ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
5380,"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( isMasternodeOwner ( msg . sender ) ) ; require ( tokens [ token ] [ msg . sender ] == amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; deleteMasternode ( getLastPerUser ( msg . sender ) ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }",Public function that allows any user to withdraw deposited tokens and stop as masternode
5381,"function migrate ( uint256 _value ) external onlyUnlocked ( ) { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }",Migrate tokens to the new token contract .
5384,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; doTransfer ( _from , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
5385,"function createDividend ( uint256 _maturity , uint256 _expiry , bytes32 _name ) external payable withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , excluded , _name ) ; }","Creates a dividend and checkpoint for the dividend , using global list of excluded addresses"
5386,function amountReceivedFromTransfer ( uint value ) external view returns ( uint ) { return value . divideDecimal ( transferFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; },The amount the recipient will receive if you send a certain number of tokens .
5388,"function approve ( address spender , uint256 value ) returns ( bool success ) { allowance [ msg . sender ] [ spender ] = value ; return true ; }",Allow another contract to spend some tokens in your behalf
5389,"function name ( ) public pure returns ( string ) { return ""Pirate Conquest Token"" ; }",A descriptive name for a collection of NFTs in this contract
5390,"function tokensBoughtWithBTC ( address _beneficiary , uint256 _tokens ) public payable { require ( msg . sender == btcTokenBoughtAddress ) ; require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; require ( _tokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , _tokens ) ; } else { _investAsBonusProgram ( _beneficiary , _tokens ) ; } }",Public payable function to buy tokens during sale or emission
5391,"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _addedValue >= 1000 , ""must approve more than 1000 sip"" ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }",Increase the amount of tokens that an owner allowed to a spender .
5392,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered ."
5393,function setMinter ( address _who ) public onlyValidator { _setMinter ( _who ) ; },Sets the necessary permissions for a user to mint tokens .
5394,function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( guaranteedBuyersLimit [ _th ] > 0 ) { buyGuaranteed ( _th ) ; } else { buyNormal ( _th ) ; } return true ; },This method will generally be called by the SNT token contract to acquire SNTs .
5395,"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard external { require ( _idPayment < authorizedPayments . length ) ; require ( _delay <= 10 ** 18 ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( p . securityGuardDelay + _delay <= maxSecurityGuardDelay ) ; require ( ! p . paid ) ; require ( ! p . canceled ) ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }",` onlySecurityGuard ` Delays a payment for a set number of seconds
5396,function setVault ( address _newVaultAddress ) onlyOwner { vaultAddress = _newVaultAddress ; },` onlyOwner ` changes the location that ether is sent
5397,"function release ( ) public { require ( now >= releaseTime ) ; assert ( current_month <= 5 ) ; uint diff = now - releaseTime ; if ( diff > month ) { releaseTime = now ; } else { releaseTime = now . add ( month . sub ( diff ) ) ; } current_month ++ ; token . safeTransfer ( beneficiary , twenty_percent_of_amount ) ; }",Transfers tokens held by timelock to beneficiary .
5400,function begin ( ) external view onlyOwner returns ( address ) { return LinkedList . begin ( darknodes ) ; },Returns the address of the first darknode in the store
5402,"function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount , ""You can only use tokens using the granularity currently set."" ) ; }",Internal function that ensures ` _amount ` is multiple of the granularity
5403,function finishMinting ( ) internal returns ( bool ) { require ( finalized == true ) ; require ( super . finishMinting ( ) ) ; return true ; },Overrides finishMinting function from RBACMintableTokenMixin to prevent finishing minting before finalization
5405,"function removeTokensFromAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused internal returns ( bool ) { balances [ _uuid ] = balances [ _uuid ] . sub ( _tokensCount ) ; return true ; }",Function for removing tokens from specified account .
5406,function getTotalRewards ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . rewardsCumulative [ _lastIndex ] ; },Returns all rewards charged for the given canvas .
5408,"function batchTransferFrom ( address _from , address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; } }",Transfer ownership of a batch of NFTs -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
5409,"function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByTypeAndToken ( _moduleType , _securityToken ) ; return _tagsByModules ( modules ) ; }",Returns all the tags related to the a module type which are valid for the given token
5412,function noError ( ) public onlyGameManager whenPaused { error = false ; },This is public rather than external so it can be called by derived contracts .
5414,"function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferFromWithReference ( _from , _to , _value , smbl , _reference , _sender ) == OK ; }",Performs allowance transfer call on the platform by the name of specified sender .
5415,"function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || getCommitHash ( msg . sender , _prevPollID ) != 0 ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , ""numTokens"" , _numTokens ) ; store . setAttribute ( UUID , ""commitHash"" , uint ( _secretHash ) ) ; VoteCommitted ( msg . sender , _pollID , _numTokens ) ; }",Commits vote using hash of choice and secret salt to conceal vote until reveal
5417,"function burn ( uint256 _value , uint256 _confirmation ) onlyOwner public returns ( bool success ) { require ( _confirmation == 7007 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; emit Burn ( msg . sender , _value ) ; return true ; }",Only central mint can burn from their own supply
5418,function updateTimeLock ( uint256 _timelockEndTime ) onlyOwner public returns ( bool ) { timelockEndTime = _timelockEndTime ; emit UpdateTimeLock ( _timelockEndTime ) ; return true ; },Called by owner to alter the token timelock
5419,"function checkBtcRequestSignature ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getBtcRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }",Checks the validity of a Bitcoin signed request & the expiration date .
5420,"function emitTransfer ( address _from , address _to , uint _value ) onlyChronoBankPlatform public { emit Transfer ( _from , _to , _value ) ; }",Emits ERC20 Transfer event on this contract .
5423,"function freeze ( address _target , uint256 _frozenAmount , uint256 _releaseAmount ) byToken public returns ( bool ) { require ( _target != 0x0 ) ; require ( _frozenAmount > 0 ) ; require ( _releaseAmount < _frozenAmount ) ; totalFrozen = totalFrozen . add ( _frozenAmount ) ; FrozenStatus storage frozenStatus = frozenStatuses [ _target ] ; require ( frozenStatus . frozenAmount == 0 ) ; frozenStatus . frozenTimestamp = now ; frozenStatus . frozenAmount = _frozenAmount ; frozenStatus . releaseAmount = _releaseAmount ; FreezeTokens ( _target , _frozenAmount ) ; return true ; }",Freeze _frozenAmount of tokens held by _target with PeriodicReleaseLock .
5425,function getBudgetOfCampaign ( bytes32 bidId ) public view returns ( uint budget ) { return advertisementStorage . getCampaignBudgetById ( bidId ) ; },Get the budget avaliable of a campaign Based on the Campaign id return the total value avaliable to pay for proofs of attention .
5426,function claimByAddress ( address _address ) public returns ( bool ) { return claimInternal ( _address ) ; },Withdraw ( for cold storage wallet ) a bid that was overbid and platform owner share
5427,"function transfer ( address _to , uint _value ) returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` msg.sender `
5430,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Sufficent Allowance is not provided"" ) ; require ( USDTieredSTOProxyAddress != address ( 0 ) , ""Proxy contract should be pre-set"" ) ; address usdTieredSTO = IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . deploySTO ( msg . sender , address ( polyToken ) , address ( this ) ) ; require ( Util . getSig ( _data ) == IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . getInitFunction ( usdTieredSTO ) , ""Invalid data"" ) ; require ( address ( usdTieredSTO ) . call ( _data ) , ""Unsuccessfull call"" ) ; emit GenerateModuleFromFactory ( usdTieredSTO , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( usdTieredSTO ) ; }",Used to launch the Module with the help of factory
5431,"function addAttribute ( uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable ;","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account of ` msg.sender ` by passing in a signed attribute approval with signature ` signature ` ."
5432,function setMinStandingBalance ( uint balance ) external onlyOwner { minStandingBalance = balance ; },Set the minimum required havven balance to have standing to bring a motion .
5434,function claimed ( address investor ) public { delete _commitments [ msg . sender ] [ investor ] ; },may be used by commitment contract to refund gas for commitment bookkeeping
5435,"function generateTokens ( address _owner , uint _amount ) public returns ( bool ) ;",Generates ` _amount ` tokens that are assigned to ` _owner `
5436,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( ( _value != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) { return false ; } allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
5438,"function takeOrder ( uint exchangeNumber , uint id , uint receiveQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { Order memory order ; ( order . sellAsset , order . buyAsset , order . sellQuantity , order . buyQuantity ) = exchanges [ exchangeNumber ] . exchangeAdapter . getOrder ( exchanges [ exchangeNumber ] . exchange , id ) ; require ( order . sellAsset != address ( this ) ) ; require ( module . pricefeed . existsPriceOnAssetPair ( order . buyAsset , order . sellAsset ) ) ; require ( isInAssetList [ order . sellAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( order . buyAsset , order . sellAsset ) ; require ( isRecent ) ; require ( receiveQuantity <= order . sellQuantity ) ; uint spendQuantity = mul ( receiveQuantity , order . buyQuantity ) / order . sellQuantity ; require ( AssetInterface ( order . buyAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , spendQuantity ) ) ; require ( module . riskmgmt . isTakePermitted ( module . pricefeed . getOrderPrice ( order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) , referencePrice , order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( ""takeOrder(address,uint256,uint256)"" ) ) , exchanges [ exchangeNumber ] . exchange , id , receiveQuantity ) ) ; if ( ! isInAssetList [ order . sellAsset ] ) { ownedAssets . push ( order . sellAsset ) ; isInAssetList [ order . sellAsset ] = true ; } order . exchangeId = id ; order . status = OrderStatus . fullyFilled ; order . orderType = OrderType . take ; order . timestamp = now ; order . fillQuantity = receiveQuantity ; orders . push ( order ) ; OrderUpdated ( id ) ; }",Takes an active order on the selected exchange
5441,function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; },Get the tags related to the module factory
5444,"function setCampaignOwnerById ( bytes32 bidId , address newOwner ) public onlyIfCampaignExists ( ""setCampaignOwnerById"" , bidId ) onlyIfWhitelisted ( ""setCampaignOwnerById"" , msg . sender ) { campaigns [ bidId ] . setOwner ( newOwner ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign ."
5445,function setPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; },Allow users to buy tokens for ` newBuyPrice ` eth
5446,"function withdrawTokens ( ) onlyOwner public returns ( bool ) { require ( token . transfer ( owner , token . balanceOf ( this ) ) ) ; return true ; }",Failsafe transfer of tokens for the team to owner wallet .
5448,"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }",Multisig msg.value ether into a multisig and set unlockTime
5449,"function renounceOwner ( ) public onlyOwner { emit TransferredOwner ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }",Renouncing to ownership will leave the contract without an owner .
5451,"function ownersOfArea ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( address [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= WIDTH && y2 <= HEIGHT ) ; result = new address [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = 0 ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 tokenId = i * WIDTH ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = pixelIndexToOwner [ tokenId + j ] ; r ++ ; } } }",Returns the addresses currently assigned ownership of the given pixel area .
5452,"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }",Checks whether redemption is permitted for a participant
5453,"function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }",The orders in this function have been wrapped in structs to reduce the local variable count
5454,function isOps ( address _address ) internal view returns ( bool ) { return ( opsAddress != address ( 0 ) && _address == opsAddress ) || isOwner ( _address ) ; },check If the sender is the ops address .
5458,function setClaimDividendPercentage ( uint256 _claimDividendPercentage ) external onlyCFO { require ( 10000 <= _claimDividendPercentage && _claimDividendPercentage <= 100000 ) ; claimDividendPercentage = _claimDividendPercentage ; },Sets the new dividend percentage for unclaimed plots .
5459,"function initializeTokenSale ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary ) public ownerOnly { initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }",Begins the token sale for this token instance
5461,"function _supportsERC165Interface ( address account , bytes4 interfaceId ) private view returns ( bool ) { ( bool success , bool result ) = _callERC165SupportsInterface ( account , interfaceId ) ; return ( success && result ) ; }","Query if a contract implements an interface , does not check ERC165 support"
5463,"function register ( address _darknodeID , bytes _publicKey , uint256 _bond ) external onlyRefunded ( _darknodeID ) { require ( _bond >= minimumBond , ""insufficient bond"" ) ; require ( ren . transferFrom ( msg . sender , address ( this ) , _bond ) , ""bond transfer failed"" ) ; ren . transfer ( address ( store ) , _bond ) ; store . appendDarknode ( _darknodeID , msg . sender , _bond , _publicKey , currentEpoch . blocknumber + minimumEpochInterval , 0 ) ; numDarknodesNextEpoch += 1 ; emit LogDarknodeRegistered ( _darknodeID , _bond ) ; }",Register a darknode and transfer the bond to this contract .
5465,"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _amount ) ; Approve ( msg . sender , _spender , _amount ) ; return true ; }",Used to approve someone to spend funds on your behalf
5466,function ( ) public payable { deposit ( msg . sender ) ; },The user sends Ether to the pool .
5468,"function balanceBlocksIn ( address account , uint256 startBlock , uint256 endBlock ) public view returns ( uint256 ) { require ( startBlock < endBlock ) ; require ( account != address ( 0 ) ) ; if ( balanceBlockNumbers [ account ] . length == 0 || endBlock < balanceBlockNumbers [ account ] [ 0 ] ) return 0 ; uint256 i = 0 ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < startBlock ) i ++ ; uint256 r ; if ( i >= balanceBlockNumbers [ account ] . length ) r = balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( startBlock ) ) ; else { uint256 l = ( i == 0 ) ? startBlock : balanceBlockNumbers [ account ] [ i - 1 ] ; uint256 h = balanceBlockNumbers [ account ] [ i ] ; if ( h > endBlock ) h = endBlock ; h = h . sub ( startBlock ) ; r = ( h == 0 ) ? 0 : balanceBlocks [ account ] [ i ] . mul ( h ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( l ) ) ; i ++ ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < endBlock ) { r = r . add ( balanceBlocks [ account ] [ i ] ) ; i ++ ; } if ( i >= balanceBlockNumbers [ account ] . length ) r = r . add ( balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] ) ) ) ; else if ( balanceBlockNumbers [ account ] [ i - 1 ] < endBlock ) r = r . add ( balanceBlocks [ account ] [ i ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) ) ; } return r ; }","Calculate the amount of balance blocks , i.e ."
5471,"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }","Adds two numbers , throws on overflow ."
5472,function pricesAreStale ( ) public view returns ( bool ) { return lastPriceUpdateTime . add ( priceStalePeriod ) < now ; },Check if the prices have n't been updated for longer than the stale period .
5475,function changeHatchEscapeCaller ( address _newEscapeHatchCaller ) public onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; },Changes the address assigned to call ` escapeHatch ( ) `
5477,function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ( ) ) { return true ; } return admins [ _address ] ; },Checks if an address is an administrator .
5478,"function setExchangeRate ( uint256 _sellExchangeRate , uint256 _buyExchangeRate ) onlyOwner public { sellExchangeRate = _sellExchangeRate ; buyExchangeRate = _buyExchangeRate ; }",Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth
5479,"function authorizePayment ( bytes32 _ref , address _dest , uint _amount ) public onlyLiquidPledging returns ( uint ) { uint idPayment = payments . length ; payments . length ++ ; payments [ idPayment ] . state = PaymentStatus . Pending ; payments [ idPayment ] . ref = _ref ; payments [ idPayment ] . dest = _dest ; payments [ idPayment ] . amount = _amount ; AuthorizePayment ( idPayment , _ref , _dest , _amount ) ; if ( autoPay ) { doConfirmPayment ( idPayment ) ; } return idPayment ; }","` onlyLiquidPledging ` authorizes payments from this contract , if ` autoPay == true ` the transfer happens automatically ` else ` the ` owner ` must call ` confirmPayment ( ) ` for a transfer to occur ( training wheels ) ; either way , a new payment is added to ` payments [ ] `"
5480,function reclaimTokenOwnership ( ) onlyOwner public { token . claimOwnership ( ) ; },Allows transfer token ownership back to distribution contract
5481,"function transferAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ;",Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver
5483,"function addProject ( string name , string url , address projectAdmin , uint64 parentProject , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idProject ) { require ( isValidPlugin ( plugin ) ) ; if ( parentProject != 0 ) { PledgeAdmin storage pa = findAdmin ( parentProject ) ; require ( pa . adminType == PledgeAdminType . Project ) ; require ( getProjectLevel ( pa ) < MAX_SUBPROJECT_LEVEL ) ; } idProject = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Project , projectAdmin , name , url , commitTime , parentProject , false , plugin ) ) ; ProjectAdded ( idProject ) ; }",Creates a Project Admin with the ` msg.sender ` as the Admin addr
5484,"function approve ( address spender , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { require ( spender != address ( 0 ) , ""Approvals for 0x0 disallowed."" ) ; allowance [ msg . sender ] [ spender ] = quantity ; emit Approval ( msg . sender , spender , quantity ) ; return true ; }",ERC20 approve function ; approves ` spender ` to transfer up to ` quantity ` tokens on the sender 's behalf .
5487,"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 25 ) ) ; canExtract = total . percent ( 25 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 50 ) ) ; canExtract = total . percent ( 50 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 9 ) ) && getTime ( ) <= finalizedTime . add ( months ( 12 ) ) ) { require ( collectedTokens < total . percent ( 75 ) ) ; canExtract = total . percent ( 75 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }",The owner will call this method to extract the tokens
5490,function setNonlistedUser ( address _who ) public onlyValidator { _setNonlistedUser ( _who ) ; },Sets the necessary permissions for a `` nonlisted '' user .
5491,"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( abi . encodePacked ( _voteOption , _salt ) ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; pollMap [ _pollID ] . voteOptions [ msg . sender ] = _voteOption ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender , _salt ) ; }",Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
5492,"function createMarket ( string question , uint32 timeout , uint32 opening_ts , address asker , uint256 nonce , address designated_reporter ) onlyInitialized external payable { bytes32 question_id = keccak256 ( keccak256 ( template_id , opening_ts , question ) , this , timeout , asker , nonce ) ; require ( realitio_questions [ question_id ] . bounty > 0 , ""Arbitration must have been requested (paid for)"" ) ; require ( realitio_questions [ question_id ] . augur_market == IMarket ( 0x0 ) , ""The market must not have been created yet"" ) ; _callAugurMarketCreate ( question_id , question , designated_reporter ) ; }",Create a market in Augur and store the creator as its owner
5493,"function registerEOSAddress ( string eosAddress ) public { assert ( bytes ( eosAddress ) . length <= 64 ) ; eosAddressBook [ msg . sender ] = eosAddress ; emit LogRegisterEOSAddress ( msg . sender , eosAddress ) ; }","Associate a string , which represents an EOS address , to the Ethereum address of the entity interacting with the contract"
5494,function pauseIssuance ( ) public onlyOwner whenNotPaused whenIssuanceNotPaused { _issuancePaused = true ; emit IssuancePaused ( ) ; },Pause all issuance of new attributes by organizations .
5495,"function startTokenVotes ( address [ 15 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }",Admins are able to approve proposal that someone submitted
5497,"function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . wallets [ _holderId ] . balance ; }",Returns asset balance for a particular holder id .
5498,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) ;",will be called on ` _spender ` address
5499,"function depositEther ( ) external payable onlyActiveState { require ( msg . value > 0 , 'Invalid value' ) ; balances [ msg . sender ] [ etherAddr ] = balances [ msg . sender ] [ etherAddr ] . add ( msg . value ) ; emit BalanceIncrease ( msg . sender , etherAddr , msg . value , ReasonDeposit ) ; }",Deposits Ethereum tokens under the ` msg.sender ` 's balance
5500,"function approveAll ( address _to ) public { require ( _to != msg . sender , ""cant approve yourself"" ) ; require ( _to != address ( 0 ) , ""invalid owner"" ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; emit ApprovalForAll ( msg . sender , _to , true ) ; }",Approves another address to claim for the ownership of any tokens owned by this account
5501,"function _changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) internal { perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit ChangePermission ( _delegate , _module , _perm , _valid , now ) ; }",Used to provide/change the permission to the delegate corresponds to the module contract
5502,"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _subtractedValue >= 1000 , ""must approve more than 1000 sip"" ) ; uint256 oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
5503,"function setRegisteredAuthority ( string firmName , address authority , bool _authorized ) public onlyAuthority ( firmName , msg . sender ) returns ( bool success ) { require ( lib . setRegisteredAuthority ( firmName , authority , _authorized ) , ""Error: Failed to register authority for issuer firm with storage contract! Please check your arguments and ensure firmName is registered before allowing an authority of said firm"" ) ; return true ; }",Registers an authority asoociated with the given firm as true/false
5504,"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount > minDiscountEther && _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > secondTierDiscountUpperLimitEther && _etherAmount <= thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FOURTH_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }",Applies the discount based on the discount tiers
5505,"function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; ethernautsStorage . transfer ( _from , _to , _tokenId ) ; }","Transfer a Asset owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
5507,"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }",Transfers the ownership of a given token ID to another address
5509,"function _addTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status , bool _fromAdmin , uint256 _fee ) internal { _setTickerOwnership ( _owner , _ticker ) ; _storeTickerDetails ( _ticker , _owner , _registrationDate , _expiryDate , _tokenName , _status ) ; emit RegisterTicker ( _owner , _ticker , _tokenName , _registrationDate , _expiryDate , _fromAdmin , _fee ) ; }",Internal - Sets the details of the ticker
5511,function numberOfProposals ( ) public view returns ( uint ) { return tokenBatches . length ; },Get number of proposals so you can know which is the last one
5514,"function setFxBpsRate ( string currency , uint bpsRate , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setFxUSDBPSRate ( currency , bpsRate ) , ""Error: Unable to set FX USD basis points rate. Please ensure issuerFirm is authorized"" ) ; return true ; }",Set the foreign currency exchange rate to USD in basis points
5515,"function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner public { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }",Allow withdrawing any token other than the relevant one
5517,"function getFeeMin ( Data storage self , address contractAddress ) internal view returns ( uint feeMin ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }",Get the minimum fee of the contract address ; typically TokenIOFeeContract
5519,"function hasRole ( address addr , string role ) public view returns ( bool ) { return roles [ addr ] [ role ] ; }",Check if an address has a role .
5520,function withdrawPendingAmounts ( ) returns ( bool ) ;,"Function to get fees , shares or refund after the closing time of the funding proposals"
5521,"function calculatePrice ( uint [ ] _pickedAssets , address _owner ) public view returns ( uint ) { if ( _pickedAssets . length == 0 ) { return 0 ; } uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( _pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( _owner , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; } } return finalPrice ; }",Function to calculate final price for an image based on selected assets
5522,"function getAccountSpendingPeriod ( Data storage self , address account ) internal view returns ( uint period ) { bytes32 id = keccak256 ( abi . encodePacked ( 'limit.spending.period' , account ) ) ; return self . Storage . getUint ( id ) ; }",Get the Account Spending Period Limit as UNIX timestamp
5523,"function releaseTransfer ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 transferFromSha = keccak256 ( ""transferFrom"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 transferSha = keccak256 ( ""transfer"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( sha == transferSha || sha == transferFromSha ) ; require ( verify ( sha , v , r , s ) == true ) ; if ( transferFromSha == sha ) { address _spender = biometricAllowee [ sha ] ; address _from = biometricFrom [ sha ] ; address _to = biometricTo [ sha ] ; uint256 _value = biometricAmount [ sha ] ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ _spender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; } if ( transferSha == sha ) { super . transfer ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; } biometricCompleted [ sha ] = true ; return true ; }","Complete pending transfer , can only be called by msg.sender if it is the originator of Transfer"
5524,"function private_list_bytes_from_bytes ( bytes32 _current_item , uint256 _count , bool _including_current , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next ) private constant returns ( bytes32 [ ] _bytes32_items ) { uint256 _i ; uint256 _real_count = 0 ; bytes32 _last_item ; _last_item = _function_last ( ) ; if ( _count == 0 || _last_item == bytes32 ( 0x0 ) ) { _bytes32_items = new bytes32 [ ] ( 0 ) ; } else { bytes32 [ ] memory _items_temp = new bytes32 [ ] ( _count ) ; bytes32 _this_item ; if ( _including_current == true ) { _items_temp [ 0 ] = _current_item ; _real_count = 1 ; } _this_item = _current_item ; for ( _i = _real_count ; ( _i < _count ) && ( _this_item != _last_item ) ; _i ++ ) { _this_item = _function_next ( _this_item ) ; if ( _this_item != bytes32 ( 0x0 ) ) { _real_count ++ ; _items_temp [ _i ] = _this_item ; } } _bytes32_items = new bytes32 [ ] ( _real_count ) ; for ( _i = 0 ; _i < _real_count ; _i ++ ) { _bytes32_items [ _i ] = _items_temp [ _i ] ; } } }","A private function to lists a Bytes collection starting from some ` _current_item ` ( which could be included or excluded ) , in the forwards or backwards direction"
5525,"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = identifiers [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }",Returns a deed identifier of the owner at the given index .
5526,"function createAndJoinCDP ( ) public stoppable payable returns ( bytes32 id ) { require ( msg . value >= minETH ) ; gem . deposit . value ( msg . value ) ( ) ; id = _openAndJoinCDPWETH ( msg . value ) ; tub . give ( id , msg . sender ) ; }",create a CDP and join with the ETH sent to this function
5527,"function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( now < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached"
5528,"function finalize ( ) public onlyOwner initialized { require ( time ( ) >= startTime ) ; require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 tokensToSecondRound = 90000000 ether ; uint256 tokensToReserve = 90000000 ether ; uint256 tokensToAngelAndOther = 30000000 ether ; tokensToSecondRound = tokensToSecondRound . add ( maxFirstRoundTokenLimit ) . sub ( totalNormalTokenGenerated ) ; tokensToSecondRound = tokensToSecondRound . add ( maxIssueTokenLimit ) . sub ( totalIssueTokenGenerated ) ; uint256 totalTokens = 300000000 ether ; require ( totalTokens == ATT . totalSupply ( ) . add ( tokensToSecondRound ) . add ( tokensToReserve ) . add ( tokensToAngelAndOther ) ) ; assert ( ATT . generateTokens ( 0xb1 , tokensToSecondRound ) ) ; assert ( ATT . generateTokens ( 0xb2 , tokensToReserve ) ) ; assert ( ATT . generateTokens ( destTokensAngel , tokensToAngelAndOther ) ) ; ATT . changeController ( attController ) ; Finalized ( ) ; }",This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
5531,"function revoke ( bytes32 _key ) external returns ( uint ) { return _revoke ( _key , msg . sender ) ; }",Revoke vote for transaction Can be called only by authorized user
5534,function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . finalize_ts ; },Returns the timestamp at which the question will be/was finalized
5535,function isOwner ( address _address ) internal view returns ( bool ) { return ( _address == owner ) ; },checks If the sender is the owner of the contract .
5536,"function setNextGameSettings ( uint256 rows , uint256 cols , uint256 initialActivityTimer , uint256 finalActivityTimer , uint256 numberOfFlipsToFinalActivityTimer , uint256 timeoutBonusTime , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 firstBuyoutPrizePoolPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage , uint256 buyoutPriceIncreasePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; if ( numberOfFlipsToFinalActivityTimer == 0 ) { require ( initialActivityTimer == finalActivityTimer ) ; } nextGameSettings = GameSettings ( { rows : rows , cols : cols , initialActivityTimer : initialActivityTimer , finalActivityTimer : finalActivityTimer , numberOfFlipsToFinalActivityTimer : numberOfFlipsToFinalActivityTimer , timeoutBonusTime : timeoutBonusTime , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage : firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage , buyoutPriceIncreasePercentage : buyoutPriceIncreasePercentage } ) ; NextGame ( rows , cols , initialActivityTimer , finalActivityTimer , numberOfFlipsToFinalActivityTimer , timeoutBonusTime , unclaimedTilePrice , buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage , buyoutPriceIncreasePercentage ) ; }",Sets the settings for the next game .
5539,function proxyPayment ( address _owner ) payable returns ( bool ) { doPayment ( _owner ) ; return true ; },` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the tokens created in an address of their choosing
5541,"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , ""Error: Unsafe multiplication operation!"" ) ; return c ; }","Multiplies two numbers , throws on overflow ."
5542,"function updateLandData ( uint256 id , string data ) external returns ( bool ) { require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; ( int256 x , int256 y ) = land . decodeTokenId ( mortgages [ id ] . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }",Enables the owner of a parcel to update the data field
5543,"function setCampaignBudgetById ( bytes32 bidId , uint newBudget ) public onlyIfCampaignExists ( ""setCampaignBudgetById"" , bidId ) onlyIfWhitelisted ( ""setCampaignBudgetById"" , msg . sender ) { campaigns [ bidId ] . setBudget ( newBudget ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }","Set a new campaign budget Based on the Campaign id , updates the total value avaliable for proof of attention registrations ."
5545,"function setBool ( bytes32 _key , bool _value ) public onlyOwner returns ( bool success ) { boolStorage [ _key ] = _value ; return true ; }",Set value for Bool associated with bytes32 id key
5546,"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] ; }",Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
5547,"function setCreator ( address creator , bool authorized ) external onlyOwner returns ( bool ) { emit SetCreator ( creator , authorized ) ; creators [ creator ] = authorized ; return true ; }",Sets a new third party creator The third party creator can request loans for other borrowers .
5548,"function _revokeAttribute ( address account ) internal returns ( bool ) { _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; return true ; }",Revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
5549,"function addBalance ( address _owner , uint256 _balanceIncrease ) public onlyImpl { balances [ _owner ] = balances [ _owner ] + _balanceIncrease ; }",Adds ` _balanceIncrease ` to ` _owner ` 's balance .
5550,function isPresent ( bytes32 channelId ) public view returns ( bool ) { return ! isAbsent ( channelId ) ; },Check if the channel is present : in open or settling state .
5551,"function getChannelInfo ( address _sender_address , address _receiver_address , uint32 _open_block_number ) external view returns ( bytes32 , uint192 , uint32 , uint192 , uint192 ) { bytes32 key = getKey ( _sender_address , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; return ( key , channels [ key ] . deposit , closing_requests [ key ] . settle_block_number , closing_requests [ key ] . closing_balance , withdrawn_balances [ key ] ) ; }",Function for retrieving information about a channel .
5552,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
5554,"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""BURN"" ; }","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata ."
5557,"function setDefaultExcluded ( address [ ] _excluded ) public withPerm ( MANAGE ) { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many excluded addresses"" ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; for ( uint256 i = j + 1 ; i < _excluded . length ; i ++ ) { require ( _excluded [ j ] != _excluded [ i ] , ""Duplicate exclude address"" ) ; } } excluded = _excluded ; emit SetDefaultExcludedAddresses ( excluded , now ) ; }",Function to clear and set list of excluded addresses used for future dividends
5558,"function tokenURI ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( string _tokenURI ) { _tokenURI = ""https://tenthousandsu.com/erc721/00000.json"" ; bytes memory _tokenURIBytes = bytes ( _tokenURI ) ; _tokenURIBytes [ 33 ] = byte ( 48 + ( _tokenId / 10000 ) % 10 ) ; _tokenURIBytes [ 34 ] = byte ( 48 + ( _tokenId / 1000 ) % 10 ) ; _tokenURIBytes [ 35 ] = byte ( 48 + ( _tokenId / 100 ) % 10 ) ; _tokenURIBytes [ 36 ] = byte ( 48 + ( _tokenId / 10 ) % 10 ) ; _tokenURIBytes [ 37 ] = byte ( 48 + ( _tokenId / 1 ) % 10 ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
5559,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ;","This works identically to the other function with an extra data parameter , except this function just sets data to `` ''"
5560,"function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) public pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }","Compute '_k ( 1+1/_q ) ^ _n ' , with precision '_p '"
5561,"function removeListing ( uint64 _pixelconIndex ) public { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; require ( msg . sender == listing . seller || msg . sender == admin , ""Insufficient permissions"" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , seller , tokenId ) ; emit Remove ( _pixelconIndex , msg . sender ) ; }",Remove the PixelCon # ` ( _pixelconIndex ) ` listing from the market
5565,function balanceOf ( address _owner ) public view returns ( uint256 ) { return _balance [ _owner ] ; },Returns the balance of an account with address ` _owner ` .
5566,"function transfer ( address _to , uint256 _value ) returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from your account
5567,function getStorageAddress ( ) public view returns ( address storageContract ) { require ( msg . sender == address ( advertisementFinance ) ) ; return address ( advertisementStorage ) ; },Get Advertisement Storage Address used by this contract This function is required to upgrade Advertisement contract address on Advertisement Finance contract .
5568,function refund ( ) public returns ( bool ) { return refundTo ( msg . sender ) ; },Sends all contributed ether back if minimum cap is not reached by the end of crowdsale
5570,"function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 25 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }",Transfers awarded MILs to the caller 's account .
5571,function ableTransfer ( ) ;,Function to able the transfer of Dao shares or contractor tokens
5572,"function _approveEscrow ( bytes32 _id , uint256 _amount ) internal returns ( bool ) { claimable = claimable . add ( _amount ) ; claimableRewards [ _id ] = _amount ; return true ; }",approve reward amount for transfer from escrow contract to creator
5573,function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { },Returns the timeout in seconds used after each answer
5574,"function uncooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; require ( closing_requests [ key ] . settle_block_number == 0 ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; ChannelCloseRequested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }",Sender requests the closing of the channel and starts the challenge period .
5575,"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cityIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
5576,"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return false ; }","Notifies the controller about an approval , for this sale all approvals are allowed by default and no extra notifications are needed"
5577,"function getEIN ( address _address ) public view _hasIdentity ( _address , true ) returns ( uint ein ) { return associatedAddressDirectory [ _address ] ; }",Gets the EIN associated with the passed address .
5578,"function changeTreasury ( address _newTreasury ) external onlyOwner { treasury = _newTreasury ; emit ChangeTreasury ( msg . sender , _newTreasury ) ; }",allows owner to change the treasury in case of hack/lost keys .
5580,"function priceIsStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }",Check if the price of havvens has n't been updated for longer than the stale period .
5581,"function pause ( ) external whenNotPaused onlyOwner { set ( Encoder . getKey ( ""paused"" ) , true ) ; emit Pause ( now ) ; }","Called by the owner to pause , triggers stopped state"
5583,function setTrading ( bool status ) public onlyOwner { tradingLive = status ; },One-way toggle to allow trading ( remove global freeze )
5584,"function _internalExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress , bool chargeFee ) internal notFeeAddress ( from ) returns ( bool ) { require ( destinationAddress != address ( 0 ) , ""Zero destination"" ) ; require ( destinationAddress != address ( this ) , ""Synthetix is invalid destination"" ) ; require ( destinationAddress != address ( proxy ) , ""Proxy is invalid destination"" ) ; synths [ sourceCurrencyKey ] . burn ( from , sourceAmount ) ; uint destinationAmount = effectiveValue ( sourceCurrencyKey , sourceAmount , destinationCurrencyKey ) ; uint amountReceived = destinationAmount ; uint fee = 0 ; if ( chargeFee ) { amountReceived = feePool . amountReceivedFromExchange ( destinationAmount ) ; fee = destinationAmount . sub ( amountReceived ) ; } synths [ destinationCurrencyKey ] . issue ( destinationAddress , amountReceived ) ; if ( fee > 0 ) { uint xdrFeeAmount = effectiveValue ( destinationCurrencyKey , fee , ""XDR"" ) ; synths [ ""XDR"" ] . issue ( feePool . FEE_ADDRESS ( ) , xdrFeeAmount ) ; } synths [ destinationCurrencyKey ] . triggerTokenFallbackIfNeeded ( from , destinationAddress , amountReceived ) ; return true ; }",Function that allows synth contract to delegate sending fee to the fee Pool .
5585,"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) || ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) && secondaryHasAttribute ( _attributeTypes [ attributeTypeID ] . secondarySource , account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ) ; }",Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is currently valid .
5586,function removeValidator ( address validator ) external ;,Remove the validator at address ` validator ` from the jurisdiction .
5590,"function transfer ( address _to , uint _tokenId ) whenNotPaused external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }",External function to transfers a token to another address .
5592,"function mint ( address _investor , uint256 _value ) external returns ( bool success ) ;",Mints new tokens and assigns them to the target _investor .
5594,"function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; who . transfer ( msg . value ) ; }","This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` ."
5596,"function allowance ( address tokenOwner , address spender ) constant public returns ( uint coinsRemaining ) { return allowance [ tokenOwner ] [ spender ] ; }",Show the allowance given by ` tokenOwner ` to the ` spender `
5597,function withdrawFunds ( ) { externalEnter ( ) ; withdrawFundsRP ( ) ; externalLeave ( ) ; },Send the caller ( ` msg.sender ` ) all ether they own .
5598,"function transferPreSignedHashing ( address _operator , address _to , address _delegate , uint256 _value , uint256 _fee , uint256 _nonce , bytes _userData ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _operator , _to , _delegate , _value , _fee , _nonce , _userData ) ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
5600,"function _setPendingAnchor ( address asset , uint newScaledPrice ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( asset , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PENDING_ANCHOR_PERMISSION_CHECK ) ; } uint oldScaledPrice = pendingAnchors [ asset ] ; pendingAnchors [ asset ] = newScaledPrice ; emit NewPendingAnchor ( msg . sender , asset , oldScaledPrice , newScaledPrice ) ; return uint ( OracleError . NO_ERROR ) ; }",provides ability to override the anchor price for an asset
5601,"function getBoardSingleSpaceDetails ( uint boardId , uint8 row , uint8 col ) external view returns ( uint8 ) { uint8 position = row * BOARD_ROW_SIZE + col ; return allBoards [ boardId ] . positionToColor [ position ] ; }",Returns the current color of a specific position in a board .
5602,"function destroy ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; selfdestruct ( owner ) ; }",Allows the owner to destroy the contract and return the tokens to the owner .
5603,"function buyArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external whenNotPaused payable { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaPrice ( fromX , fromY , toX , toY ) ) ) ; depositFunds ( ) ; uint id = market . buyBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogBuys ( id , fromX , fromY , toX , toY , msg . sender ) ; }",lets a message sender to buy blocks within area
5604,function getValidAttributeID ( ) external view returns ( uint256 ) { return _validAttributeTypeID ; },Get the ID of the attribute type required to receive tokens .
5606,"function withdrawStake ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 stakeAmount = refundUserBalance ( msg . sender ) ; delete registeredInvitationCodes [ members [ msg . sender ] . invitationCode ] ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = 0 ; member . startOfLoyaltyRewardEligibility = 0 ; emit StakeWithdrawn ( msg . sender , stakeAmount ) ; }",This function will return all stake and eligible reward balance back to the user
5607,"function setProxy ( address _proxyAddress , bytes32 _symbol ) public onlyOneOfContractOwners returns ( uint ) { if ( proxies ( _symbol ) != 0x0 ) { return CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS ; } set ( store , proxiesStorage , _symbol , _proxyAddress ) ; return OK ; }",Sets Proxy contract address for a particular asset .
5609,"function changeRegistrationStatuses ( address [ ] targets , bool isRegistered ) public onlyBy ( owner ) { for ( uint i = 0 ; i < targets . length ; i ++ ) { changeRegistrationStatus ( targets [ i ] , isRegistered ) ; } }",Updates registration status for multiple addresses for participation
5611,"function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
5612,"function cancelSale ( uint256 _tokenId ) external whenNotPaused { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
5613,"function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Incorrect dividend index"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry is in the future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""Dividend is already claimed"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; dividend . reclaimed = true ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; owner . transfer ( remainingAmount ) ; emit EtherDividendReclaimed ( owner , _dividendIndex , remainingAmount ) ; }","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends"
5614,"function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }",Used to create new tokens and increase total supply
5615,"function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; require ( ! isExploring ( _tokenId ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }",Allows someone buy obtain an GoldenGoose asset token
5616,function getMemeSellingPrices ( uint256 [ ] _tokenIds ) public view returns ( uint256 [ ] sellingPrices ) { sellingPrices = new uint256 [ ] ( _tokenIds . length ) ; for ( uint i = 0 ; i < _tokenIds . length ; i ++ ) { sellingPrices [ i ] = memeIndexToPrice [ _tokenIds [ i ] ] ; } },Returns all the relevant information about a specific meme .
5617,function setManager ( address _newManager ) external requireGod { require ( _newManager != address ( 0 ) ) ; managerAddress = _newManager ; },Assigns a new address to act as the Manager .
5618,function proxyPayment ( address _owner ) public payable returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract
5619,"function cofounderApproveSwitchRequest ( address _newFounderAddr , bytes32 _oneTimesharedPhrase ) external returns ( bool success ) { if ( msg . sender != cofounder || sha3 ( _newFounderAddr , founderHash , _oneTimesharedPhrase ) != tempHashes [ _newFounderAddr ] ) throw ; previousFounders . push ( founder ) ; founder = _newFounderAddr ; FounderSwitchedEvent ( _newFounderAddr ) ; return true ; }",` msg.sender.address ( ) ` approving ` _newFounderAddr.address ( ) ` as new founder address
5620,function changeController ( address _newController ) onlyOwner public { tokenContract . changeController ( _newController ) ; },` onlyOwner ` changes the controller of the tokenContract
5622,"function emitCampaignUpdated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignUpdated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }",Function to emit campaign updates It emits a CampaignUpdated event with the new campaign information .
5624,"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { doTransfer ( msg . sender , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
5626,"function depositETH ( ) payable { DonationDeposited4Matching ( msg . sender , msg . value ) ; }",Simple function to deposit more ETH to match future donations
5627,"function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external onlyOwner { require ( _STFactoryAddress != address ( 0 ) , ""0x address is not allowed"" ) ; _setProtocolVersion ( _STFactoryAddress , _major , _minor , _patch ) ; }",Changing versions does not affect existing tokens .
5630,function reopenSale ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; crowdsaleClosed = false ; },Reopens closed sale to recalcualte total tokens sold if there are any late deals - such as delayed whitelist processing .
5631,function getOpeningTS ( bytes32 question_id ) public view returns ( uint32 ) { },Returns the timestamp when the question can first be answered
5633,"function setAccessPolicy ( IAccessPolicy newPolicy , address newAccessController ) public ;",it is a huge issue for Solidity that modifiers are not part of function signature then interfaces could be used for example to control access semantics
5635,"function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }",set ` paused ` to the specified state
5637,function settlementRegistration ( uint64 _settlementID ) external view returns ( bool ) { return settlementDetails [ _settlementID ] . registered ; },Returns the settlement contract of a settlement layer .
5638,"function approve ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { address _owner = ownerOf ( _tokenId ) ; require ( _to != _owner , ""already owns"" ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; emit Approval ( _owner , _to , _tokenId ) ; } }",Approves another address to claim for the ownership of the given token ID
5639,"function transfer ( address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , """" ) ; } }",Transfers asset balance from the caller to specified receiver .
5640,"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool success ) { if ( _from == vaultAddress ) { return true ; } return false ; }","Notifies the controller about a transfer , for this EarlyTokenSale all transfers are allowed by default and no extra notifications are needed"
5641,function destroy ( ) public onlyOwner { selfdestruct ( owner ( ) ) ; },Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .
5642,"function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external { require ( isAttributeType ( ID ) , ""unable to set secondary source, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . secondarySource = attributeRegistry ; _attributeTypes [ ID ] . secondaryAttributeTypeID = sourceAttributeTypeID ; }","Set a secondary source for a given attribute type ID ` ID ` , with an address ` registry ` of the secondary source in question and a given ` sourceAttributeTypeID ` for attribute type ID to check on the secondary source ."
5644,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
5645,function balanceOf ( address _person ) public view returns ( uint256 balance ) { return balances [ _person ] ; },Used to look up balance of a user
5647,function isPaused ( ) external view returns ( bool ) ;,Check whether the contract operations is paused or not
5648,"function createCheckpoint ( ) public onlyModule ( CHECKPOINT_KEY , true ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; emit LogCheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }",Creates a checkpoint that can be used to query historical balances / totalSuppy
5649,"function release ( ) public { require ( block . timestamp >= _releaseTime ) ; uint256 amount = _token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; _token . safeTransfer ( _beneficiary , amount ) ; }",Transfers tokens held by timelock to beneficiary .
5650,"function receiveApproval ( address from , uint256 , address _token , bytes _data ) public returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == 0 ) ; require ( _token == address ( NEUMARK ) , ""NF_ONLY_NEU"" ) ; unlockInvestor ( from ) ; return true ; }","unlocks investors funds , see unlockInvestor for details"
5652,"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
5653,"function mDestroyTokens ( address owner , uint256 amount ) internal ;",Burns ` amount ` tokens from ` owner `
5656,"function withdrawToken ( address _token , uint256 _amount ) external onlyOwner returns ( bool ) { return ERC20SafeTransfer . safeTransfer ( _token , owner , _amount ) ; }",Withdraw ether contained in this contract and send it back to owner
5659,function isTokenEscapable ( address _token ) view public returns ( bool ) { return ! escapeBlacklist [ _token ] ; },Checks to see if ` _token ` is in the blacklist of tokens
5660,"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
5662,"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }",Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
5663,function getCampaignOwnerById ( bytes32 bidId ) public view returns ( address campOwner ) { return campaigns [ bidId ] . getOwner ( ) ; },"Get the owner of a campaign Based on the Campaign id , return the address of the campaign owner ."
5664,"function approve ( address _spender , uint256 _value ) external { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; }",Authorize an address to retrieve funds from you ~ ERC-20 Standard
5666,"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external view returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash , ""content hash must match"" ) ; require ( arbitrator == questions [ question_id ] . arbitrator , ""arbitrator must match"" ) ; require ( min_timeout <= questions [ question_id ] . timeout , ""timeout must be long enough"" ) ; require ( min_bond <= questions [ question_id ] . bond , ""bond must be high enough"" ) ; return questions [ question_id ] . best_answer ; }","Return the final answer to the specified question , provided it matches the specified criteria ."
5667,function ownerOf ( uint _tokenId ) external view returns ( address ) { require ( tokenIndexToOwner [ _tokenId ] != address ( 0 ) ) ; return tokenIndexToOwner [ _tokenId ] ; },Returns the address currently assigned ownership of a given token .
5668,"function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) ;",Used to check the permission on delegate corresponds to module contract address
5669,"function isManagingProxy ( address _account , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return _account == Owned ( _userRouter ) . contractOwner ( ) ; }",Says if user account ` _account ` owns a user proxy contract ` _accountProxy ` and could manage it through UserInterface interface .
5670,"function allowAddress ( address _address , bool _allow ) onlyOwner { allowedAddresses [ _address ] = _allow ; }",Set allowance for address to interact with contract .
5671,function proxyPurchase ( address _addr ) public payable returns ( bool ) ;,Processes a token purchase for ` _addr `
5672,"function authorize ( string _contractName , address _accessor ) external onlyContractOwner ( _contractName , _accessor ) view returns ( bool ) { return true ; }",Check whether the accessor is authorized to access that contract
5673,"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by approvePreSigned
5674,function setPoolToClosed ( ) public isAdmin isOpen { state = PoolState . CLOSED ; emit PoolIsClosed ( ) ; },Allows the admin to set the state of the pool to CLOSED .
5675,"function release ( address who ) public onlyTransferAgent returns ( bool ) { Holding memory holding = heldTokens [ who ] ; require ( ! holding . isAffiliate , ""To release tokens for an affiliate use partialRelease()."" ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( who , holding . quantity ) ; if ( res ) { heldTokens [ who ] = Holding ( 0 , 0 , holding . isAffiliate ) ; emit TokensReleased ( who , holding . quantity ) ; return true ; } } return false ; }","Release the tokens once the holding period expires , transferring them back to the ERC20 contract to the holder ."
5676,"function startTokenVotes ( address [ 10 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }",Admins are able to approve proposal that someone submitted
5678,"function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }",converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
5679,function setBuyoutDividendPercentage ( uint256 _buyoutDividendPercentage ) external onlyCFO { require ( 2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500 ) ; buyoutDividendPercentage = _buyoutDividendPercentage ; },Sets the new dividend percentage for buyouts .
5680,function setGasPrice ( uint256 _gasPrice ) onlyOwner public { oraclize_setCustomGasPrice ( _gasPrice ) ; },"NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled"
5682,"function _depositTokens ( address _beneficiary , uint256 _amountTokens ) internal { require ( _amountTokens != 0 ) ; if ( investors [ _beneficiary ] == 0 ) { investorCount ++ ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _amountTokens ) ; mintableFida . sendBoughtTokens ( _beneficiary , _amountTokens ) ; }",Internal function for depositing tokens after they had been bought
5685,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { success = TokenApprovalController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_APPROVAL ) ) . approve ( msg . sender , _spender , _value ) ; }",approve given spender to transfer given amount this will set allowance to 0 if current value is non-zero
5686,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( SENToken ) { SENToken newToken = new SENToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
5687,"function validatePurchaseAndDistributeFunds ( uint24 [ ] purchase , uint24 [ ] purchasedAreas , uint256 [ ] areaIndices ) private returns ( uint256 ) { require ( purchase . length == 4 ) ; Geometry . Rect memory plotToPurchase = Geometry . Rect ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] ) ; require ( plotToPurchase . x < GRID_WIDTH && plotToPurchase . x >= 0 ) ; require ( plotToPurchase . y < GRID_HEIGHT && plotToPurchase . y >= 0 ) ; require ( plotToPurchase . w > 0 && plotToPurchase . w + plotToPurchase . x <= GRID_WIDTH ) ; require ( plotToPurchase . h > 0 && plotToPurchase . h + plotToPurchase . y <= GRID_HEIGHT ) ; require ( plotToPurchase . w * plotToPurchase . h < MAXIMUM_PURCHASE_AREA ) ; require ( purchasedAreas . length >= 4 ) ; require ( areaIndices . length > 0 ) ; require ( purchasedAreas . length % 4 == 0 ) ; require ( purchasedAreas . length / 4 == areaIndices . length ) ; Geometry . Rect [ ] memory subPlots = new Geometry . Rect [ ] ( areaIndices . length ) ; uint256 totalArea = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < areaIndices . length ; i ++ ) { Geometry . Rect memory rect = Geometry . Rect ( purchasedAreas [ ( i * 4 ) ] , purchasedAreas [ ( i * 4 ) + 1 ] , purchasedAreas [ ( i * 4 ) + 2 ] , purchasedAreas [ ( i * 4 ) + 3 ] ) ; subPlots [ i ] = rect ; require ( rect . w > 0 ) ; require ( rect . h > 0 ) ; totalArea = SafeMath . add ( totalArea , SafeMath . mul ( rect . w , rect . h ) ) ; require ( Geometry . rectContainedInside ( rect , plotToPurchase ) ) ; } require ( totalArea == plotToPurchase . w * plotToPurchase . h ) ; for ( i = 0 ; i < subPlots . length ; i ++ ) { for ( j = i + 1 ; j < subPlots . length ; j ++ ) { require ( ! Geometry . doRectanglesOverlap ( subPlots [ i ] , subPlots [ j ] ) ) ; } } uint256 remainingBalance = checkHolesAndDistributePurchaseFunds ( subPlots , areaIndices ) ; uint256 purchasePrice = SafeMath . sub ( msg . value , remainingBalance ) ; return purchasePrice ; }",This function does a lot of the heavy lifting for validating that all of the data passed in to the purchase function is ok .
5688,"function symbol ( ) external pure returns ( string _symbol ) { return ""BC"" ; }",An abbreviated name for NFTs in this contract
5690,"function transferFrom ( address _owner , address _receiver , uint256 _amount ) { require ( ! tokenTransfersFrozen ) ; require ( sub ( allowance [ _owner ] [ msg . sender ] , _amount ) >= 0 ) ; if ( transferCheck ( _owner , _receiver , _amount ) ) { balances [ _owner ] = sub ( balances [ _owner ] , _amount ) ; balances [ _receiver ] = add ( balances [ _receiver ] , _amount ) ; allowance [ _owner ] [ _receiver ] = sub ( allowance [ _owner ] [ _receiver ] , _amount ) ; Transfer ( _owner , _receiver , _amount ) ; } else { revert ( ) ; } }",Used to transfer funds on behalf of one person
5691,"function withdrawTokens ( ) public whenNotPaused returns ( bool ) { uint256 amount = rewards [ msg . sender ] ; require ( amount > 0 , ""amount is zero"" ) ; rewards [ msg . sender ] = 0 ; emit TokensWithdrawn ( msg . sender , amount ) ; require ( token . transfer ( msg . sender , amount ) , ""token transfer failed"" ) ; return true ; }",allows participants in the Atonomi network to claim their rewards
5692,"function mint ( address _investor , uint256 _value ) public returns ( bool success ) { return mintWithData ( _investor , _value , """" ) ; }",Mints new tokens and assigns them to the target _investor .
5694,function claimTokenTokens ( address _token ) public onlyOwner { require ( _token != address ( ethealToken ) ) ; ethealToken . claimTokens ( _token ) ; },Retrieve mistakenly sent tokens ( other than the etheal token ) from the token contract
5697,"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now + get ( ""pApplyStageLen"" ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now + get ( ""pApplyStageLen"" ) + get ( ""pCommitStageLen"" ) + get ( ""pRevealStageLen"" ) + PROCESSBY , value : _value } ) ; _ReparameterizationProposal ( msg . sender , _name , _value , propID ) ; return propID ; }",propose a reparamaterization of the key _name 's value to _value .
5698,"function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit LogSetManualOverride ( _override , now ) ; }",Determine whether manual price is used or not
5701,"function division ( uint numerator , uint denominator ) public view returns ( uint result ) { uint _quotient = numerator / denominator ; return _quotient ; }",Returns the division of two numbers Function used for division operations inside the smartcontract
5702,function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .
5705,"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( ( msg . sender == owner ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }",Change or reaffirm the approved address for an NFT
5707,function multiCancel ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doCancelPayment ( _idPayments [ i ] ) ; } },` onlyOwner ` An efficient way to cancel multiple payments
5710,function closePreSale ( ) private { closed = true ; SaleClosed ( now ) ; },Private function used to close the pre-sale when the hard-cap is hit
5711,function setAquariumCost ( uint256 _fee ) onlyOwner public { aquariumCost = _fee ; },Sets the cost for fishing in the aquarium
5712,function setFundingFueled ( uint _proposalID ) external ;,Function used by the main partner to set the funding fueled
5714,"function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MIN_AMOUNT ) throw ; if ( msg . value > MAX_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }",A participant 's contribution will be rejected if the presale has been funded to the maximum amount
5716,"function approvePayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . proofOfLastWorkVerified == true ) ; } require ( job . noOfTotalPayments > job . noOfPaymentsMade ) ; uint currentPayment = job . salaryDeposited . div ( job . noOfTotalPayments ) ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + currentPayment ; job . salaryDeposited = job . salaryDeposited - currentPayment ; job . noOfPaymentsMade ++ ; if ( job . noOfTotalPayments == job . noOfPaymentsMade ) { job . status = JobStatus . Completed ; } emit PaymentApproved ( msg . sender , _JobID , currentPayment ) ; }",this function lets the manager to approve payment
5717,function _isSTOAttached ( ) internal view returns ( bool ) { bool attached = ISecurityToken ( securityToken ) . getModulesByType ( 3 ) . length > 0 ; return attached ; },Internal function use to know whether the STO is attached or not
5718,function setICOEndDate ( uint _date ) public onlyAdmin { require ( ICOEndDate == 0 ) ; require ( _date > now ) ; ICOEndDate = _date ; emit ICOEndDateSet ( _date ) ; },This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
5720,"function burn ( address _where , uint _amount ) external onlyOwner { _burn ( _where , _amount ) ; }",Burn the specified amount of tokens from any address can only be called by the smart contract owner
5721,function deleteUncompletableRequest ( bytes32 _requestMsgHash ) public { Request storage request = requestMap [ _requestMsgHash ] ; uint256 idx = request . idx ; require ( 0 < idx && idx < lastCompletedIdxs [ request . callbackAddress ] [ request . callbackSelector ] ) ; delete requestMap [ _requestMsgHash ] ; },Reclaim the storage of a pending request that is uncompleteable .
5722,"function tileTimeoutTimestamp ( uint256 identifier , address player ) public view returns ( uint256 ) { uint256 bonusTime = gameSettings . timeoutBonusTime . mul ( gameStates [ gameIndex ] . addressToNumberOfTiles [ player ] ) ; uint256 timeoutTimestamp = block . timestamp . add ( calculateBaseTimeout ( ) ) . add ( bonusTime ) ; uint256 currentTimeoutTimestamp = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] ; if ( currentTimeoutTimestamp == 0 ) { currentTimeoutTimestamp = gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) ; } if ( timeoutTimestamp >= currentTimeoutTimestamp ) { return timeoutTimestamp ; } else { return currentTimeoutTimestamp ; } }",Get the new timeout timestamp for a tile .
5723,"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }",Helper function that checks for ERC777TokensSender on the sender and calls it .
5724,"function setMaximumIssuableAttributes ( address organization , uint256 maximumIssuableAttributes ) external onlyOwner whenNotPaused { require ( _organizations [ organization ] . exists == true , ""an organization does not exist at the provided account address"" ) ; require ( _organizations [ organization ] . accounts . length <= maximumIssuableAttributes , ""maximum cannot be set to amounts less than the current account total"" ) ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; }",Modify an organization at account ` organization ` to change the number of issuable attributes to ` maximumIssuableAttributes ` .
5725,"function participantClaimCredits ( ) external { require ( now >= TOKEN_WITHDRAWAL_START_DATE ) ; require ( now < TOKEN_WITHDRAWAL_END_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; require ( creditBalanceOf [ msg . sender ] > 0 ) ; var tokensToApprove = creditBalanceOf [ msg . sender ] ; spentParsecCredits = spentParsecCredits . add ( tokensToApprove ) ; creditBalanceOf [ msg . sender ] = 0 ; parsecToken . approve ( msg . sender , tokensToApprove ) ; }",The participant will need to withdraw their Parsec credits if minimal pre-sale amount was reached and date between TOKEN_WITHDRAWAL_START_DATE and TOKEN_WITHDRAWAL_END_DATE
5726,"function mintToken ( uint256 mintedAmount ) onlyOwner public { balanceOf [ this ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` owner `
5728,"function getCity ( uint256 _tokenId ) public view returns ( string cityName , uint256 sellingPrice , address owner ) { City storage city = citys [ _tokenId ] ; cityName = city . name ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific city .
5729,"function manualTransfer ( address _to , uint _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }",Manual transfer for investors who paid from payment cards
5732,"function withdraw ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; _makeWithdrawForPeriod ( _userKey , _value ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = periodsCount ; delete periods [ _periodsCount ] . startDate ; ERC20 _token = ERC20 ( token ) ; if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } uint _withdrawnAmount = _value - _feeAmount ; if ( ! _token . transfer ( _withdrawAddress , _withdrawnAmount ) ) { revert ( ) ; } TreasuryWithdrawn ( _userKey , _withdrawnAmount ) ; return OK ; }",Withdraws deposited tokens on behalf of users Allowed only for oracle
5733,function decodeAssets ( bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] assets ) { require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetsCopy = new uint [ ] ( _potentialAssets . length * 10 ) ; uint numberOfAssets = 0 ; for ( uint j = 0 ; j < _potentialAssets . length ; j ++ ) { uint input ; bytes32 pot = _potentialAssets [ j ] ; assembly { input := pot } for ( uint i = 10 ; i > 0 ; i -- ) { uint mask = ( 2 << ( ( i - 1 ) * 24 ) ) / 2 ; uint b = ( input & ( mask * 16777215 ) ) / mask ; if ( b != 0 ) { assetsCopy [ numberOfAssets ] = b ; numberOfAssets ++ ; } } } assets = new uint [ ] ( numberOfAssets ) ; for ( i = 0 ; i < numberOfAssets ; i ++ ) { assets [ i ] = assetsCopy [ i ] ; } },Function which decodes bytes32 to array of integers
5734,"function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( securityToken , Ownable ( factory ) . owner ( ) , _amount ) , ""Unable to take fee"" ) ; return true ; }",used to withdraw the fee by the factory owner
5735,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ethernautsStorage . ownerOf ( _tokenId ) ; require ( owner != address ( 0 ) ) ; },Returns owner of a given Asset ( Token ) .
5738,"function addChunk4ToWhiteList ( ) external onlyOwner { require ( ! chunk4IsAdded ) ; addToWhitelist ( 0x47169f78750Be1e6ec2DEb2974458ac4F8751714 , 1 ether ) ; addToWhitelist ( 0x499114EF97E50c0F01EDD6558aD6203A9B295419 , 1 ether ) ; addToWhitelist ( 0x49C11D994DC19C5Edb62F70DFa76c393941d5fFf , 1 ether ) ; addToWhitelist ( 0x4bCC31189527dCdFde2f4c887A59b0b0C5dBBB1c , 1 ether ) ; addToWhitelist ( 0x4E5Be470d1B97400ce5E141Da1372e06575383ee , 1 ether ) ; addToWhitelist ( 0x5203CDD1D0b8cDc6d7CF60228D0c7E7146642405 , 1 ether ) ; addToWhitelist ( 0x554C033720EfDaD25e5d6400Bdea854bF9E709b6 , 1 ether ) ; addToWhitelist ( 0x5700e809Ea5b49f80B6117335FB7f6B29E0E4529 , 1 ether ) ; addToWhitelist ( 0x62f33168582712391f916b4d42f9d7433ed390ea , 1 ether ) ; addToWhitelist ( 0x62f4e10FA6f1bA0f2b8282973FF4fE2141F917D6 , 1 ether ) ; addToWhitelist ( 0x635Dc49b059dB00BF0d2723645Fa68Ffc839a525 , 1 ether ) ; addToWhitelist ( 0x6465dFa666c6bFDF3E9bd95b5EC1E502843eeEB7 , 1 ether ) ; addToWhitelist ( 0x6E88904BA0A062C7c13772c1895900E1482deC8e , 1 ether ) ; addToWhitelist ( 0x70580eA14d98a53fd59376dC7e959F4a6129bB9b , 1 ether ) ; addToWhitelist ( 0x70EbC02aBc8922c34fA901Bd0931A94634e5B6b2 , 1 ether ) ; addToWhitelist ( 0x71b492cd6695fd85b21af5ae9f818c53f3823046 , 1 ether ) ; addToWhitelist ( 0x7b8a0D81e8A760D1BCC058250D77F79d4827Fd3c , 1 ether ) ; addToWhitelist ( 0x7ba67f190771Cf0C751F2c4e461f40180e8a595c , 1 ether ) ; addToWhitelist ( 0x7ce2C04EfC51EaA4Ca7e927a61D51F4dc9A19f41 , 1 ether ) ; addToWhitelist ( 0x7E8658A0467e34c3ac955117FA3Ba9C18d25d22A , 1 ether ) ; addToWhitelist ( 0x7eedaC1991eE2A59B072Be8Dc6Be82CCE9031f91 , 1 ether ) ; addToWhitelist ( 0x7aa1bb9e0e5439298ec71fb67dc1574f85fecbd1 , 1 ether ) ; addToWhitelist ( 0x832aC483326472Da0c177EAAf437EA681fAb3ABe , 1 ether ) ; addToWhitelist ( 0x861739a2fe0D7d16544c4a295b374705aEEA004F , 1 ether ) ; addToWhitelist ( 0x898C86446CcE1B7629aC7f5B5fD8eA0F51a933b3 , 1 ether ) ; addToWhitelist ( 0x8b2F96cEc0849C6226cf5cFAF32044c12B16eeD9 , 1 ether ) ; addToWhitelist ( 0x8fF73A67b4406341AfBc4b37c9f595a77Aa062A2 , 1 ether ) ; addToWhitelist ( 0x964b513c0F30E28B93081195231305a2D92C7762 , 1 ether ) ; addToWhitelist ( 0x96BC6015ff529eC3a3d0B5e1B7164935Df2bF2fd , 1 ether ) ; addToWhitelist ( 0x96BF1A8660C8D74603b3c4f429f6eC53AD32b0B0 , 1 ether ) ; addToWhitelist ( 0x9840a6b89C53DDB6D6ef57240C6FC972cC97731A , 1 ether ) ; addToWhitelist ( 0xA8625D251046abd3F2858D0163A827368a068bac , 1 ether ) ; addToWhitelist ( 0xa93e77C28fB6A77518e5C3E61348Aec81E5004fD , 1 ether ) ; addToWhitelist ( 0xaEafb182b64FD2CC3866766BA72B030F9AcE69f0 , 1 ether ) ; addToWhitelist ( 0xB3eA2C6feDb15CDC5228dd0B8606592d712c53e1 , 1 ether ) ; addToWhitelist ( 0xBde128e0b3EA8E4a6399401A671ce9731282C4C2 , 1 ether ) ; addToWhitelist ( 0xC3dA85745022fC89CdC774e1FE95ABC4F141292f , 1 ether ) ; addToWhitelist ( 0xC62c61Bbcd61A4817b95dA22339A4c856EC4A3F9 , 1 ether ) ; addToWhitelist ( 0xcE13de0cBd0D7Bde1d2444e2d513868177D2B15F , 1 ether ) ; addToWhitelist ( 0xd45546Cbc3C4dE75CC2B1f324d621A7753f25bB3 , 1 ether ) ; addToWhitelist ( 0xDAF8247Ebcd4BB033D0B82947c3c64a3E5089444 , 1 ether ) ; addToWhitelist ( 0xEF2F95dbEEd23a04DD674898eaB10cA4C883d780 , 1 ether ) ; addToWhitelist ( 0xDe3b6c96f7E6c002c1018b77f93b07956C6fB3e8 , 1 ether ) ; addToWhitelist ( 0xe415638FC30b277EC7F466E746ABf2d406f821FF , 1 ether ) ; addToWhitelist ( 0xE4A12D142b218ed96C75AA8D43aa153dc774F403 , 1 ether ) ; addToWhitelist ( 0xEEBEA0A8303aAc18D2cABaca1033f04c4a43E358 , 1 ether ) ; addToWhitelist ( 0xf12059ad0EB7D393E41AC3b3250FB5E446AA8dFB , 1 ether ) ; addToWhitelist ( 0xF94EfB6049B7bca00cE8e211C9A3f5Ca7ff4800b , 1 ether ) ; addToWhitelist ( 0xFBCe0CBB70bD0Bf43B11f721Beaf941980C5fF4a , 1 ether ) ; addToWhitelist ( 0x573648f395c26f453bf06Fd046a110A016274710 , 1.2 ether ) ; addToWhitelist ( 0x95159e796569A9A7866F9A6CF0E36B8D6ddE9c02 , 1.2 ether ) ; addToWhitelist ( 0xEafF321951F891EBD791eF57Dc583A859626E295 , 1.2 ether ) ; chunk4IsAdded = true ; }",Add chunk 4 / 7 to the whitelist
5740,"function setPrices ( uint256 newSellPrice , uint256 newSellMultiplier , uint256 newBuyPrice , uint256 newBuyMultiplier ) onlyOwner public { sellPrice = newSellPrice ; sellMultiplier = newSellMultiplier ; buyPrice = newBuyPrice ; buyMultiplier = newBuyMultiplier ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .
5741,"function setMasterFeeContract ( Data storage self , address contractAddress ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; require ( self . Storage . setAddress ( id , contractAddress ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }",Set the master fee contract used as the default fee contract when none is provided
5743,function reduce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; },Reduce digital artwork tokens for changing physical artwork
5745,"function manualTransfer ( address _to , uint256 _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }",Manual transfer for investors who paid from payment cards
5746,"function issueAttribute ( bool doYouLoveCats , bool doYouLoveDogsMoreThanCats , bool areYouACrazyCatLady ) external { require ( doYouLoveCats , ""only cat lovers allowed"" ) ; require ( doYouLoveDogsMoreThanCats , ""no liars allowed"" ) ; require ( ! areYouACrazyCatLady , ""we are very particular"" ) ; require ( _issueAttribute ( msg . sender ) ) ; }",Issue an attribute of the type with the default ID to ` msg.sender ` on the jurisdiction .
5748,"function createRequestAsPayeeAction ( address [ ] _payeesIdAddress , bytes _payeesPaymentAddress , int256 [ ] _expectedAmounts , address _payer , bytes _payerRefundAddress , string _data ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender == _payeesIdAddress [ 0 ] && msg . sender != _payer && _payer != 0 , ""caller should be the payee"" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( _payer , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , ""fees should be the correct amout"" ) ; extractAndStoreBitcoinAddresses ( requestId , _payeesIdAddress . length , _payeesPaymentAddress , _payerRefundAddress ) ; return requestId ; }",Function to create a request as payee .
5749,function setNextUpgradeAgent ( address agent ) external { if ( agent == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeAgent = NextUpgradeAgent ( agent ) ; if ( ! nextUpgradeAgent . isUpgradeAgent ( ) ) revert ( ) ; nextUpgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( nextUpgradeAgent ) ; },Set address of next upgrade target contract and enable upgrade process .
5750,"function addNFToken ( address _to , uint256 _tokenId ) noOwnerExists ( _tokenId ) internal { nft [ _tokenId ] . owner = _to ; ownerToTokenList [ _to ] . push ( _tokenId ) ; }",Use and override this function with caution .
5752,"function moveTokensToAddress ( bytes16 _uuid , address _address , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { removeTokensFromAccount ( _uuid , _tokensCount ) ; rntToken . transfer ( _address , _tokensCount ) ; tokens = tokens . sub ( _tokensCount ) ; tokenTransfers [ _address ] = _uuid ; return true ; }",Function for withdrawal tokens from Vault account to address .
5753,"function adjustTotalSupplyCheckpoints ( ) internal { adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) ) ; }",adjust totalsupply at checkpoint after minting or burning tokens
5756,"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }",Use and override this function with caution .
5757,"function refund ( ) minCapNotReached salePeriodCompleted registeredUser isValidState external { require ( msg . sender != gmtFundAddress ) ; uint256 gmtVal = balances [ msg . sender ] ; require ( gmtVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( gmtVal ) ; assignedSupply = assignedSupply . sub ( gmtVal ) ; uint256 ethVal = gmtVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }",Allows contributors to recover their ETH in the case of a failed token sale
5758,"function fill ( address makerAddress , uint makerAmount , address makerToken , address takerAddress , uint takerAmount , address takerToken , uint256 expiration , uint256 nonce , uint8 v , bytes32 r , bytes32 s ) external payable ;",Fills an order by transferring tokens between ( maker or escrow ) and taker
5759,"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }",Check ` _value ` tokens allowed to ` _spender ` by ` _owner `
5760,function setTransferAgent ( address who ) public onlyIssuer { transferAgent = who ; },Set the address of the Transfer Agent .
5762,function rolloverFeePeriodIfElapsed ( ) public { if ( now >= feePeriodStartTime + feePeriodDuration ) { lastFeesCollected = nomin . feePool ( ) ; lastFeePeriodStartTime = feePeriodStartTime ; feePeriodStartTime = now ; emitFeePeriodRollover ( now ) ; } },Check if the fee period has rolled over .
5764,"function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , ""Beneficiary must not be the zero address"" ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }",Set the beneficiary address of this contract .
5765,function setMinSellAmount ( uint256 _minSellAmount ) onlyOwner public { minSellAmount = _minSellAmount ; },set minimal amount of ether which can be used to buy tokens
5766,"function distributeTokens ( address _to , uint256 _amount ) public onlyOwnerOrCrowdsale { require ( _to != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( tokensRaised . add ( _amount ) <= crowdsaleTokens ) ; tokensRaised = tokensRaised . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; }",To distribute the presale and ICO tokens and increase the total supply accordingly .
5767,"function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner { require ( _address != address ( tokenReward ) ) ; StandardToken token = StandardToken ( _address ) ; token . transfer ( beneficiary , _amount ) ; TokensWithdraw ( beneficiary , _address , _amount ) ; }",Withdraws tokens other than DGZ to beneficiary .
5769,"function getFeeFlat ( Data storage self , address contractAddress ) internal view returns ( uint feeFlat ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }",Get the flat fee of the contract address ; typically TokenIOFeeContract
5771,"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }",Transfer tokens from one account to the other
5772,function updateCounters ( uint256 _etherAmount ) internal ;,Updates the counters for the amount of Ether paid
5774,"function getCurrencySymbol ( ) external view returns ( bytes32 ) { return bytes32 ( ""ETH"" ) ; }",Returns symbol of oracle currency ( 0x0 for ETH )
5778,"function verifyTransfer ( address , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . getInvestorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }",Used to verify the transfer transaction and prevent a transfer if it passes the allowed amount of token holders
5779,function getStats ( uint256 _tokenId ) public view returns ( uint8 [ STATS_SIZE ] ) { return assets [ _tokenId ] . stats ; },Returns only stats data about a specific asset .
5781,"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }",Get the allowance of an specified address to use another address balance .
5782,"function addVest ( address _vester , uint256 _totalAmountToVest , uint256 [ ] _releaseDates , uint256 [ ] _releaseAmounts ) public nonActiveVester ( _vester ) onlyAdmin returns ( bool ) { require ( _releaseDates . length > 0 && _releaseAmounts . length > 0 && _totalAmountToVest > 0 , ""attempting to use non zero values"" ) ; require ( _releaseDates . length == _releaseAmounts . length , ""array lengths are not equal"" ) ; uint256 total ; for ( uint256 i = 0 ; i < _releaseAmounts . length ; i ++ ) { total = total . add ( _releaseAmounts [ i ] ) ; require ( now < _releaseDates [ i ] , ""release date must be in the future"" ) ; } require ( total == _totalAmountToVest , ""invalid total amount to vest"" ) ; Vest memory v = Vest ( { totalVest : _totalAmountToVest , releaseDates : _releaseDates , releaseAmounts : _releaseAmounts , state : VestState . vesting } ) ; vests [ _vester ] = v ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _totalAmountToVest ) , ""transfer from failed, most likely needs approval"" ) ; return true ; }","Used to deposit a vest for someone Mythril will report an overflow here , however it is a false positive"
5783,"function issueAndFreeze ( address _to , uint _value , uint _freezePeriod ) onlyOwner public { _transfer ( msg . sender , _to , _value ) ; freezeAccount [ _to ] = FreezeAccountInfo ( { freezeStartTime : now , freezePeriod : _freezePeriod , freezeTotal : _value } ) ; emit IssueAndFreeze ( _to , _value , _freezePeriod ) ; }",Issue tokens to account and these tokens will be frozen for a period of time
5791,"function requestInvestment ( uint giveQuantity , uint shareQuantity , address investmentAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed [ investmentAsset ] ) pre_cond ( modules . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestAsset : investmentAsset , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : modules . pricefeed . getLastUpdateId ( ) } ) ) ; emit RequestUpdated ( getLastRequestId ( ) ) ; }",Give melon tokens to receive shares of this fund
5792,"function withdraw ( uint64 idPledge , uint amount ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Pledged ) ; PledgeAdmin storage owner = findAdmin ( p . owner ) ; checkAdminOwner ( owner ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paying ) ; doTransfer ( idPledge , idNewPledge , amount ) ; vault . authorizePayment ( bytes32 ( idNewPledge ) , owner . addr , amount ) ; }",This method is used to withdraw value from the system .
5794,"function getPlotData ( uint256 plotIndex ) public view returns ( string ipfsHash , string url , bool plotBlocked ) { require ( plotIndex < ownership . length ) ; return ( data [ plotIndex ] . url , data [ plotIndex ] . ipfsHash , plotBlockedTags [ plotIndex ] ) ; }",Gets the data stored with a specific plot .
5796,"function _processBonus ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonusTokens = getBonusTokens ( _tokenAmount ) ; if ( BONUS_TOKENS < bonusTokens ) { bonusTokens = BONUS_TOKENS ; } if ( bonusTokens > 0 ) { BONUS_TOKENS = BONUS_TOKENS . sub ( bonusTokens ) ; token . transfer ( _beneficiary , bonusTokens ) ; emit BonusSent ( address ( token ) , _beneficiary , _tokenAmount , bonusTokens ) ; tokensSold = tokensSold . add ( bonusTokens ) ; } }",Function to calculate bonus from bought tokens .
5797,function setOracleQueryType ( string _oracleQueryType ) onlyOwner public { oracleQueryType = _oracleQueryType ; },Allows owner to set type used in Oraclize queries
5798,"function release ( address account ) public isVestedAccount ( account ) { uint256 unreleased = releasableAmount ( account ) ; require ( unreleased > 0 ) ; beneficiary [ account ] . releasedAmount = beneficiary [ account ] . releasedAmount . add ( unreleased ) ; token . transfer ( account , unreleased ) ; emit Released ( account , unreleased ) ; if ( beneficiary [ account ] . releasedAmount == beneficiary [ account ] . totalAmount ) { delete beneficiary [ account ] ; } }",Transfers available vested tokens to the beneficiary .
5799,function setRentAuctionContractAddress ( address _address ) external onlyOwner { RentAuction _contract = RentAuction ( _address ) ; require ( _contract . isRentAuction ( ) ) ; rentAuctionContract = _contract ; },Set the contract address of the rent auction .
5800,function seal ( ) { if ( now < endFundingTime ) throw ; tokenContract . seal ( ) ; },` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract
5802,"function mintToken ( address _target , uint _mintedAmount ) onlyOwner public { balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; _totalSupply = _totalSupply . add ( _mintedAmount ) ; Transfer ( address ( 0 ) , _target , _mintedAmount ) ; }",Create ` mintedAmount ` tokens and send it to ` _target `
5803,"function withdrawERC20 ( address _tokenContract , uint256 _value ) external ;",Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token .
5804,"function getCurrentSellOffer ( uint32 _canvasId ) external view returns ( bool isForSale , address seller , uint minPrice , address onlySellTo ) { SellOffer storage offer = canvasForSale [ _canvasId ] ; return ( offer . isForSale , offer . seller , offer . minPrice , offer . onlySellTo ) ; }",Returns current sell offer for the canvas .
5806,function tokenPriceInEuroCents ( ) public constant returns ( uint ) ;,price of one token ( 1e18 wei-tokens ) in euro cents
5808,"function mintPartOfEmission ( address to , uint part , uint partOfEmissionForPublicSales ) public payloadSizeIs ( 32 * 3 ) validAddress ( to ) requiresState ( State . MINTING2POOLS ) onlyBy ( m_pools ) { uint poolTokens = m_publiclyDistributedTokens . mul ( part ) . div ( partOfEmissionForPublicSales ) ; m_SMR . mint ( to , poolTokens ) ; }",Mints tokens to predefined token pools after public sales
5811,function numberOfAuthorizedPayments ( ) public view returns ( uint ) { return authorizedPayments . length ; },States the total number of authorized payments in this contract
5812,function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; },Sets a new game starter dividend percentage .
5813,function balanceOf ( address _owner ) public view returns ( uint count ) { return howManyDoYouHave [ _owner ] ; },Returns the number of rabbits owned by a specific address .
5815,"function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }",This function is disabled during the funding .
5816,"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }",Checks if the makeOrder price is reasonable and not manipulative
5818,function updateCounters ( uint256 _etherAmount ) internal { totalEtherPaid = totalEtherPaid . add ( _etherAmount ) ; },Updates the counters for the amount of Ether paid
5819,"function renameCollection ( uint64 _collectionIndex , bytes8 _name ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , ""Collection has been cleared"" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; } collectionNames [ _collectionIndex ] = _name ; emit RenameCollection ( _collectionIndex , _name ) ; return _collectionIndex ; }",Rename collection # ` ( _collectionIndex ) `
5820,function setLastBidId ( bytes32 _newBidId ) internal { lastBidId = _newBidId ; },Internal function to set most recent bidId This value is stored to avoid conflicts between Advertisement contract upgrades .
5822,function getVaultBalance ( ) onlyAllowedAddresses public constant returns ( uint256 ) { return rntToken . balanceOf ( ) ; },Get current amount of tokens on Vault address .
5825,function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 5000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; },Sets a new game starter dividend percentage .
5826,function setPoolToOpen ( ) public isAdmin isClosed { state = PoolState . OPEN ; emit PoolIsOpen ( ) ; },Allows the admin to set the state of the pool to OPEN .
5829,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , _operatorData , true ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }",Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
5830,"function getTagsByType ( uint8 _moduleType ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByType ( _moduleType ) ; return _tagsByModules ( modules ) ; }",Returns all the tags related to the a module type which are valid for the given token
5831,function getTotalDepositsAmountLeft ( ) public view returns ( uint _amount ) { uint _lastDepositDate = lastDepositDate ; for ( uint _startDate = firstDepositDate ; _startDate <= _lastDepositDate || _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { _amount = _amount . add ( distributionDeposits [ _startDate ] . left ) ; } },Gets total amount of deposits that has left after users ' bonus withdrawals
5833,function callWithdraw ( address realitycheck ) onlyOwner public { RealityCheckAPI ( realitycheck ) . withdraw ( ) ; },Withdraw any accumulated question fees from the specified address into this contract
5834,function unpause ( ) public onlyCEO whenPaused { paused = false ; Unpaused ( ) ; },"called by the CEO to unpause , returns to normal state"
5836,function getTokenMinted ( ) public constant returns ( uint ) ;,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! )
5837,"function getBuyPrices ( uint256 _gameID , uint256 [ ] memory _keys ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalEth = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _keys . length , ""Incorrect number of teams"" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _keys [ i ] > 0 ) { _eth [ i ] = getBuyPrice ( _gameID , i , _keys [ i ] ) ; _totalEth = _totalEth . add ( _eth [ i ] ) ; } } return ( _totalEth , _eth ) ; }",Get the prices buyer have to pay for next keys for all teams .
5838,"function convertToUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . mul ( _amount , rate ) ; }",This function converts from ETH or POLY to USD
5840,function listAcceptedTokens ( ) public view returns ( address [ ] ) { return tokensList ; },Returns an array of all accepted token .
5841,"function retrieveFunds ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , ""Transfer did not work"" ) ; selfdestruct ( msg . sender ) ; }",Extract balance in ETH + SNT from the contract
5842,"function getListing ( uint64 _pixelconIndex ) public view returns ( address _seller , uint256 _startPrice , uint256 _endPrice , uint256 _currPrice , uint64 _startDate , uint64 _duration , uint64 _timeLeft ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; _seller = listing . seller ; _startPrice = uint256 ( listing . startAmount ) * WEI_PER_GWEI ; _endPrice = uint256 ( listing . endAmount ) * WEI_PER_GWEI ; _currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; _startDate = listing . startDate ; _duration = listing . duration ; _timeLeft = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; }",Get the details of the market listings for PixelCon # ` ( _pixelconIndex ) `
5843,"function setAllowance ( address _owner , address _spender , uint256 _value ) public onlyImpl { allowed [ _owner ] [ _spender ] = _value ; }",Sets how much ` _owner ` allows ` _spender ` to transfer on behalf of ` _owner ` .
5844,"function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }",Cancel is not implemented on exchange for smart contracts
5845,function propExists ( bytes32 _propID ) view public returns ( bool ) { return proposals [ _propID ] . processBy > 0 ; },Determines whether a proposal exists for the provided proposal ID
5846,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }","Transfer a Property owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
5847,"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return ownerOperators [ _owner ] [ _operator ] ; }",Query if an address is an authorized operator for another address
5848,"function newRepoWithVersion ( string _name , address _dev , uint16 [ 3 ] _initialSemanticVersion , address _contractAddress , bytes _contentURI ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { Repo repo = _newRepo ( _name , this ) ; repo . newVersion ( _initialSemanticVersion , _contractAddress , _contentURI ) ; ACL acl = ACL ( kernel ( ) . acl ( ) ) ; acl . revokePermission ( this , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . grantPermission ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . setPermissionManager ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; return repo ; }",Create new repo in registry with ` _name ` and first repo version
5849,"function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _dao , uint _minutesDebatingPeriod ) payable returns ( uint ) ;",Function to make a proposal to change the Dao rules
5850,"function withdrawPool ( uint256 amountToWithdraw ) public onlyOwner { if ( amountToWithdraw > 0 ) { require ( totalPoolBalance >= amountToWithdraw && ixtToken . transfer ( msg . sender , amountToWithdraw ) , ""Unable to withdraw this value of IXT."" ) ; totalPoolBalance = SafeMath . sub ( totalPoolBalance , amountToWithdraw ) ; } emit PoolWithdraw ( msg . sender , amountToWithdraw ) ; }",This function can only be called by the contract owner
5853,"function approve ( address _spender , uint256 _value ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . approve ( _spender , _value ) ; }",Approves a wallet address to spend on behalf of the sender .
5855,"function computeStablecoinFee ( uint256 _amount , address _stablecoin ) public view returns ( uint256 ) { uint256 fee = fees [ _stablecoin ] ; return computeFee ( _amount , fee ) ; }",Compute the fee that will be charged on a `` burn '' operation .
5856,function finalizePresale ( ) whenNotPaused onlyOwner external { require ( isPresaleStarted && ! isPresaleFinalized ) ; require ( presaleFinalizeAgent . isSane ( ) ) ; uint256 presaleSupply = token . totalSupply ( ) ; presaleSupply = presaleSupply . div ( 5 ) ; presaleFinalizeAgent . finalizePresale ( presaleSupply ) ; uint tokenWei = presaleFinalizeAgent . weiPerToken ( ) ; pricingStrategy . setTokenPriceInWei ( tokenWei ) ; TokensPerWeiReceived ( tokenWei ) ; require ( tokenWei > 0 ) ; currentStatus = Status . Unknown ; isPresaleFinalized = true ; presaleEndTime = now ; PresaleFinalized ( presaleEndTime ) ; },"Finalize presale , calculate token price , track finalize time ."
5859,function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && totalSupply < tokenCreationMax ) return State . Funding ; else if ( totalSupply >= tokenCreationMin ) return State . Success ; else return State . Failure ; },This manages the crowdfunding state machine We make it a function and do not assign the result to a variable So there is no chance of the variable being stale
5860,"function getPartialAmount ( uint numerator , uint denominator , uint target ) public pure returns ( uint ) { return numerator . mul ( target ) . div ( denominator ) ; }",Calculates partial value given a numerator and denominator .
5862,"function addBounty ( address _hunter , uint256 _amount ) onlyOwner public { require ( _hunter != 0x0 ) ; require ( toWei ( _amount ) <= safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ) ; bounties [ _hunter ] = safeAdd ( bounties [ _hunter ] , toWei ( _amount ) ) ; bonusAndBountyTokens = safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ; emit AddBounty ( _hunter , toWei ( _amount ) ) ; }",set token for bounty hunter to release when ICO success
5863,"function onApprove ( address _owner , address _spender , uint256 _amount ) returns ( bool ) ;",Notifies the controller about an approval allowing the controller to react if desired
5865,"function _sameClassAxiesPrice ( uint8 _class , uint256 _quantity ) private view returns ( uint256 _totalPrice , uint256 _currentIncrement , uint256 _currentPrice ) { _currentIncrement = priceIncrement [ _class ] ; _currentPrice = currentPrice [ _class ] ; uint256 _nextPrice ; for ( uint256 i = 0 ; i < _quantity ; i ++ ) { _totalPrice = _totalPrice . add ( _currentPrice ) ; _nextPrice = _currentPrice . add ( _currentIncrement ) ; if ( _nextPrice / 100 finney != _currentPrice / 100 finney ) { _currentIncrement >>= 1 ; } _currentPrice = _nextPrice ; } }",Calculate price of Axies from the same class .
5869,"function sendTokens ( address msg_sender , uint msg_value ) internal { var prices = price1stWeek ; if ( now >= startTime + 2 weeks ) prices = price3rdWeek ; else if ( now >= startTime + 1 weeks ) prices = price2ndWeek ; uint currentPrice = prices [ 0 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue5 ) { currentPrice = prices [ 1 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue10 ) currentPrice = prices [ 2 ] ; } uint amountSendTokens = msg_value / currentPrice ; if ( amountSendTokens > ( tokensAvailableForSale - tokensSoldOnPublicRound ) ) { uint tokensAvailable = tokensAvailableForSale - tokensSoldOnPublicRound ; uint refund = msg_value - ( tokensAvailable * currentPrice ) ; amountSendTokens = tokensAvailable ; tokensSoldOnPublicRound += amountSendTokens ; msg_sender . transfer ( refund ) ; balanceOf [ msg_sender ] += ( msg_value - refund ) ; } else { tokensSoldOnPublicRound += amountSendTokens ; balanceOf [ msg_sender ] += msg_value ; } tokenReward . transfer ( msg_sender , amountSendTokens ) ; DGZTokensSold ( msg_sender , amountSendTokens ) ; }",Internal function which is responsible for sending tokens .
5870,function enableTransfers ( bool _transfersEnabled ) ownerOrController public { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
5872,"function submitLocation ( uint encryptKey , uint8 locationNumber ) public payable { require ( encryptKey != 0 ) ; require ( locationNumber < locations . length ) ; if ( ! grace ) { require ( msg . value >= cost ) ; uint contribution = cost - cost / 10 ; ownersBalance += cost - contribution ; pot += contribution ; } hunters [ msg . sender ] [ locationNumber ] = KeyLog ( encryptKey , block . number ) ; }",The message value must be greater than ` cost `
5874,"function requestRedemption ( uint shareQuantity , uint receiveQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isRedeemAllowed ) pre_cond ( module . compliance . isRedemptionPermitted ( msg . sender , shareQuantity , receiveQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . redeem , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : shareQuantity , receiveQuantity : receiveQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }",Give shares of this fund to receive melon tokens
5876,"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }",Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
5879,"function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerTokens = etherAmount . mul ( CALLER_EXCHANGE_RATE ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( RESERVE_EXCHANGE_RATE ) ; uint256 founderTokens = etherAmount . mul ( FOUNDER_EXCHANGE_RATE ) ; uint256 bountyTokens = etherAmount . mul ( BOUNTY_EXCHANGE_RATE ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; payAffiliate ( callerTokensWithDiscount , msg . value , msg . sender ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }","This method sends the Ether received to the Ether escrow address and generates the calculated number of SHP tokens , sending them to the caller 's address ."
5880,"function setRenewable ( uint256 _productId , bool _newRenewable ) external onlyCLevel { _setRenewable ( _productId , _newRenewable ) ; ProductRenewableChanged ( _productId , _newRenewable ) ; }",setRenewable - sets if a product is renewable
5881,"function allocate ( ) external { uint256 unallocated = address ( this ) . balance . sub ( balanceTotal ) ; require ( unallocated > 0 , ""No funds to allocate"" ) ; uint256 num_recipients = recipients . length ; uint256 each = unallocated / num_recipients ; require ( each > 0 , ""No money left to be allocated after rounding down"" ) ; uint256 i ; for ( i = 0 ; i < num_recipients ; i ++ ) { address recip = recipients [ i ] ; balanceOf [ recip ] = balanceOf [ recip ] . add ( each ) ; balanceTotal = balanceTotal . add ( each ) ; } assert ( address ( this ) . balance >= balanceTotal ) ; }",Allocate any unallocated funds from the contract balance
5882,"function quoteBid ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }",Calculates the bid price in wei per aToken based on the current reserve amount
5884,"function get ( MapStorage storage self , uint index ) public view returns ( address ) { require ( index < self . addresses . length ) ; return self . addresses [ index ] ; }",Retrieves a address from the given ` MapStorage ` using a index Key .
5885,"function transferToGrant ( uint256 _id , uint256 _amount ) public onlyOwner { require ( _id < tokenGrants . length && _amount > 0 && now <= tokenGrants [ _id ] . start ( ) ) ; require ( ethealToken . transfer ( address ( tokenGrants [ _id ] ) , _amount ) ) ; }",Transfer tokens to a grant until it is starting
5886,function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = propertyIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given Property .
5889,"function cancelAuction ( uint256 _axieId ) external { Auction storage _auction = auctions [ _axieId ] ; require ( _isOnAuction ( _auction ) ) ; require ( msg . sender == _auction . seller ) ; _cancelAuction ( _axieId , _auction . seller ) ; }",This is a state-modifying function that can be called while the contract is paused .
5891,function removeBlacklistedUser ( address _who ) public onlyValidator { _removeBlacklistedUser ( _who ) ; },Removes the necessary permissions for a `` blacklisted '' user .
5893,function updateMinimumBond ( uint256 _nextMinimumBond ) external onlyOwner { nextMinimumBond = _nextMinimumBond ; },Allows the contract owner to update the minimum bond .
5894,"function getChannelWith ( Data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != 0 ) { return self . all_channels [ channel_pos - 1 ] ; } }",Get the address of channel with a partner
5895,"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }","This works identically to the other function with an extra data parameter , except this function just sets data to `` ''"
5896,"function removeUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , ""Permission being removed must be for a valid method signature"" ) ; userPermissions [ _who ] [ _methodsignature ] = false ; }",Removes a permission from the list of permissions that a user has .
5897,"function getCertification ( address student ) payable requestFeePaid returns ( bool certified , uint256 timestamp , address certifier , uint256 documentCount ) { Certification certification = studentCertifications [ student ] ; return ( certification . certified , certification . timestamp , certification . certifier , certification . documents . length ) ; }",Requesting a certification is a paying feature .
5898,"function milestoneCompleted ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }",` onlyRecipient ` Marks a milestone as DONE and ready for review
5899,"function approve ( address _approved , uint256 _tokenId ) external canOperate ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( _approved != tokenOwner ) ; idToApprovals [ _tokenId ] = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }",The zero address indicates there is no approved address .
5901,"function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) ;","` msg.sender ` approves ` spender ` to send ` amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` spender ` ."
5902,function ownerWithdraw ( uint256 value ) external onlyOwner { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; },"The owner can withdraw ethers after the presale has completed , only if the minimum funding level has been reached"
5903,"function isUserEnabledForContract ( address marketContractAddress , address userAddress ) external view returns ( bool ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] >= lockQtyToAllowTrading ; }",checks if a user address has locked the needed qty to allow trading to a given contract address
5905,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = loans . length - 1 ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } },Returns all the loans that a lender possess
5906,"function _setCampaign ( bytes32 bidId , uint price , uint budget , uint startDate , uint endDate , bool valid , address owner ) public onlyIfWhitelisted ( ""setCampaign"" , msg . sender ) { CampaignLibrary . Campaign storage campaign = campaigns [ bidId ] ; campaign . setBidId ( bidId ) ; campaign . setPrice ( price ) ; campaign . setBudget ( budget ) ; campaign . setStartDate ( startDate ) ; campaign . setEndDate ( endDate ) ; campaign . setValidity ( valid ) ; bool newCampaign = ( campaigns [ bidId ] . getOwner ( ) == 0x0 ) ; campaign . setOwner ( owner ) ; if ( newCampaign ) { emitCampaignCreated ( campaign ) ; setLastBidId ( bidId ) ; } else { emitCampaignUpdated ( campaign ) ; } }","Add or update a campaign information Based on a campaign Id ( bidId ) , a campaign can be created ( if non existent ) or updated ."
5907,"function getFirmFromAuthority ( Data storage self , address authorityAddress ) internal view returns ( string issuerFirm ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getString ( id ) ; }",Get the issuer firm registered to the authority Ethereum address
5908,function changeOwner ( address _newOwner ) onlyOwner { newOwner = _newOwner ; },` owner ` can step down and assign some other address to this role
5909,"function getAuditOutcome ( address _auditor , bytes32 _codeHash ) public view returns ( uint8 ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . outcome ; }",returns the outcome of the audit or NOT_AUDITED ( 0 ) if none
5911,"function verifyTransfer ( address , address _to , uint256 _amount , bool ) public returns ( Result ) { if ( ! paused ) { if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( 10 ** uint256 ( ISecurityToken ( securityToken ) . decimals ( ) ) ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }",Used to verify the transfer transaction according to the rule implemented in the trnasfer managers
5913,function setQuestionFee ( uint256 fee ) onlyOwner public { realitycheck . setQuestionFee ( fee ) ; LogSetQuestionFee ( fee ) ; },Set a fee for asking a question with us as the arbitrator
5915,function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( siringAuction != address ( 0 ) ) ; require ( geneScience != address ( 0 ) ) ; require ( lottery != address ( 0 ) ) ; require ( variation != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
5916,"function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner { require ( getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) != uint256 ( 0 ) , ""Module factory must be registered"" ) ; set ( Encoder . getKey ( ""verified"" , _moduleFactory ) , _verified ) ; emit ModuleVerified ( _moduleFactory , _verified ) ; }",- > Only if Polymath enabled the feature .
5918,"function withdrawAll ( ) { Splitter . withdrawInternal ( 0 , true ) ; }",Withdraws all funds available to the sender and deposits them into the sender 's account .
5919,"function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) , ""to address cannot be 0x0"" ) ; require ( _amount <= balanceOf ( msg . sender ) , ""not enough balance to transfer"" ) ; tokenStorage . subBalance ( msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }",Initiates a `` send '' operation towards another user .
5920,"function requestTokenPayment ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) external onlyAttestationLogic { validatePaymentSig ( _payer , _receiver , _amount , _nonce , _paymentSig ) ; payTokensFromEscrow ( _payer , _receiver , _amount ) ; emit TokenMarketplaceEscrowPayment ( _payer , _receiver , _amount ) ; }",Pay tokens to receiver from payer 's escrow given a valid signature
5921,"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by approvePreSigned
5922,"function isDataResponseValid ( address order , address seller , address notary , string dataHash , bytes signature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes memory packed = bytes ( dataHash ) . length > 0 ? abi . encodePacked ( order , notary , dataHash ) : abi . encodePacked ( order , notary ) ; bytes32 hash = keccak256 ( packed ) ; return isSignedBy ( hash , seller , signature ) ; }",Checks if the parameters passed correspond to the seller 's signature used .
5923,"function claimTokens ( address _token ) onlyOwner public { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } TokenERC20 token = TokenERC20 ( _token ) ; uint balance = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , balance ) ; }",This method can be used by the owner to extract sent tokens or ethers to this contract .
5924,"function collectAll ( uint8 max ) public returns ( uint8 collected ) { max = uint8 ( min ( max , contributors . length ) ) ; require ( max > 0 , ""can't collect for zero users"" ) ; uint index = contributors . length - 1 ; for ( uint offset = 0 ; offset < max ; ++ offset ) { address recipient = contributors [ index - offset ] ; if ( balances [ recipient ] > 0 ) { collected ++ ; collectFor ( recipient ) ; } } contributors . length -= offset ; }",Collects the balances for members of the purchase
5925,"function tokensOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 tokenId ) { uint256 count = 0 ; for ( uint256 i = 1 ; i <= totalSupply ( ) ; i ++ ) { if ( fighterIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }","Returns the nth Fighter assigned to an address , with n specified by the _index argument ."
5926,function finishPreICO ( ) onlyOwner external { require ( state == State . PreICO ) ; require ( icoStartTimestamp != 0 && icoEndTimestamp != 0 ) ; state = State . ICO ; },Finish PreICO stage and start ICO ( after time comes )
5927,function getProjectLevel ( PledgeAdmin m ) internal returns ( uint ) { assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . parentProject == 0 ) return ( 1 ) ; PledgeAdmin storage parentNM = findAdmin ( m . parentProject ) ; return getProjectLevel ( parentNM ) + 1 ; },A getter to find the level of authority a specific Project has using a self-referential loop
5928,"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
5930,"function isResolverFor ( uint ein , address resolver ) public view returns ( bool ) { return identityDirectory [ ein ] . resolvers . contains ( resolver ) ; }",Checks whether the passed resolver is set for the passed EIN .
5931,function unpause ( ) external onlyAdmin whenPaused { paused = false ; emit Unpaused ( ) ; },Unpauses the contract and returns to normal state .
5934,function getApproved ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; },Gets the approved address to take ownership of a given token ID
5935,"function _updateWhitelist ( address _account , uint8 _phase ) internal { if ( _phase == 1 ) { _whitelist [ _account ] = _invCap ; } else { _whitelist [ _account ] = 0 ; } emit WhitelistUpdated ( _account , _phase ) ; }",function to whitelist an address which can be called only by the capper address .
5936,function eligibleForDividence ( address _user ) public view returns ( bool _success ) { if ( moneySpent [ _user ] == 0 ) { return false ; } else if ( ( balances [ _user ] + allowed [ selfAddress ] [ _user ] ) / moneySpent [ _user ] > 20 ) { return false ; } return true ; },Query whether the user is eligible for claiming dividence
5937,"function alterBankBalance ( address _toAlter , uint256 _amount , bool sign ) external DAppOnline isAdmin { if ( sign && ( _amount + allowed [ selfAddress ] [ _toAlter ] ) > allowed [ selfAddress ] [ _toAlter ] ) { allowed [ selfAddress ] [ _toAlter ] = _amount + allowed [ selfAddress ] [ _toAlter ] ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { allowed [ selfAddress ] [ _toAlter ] = safeSub ( allowed [ selfAddress ] [ _toAlter ] , _amount ) ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }",Rise or lower user bank balance - Backend Function
5938,"function approve ( address _approved , uint256 _tokenId ) external payable canOperate ( _tokenId ) { address _owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( _owner == address ( 0 ) ) { _owner = address ( this ) ; } tokenApprovals [ _tokenId ] = _approved ; emit Approval ( _owner , _approved , _tokenId ) ; }",Change or reaffirm the approved address for an NFT
5939,"function approve ( address spender , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; tokenState . setAllowance ( sender , spender , value ) ; emitApproval ( sender , spender , value ) ; return true ; }",Approves spender to transfer on the message sender 's behalf .
5940,"function addMember ( bytes32 _membershipNumber , address _memberAddress , bytes32 _invitationCode , bytes32 _referralInvitationCode ) public onlyValidator isNotMember ( _memberAddress ) notStaking ( _memberAddress ) { require ( _memberAddress != address ( 0x0 ) , ""Member address was set to 0."" ) ; Member memory member = Member ( { addedTimestamp : block . timestamp , stakeTimestamp : 0 , startOfLoyaltyRewardEligibility : 0 , membershipNumber : _membershipNumber , invitationCode : _invitationCode , stakeBalance : 0 , invitationRewards : 0 , previouslyAppliedLoyaltyBalance : 0 } ) ; members [ _memberAddress ] = member ; membersArray . push ( _memberAddress ) ; registeredInvitationCodes [ member . invitationCode ] = _memberAddress ; address rewardMemberAddress = registeredInvitationCodes [ _referralInvitationCode ] ; if ( rewardMemberAddress != address ( 0x0 ) ) { Member storage rewardee = members [ rewardMemberAddress ] ; rewardee . invitationRewards = SafeMath . add ( rewardee . invitationRewards , invitationReward ) ; emit InvitationRewardGiven ( rewardMemberAddress , _memberAddress , invitationReward ) ; } emit MemberAdded ( _memberAddress , _membershipNumber , _invitationCode ) ; }",This function can only be called by a `` validator '' which is set inside the constructor
5942,"function assignShareTokens ( uint _count ) public onlyOwner { require ( status == state . success ) ; uint count = _count ; if ( winner_bids < assigned_bids . add ( count ) ) { count = winner_bids . sub ( assigned_bids ) ; } require ( count > 0 ) ; uint cursor = assigned_bids ; assigned_bids = assigned_bids . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; uint _shares_to_assign ; uint _executed_amount_valuation ; uint _return_amount ; ( _shares_to_assign , _executed_amount_valuation , _return_amount ) = calculate_shares_and_return ( bid . shares_count , bid . share_price , bid . transfer_valuation , final_share_price , bids [ bid . origin_index ] . art_price , bid . transfer_token ) ; bid . executed_amount = _executed_amount_valuation ; bid . asigned_shares_count = _shares_to_assign ; assigned_shares = assigned_shares . add ( _shares_to_assign ) ; final_fundraise = final_fundraise . add ( _executed_amount_valuation ) ; final_shares_sold = final_shares_sold . add ( _shares_to_assign ) ; if ( _return_amount > 0 ) { art_token_contract . transfer ( bid . investor_address , _return_amount ) ; } bid . closed = true ; if ( shares_holders_balance [ bid . investor_address ] == 0 ) { shares_holders [ shares_holders_count ++ ] = bid . investor_address ; } emit Assigned ( bid . origin_index , _shares_to_assign , _executed_amount_valuation , _return_amount ) ; shares_holders_balance [ bid . investor_address ] = shares_holders_balance [ bid . investor_address ] . add ( _shares_to_assign ) ; cursor ++ ; count -- ; } }",Assign the asset share tokens to winner bid 's authors
5944,"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { remaining = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_allowance ( _owner , _spender ) ; }",check the spending allowance of a given user from a given account
5946,"function acceptOwnership ( ) public { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership"
5947,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyAuthorized public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
5948,"function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = collectibleIndexToOwner [ _tokenId ] ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }",Returns all the relevant information about a specific collectible .
5950,function fundsOf ( address _address ) constant returns ( uint valueWei ) { return funds [ _address ] ; },Amount of ether held for ` _address ` .
5952,"function setInterfaceImplementer ( address addr , bytes32 iHash , address implementer ) public canManage ( addr ) { interfaces [ addr ] [ iHash ] = implementer ; InterfaceImplementerSet ( addr , iHash , implementer ) ; }",Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it
5953,function setFallback ( address _fallback ) public onlyOwner returns ( bool ) { fallback = _fallback ; return true ; },"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle"
5954,function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .
5955,"function getRawPendingAmount ( uint index ) public view returns ( uint256 ) { Loan memory loan = loans [ index ] ; return safeSubtract ( safeAdd ( safeAdd ( loan . amount , loan . interest ) , loan . punitoryInterest ) , loan . paid ) ; }",Returns the pending amount up to the last time of the interest update .
5956,function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = elementToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given element .
5958,"function transferFrom ( address _from , address _to , uint256 _value ) public payloadSizeIs ( 3 * 32 ) returns ( bool ) { thawSomeTokens ( _from , _value ) ; return super . transferFrom ( _from , _to , _value ) ; }",Standard transferFrom overridden to have a chance to thaw sender 's tokens .
5959,function reclaimEther ( ) external onlyAdmin { msg . sender . transfer ( address ( this ) . balance ) ; },Transfers all Ether held by the contract to the owner .
5960,"function setApprovalForAll ( address _operator , bool _approved ) external { if ( _approved ) { addressToApprovedAll [ msg . sender ] = _operator ; } else { delete addressToApprovedAll [ msg . sender ] ; } emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .
5961,"function setGuaranteedAddress ( address _th , uint256 _limit ) public initialized onlyOwner { require ( getBlockNumber ( ) < startBlock ) ; require ( _limit > 0 && _limit <= maxGuaranteedLimit ) ; guaranteedBuyersLimit [ _th ] = _limit ; GuaranteedAddress ( _th , _limit ) ; }",Sets the limit for a guaranteed address .
5963,"function authorizePayment ( address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; if ( _paymentDelay > 10 ** 18 ) throw ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }",only ` allowedSpenders [ ] ` Creates a new ` Payment `
5964,"function pickRandomAssetPosition ( uint _randomSeed , uint _width , uint _height ) public pure returns ( uint x , uint y , uint zoom , uint rotation , uint layer ) { x = _randomSeed % _width ; y = _randomSeed % _height ; zoom = _randomSeed % 200 + 800 ; rotation = _randomSeed % 360 ; layer = _randomSeed % 1234567 ; }",Function to pick random position for an asset
5969,"function getPrices ( address [ ] ofAssets ) view returns ( bool areRecent , uint [ ] prices , uint [ ] decimals ) { areRecent = true ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( isRecent , price , decimal ) = getPrice ( ofAssets [ i ] ) ; if ( ! isRecent ) { areRecent = false ; } prices [ i ] = price ; decimals [ i ] = decimal ; } }","Price of a registered asset in format ( bool areRecent , uint [ ] prices , uint [ ] decimals )"
5970,"function playerForceGameEnd ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . PLAYER_INITIATED_END ) ; int newBalance = conflictRes . playerForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , playerAddress , ReasonEnded . END_FORCED_BY_PLAYER , newBalance ) ; }",Force end of game if server does not respond .
5973,"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit LogGenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( permissionManager ) ; }",used to launch the Module with the help of factory
5976,"function addProposal ( uint _duration , bytes32 _storageHash ) public returns ( uint _proposalId ) { require ( _duration >= MIN_PROPOSAL_DURATION ) ; require ( _duration <= MAX_PROPOSAL_DURATION ) ; uint amount = MiniMeToken ( nectarToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; _proposalId = proposals . length ; proposals . length ++ ; Proposal storage p = proposals [ _proposalId ] ; p . storageHash = _storageHash ; p . duration = _duration * ( 1 days ) ; p . proposer = msg . sender ; emit NewProposal ( _proposalId , _duration , _storageHash ) ; }",Add new proposal and put it in list to be approved
5977,function countValidators ( ) external view returns ( uint256 ) ;,Count the number of validators defined by the jurisdiction .
5979,"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { for ( uint256 i = 0 ; i < modules [ PERMISSION_KEY ] . length ; i ++ ) { if ( ! modulesToData [ modules [ PERMISSION_KEY ] [ i ] ] . isArchived ) return TokenLib . checkPermission ( modules [ PERMISSION_KEY ] , _delegate , _module , _perm ) ; } return false ; }","Validate permissions with PermissionManager if it exists , If no Permission return false"
5980,"function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == holderId || assets [ _symbol ] . partowners [ holderId ] ) ; }",Checks if a specified address has asset owner or co-owner rights .
5985,function giveMeETH ( ) public auth { msg . sender . transfer ( address ( this ) . balance ) ; },transfer all ETH balance from this contract to the sender
5986,"function goalReached ( ) internal { emit SoftcapReached ( treasury , fundingGoal ) ; fundingGoalReached = true ; if ( weiRaisedInPICO < fundingGoal ) { PICO . extGoalReached ( ) ; } }",a function that changes state if goal reached .
5988,"function _answerData ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { bool is_pending_arbitration ; bytes32 history_hash ; if ( last_bond == 0 ) { return ( false , bytes32 ( 0 ) ) ; } bytes32 last_answer ; bool is_answered ; if ( is_commitment ) { uint256 reveal_ts ; bool is_revealed ; bytes32 revealed_answer ; ( reveal_ts , is_revealed , revealed_answer ) = realitio . commitments ( last_answer_or_commitment_id ) ; if ( is_revealed ) { last_answer = revealed_answer ; is_answered = true ; } else { require ( reveal_ts < uint32 ( now ) , ""Arbitration cannot be done until the last answerer has had time to reveal their commitment"" ) ; is_answered = false ; } } else { last_answer = last_answer_or_commitment_id ; is_answered = true ; } return ( is_answered , last_answer ) ; }","Given the last history entry , get whether they had a valid answer if so what it was"
5990,"function transfer ( address _to , uint _value ) returns ( bool ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",` _value ` tokens will be sended to ` _to `
5991,"function cloneOrder ( address _contractorAddress , uint _contractorProposalID , uint _orderAmount , uint _lastOrderDate ) { if ( projectManager != 0 ) throw ; addOrder ( _contractorAddress , _contractorProposalID , _orderAmount , _lastOrderDate ) ; }",Function to allow cloning orders in case of upgrade
5993,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { address tokenOwner = ownerOf ( _tokenId ) ; require ( isSenderApprovedFor ( _tokenId ) || ( approvedContractAddresses [ msg . sender ] && tokenOwner == tx . origin ) , ""not an approved sender"" ) ; require ( tokenOwner == _from , ""wrong owner"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }","Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
5995,"function removeDarknode ( address darknodeID ) external onlyOwner { uint256 bond = darknodeRegistry [ darknodeID ] . bond ; delete darknodeRegistry [ darknodeID ] ; LinkedList . remove ( darknodes , darknodeID ) ; require ( ren . transfer ( owner , bond ) , ""bond transfer failed"" ) ; }",Removes a darknode from the store and transfers its bond to the owner of this contract .
5999,"function insertAfter ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , ""already in list"" ) ; require ( isInList ( self , target ) || target == NULL , ""not in list"" ) ; address n = self . list [ target ] . next ; self . list [ newNode ] . previous = target ; self . list [ newNode ] . next = n ; self . list [ target ] . next = newNode ; self . list [ n ] . previous = newNode ; self . list [ newNode ] . inList = true ; }",Insert a new node after an existing node .
6000,"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
6003,"function executeTransaction ( address destination , uint value , bytes data ) public onlyOwner { if ( destination . call . value ( value ) ( data ) ) emit Execution ( destination , value , data ) ; else emit ExecutionFailure ( destination , value , data ) ; }",Proxy function which allows sending of transactions in behalf of the contract
6005,"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ; }",Hash ( keccak256 ) of the payload used by transferPreSigned
6006,"function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time , ""Time must be in the future"" ) ; require ( quantity != 0 , ""Quantity cannot be zero"" ) ; totalVestedBalance = totalVestedBalance . add ( quantity ) ; require ( totalVestedBalance <= synthetix . balanceOf ( this ) , ""Must be enough balance in the contract to provide for the vesting entry"" ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES , ""Vesting schedule is too long"" ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time , ""Cannot add new vested entries earlier than the last one"" ) ; totalVestedAccountBalance [ account ] = totalVestedAccountBalance [ account ] . add ( quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }",Add a new vesting entry at a given time and quantity to an account 's schedule .
6007,"function buy ( ) public payable returns ( uint256 amount ) { if ( initialSaleComplete ) { uint256 b = 0 ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1 + _totalSupply / SU ) , 1 ) ; p = ( S * p ) >> ps ; b = ( ln_fixed3_lnr_18 ( RS * msg . value / SU + p , 1 ) - 1e18 * lnRS - 1e18 * FIXED_3 ) / FIXED_3 ; refund = msg . value - ( msg . value / SU ) * SU ; amount = b * SU / 1e18 - _totalSupply ; reserveAddress . transfer ( ( msg . value / SU ) * SU ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; msg . sender . transfer ( refund ) ; quoteAsk ( ) ; quoteBid ( ) ; } else { ask = ICOask ; amount = 1e16 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e16 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }",Buys aToken in exchnage for wei at the current ask price
6008,function closeSale ( ) public onlyOwner { closePreSale ( ) ; },Public function enables closing of the pre-sale manually if necessary
6009,function mintTokens ( uint256 _tokens ) external ;,Called when new tokens are needed in circulation
6011,"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }",Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
6012,function setPricesManually ( string _prices ) external onlyOwner { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; setPrices ( _prices ) ; },"set the price of currencies in euro , called in case we do n't get oraclize data for more than double the update interval"
6015,"function emergencyWithdraw ( address _withdrawer , address _token , uint256 _amount ) external onlyCoordinator onlyInactiveState { _withdraw ( _withdrawer , _token , _amount , etherAddr , 0 ) ; }",Withdraws tokens to the owner without requiring the owner 's signature
6018,function withdraw ( address addr ) onlyOwner public { addr . transfer ( this . balance ) ; },Withdraw any accumulated fees to the specified address
6019,"function setAllowedAddress ( address _addr ) public onlyOwner ( ""setAllowedAddress"" ) { if ( allowedAddress != 0x0 ) { StorageUser storageUser = StorageUser ( _addr ) ; address storageContract = storageUser . getStorageAddress ( ) ; require ( storageContract == advStorageContract ) ; } super . setAllowedAddress ( _addr ) ; }",Sets the Advertisement contract address to allow calls from Advertisement contract This function is used for upgrading the Advertisement contract without need to redeploy Advertisement Finance and Advertisement Storage contracts .
6023,function toggleContractStopped ( ) public onlyOwner { contractStopped = ! contractStopped ; },only the contract owner is allowed to change
6024,"function challengeBefore ( uint64 slot , bytes prevTxBytes , bytes txBytes , bytes prevTxInclusionProof , bytes txInclusionProof , bytes signature , uint256 [ 2 ] blocks ) external payable isBonded isState ( slot , State . EXITING ) { doInclusionChecks ( prevTxBytes , txBytes , prevTxInclusionProof , txInclusionProof , signature , blocks ) ; setChallenged ( slot , txBytes . getOwner ( ) , blocks [ 1 ] , txBytes . getHash ( ) ) ; }",Exitor has to call respondChallengeBefore and submit a transaction before prevTx or prevTx itself .
6025,"function newTokenDeposit ( ERC20 _token , uint _amount , uint _block ) public onlyOwner returns ( uint _idDeposit ) { require ( _amount > 0 ) ; require ( _block < block . number ) ; require ( _token . transferFrom ( msg . sender , address ( this ) , _amount ) ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = _token ; d . amount = _amount ; NewDeposit ( _idDeposit , _token , _amount ) ; }",Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens
6027,"function redeemVoucherSingle ( uint256 voucherCode , address voucherOwner , address seller , uint256 quantity ) public onlyOwner payable { TradeOrder memory order = orderBook [ seller ] ; execute ( seller , quantity , order . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , quantity ) ; }",A user has redeemed a top-up voucher for phone credit .
6031,"function approve ( address _spender , uint _value ) returns ( bool success ) { }",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
6032,"function claimTokens ( address _token ) public onlyOwner { if ( SNT . controller ( ) == address ( this ) ) { SNT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
6033,"function updatePrice ( uint gasPriceInWei ) public payable whenNotPaused { if ( gasPriceInWei > 0 ) { oraclize_setCustomGasPrice ( gasPriceInWei ) ; } if ( oraclize_getPrice ( ""URL"" ) > address ( this ) . balance ) { emit LogOraclizeQuery ( """" , gasPriceInWei , ""Oraclize query was NOT sent, please add some ETH to cover for the query fee"" ) ; } else { bytes32 queryId = oraclize_query ( 0 , ""URL"" , REQUEST_URL , callbackGasLimit ) ; validIds [ queryId ] = true ; emit LogOraclizeQuery ( queryId , gasPriceInWei , ""Oraclize query was sent, standing by for the answer..."" ) ; } }",Will not check the right ammount of money .
6034,function get_Sponsors_list_by_Job ( uint _JobID ) public view returns ( address [ ] list ) { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; list = new address [ ] ( job . sponsorsCount ) ; list = job . sponsorList ; },this function lets retrieve the list of all sponsors in a given job
6035,function debtLedgerLength ( ) external view returns ( uint ) { return debtLedger . length ; },Retrieve the length of the debt ledger array
6036,function hasRecentPrices ( address [ ] ofAssets ) view returns ( bool areRecent ) { for ( uint i ; i < ofAssets . length ; i ++ ) { if ( ! hasRecentPrice ( ofAssets [ i ] ) ) { return false ; } } return true ; },Whether prices of assets have been updated less than VALIDITY seconds ago
6037,function setUpgradeHasBegun ( ) internal { if ( ! upgradeHasBegun ) { upgradeHasBegun = true ; UpgradeHasBegun ( ) ; } },Sets flag to prevent changing newToken after upgrade
6038,"function multiCall ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeCall ( _addresses [ i ] , _amounts [ i ] ) ; MultiCall ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }",Call to multiple contracts using two arrays which includes the contract address and the amount .
6039,"function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; address [ ] memory investors = ISecurityToken ( securityToken ) . getInvestors ( ) ; uint256 numberInvestors = Math . min256 ( investors . length , _start . add ( _iterations ) ) ; for ( uint256 i = _start ; i < numberInvestors ; i ++ ) { address payee = investors [ i ] ; if ( ( ! dividend . claimed [ payee ] ) && ( ! dividend . dividendExcluded [ payee ] ) ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }",Issuer can push dividends using the investor list from the security token
6040,"function cancelProject ( uint uuid ) public onlyCurator { communityAccount . setTotalProjectEscrow ( SafeMath . sub ( communityAccount . totalProjectEscrow ( ) , communityAccount . escrowedProjectBalances ( uuid ) ) ) ; communityAccount . setEscrowedProjectBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""cancelProject"" , """" ) ; }",Subtracts tasks escrow and sets tasks escrow balance to 0
6041,"function requestRefund ( ) external { assert ( getState ( ) == State . Failure ) ; assert ( funders [ msg . sender ] > 0 ) ; msg . sender . transfer ( funders [ msg . sender ] ) ; emit Refund ( msg . sender , funders [ msg . sender ] , block . number ) ; funders [ msg . sender ] = 0 ; }",Get back the ether sent during the funding in case the funding has not reached the soft cap .
6042,"function getLibrary ( uint256 _tokenId ) public view returns ( string language , string libraryName , uint256 tokenPrice , uint256 funds , address tokenOwner , address founder ) { Library storage x = libraries [ _tokenId ] ; libraryName = x . name ; language = x . language ; founder = libraryIndexToFounder [ _tokenId ] ; funds = libraryIndexToFunds [ _tokenId ] ; tokenPrice = libraryIndexToPrice [ _tokenId ] ; tokenOwner = libraryIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific library .
6043,"function mint ( address _to , uint256 _tokenId ) auth ( MINT_ROLE ) public { _mint ( _to , _tokenId ) ; }",Mint ` _tokenId ` and give the ownership to ` _to `
6044,"function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , ""Self destruct has not yet been initiated"" ) ; require ( initiationTime + SELFDESTRUCT_DELAY < now , ""Self destruct delay has not yet elapsed"" ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }","If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address ."
6045,function getMinerHalvingHashRate ( ) public constant returns ( uint256 ) { return getMinerHalvingHashRateOf ( msg . sender ) ; },Total hash rate of a miner in a halving
6047,"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( msg . sender ) ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from your account
6048,"function personalizeSquare ( uint256 _squareId , bytes _rgbData , string _title , string _href ) external onlyOwnerOf ( _squareId ) payable { require ( bytes ( _title ) . length <= 64 ) ; require ( bytes ( _href ) . length <= 96 ) ; require ( _rgbData . length == 300 ) ; suSquares [ _squareId ] . version ++ ; suSquares [ _squareId ] . rgbData = _rgbData ; suSquares [ _squareId ] . title = _title ; suSquares [ _squareId ] . href = _href ; if ( suSquares [ _squareId ] . version > 3 ) { require ( msg . value == 10 finney ) ; } emit Personalized ( _squareId ) ; }","Update the contents of your square , the first 3 personalizations for a square are free then cost 100 finney ( 0.01 ether ) each"
6050,"function unlockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( ""BrickblockToken"" ) ) ; require ( _amount <= lockedBbkPerUser [ msg . sender ] ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . sub ( _amount ) ; totalLockedBBK = totalLockedBBK . sub ( _amount ) ; require ( _bbk . transfer ( msg . sender , _amount ) ) ; emit BbkUnlocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }",Transfers BBK from this contract to an account 1 .
6052,"function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }",Send ` _value ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
6053,"function disableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( executorEntry . enabled , ERROR_EXECUTOR_DISABLED ) ; executorEntry . enabled = false ; emit DisableExecutor ( _executorId , executorEntry . executor ) ; }",Disable script executor with ID ` _executorId `
6054,"function unlock ( ) external { require ( allocations [ msg . sender ] . locked ) ; require ( now >= allocations [ msg . sender ] . end ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( allocations [ msg . sender ] . value ) ; allocations [ msg . sender ] . locked = false ; Transfer ( this , msg . sender , allocations [ msg . sender ] . value ) ; Unlock ( this , msg . sender , allocations [ msg . sender ] . value ) ; }",Only the owner of a locked wallet can unlock the tokens .
6055,"function collect ( ) public { assert ( getBlockNumber ( ) > contribution . startBlock ( ) ) ; uint256 balance = sit . balanceOfAt ( msg . sender , contribution . initializedBlock ( ) ) ; uint256 amount = balance . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( msp . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }",This method should be called by the SIT holders to collect their corresponding MSPs
6056,function removeModule ( address _moduleFactory ) external ;,Called by the ModuleFactory owner or registry curator to delete a ModuleFactory
6058,"function buyoutWithData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { require ( buyoutsEnabledFromTimestamp <= block . timestamp ) ; address currentOwner = identifierToOwner [ _deedId ] ; require ( currentOwner != 0x0 ) ; uint256 [ ] memory claimedSurroundingPlots = _claimedSurroundingPlots ( _deedId ) ; uint256 totalCost = _calculateAndAssignBuyoutProceeds ( currentOwner , _deedId , claimedSurroundingPlots ) ; require ( msg . value >= totalCost ) ; _transfer ( currentOwner , msg . sender , _deedId ) ; SetData ( _deedId , name , description , imageUrl , infoUrl ) ; identifierToBuyoutPrice [ _deedId ] = nextBuyoutPrice ( totalCost ) ; if ( ! identifierToBoughtOutOnce [ _deedId ] ) { identifierToBoughtOutOnce [ _deedId ] = true ; } uint256 excess = msg . value - totalCost ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }",Buy the current owner out of the plot .
6060,"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Metadollar price updated!"" ) ; } }",Set current ICO prices in wei for one metadollar
6063,"function redeemVoucher ( uint256 voucherCode , address voucherOwner , address tokenSeller , uint256 quantity ) public onlyOwner payable { buy ( tokenSeller , quantity , orderBook [ tokenSeller ] . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , tokenSeller , quantity ) ; }",A user has redeemed a top-up voucher for phone credit .
6067,function setFundsRegistry ( address _funds ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _funds ) ; m_funds = FundsRegistry ( _funds ) ; },In case we need to attach to existent funds
6069,"function checkIfTradeAmountsAcceptable ( Trade trade , uint256 amountSpentOnTrade , uint256 amountReceivedFromTrade ) internal view returns ( bool passed ) { uint256 tokenAmount = trade . isSell ? amountSpentOnTrade : amountReceivedFromTrade ; passed = tokenAmount >= trade . minimumAcceptableTokenAmount ; if ( ! passed ) { } if ( passed ) { uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 actualRate = Utils . calcRateFromQty ( amountSpentOnTrade , amountReceivedFromTrade , srcDecimals , destDecimals ) ; passed = actualRate >= trade . minimumExchangeRate ; } if ( ! passed ) { } }",Check if the amounts spent and gained on a trade are within the user '' s set limits
6070,function getApproved ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( address ) { return tokenApprovals [ _tokenId ] ; },Get the approved address for a single NFT
6072,"function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = IMedianizer ( medianizer ) . peek ( ) ; require ( valid , ""MakerDAO Oracle returning invalid value"" ) ; return uint256 ( price ) ; }",Returns price - should throw if not valid
6074,function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit AllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; },Used to change the flag true - It refers that time lock is ignored for transfers ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
6075,"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = powIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }",Allow pre-approved user to take ownership of a token
6078,"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _decreaseApproval ( _spender , _subtractedValue , msg . sender ) ; return true ; }",decreaseApproval should be used instead of approve when the user 's allowance is greater than 0 .
6081,"function setFundsRegistry ( address _funds ) external validAddress ( _funds ) timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { m_funds = FundsRegistry ( _funds ) ; }",In case we need to attach to existent funds
6082,"function increaseGasSpent ( bytes32 _tradeHash , uint128 _gas ) private { escrows [ _tradeHash ] . totalGasFeesSpentByRelayer += _gas * uint128 ( tx . gasprice ) ; }",Increase the amount of gas to be charged later on completion of an escrow
6083,"function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched value parameter and tx value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether transfer"" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , receivedValue ) ; }",Deposits ETH or an ERC20 token into the contract .
6084,"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
6087,function setMinimumInitialBudgetForAudits ( uint256 _minimumInitialBudgetForAudits ) public onlyOwner whenNotPaused returns ( bool ) { minimumInitialBudgetForAudits = _minimumInitialBudgetForAudits ; return true ; },Sets the minimum initial budget for audits to be placed by a buyer on DataOrder creation .
6091,function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ethernautsStorage . balanceOf ( _owner ) ; },Returns the number of Assets owned by a specific address .
6092,"function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( ""TTP unable to transfer tokens to primary"" ) ; } } } }","Iterates through a list of token orders , transfer the SELL orders to this contract & calculates if we have the ether needed"
6093,"function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex""A0"" ) ; } if ( ! _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex""B0"" ) ; } ( address validator , bool unused ) = _jurisdiction . getAttributeValidator ( account , _validAttributeTypeID ) ; unused ; if ( validator != address ( this ) ) { return ( false , hex""C0"" ) ; } return ( true , hex""01"" ) ; }",Check if the validator is approved to revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
6095,"function updateWhitelistAddresses ( address [ ] _accounts , uint8 _phase ) external onlyCapper { for ( uint256 i = 0 ; i < _accounts . length ; i ++ ) { require ( _accounts [ i ] != address ( 0 ) ) ; _updateWhitelist ( _accounts [ i ] , _phase ) ; } }",function to whitelist an address which can be called only by the capper address .
6096,function darknodeRegisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . registeredAt ; },Returns the registration time of a given darknode .
6098,function getAddress ( bytes32 _key ) public view returns ( address _value ) { return addressStorage [ _key ] ; },Get value for Address associated with bytes32 id key
6100,"function claimVestedTokens ( address _recipient ) external { uint256 yearsVested ; uint256 amountVested ; ( yearsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; require ( amountVested > 0 , ""amountVested is 0"" ) ; Grant storage tokenGrant = tokenGrants [ _recipient ] ; tokenGrant . yearsClaimed = yearsVested ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( _recipient , amountVested ) , ""no tokens"" ) ; emit GrantTokensClaimed ( _recipient , amountVested ) ; }",Allows a grant recipient to claim their vested tokens .
6102,"function donateAndCreateGiver ( address giver , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giver != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit DonateAndCreateGiver ( giver , receiverId , token , amount ) ; }",It is not recommened to call this function outside of the giveth dapp ( giveth.io ) this function is bridged to a side chain .
6104,"function grantToken ( uint256 _tokenId , address _newOwner ) external onlyOperatingOfficer mustBeValidToken ( _tokenId ) mustBeOwnedByThisContract ( _tokenId ) { require ( promoCreatedCount < PROMO_CREATION_LIMIT ) ; promoCreatedCount ++ ; _transfer ( _tokenId , _newOwner ) ; }","BEWARE , this does not use a safe transfer mechanism !"
6105,"function generate_token_for ( address _addrTo , uint256 _amount ) mayGenerate returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _addrTo ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _addrTo ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _addrTo , _amount ) ; return true ; }",This function is copy-paste of the generateTokens of the original MiniMi contract except it uses mayGenerate modifier ( original uses onlyController )
6110,"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }",Access point for the oracle to update the prices of havvens / eth .
6111,"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , ""Interval between scheduled time should be greater than zero"" ) ; require ( _iters > 0 , ""No iterations specified"" ) ; require ( _startTime >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; require ( oraclize_getPrice ( ""URL"" , gasLimit ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }",Allows owner to schedule future Oraclize calls on a rolling schedule
6114,function proxyPayment ( address _owner ) payable returns ( bool ) { return false ; },"` proxyPayment ( ) ` returns false , meaning ether is not accepted at the token address , only the address of FiinuCrowdSale"
6115,function ( ) payable { receiveEther ( ) ; },The fall back function is called whenever ether is sent to this contract
6116,function removeContract ( ) public onlyOwner { if ( ! saleFinalized ) revert ( ) ; selfdestruct ( msg . sender ) ; },remove conttact only when sale has been finalized transfer all the fund to the contract owner
6117,"function canIssueAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex""A0"" ) ; } if ( _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex""B0"" ) ; } return ( true , hex""01"" ) ; }",Check if the validator is approved to issue an attribute of the type with ID ` attributeTypeID ` to account ` account ` on the jurisdiction .
6118,function executeDecision ( uint _boardMeetingID ) returns ( bool ) ;,Function to execute a board meeting decision and close the board meeting
6120,"function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , bytes32 _name ) external payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , excluded , _name ) ; }","Creates a dividend with a provided checkpoint , using global list of excluded addresses"
6122,"function setCampaign ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _owner , string _endPoint ) public onlyIfWhitelisted ( ""setCampaign"" , msg . sender ) { bool newCampaign = ( getCampaignOwnerById ( _bidId ) == 0x0 ) ; _setCampaign ( _bidId , _price , _budget , _startDate , _endDate , _valid , _owner ) ; campaignEndPoints [ _bidId ] = _endPoint ; if ( newCampaign ) { emit ExtendedCampaignEndPointCreated ( _bidId , _endPoint ) ; } else { emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; } }","Add or update a campaign information Based on a campaign Id ( bidId ) , a campaign can be created ( if non existent ) or updated ."
6123,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) throw ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
6124,"function tokenOfCollectionByIndex ( uint64 _collectionIndex , uint256 _index ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; require ( _index < collectionTokens [ _collectionIndex ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ collectionTokens [ _collectionIndex ] [ _index ] ] ; return pixelcon . tokenId ; }",Enumerate PixelCon in collection # ` ( _collectionIndex ) `
6125,"function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }",Access point for the oracle to update the price of havvens .
6126,function isBalanceSufficientForContractCreation ( address userAddress ) external view returns ( bool ) { return balances [ userAddress ] >= minBalanceToAllowContractCreation ; },checks if a user address has enough token balance to be eligible to create a contract
6127,function hasIssued ( address account ) external view returns ( bool ) { return issuanceData [ account ] . initialDebtOwnership > 0 ; },Query whether an account has issued and has an outstanding debt balance
6129,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }",Transfer `` _value '' tokens from `` _from '' to `` _to '' if `` msg.sender '' is allowed .
6130,"function pack ( uint8 _major , uint8 _minor , uint8 _patch ) internal pure returns ( uint24 ) { return ( uint24 ( _major ) << 16 ) | ( uint24 ( _minor ) << 8 ) | uint24 ( _patch ) ; }",Used to pack the uint8 [ ] array data into uint24 value
6131,"function registerModule ( address _moduleFactory ) external whenNotPaused returns ( bool ) { require ( registry [ _moduleFactory ] == 0 , ""Module factory should not be pre-registered"" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; require ( moduleFactory . getType ( ) != 0 , ""Factory type should not equal to 0"" ) ; registry [ _moduleFactory ] = moduleFactory . getType ( ) ; moduleList [ moduleFactory . getType ( ) ] . push ( _moduleFactory ) ; reputation [ _moduleFactory ] = new address [ ] ( 0 ) ; emit LogModuleRegistered ( _moduleFactory , moduleFactory . owner ( ) ) ; return true ; }",Called by moduleFactory owner to register new modules for SecurityToken to use
6132,function synthsReceivedForEther ( uint amount ) public view returns ( uint ) { uint synthsTransferred = amount . multiplyDecimal ( usdToEthPrice ) ; return feePool . amountReceivedFromTransfer ( synthsTransferred ) ; },Calculate how many synths you will receive if you transfer an amount of ether .
6133,function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; },function balanceOf will display balance of given address
6136,function countOfDeedsByOwner ( address _owner ) public view returns ( uint256 ) { return ownershipDeedCount [ _owner ] ; },Returns the number of deeds owned by a specific address .
6137,"function updateDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyProjectManager { description = _projectDescription ; hashOfTheDocument = _hashOfTheDocument ; ProjectDescriptionUpdated ( msg . sender , _projectDescription , _hashOfTheDocument ) ; }",Function to allow the project manager updating the description of the project
6138,"function setAddressAliasUnsafe ( address oldAddr , address newAddr ) public onlyRole ( roleAddressAliaser ( ) ) { addressAlias [ newAddr ] = oldAddr ; emit UserAddressAliased ( oldAddr , newAddr ) ; }","Alias a new address to an old address , bypassing all safety checks ."
6139,"function postIcoHold ( address who , uint256 quantity , uint256 addedTime ) public onlyTransferAgent { require ( who != 0x0 , ""The null address cannot own tokens."" ) ; require ( quantity != 0 , ""Quantity must be greater than zero."" ) ; require ( ! isExistingHolding ( who ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; Holding memory holding = Holding ( quantity , block . timestamp + addedTime , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }",Hold tokens post-ICO with a variable release date on those tokens .
6140,function getSuppliers ( ) public view returns ( SupplierInterface [ ] ) { return suppliers ; },should be called off chain with as much gas as needed
6141,"function addCommissionToPendingWithdrawals ( uint32 _canvasId ) external onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; uint commission ; bool isPaid ; ( commission , isPaid ) = calculateCommission ( _canvasId ) ; require ( commission > 0 ) ; require ( ! isPaid ) ; canvas . isCommissionPaid = true ; addPendingWithdrawal ( owner , commission ) ; emit CommissionAddedToWithdrawals ( _canvasId , commission , ACTION_INITIAL_BIDDING ) ; }",Only for the owner of the contract .
6142,"function addPermission ( bytes4 _methodsignature , string _permissionName , string _permissionDescription , string _contractName ) public onlyValidator { Permission memory p = Permission ( _permissionName , _permissionDescription , _contractName , true ) ; permissions [ _methodsignature ] = p ; emit PermissionAdded ( _methodsignature ) ; }",Sets a permission within the list of permissions .
6143,"function addValidator ( address validator , string description ) external onlyOwner whenNotPaused { require ( validator != address ( 0 ) , ""must supply a valid address"" ) ; require ( isValidator ( validator ) == false , ""a validator with the provided address already exists"" ) ; _validators [ validator ] = Validator ( { exists : true , index : _validatorAccounts . length , description : description } ) ; _validatorAccounts . push ( validator ) ; emit ValidatorAdded ( validator , description ) ; }",Add account ` validator ` as a validator with a description ` description ` who can be approved to set attributes of specific types .
6146,function ( ) public payable { require ( msg . value >= MIN_INVESTMENT ) ; require ( now >= preIcoStart && now <= preIcoEnd ) ; require ( isContract ( msg . sender ) == false ) ; if ( invested [ msg . sender ] == false ) { invested [ msg . sender ] = true ; } preIcoAddr . buyTokens . value ( msg . value ) ( msg . sender ) ; },"This function will record your investment in this reservation contract and forward eths to the pre-ico , please note , you need to invest at least MIN_INVESTMENT and you must invest directly from your address , contracts are not allowed"
6147,"function isLegalCoordinates ( uint8 _fromX , uint8 _fromY , uint8 _toX , uint8 _toY ) private pure returns ( bool ) { return ( ( _fromX >= 1 ) && ( _fromY >= 1 ) && ( _toX <= 100 ) && ( _toY <= 100 ) && ( _fromX <= _toX ) && ( _fromY <= _toY ) ) ; }",insures that area coordinates are within 100x100 field and from-coordinates > = to-coordinates
6148,function balanceOf ( address _owner ) external view returns ( uint ) { return addressToCount [ _owner ] ; },Returns number of canvases owned by the given address .
6149,function setWinnerPrizes ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . TopWinnersAssigned ) { require ( lastPrizeGiven + amount <= winnerCounter ) ; uint16 inRangeCounter = payDistributionAmount [ payoutRange ] ; for ( uint256 i = 0 ; i < amount ; i ++ ) { if ( inRangeCounter == 0 ) { payoutRange ++ ; inRangeCounter = payDistributionAmount [ payoutRange ] ; } uint256 tokenId = sortedWinners [ i + lastPrizeGiven ] ; tokenToPayoutMap [ tokenId ] = payoutDistribution [ payoutRange ] ; inRangeCounter -- ; } lastPrizeGiven += amount ; payDistributionAmount [ payoutRange ] = inRangeCounter ; if ( lastPrizeGiven == winnerCounter ) { pValidationState = pointsValidationState . WinnersAssigned ; return ; } },Sets prize percentage to every address that wins from the position 30th onwards
6151,function setSanityBounds ( uint256 _sanityBounds ) onlyOwner public { sanityBounds = _sanityBounds ; },Allows owner to set new sanity bounds for price updates
6152,"function hasRecentPrice ( address ofAsset ) view pre_cond ( information [ ofAsset ] . exists ) returns ( bool isRecent ) { return sub ( now , information [ ofAsset ] . timestamp ) <= VALIDITY ; }",Whether price of asset has been updated less than VALIDITY seconds ago
6153,"function registerAndActivateDevice ( bytes32 _deviceId , bytes32 _deviceType , bytes32 _devicePublicKey ) public onlyManufacturer whenNotPaused returns ( bool ) { uint256 registrationFee = settings . registrationFee ( ) ; uint256 activationFee = settings . activationFee ( ) ; bytes32 deviceIdHash = keccak256 ( _deviceId ) ; Device memory d = _registerDevice ( msg . sender , deviceIdHash , _deviceType , _devicePublicKey ) ; bytes32 manufacturerId = d . manufacturerId ; emit DeviceRegistered ( msg . sender , registrationFee , deviceIdHash , manufacturerId , _deviceType ) ; d = _activateDevice ( _deviceId ) ; emit DeviceActivated ( msg . sender , activationFee , _deviceId , manufacturerId , _deviceType ) ; uint256 fee = registrationFee . add ( activationFee ) ; _depositTokens ( msg . sender , fee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , fee ) , ""transferFrom failed"" ) ; return true ; }","Registers and immediately activates device , used by manufacturers to prepay activation"
6154,"function allocate ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) onlyAllowedAddresses whenNotPaused external { crowdsale . allocateTokens ( _receiver , _customerUuid , _weiAmount ) ; }","Add tokens to specified address , tokens amount depends of wei amount ."
6155,function finishHardcap ( ) public onlyContractOwner onlySale notHardcapReached returns ( uint ) { finishedHardcap = true ; _emitHardcapFinishedManually ( ) ; return OK ; },Performs finish hardcap manually Only by contract owner and in sale period
6156,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalProperties = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 1 ; tokenId <= totalProperties ; tokenId ++ ) { if ( propertyIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } },Returns a list of all Property IDs assigned to an address .
6157,"function bulkClaimReward ( uint256 [ ] _blockNumbers ) external canMint returns ( bool ) { require ( _blockNumbers . length <= 20 , ""can only claim up to 20 rewards at once"" ) ; uint256 totalMint ; for ( uint256 i = 0 ; i < _blockNumbers . length ; i ++ ) { totalMint = totalMint . add ( claimReward ( _blockNumbers [ i ] ) ) ; } emit MergedMinedRewardClaimed ( msg . sender , _blockNumbers , totalMint ) ; require ( totalMint > 0 , ""total coins to mint must be greater than 0"" ) ; require ( RTI . mint ( msg . sender , totalMint ) , ""unable to mint tokens"" ) ; return true ; }",Used by a miner to bulk claim their merged mined RTC
6158,"function getColor ( uint256 _tokenId ) public view returns ( string colorName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Color storage color = colors [ _tokenId ] ; colorName = color . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; previousPrice = colorIndexToPreviousPrice [ _tokenId ] ; previousOwners = colorIndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific color .
6159,"function internalUpdateRates ( bytes4 [ ] currencyKeys , uint [ ] newRates , uint timeSent ) internal returns ( bool ) { require ( currencyKeys . length == newRates . length , ""Currency key array length must match rates array length."" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time is too far into the future"" ) ; for ( uint i = 0 ; i < currencyKeys . length ; i ++ ) { require ( newRates [ i ] != 0 , ""Zero is not a valid rate, please call deleteRate instead."" ) ; require ( currencyKeys [ i ] != ""sUSD"" , ""Rate of sUSD cannot be updated, it's always UNIT."" ) ; if ( timeSent >= lastRateUpdateTimes [ currencyKeys [ i ] ] ) { rates [ currencyKeys [ i ] ] = newRates [ i ] ; lastRateUpdateTimes [ currencyKeys [ i ] ] = timeSent ; } } emit RatesUpdated ( currencyKeys , newRates ) ; updateXDRRate ( timeSent ) ; return true ; }",Internal function which sets the rates stored in this contract
6160,function transferOwnership ( address newOwner ) onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; },Allows the current owner to transfer control of the contract to a newOwner .
6165,"function _forwardPoly ( address _beneficiary , address _to , uint256 _fundsAmount ) internal { polyToken . transferFrom ( _beneficiary , _to , _fundsAmount ) ; }",Internal function used to forward the POLY raised to beneficiary address
6167,"function mintToken ( uint256 mintedAmount ) onlyOwner public { require ( mintedAmount >= 0 ) ; _balanceOf [ _owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , _owner , mintedAmount ) ; }","Create ` mintedAmount ` tokens and send it to ` owner ` , can be run only by owner"
6170,"function mintTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; }",Called when new tokens are needed in circulation
6171,"function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }",Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
6172,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfer ` _value ` tokens from ` _from ` to ` _to ` if ` msg.sender ` is allowed .
6174,function takeOwnership ( uint256 _deedId ) external ;,Become owner of a deed for which you are currently approved
6176,"function incrementInventory ( uint256 _productId , uint256 _inventoryAdjustment ) external onlyCLevel { _incrementInventory ( _productId , _inventoryAdjustment ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }",incrementInventory - increments the inventory of a product
6177,"function approveWithSender ( address _sender , address _spender , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; erc20Store . setAllowance ( _sender , _spender , _value ) ; erc20Proxy . emitApproval ( _sender , _spender , _value ) ; return true ; }",Core logic of the ERC20 ` approve ` function .
6178,"function isPaused ( ) public view returns ( bool ) { return getBool ( Encoder . getKey ( ""paused"" ) ) ; }",Checks whether the contract operations is paused or not
6179,"function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; _policy . sig = _sig ; _policy . contractAddress = _contract ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }",Register new policy rule Can be called only by contract owner
6180,function replaceWizard ( address _replacement ) { externalEnter ( ) ; replaceWizardRP ( _replacement ) ; externalLeave ( ) ; },Used by either the topWizard or subWizard to transfer all rights to future commissions to the ` _replacement ` wizard .
6183,function ownerPowerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSECS_TOTAL_AMOUNT ) ; contractPoweredUp = true ; },Check if contract has enough Parsecs to cover hard cap
6185,function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } },Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
6187,function getBonusPercentage ( uint _cents ) view public returns ( uint256 ) { for ( uint8 i = 0 ; i < bonusLimits . length ; i ++ ) { if ( _cents >= bonusLimits [ i ] ) { return bonusPercentages [ i ] ; } } },Gets the bonus applicable for the supplied dollar cent value .
6188,function removeAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; },Removes the specified address from the list of administrators .
6189,"function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return USER_MANAGER_GROUP_ALREADY_EXIST ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }",Create group Can be called only by contract owner
6190,"function getDeedTimestampByAddress ( string propertyAddress , uint256 i ) public constant returns ( uint256 ) { string memory deed = getDeedByAddress ( propertyAddress , i ) ; return getDeedTimestamp ( deed ) ; }",Gets the deed registration timestamp by property address and chronological index
6191,"function getCity ( uint256 _tokenId ) public view returns ( string cityName , string country , uint256 sellingPrice , address owner ) { City storage city = cities [ _tokenId ] ; cityName = city . name ; country = city . country ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }",Returns all the relevant information about a specific city .
6192,"function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
6196,function setTokenState ( TokenState _tokenState ) external optionalProxy_onlyOwner { tokenState = _tokenState ; emitTokenStateUpdated ( _tokenState ) ; },Set the address of the TokenState contract .
6197,function invokeFor ( address _invoker ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
6198,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DOTSToken ) { DOTSToken newToken = new DOTSToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
6201,"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == countTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( countTransferManager ) . call ( _data ) , ""Un-successfull call"" ) ; emit LogGenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( countTransferManager ) ; }",used to launch the Module with the help of factory
6202,"function havvensReceivedForNomins ( uint amount ) public view returns ( uint ) { uint nominsReceived = nomin . amountReceived ( amount ) ; return safeDiv_dec ( nominsReceived , usdToHavPrice ) ; }",Calculate how many havvens you will receive if you transfer an amount of nomins .
6206,function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { return assetIndexToOwner [ _tokenId ] ; },Returns owner of a given Asset ( Token ) .
6207,function resolveAddress ( address addr ) public view returns ( address ) { address parentAddr = addressAlias [ addr ] ; if ( parentAddr == address ( 0 ) ) { return addr ; } else { return parentAddr ; } },Resolve an address to its canonical address .
6208,"function transferPlusFee ( uint value ) external view returns ( uint ) { return safeAdd ( value , transferFeeIncurred ( value ) ) ; }",The value that you would need to send so that the recipient receives a specified value .
6209,"function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , toPay ) ; require ( transferValue > 0 || toPay < _amount ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }","Pay loan Does a payment of a given Loan , before performing the payment the accumulated interest is computed and added to the total pending amount ."
6210,"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } return super . approve ( _spender , _amount ) ; }",` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
6211,"function _adjustBalanceCheckpoints ( address _investor ) internal { TokenLib . adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) , currentCheckpointId ) ; }",Internal - adjusts token holder balance at checkpoint after a token transfer
6212,function checkMonthlyLimit ( ) external constant returns ( uint256 remaining ) { return monthlyLimit [ msg . sender ] ; },Check how much Casino withdrawal balance remains for address
6213,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = WHITELIST ; return allPermissions ; },Return the permissions flag that are associated with Percentage transfer Manager
6214,"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( modules [ PERMISSIONMANAGER_KEY ] . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < modules [ PERMISSIONMANAGER_KEY ] . length ; i ++ ) { if ( IPermissionManager ( modules [ PERMISSIONMANAGER_KEY ] [ i ] . moduleAddress ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } }","Validate permissions with PermissionManager if it exists , If no Permission return false"
6215,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _tokenExists ( _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; }",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
6216,"function ensureInAccountList ( address addr ) internal { require ( ! readOnly , ""Read only mode engaged"" ) ; bool found = false ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == addr ) { found = true ; break ; } current = addressLinkedList [ current ] ; } if ( ! found ) { addToAccountList ( addr ) ; } }",Make sure that this address exists in our linked list
6217,"function claimTokens ( address _token ) public onlyOwner { NEC token = NEC ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }",This method can be used by the owner to extract mistakenly sent tokens to this contract .
6218,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) ;","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
6220,function setPreDGZtoDgzRate ( uint rate ) public onlyOwner { preDGZtoDGZExchangeRate = rate ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; },"In case if prices are changed due to some great change in ETH price , this function can be used to change conversion rate for preDGZ owners ."
6222,function updateFromRegistry ( ) external ;,Use to get the latest contract address of the regstries
6228,function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != supply ) { revert ( ) ; } },Set address of migration target contract and enable migration process .
6230,function changeController ( address _newController ) public auth { require ( _newController != 0x0 ) ; pls . changeController ( _newController ) ; ControllerChanged ( _newController ) ; },"The owner of this contract can change the controller of the PLS token Please , be sure that the owner is a trusted agent or 0x0 address ."
6232,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowed = allowance [ _from ] [ msg . sender ] ; require ( _value <= allowed || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed != MAX_UINT256 && _from != msg . sender ) { allowance [ _from ] [ msg . sender ] = allowed . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; success = true ; }",send ` _value ` tokens to ` _to ` address from ` _from ` address if allowance allows
6234,"function collateralisationRatio ( address issuer ) public view returns ( uint ) { uint totalOwnedSynthetix = collateral ( issuer ) ; if ( totalOwnedSynthetix == 0 ) return 0 ; uint debtBalance = debtBalanceOf ( issuer , ""SNX"" ) ; return debtBalance . divideDecimalRound ( totalOwnedSynthetix ) ; }",The current collateralisation ratio for a user .
6235,"function batchTransfer ( address [ ] _tos , uint256 [ ] _values ) public returns ( bool success ) { require ( _tos . length == _values . length ) ; uint256 numTransfers = _tos . length ; uint256 senderBalance = erc20Store . balances ( msg . sender ) ; for ( uint256 i = 0 ; i < numTransfers ; i ++ ) { address to = _tos [ i ] ; require ( to != address ( 0 ) ) ; uint256 v = _values [ i ] ; require ( senderBalance >= v ) ; if ( msg . sender != to ) { senderBalance -= v ; erc20Store . addBalance ( to , v ) ; } erc20Proxy . emitTransfer ( msg . sender , to , v ) ; } erc20Store . setBalance ( msg . sender , senderBalance ) ; return true ; }",A function for a sender to issue multiple transfers to multiple different addresses at once .
6236,"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private whenNotPaused { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }",Helper function that checks for ERC777TokensSender on the sender and calls it .
6237,function sellMaximumPossibleAmountOfTokens ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } },"Allow user to sell maximum possible amount of metadollars , depend on ether amount on contract"
6238,"function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , ""Mortgage not ongoing"" ) ; require ( mortgage . loanId == loanId , ""Mortgage don't match loan id"" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , ""Sender not authorized"" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , ""Sender not lender"" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( ""Mortgage not defaulted/paid"" ) ; } _destroy ( mortgageId ) ; delete mortgageByLandId [ mortgage . landId ] ; return true ; }",Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds .
6239,function deedName ( uint256 _deedId ) external pure returns ( string _deedName ) ;,A distinct name for a deed managed by this contract
6242,"function paymentMixed ( uint256 _regularTokenAmount , uint256 _rewardTokenAmount , uint256 _rewardPercentageIndex ) public { paymentRewardTokens ( _rewardTokenAmount ) ; paymentRegularTokens ( _regularTokenAmount , _rewardPercentageIndex ) ; }",Process a TRVL tokens payment with a combination of regular and rewards tokens .
6243,"function freezeAccount ( address _target , bool _freeze ) public onlyOwner returns ( bool ) { _frozenAccount [ _target ] = _freeze ; AccountFrozen ( _target , _freeze ) ; return true ; }","Freeze or unfreeze account , can be run only by owner"
6244,"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin returns ( bool ) { require ( _destinations . length == _amounts . length , ""Invalid operation."" ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance , ""You don't have sufficient funds to transfer amount that large."" ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; return true ; }",Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
6245,"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { return _contributorTokens ; }",Applies the discount based on the discount tiers
6248,"function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }",returns additional amount of neumarks issued for euroUlps at totalEuroUlps
6249,function setDirectPaymentThreshold ( uint256 threshold ) external onlyCFO { directPaymentThreshold = threshold ; },Set the threshold for a payment to be sent directly .
6251,"function withdrawHavvens ( uint quantity ) external onlyOwner onlyDuringSetup { havven . transfer ( havven , quantity ) ; }",Withdraws a quantity of havvens back to the havven contract .
6252,"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage , address creator ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; creator = item . creatoraddress ; }",Returns all the relevant information about a specific item .
6254,"function approve ( address _spender , uint256 _amount ) returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }",Used to approve a third-party to send funds on your behalf
6255,"function transferFrom ( address from , address to , uint value ) public returns ( bool ) ;",send ` value ` token to ` to ` from ` from ` on the condition it is approved by ` from `
6256,"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; require ( ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }",Deposits ERC20 tokens under the ` _user ` 's balance
6257,function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . AuctionCanceled || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; },"Get the XCH price in WEI during the auction , at the time of calling this function ."
6258,"function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` .
6259,function changeEscapeCaller ( address _newEscapeCaller ) onlyEscapeCallerOrOwner { escapeCaller = _newEscapeCaller ; },Changes the address assigned to call ` escapeHatch ( ) `
6260,"function tokenFallback ( address _sender_address , uint256 _deposit , bytes _data ) external { require ( msg . sender == address ( token ) ) ; uint192 deposit = uint192 ( _deposit ) ; require ( deposit == _deposit ) ; uint length = _data . length ; require ( length == 40 || length == 44 ) ; address channel_sender_address = address ( addressFromBytes ( _data , 0x20 ) ) ; require ( _sender_address == channel_sender_address || trusted_contracts [ _sender_address ] ) ; address channel_receiver_address = address ( addressFromBytes ( _data , 0x34 ) ) ; if ( length == 40 ) { createChannelPrivate ( channel_sender_address , channel_receiver_address , deposit ) ; } else { uint32 open_block_number = uint32 ( blockNumberFromBytes ( _data , 0x48 ) ) ; updateInternalBalanceStructs ( channel_sender_address , channel_receiver_address , open_block_number , deposit ) ; } }","Opens a new channel or tops up an existing one , compatibility with ERC 223 ."
6261,"function canClaim ( bytes32 channelId , uint256 payment , address origin , bytes signature ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isReceiver = origin == channel . receiver ; bytes32 hash = recoveryPaymentDigest ( channelId , payment ) ; bool isSigned = channel . sender == ECRecovery . recover ( hash , signature ) ; return isReceiver && isSigned ; }",Ensure ` origin ` address can claim ` payment ` amount on channel identified by ` channelId ` .
6266,"function removeAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = getHolderId ( _partowner ) ; delete assets [ _symbol ] . partowners [ holderId ] ; Emitter ( eventsHistory ) . emitOwnershipChange ( _partowner , 0x0 , _symbol ) ; return OK ; }",Removes a co-owner for an asset with provided symbol .
6268,"function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , ""Error: Account is not verified!"" ) ; require ( lib . withdraw ( currency , account , amount , issuerFirm ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; return true ; }",Withdraws a specified amount of tokens of a given currency
6269,"function transferFrom ( address from , address to , uint256 tokenAmount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }",Transfer tokens from an address to another one through an allowance made before
6270,"function startBuyback ( uint256 _roundStartTime , uint256 _rate ) onlyOwner external payable { require ( _roundStartTime > now ) ; roundStartTime = _roundStartTime ; rate = _rate ; }","Starts buyback at specified time , with specified rate"
6272,"function getAssetPackData ( uint _assetPackId ) public view returns ( bytes32 , address , uint , uint [ ] , uint [ ] , bytes32 [ ] , string , string , bytes32 ) { require ( _assetPackId < numberOfAssetPacks ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; bytes32 [ ] memory hashes = new bytes32 [ ] ( assetPack . assetIds . length ) ; for ( uint i = 0 ; i < assetPack . assetIds . length ; i ++ ) { hashes [ i ] = getAssetIpfs ( assetPack . assetIds [ i ] ) ; } uint [ ] memory attributes = getAttributesForAssets ( assetPack . assetIds ) ; return ( assetPack . packCover , assetPack . creator , assetPack . price , assetPack . assetIds , attributes , hashes , assetPack . ipfsHash , userManager . getUsername ( assetPack . creator ) , userManager . getProfilePicture ( assetPack . creator ) ) ; }",Function to get ipfs hash and id for all assets in one asset pack
6273,"function createNewTask ( uint uuid , uint amount ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedTaskBalances ( uuid , amount ) ; communityAccount . setTotalTaskEscrow ( SafeMath . add ( communityAccount . totalTaskEscrow ( ) , amount ) ) ; logger . emitTaskCreated ( uuid , amount ) ; logger . emitGenericLog ( ""createNewTask"" , """" ) ; }",Updates the escrow values for a new task
6274,"function addInvestorBonusInPercent ( address _to , uint8 p ) public onlyOwner { require ( p > 0 && p <= 5 ) ; uint bonus = balances [ _to ] . mul ( p ) . div ( 100 ) ; investorGiven = investorGiven . add ( bonus ) ; require ( investorGiven <= investorSupply ) ; _freezeTransfer ( _to , bonus ) ; }",addInvestorBonusInPercent is used for sending bonuses for big investors in %
6275,"function withdraw ( uint256 amount ) public { require ( _balances [ msg . sender ] >= amount ) ; _balances [ msg . sender ] = sub ( _balances [ msg . sender ] , amount ) ; _totalSupply = sub ( _totalSupply , amount ) ; LogWithdrawal ( msg . sender , amount ) ; Transfer ( msg . sender , address ( 0 ) , amount ) ; }",withdraws 'amount ' of EUR-T by burning required amount and providing a proof of whithdrawal
6276,function ( ) payable { if ( controller == 0 ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { if ( ! controller . send ( msg . value ) ) throw ; } },"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method ."
6277,"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ; }",Hash ( keccak256 ) of the payload used by setCEO
6278,function maxCommitTime ( Pledge p ) internal returns ( uint commitTime ) { PledgeAdmin storage m = findAdmin ( p . owner ) ; commitTime = m . commitTime ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { m = findAdmin ( p . delegationChain [ i ] ) ; if ( m . commitTime > commitTime ) commitTime = m . commitTime ; } },A getter to find the longest commitTime out of the owner and all the delegates for a specified pledge
6279,function enableTransfers ( bool _transfersEnabled ) onlyController public { transfersEnabled = _transfersEnabled ; },Enables token holders to transfer their tokens freely if true
6280,function seal ( ) onlyController returns ( bool success ) { tokenController = 0 ; return true ; },` seal ( ) ` ends the Campaign by making it impossible to create more tokens .
6281,"function setNextGameSettings ( uint256 rows , uint256 cols , uint256 activityTimer , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; nextGameSettings = GameSettings ( { rows : rows , cols : cols , activityTimer : activityTimer , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage } ) ; NextGame ( rows , cols , activityTimer , unclaimedTilePrice , buyoutReferralBonusPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage ) ; }",Sets the settings for the next game .
6282,"function canMateWith ( uint256 _matronId , uint256 _sireId ) external view returns ( bool ) { require ( _matronId > 0 ) ; require ( _sireId > 0 ) ; Pony storage matron = ponies [ _matronId ] ; Pony storage sire = ponies [ _sireId ] ; return _isValidMatingPair ( matron , _matronId , sire , _sireId ) && _isMatingPermitted ( _sireId , _matronId ) ; }","Checks to see if two ponies can breed together , including checks for ownership and siring approvals ."
6283,function changeDonor ( address _newDonor ) onlyDonor { donor = _newDonor ; },` onlyDonor ` Reassigns the ` donor ` to a new address
6284,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public validAddress ( _from ) validAddress ( _to ) validId ( _tokenId ) { require ( isApprovedOrOwner ( msg . sender , _tokenId ) , ""Sender does not have permission to transfer PixelCon"" ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }",Transfer the ownership of PixelCon ` ( _tokenId ) ` to ` ( _to ) ` ( try to use 'safeTransferFrom ' instead )
6286,"function replaySweep ( address [ ] _froms , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; uint256 lenFroms = _froms . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < lenFroms ; ++ i ) { address from = _froms [ i ] ; if ( sweptSet [ from ] ) { uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }","For accounts that have delegated , transfer control to the sweeper , this function transfers their balances to the given destination ."
6287,"function calculateSeed ( uint [ ] _randomHashIds , uint _timestamp ) public view returns ( uint ) { require ( _timestamp != 0 ) ; require ( _randomHashIds . length == 10 ) ; bytes32 randomSeed = keccak256 ( abi . encodePacked ( randomHashes [ _randomHashIds [ 0 ] ] , randomHashes [ _randomHashIds [ 1 ] ] , randomHashes [ _randomHashIds [ 2 ] ] , randomHashes [ _randomHashIds [ 3 ] ] , randomHashes [ _randomHashIds [ 4 ] ] , randomHashes [ _randomHashIds [ 5 ] ] , randomHashes [ _randomHashIds [ 6 ] ] , randomHashes [ _randomHashIds [ 7 ] ] , randomHashes [ _randomHashIds [ 8 ] ] , randomHashes [ _randomHashIds [ 9 ] ] , _timestamp ) ) ; return uint ( randomSeed ) ; }",Function to calculate initial random seed based on our hashes
6288,"function isRegisteredInEpoch ( address _darknodeID , Epoch _epoch ) private view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; bool registered = registeredAt != 0 && registeredAt <= _epoch . blocknumber ; bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch . blocknumber ; return registered && notDeregistered ; }",Returns if a darknode was in the registered state for a given epoch .
6289,"function transferToSelf ( uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; IOUSupply += _value ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }",Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition
6291,"function getAssetInfo ( uint id ) public view returns ( uint , uint , uint , bytes32 ) { require ( id >= 0 ) ; require ( id < numberOfAssets ) ; Asset memory asset = assets [ id ] ; return ( asset . id , asset . packId , asset . attributes , asset . ipfsHash ) ; }",Method to get all info for an asset
6293,"function finalizeSale ( ) onlyController { require ( now > endFundingTime || totalCollected >= maximumFunding ) ; require ( ! finalized ) ; uint256 reservedTokens = 225000000 * 0.35 * 10 ** 18 ; if ( ! tokenContract . generateTokens ( vaultAddress , reservedTokens ) ) { revert ( ) ; } finalized = true ; }",` finalizeSale ( ) ` ends the EarlyTokenSale .
6294,function isOpen ( bytes32 channelId ) public view returns ( bool ) { return isPresent ( channelId ) && ! isSettling ( channelId ) ; },Check if the channel is open : present and not settling .
6295,function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; },Get a description of the attribute type with ID ` attributeTypeID ` .
6297,"function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) throw ; if ( balanceOf [ msg . sender ] < value ) throw ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; if ( ! msg . sender . send ( value ) ) throw ; }",The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
6299,"function blockNumber ( bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetBlockNumber , _symbol ) ; }",Returns block number from which asset can be used .
6300,"function approve ( address _spender , uint256 _value ) public onlyIfLockTimePassed returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }",Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
6302,"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; tradeActive = true ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
6303,"function extract ( address _to ) onlyController { require ( _to != 0x0 ) ; uint256 available = availableNow ( ) ; require ( available > 0 ) ; extracted = extracted . add ( available ) ; assert ( token . transfer ( _to , available ) ) ; Extract ( _to , available ) ; }",Send all available tokens to a given address
6304,"function addValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) && isAttributeType ( attributeTypeID ) , ""must specify both a valid attribute and an available validator"" ) ; require ( _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] == false , ""validator is already approved on the provided attribute"" ) ; _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] = true ; uint256 index = _validatorApprovals [ validator ] . length ; _validatorApprovalsIndex [ validator ] [ attributeTypeID ] = index ; _validatorApprovals [ validator ] . push ( attributeTypeID ) ; emit ValidatorApprovalAdded ( validator , attributeTypeID ) ; }",Approve the validator at address ` validator ` to issue attributes of the type with ID ` attributeTypeID ` .
6305,function lockedBbkOf ( address _address ) external view returns ( uint256 ) { return lockedBbkPerUser [ _address ] ; },Check an address for amount of currently locked BBK works similar to basic ERC20 balanceOf
6309,"function setTokenConverter ( TokenConverter _tokenConverter ) external onlyOwner returns ( bool ) { emit SetTokenConverter ( tokenConverter , _tokenConverter ) ; tokenConverter = _tokenConverter ; return true ; }",Sets the token converter used to convert the MANA into RCN when performing the payment
6310,function setMigrationAgent ( address _agent ) external onlyOwner { require ( migrationAgent == 0x0 && totalMigrated == 0 ) ; migrationAgent = _agent ; },Set address of migration target contract and enable migration process
6311,"function vote ( uint _proposalId , bool _yes ) public { require ( _proposalId < proposals . length ) ; require ( checkIfCurrentlyActive ( _proposalId ) ) ; Proposal memory p = proposals [ _proposalId ] ; uint amount = MiniMeToken ( p . token ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( MiniMeToken ( p . token ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; if ( _yes ) { proposals [ _proposalId ] . yesVotes += amount ; } else { proposals [ _proposalId ] . noVotes += amount ; } emit Vote ( _proposalId , msg . sender , _yes , amount ) ; }",Vote for specific proposal with yes or no
6312,"function recoverUnawardedMILs ( ) public { uint256 MILs = militaryToken . balanceOf ( address ( this ) ) ; if ( totalAwards < MILs ) { militaryToken . transfer ( owner , MILs - totalAwards ) ; } }",Transfers any un-awarded MILs to the contract owner .
6313,"function setApprove ( address _sender , address _spender , uint256 _value ) external onlyModule returns ( bool ) { allowed [ _sender ] [ _spender ] = _value ; return true ; }",Set allowance of ` _spender ` in behalf of ` _sender ` at ` _value `
6314,"function transfer ( address to , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; ensureInAccountList ( to ) ; return true ; }",Transfer the balance from token owner 's account to ` to ` account - Owner 's account must have sufficient balance to transfer - 0 value transfers are allowed
6316,function setSlippage ( uint slip ) public auth { require ( slip < WAD ) ; slippage = slip ; },set the acceptable price slippage for trades .
6317,function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; process_contribution ( _toAddr ) ; },This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf
6318,"function createERC20TokenNetwork ( address _token_address ) canCreateTokenNetwork external returns ( address token_network_address ) { require ( token_to_token_networks [ _token_address ] == address ( 0x0 ) ) ; token_network_created = true ; TokenNetwork token_network ; token_network = new TokenNetwork ( _token_address , secret_registry_address , chain_id , settlement_timeout_min , settlement_timeout_max , deprecation_executor ) ; token_network_address = address ( token_network ) ; token_to_token_networks [ _token_address ] = token_network_address ; emit TokenNetworkCreated ( _token_address , token_network_address ) ; return token_network_address ; }",Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .
6319,function setWallet ( address _wallet ) external validAddress ( _wallet ) onlyOwner { wallet = _wallet ; },To set the wallet address by the owner only
6320,"function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; assert ( tokens . length > 0 ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; assert ( tokens [ tokenIndex ] == _tokenId ) ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens . length -- ; idToIndex [ lastToken ] = tokenIndex ; idToIndex [ _tokenId ] = 0 ; }",This is a private function which should be called from user-implemented external burn function .
6321,"function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) ;",Used to return all permission of a single or multiple module
6322,"function payToEvaluator ( uint _JobID , uint _payment ) public { require ( _JobID >= 0 ) ; require ( _payment > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . manager ) ; address evaluator = job . evaluator ; require ( DAI . allowance ( job . manager , address ( this ) ) >= _payment ) ; emit EvaluatorPaid ( msg . sender , evaluator , _JobID , _payment ) ; DAI . transferFrom ( job . manager , evaluator , _payment ) ; }",this function lets the manager pay DAI to arbitrator
6323,function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = ADMIN ; return allPermissions ; },Return the permissions flag that are associated with Percentage transfer Manager
6324,"function removeModule ( address _moduleFactory ) external whenNotPausedOrOwner { uint256 moduleType = getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) ; require ( moduleType != 0 , ""Module factory should be registered"" ) ; require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , ""msg.sender must be the Module Factory owner or registry curator"" ) ; uint256 index = getUint ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) ) ; uint256 last = getArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) ) . length - 1 ; address temp = getArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) ) [ last ] ; if ( index != last ) { setArrayIndexValue ( Encoder . getKey ( ""moduleList"" , moduleType ) , index , temp ) ; set ( Encoder . getKey ( ""moduleListIndex"" , temp ) , index ) ; } deleteArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) , last ) ; set ( Encoder . getKey ( ""registry"" , _moduleFactory ) , uint256 ( 0 ) ) ; setArray ( Encoder . getKey ( ""reputation"" , _moduleFactory ) , new address [ ] ( 0 ) ) ; set ( Encoder . getKey ( ""verified"" , _moduleFactory ) , false ) ; set ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) , uint256 ( 0 ) ) ; emit ModuleRemoved ( _moduleFactory , msg . sender ) ; }",Called by the ModuleFactory owner or registry curator to delete a ModuleFactory from the registry
6325,"function addPlotAndData ( uint24 [ ] purchase , string ipfsHash , string url , uint256 initialBuyoutPriceInWeiPerPixel ) private returns ( uint256 ) { uint256 newPlotIndex = ownership . length ; ownership . push ( PlotOwnership ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] , msg . sender ) ) ; data [ newPlotIndex ] = PlotData ( ipfsHash , url ) ; if ( initialBuyoutPriceInWeiPerPixel > 0 ) { plotIdToPrice [ newPlotIndex ] = initialBuyoutPriceInWeiPerPixel ; } return newPlotIndex ; }",Stores the plot information and data for a newly purchased plot .
6326,"function addDistributionPeriod ( ) public onlyProfiterole returns ( uint ) { uint _periodsCount = periodsCount ; uint _nextPeriod = _periodsCount . add ( 1 ) ; periodDate2periodIdx [ now ] = _periodsCount ; Period storage _previousPeriod = periods [ _periodsCount ] ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( now , _periodsCount ) ; periods [ _nextPeriod ] . startDate = now ; periods [ _nextPeriod ] . bmcDaysPerDay = _previousPeriod . bmcDaysPerDay ; periods [ _nextPeriod ] . totalBmcDays = _totalBmcDeposit ; periodsCount = _nextPeriod ; return OK ; }",Makes a checkpoint to start counting a new period
6328,"function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }","Breed cuties that you own , or for which you have previously been given Breeding approval ."
6329,"function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length - 1 ; }",Use and override this function with caution .
6330,"function convert_valuation_to_art ( uint _valuation , uint _art_price ) view public returns ( uint amount ) { amount = ( ( _valuation . mul ( oracle_price_decimals_factor ) ) . div ( _art_price ) ) . mul ( decimal_precission_difference_factor ) ; }",Helper function that calculates the valuation of the asset in terms of an ART token quantity .
6332,"function clearApproval ( address _owner , uint256 _tokenId ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _clearApproval ( msg . sender , _tokenId ) ; }","Clear current approval of ` _tokenId ` owned by ` _owner ` ,"
6333,"function changeRegistrationStatus ( address target , bool isRegistered ) public onlyBy ( owner ) { registered [ target ] = isRegistered ; }",Updates registration status of an address for sale participation
6335,"function upgrade ( uint256 value ) external { if ( nextUpgradeAgent . owner ( ) == 0x0 ) revert ( ) ; if ( finalizedNextUpgrade ) revert ( ) ; if ( value == 0 ) revert ( ) ; if ( value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; nextUpgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , nextUpgradeAgent , value ) ; }",Upgrade tokens to the new token contract .
6336,"function requestImplChange ( address _proposedImpl ) public returns ( bytes32 lockId ) { require ( _proposedImpl != address ( 0 ) ) ; lockId = generateLockId ( ) ; implChangeReqs [ lockId ] = ImplChangeRequest ( { proposedNew : _proposedImpl } ) ; emit ImplChangeRequested ( lockId , msg . sender , _proposedImpl ) ; }",Requests a change of the active implementation associated with this contract .
6337,"function getFeeContract ( Data storage self , address contractAddress ) internal view returns ( address feeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.account' , contractAddress ) ) ; address feeAccount = self . Storage . getAddress ( id ) ; if ( feeAccount == 0x0 ) { return getMasterFeeContract ( self ) ; } else { return feeAccount ; } }",Get the fee contract set for a contract interface
6338,"function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . length ; ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length ; }",Use and override this function with caution .
6339,"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { return appendUintToString ( hostname , _tokenId ) ; }",A distinct Uniform Resource Identifier ( URI ) for a given asset .
6340,"function undelegate ( uint64 idPledge , uint amount , uint q ) internal returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length - q ) ; for ( uint i = 0 ; i < p . delegationChain . length - q ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; return toPledge ; }",` appendDelegate ` allows for a delegate to be added onto the end of the delegate chain for a given Pledge .
6341,"function getTokenBalance ( string currency , address account ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , account ) ; }",Gets balance of sepcified account for a given currency
6343,function getTokenMinted ( ) public constant returns ( uint ) { return m_tokensMinted ; },amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! )
6344,"function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; bytes32 _message = getMessageForTransaction ( transactionId , pass ) ; address _owner = getSigner ( _message , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; _assertMultisigInitiator ( _owner , BytesLib . getSig ( data ) ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }",Allows anyone with correctly signed message to submit a transaction .
6345,"function setPartners ( bool _valid , uint _from , uint _to ) ;",Function used by the creator to set addresses that can fund the dao
6346,"function unlock ( ) external { if ( now < unlockedAt ) throw ; uint256 vested = allocations [ msg . sender ] * 10 ** decimals ; if ( vested < 0 ) throw ; allocations [ msg . sender ] = 0 ; reservedTokens = safeSub ( reservedTokens , vested ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , vested ) ; Vested ( msg . sender , vested ) ; }",Allow developer to unlock allocated tokens by transferring them to developer 's address on vesting schedule of `` vested 100 % on 1 year )
6347,"function setBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , ""Blacklist token destruction not supported by token"" ) ; setUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogSetBlacklistDestroyer ( _who ) ; }",Sets the necessary permissions for a user to destroy tokens from a blacklisted account .
6348,"function createETHCardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 2 , _nftData ) ; }","Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController"
6349,"function forward ( bytes _evmScript ) public { require ( canForward ( msg . sender , _evmScript ) , ERROR_CAN_NOT_FORWARD ) ; _newVote ( _evmScript , """" , true , true ) ; }","Creates a vote to execute the desired action , and casts a support vote if possible"
6350,"function addUsersToGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; require ( _memberIndex != 0 ) ; if ( _group . memberAddress2index [ _user ] != 0 ) { continue ; } _groupMembersCount = _groupMembersCount . add ( 1 ) ; _group . memberAddress2index [ _user ] = _groupMembersCount ; _group . index2globalIndex [ _groupMembersCount ] = _memberIndex ; _addGroupToMember ( _user , _groupName ) ; UserToGroupAdded ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }",Add users in group Can be called only by contract owner
6351,function updateEndTime ( uint256 _endTime ) onlyOwner public returns ( bool ) { endTime = _endTime ; emit UpdateEndTime ( _endTime ) ; },Called by owner to alter the ICO deadline
6352,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `
6355,"function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }",Create a new reusable template and use it to ask a question
6356,function setRequiredMajority ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_MAJORITY <= fraction ) ; requiredMajority = fraction ; },Set what portion of voting havvens need to be in the affirmative to allow it to pass .
6358,"function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; var overflow = balanceOf ( _to ) + _value < balanceOf ( _to ) ; if ( _value > 0 && senderBalance >= _value && ! overflow ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }",send ` _value ` ART to ` _to ` from ` msg.sender ` to provided account address ` _to ` .
6360,"function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { _amount = _amount * ( 10 ** uint256 ( decimals ) ) ; mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }",Mints the tokens only once against the supplied key ( category ) .
6361,"function isRegisteredToFirm ( Data storage self , string issuerFirm , address authorityAddress ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getBool ( id ) ; }",Return the boolean ( true/false ) status if an authority is registered to an issuer firm
6362,function receiveFees ( ) payable ;,Function to allow sending fees in wei to the Dao
6363,function invokeOnce ( ) public returns ( uint ) ;,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
6365,"function updateBalancesContract ( address _balancesContract ) external onlyOwner { emit LogBalancesContractUpdated ( balancesContract , _balancesContract ) ; balancesContract = _balancesContract ; }",Allows the owner of the contract to update the address of the RenExBalances contract .
6366,"function unlock ( uint256 channel_identifier , address participant , address partner , bytes merkle_tree_leaves ) public { require ( channel_identifier != getChannelIdentifier ( participant , partner ) ) ; require ( channels [ channel_identifier ] . state == ChannelState . NonExistent ) ; require ( merkle_tree_leaves . length > 0 ) ; bytes32 unlock_key ; bytes32 computed_locksroot ; uint256 unlocked_amount ; uint256 locked_amount ; uint256 returned_tokens ; ( computed_locksroot , unlocked_amount ) = getMerkleRootAndUnlockedAmount ( merkle_tree_leaves ) ; unlock_key = getUnlockIdentifier ( channel_identifier , partner , participant ) ; UnlockData storage unlock_data = unlock_identifier_to_unlock_data [ unlock_key ] ; locked_amount = unlock_data . locked_amount ; require ( unlock_data . locksroot == computed_locksroot ) ; require ( locked_amount > 0 ) ; unlocked_amount = min ( unlocked_amount , locked_amount ) ; returned_tokens = locked_amount - unlocked_amount ; delete unlock_identifier_to_unlock_data [ unlock_key ] ; emit ChannelUnlocked ( channel_identifier , participant , partner , computed_locksroot , unlocked_amount , returned_tokens ) ; if ( unlocked_amount > 0 ) { require ( token . transfer ( participant , unlocked_amount ) ) ; } if ( returned_tokens > 0 ) { require ( token . transfer ( partner , returned_tokens ) ) ; } assert ( locked_amount >= returned_tokens ) ; assert ( locked_amount >= unlocked_amount ) ; }",Unlocks all pending off-chain transfers from ` partner ` to ` participant ` and sends the locked tokens corresponding to locks with secrets registered on-chain to the ` participant ` .
6367,"function escapeHatch ( ) onlyEscapeHatchCaller { uint total = getBalance ( ) ; transfer ( escapeHatchDestination , total ) ; EscapeHatchCalled ( total ) ; }",The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
6369,"function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; ( Error err4 , Exp memory floorSupplyRate ) = divScalar ( Exp ( { mantissa : mantissaZeroPointFivePercent } ) , blocksPerYear ) ; assert ( err4 == Error . NO_ERROR ) ; if ( lessThanExp ( supplyRate1 , floorSupplyRate ) ) { return ( uint ( IRError . NO_ERROR ) , floorSupplyRate . mantissa ) ; } else { return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; } }","Gets the current supply interest rate based on the given asset , total cash and total borrows"
6370,function releaseTokenForTransfer ( ) public onlyAdmin whenNotPaused { require ( ! released ) ; released = true ; emit TokenReleased ( released ) ; },This function enables token transfers for everyone.Can only be enabled after the end of the ICO .
6371,"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }",Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
6372,"function revokePermission ( address _entity , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermission ( _entity , _app , _role , NO_PERMISSION ) ; }",Revoke from ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `
6373,"function destroy ( address owner , uint256 amount ) public only ( ROLE_EURT_LEGAL_MANAGER ) { destroyTokensPrivate ( owner , amount ) ; emit LogDestroy ( owner , msg . sender , amount ) ; }","this method allows to destroy EUR-T belonging to any account note that EURO is fiat currency and is not trustless , EUR-T is also just internal currency of Neufund platform , not general purpose stable coin we need to be able to destroy EUR-T if ordered by authorities"
6374,"function requestArbitration ( bytes32 question_id , uint256 max_previous ) onlyInitialized external payable returns ( bool ) { require ( msg . value >= dispute_fee , ""The payment must cover the fee"" ) ; realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; realitio_questions [ question_id ] . bounty = msg . value ; realitio_questions [ question_id ] . disputer = msg . sender ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; }","Request arbitration , freezing the question until we send submitAnswerByArbitrator"
6375,"function symbolsCount ( ) public view returns ( uint ) { return count ( store , symbolsStorage ) ; }",Provides a cheap way to get number of symbols registered in a platform
6376,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
6377,"function getTeam ( uint256 _index ) public view returns ( string teamName , uint256 sellingPrice , address owner , uint256 goals ) { Team storage team = teams [ _index ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _index ] ; owner = teamIndexToOwner [ _index ] ; goals = teamIndexToGoals [ _index ] ; }",Returns all the relevant information about a specific team .
6378,function hasHardCap ( ) internal constant returns ( bool ) { return getMaximumFunds ( ) != 0 ; },whether to apply hard cap check logic via getMaximumFunds ( ) method
6381,"function safeTransferFrom ( address token , address from , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , ""transferFrom failed"" ) ; }",Calls transferFrom on the token and reverts if the call fails .
6382,"function ( ) external payable isInitialized transitionsPeriod { _deposit ( ETH , msg . value , ""Ether transfer to Finance app"" , msg . sender , true ) ; }","Deposit ETH to the Vault , to avoid locking them in this Finance app forever"
6383,"function approveTakeover ( uint _assetPackId , address _newCreator ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; approvedTakeover [ _assetPackId ] = _newCreator ; }",Approve address to become creator of that pack
6384,"function _supportsInterface ( address account , bytes4 interfaceId ) internal view returns ( bool ) { return _supportsERC165 ( account ) && _supportsERC165Interface ( account , interfaceId ) ; }","Query if a contract implements an interface , also checks support of ERC165"
6385,"function getItem23 ( uint256 _tokenId ) public view returns ( string item23Name , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Item23 storage item23 = item23s [ _tokenId ] ; item23Name = item23 . name ; sellingPrice = item23IndexToPrice [ _tokenId ] ; owner = item23IndexToOwner [ _tokenId ] ; previousPrice = item23IndexToPreviousPrice [ _tokenId ] ; previousOwners = item23IndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific item23 .
6386,"function _deleteTickerOwnership ( address _owner , string _ticker ) internal { uint256 index = uint256 ( getUint ( Encoder . getKey ( ""tickerIndex"" , _ticker ) ) ) ; bytes32 ownerKey = Encoder . getKey ( ""userToTickers"" , _owner ) ; bytes32 [ ] memory tickers = getArrayBytes32 ( ownerKey ) ; assert ( index < tickers . length ) ; assert ( _tickerOwner ( _ticker ) == _owner ) ; deleteArrayBytes32 ( ownerKey , index ) ; if ( getArrayBytes32 ( ownerKey ) . length > index ) { bytes32 switchedTicker = getArrayBytes32 ( ownerKey ) [ index ] ; set ( Encoder . getKey ( ""tickerIndex"" , Util . bytes32ToString ( switchedTicker ) ) , index ) ; } }",Internal - Removes the owner of a ticker
6387,"function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }",Upgrade tokens to the new token contract .
6390,"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) returns ( bool success ) ;",Function to clone a proposal from the last manager
6392,"function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , ""Beneficiary must not be the zero address."" ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }",Set the beneficiary address of this contract .
6394,"function transferCollectedFees ( string currency , address to , uint amount , bytes data ) public onlyOwner returns ( bool success ) { require ( lib . forceTransfer ( currency , address ( this ) , to , amount , data ) , ""Error: unable to transfer fees to account."" ) ; return true ; }",Transfer collected fees to another account ; onlyOwner
6397,"function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled && balance != 0 ; }",Determine if user can bote for a poll
6399,"function changeManager ( address addr , address newManager ) public canManage ( addr ) { managers [ addr ] = newManager ; ManagerChanged ( addr , newManager ) ; }",Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .
6401,function _totalSupply ( ) internal view returns ( uint256 ) { return cuties . length - 1 ; },Returns the total number of Cuties in existence .
6402,"function _adoptSameClassAxies ( address _adopter , uint8 _class , uint256 _quantity , address _referrer ) private returns ( uint256 _totalPrice ) { ( _totalPrice , priceIncrement [ _class ] , currentPrice [ _class ] ) = _sameClassAxiesPrice ( _class , _quantity ) ; _numAdoptedAxies [ _adopter ] [ _class ] = _numAdoptedAxies [ _adopter ] [ _class ] . add ( _quantity ) ; _totalAdoptedAxies [ _class ] = _totalAdoptedAxies [ _class ] . add ( _quantity ) ; AxiesAdopted ( _adopter , _class , _quantity , _referrer ) ; }",Adopt some Axies from the same class .
6403,function maximumInitialBuyoutPrice ( uint256 _deedId ) public view returns ( uint256 ) { uint256 mul = 4 ; if ( identifierIsOriginal [ _deedId ] ) { mul = 100 ; } return initialPricePaid [ _deedId ] . mul ( mul ) ; },Calculate the maximum initial buyout price for a plot .
6404,function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ( ) ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; },Adds multiple addresses to the administrator list .
6405,function disableTransfer ( uint _closingTime ) ;,Function to disable the transfer of Dao shares
6408,"function sendTokens ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . REFUNDING ) { require ( value > 0 && m_token . balanceOf ( this ) >= value ) ; m_token . transfer ( to , value ) ; }","owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether"
6410,function withdraw ( ) public { uint amount = artistBalance [ msg . sender ] ; artistBalance [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; },Function where all artists can withdraw their funds
6411,function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= limitTier3 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = amountPaid . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; },Calculates how many ether will be used to generate the tokens in case the buyer sends more than the maximum balance but has some balance left and updates the balance of that buyer .
6413,function addManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } },Adds multiple addresses to the administrator list .
6416,"function transfer ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transfer ( to , value , data ) ; }",Override the functions to not allow token transfers until the end of the ICO
6417,"function addRewardToPendingWithdrawals ( uint32 _canvasId ) public stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw ; ( _toWithdraw , ) = calculateRewardToWithdraw ( _canvasId , msg . sender ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . addressToPaidRewardIndex [ msg . sender ] = _lastIndex ; addPendingWithdrawal ( msg . sender , _toWithdraw ) ; emit RewardAddedToWithdrawals ( _canvasId , msg . sender , _toWithdraw ) ; }",Adds all unpaid rewards of the caller to his pending withdrawals .
6419,function checkUserExists ( address userAddress ) internal constant returns ( bool ) { for ( uint256 i = 0 ; i < bountyUsers . length ; i ++ ) { if ( bountyUsers [ i ] == userAddress ) return true ; } return false ; },checkUserExists : this function checks if the user address has the token before
6420,"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }",Transfer the balance from token owner 's account to to account
6422,"function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; require ( pixelIndexToApproved [ _tokenId ] != address ( this ) ) ; pixelIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific pixel via transferFrom ( ) .
6423,function withdrawFreeAuctionBalances ( ) external onlyCFO { saleAuctionContract . withdrawFreeBalance ( ) ; rentAuctionContract . withdrawFreeBalance ( ) ; },Allow the CFO to capture the free balance available in the auction contracts .
6424,"function updateExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex , int256 _deltaAmount ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; if ( _payeeIndex == 0 ) { r . payee . expectedAmount = r . payee . expectedAmount . add ( _deltaAmount ) ; } else { Payee storage sp = subPayees [ _requestId ] [ _payeeIndex - 1 ] ; sp . expectedAmount = sp . expectedAmount . add ( _deltaAmount ) ; } emit UpdateExpectedAmount ( _requestId , _payeeIndex , _deltaAmount ) ; }",Function update the expectedAmount adding additional or subtract .
6426,function getMinimumFunds ( ) internal constant returns ( uint ) { return 3500 ether ; },minimum amount of funding to consider crowdsale as successful
6427,"function allowed ( address subject , bytes32 role , address object , bytes4 verb ) public returns ( bool ) ;",We do n't make this function constant to allow for state-updating access controls such as rate limiting .
6428,function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalTokens = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 0 ; tokenId <= totalTokens ; tokenId ++ ) { if ( tokenIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } },This method MUST NEVER be called by smart contract code .
6429,"function proxyChangeTokenMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( ""PoaManager"" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaTokenMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaTokenMaster ; poaTokenMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( ""PoaLogger"" ) . call ( bytes4 ( keccak256 ( ""logProxyUpgraded(address,address)"" ) ) , _oldMaster , _newMaster ) ; return true ; }",Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract
6431,"function removeDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = getHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , false ) ; _emitter ( ) . emitOwnershipChange ( _manager , 0x0 , _symbol ) ; return OK ; }",Removes a asset manager for an asset with provided symbol .
6432,function removeOwnership ( address _dac ) public onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone"
6433,"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = ""Capped"" ; availableTags [ 1 ] = ""Non-refundable"" ; availableTags [ 2 ] = ""POLY"" ; availableTags [ 3 ] = ""ETH"" ; return availableTags ; }",Get the tags related to the module factory
6434,function setPreICOPrice ( uint256 priceForPreIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( preICOprice != priceForPreIcoInWei ) ; preICOprice = priceForPreIcoInWei ; updatePrices ( ) ; },Set current preICO price in wei for one metadollar
6435,function withdrawHouseCutFromGame ( uint gameId ) external onlyOwner whenGameIsClosed ( gameId ) { if ( ! games [ gameId ] . isHouseCutWithdrawn ) { games [ gameId ] . isHouseCutWithdrawn = true ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; owner . transfer ( houseCutAmount ) ; } },We use this function to withdraw the house cut from a game
6436,"function onApprove ( address , address , uint ) returns ( bool ) { return transferable ; }",Notifies the controller about an approval allowing the controller to react if desired
6438,"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( icoIsRunning ) { checkIcoStatus ( ) ; } if ( icoIsRunning ) { currentTokenPrice = icoPrice ; } else { currentTokenPrice = icoPrice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Token price updated!"" ) ; } }",Set current ICO prices in wei for one token
6441,"function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }",This function is disabled during the funding .
6443,"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ; }",Hash ( keccak256 ) of the payload used by setCFO
6445,function symbol ( ) external constant returns ( string _symbol ) { return symbol ; },Check the symbol of the token ~ ERC-20 Standard
6446,"function approveLoan ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; loan . approbations [ msg . sender ] = true ; ApprovedBy ( index , msg . sender ) ; return true ; }",Called by the members of the loan to show that they agree with the terms of the loan ; the borrower must call this method before any lender could call the method `` lend '' .
6448,function exists ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; return owner != address ( 0 ) ; },Check if PixelCon ` ( _tokenId ) ` exists
6449,function loginUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = true ; },Freeze user during platform use - Backend Function
6451,"function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) || _from == address ( disbursementHandler ) ; }",only the Sale and DisbursementHandler can disburse the initial tokens to their future owners
6452,"function getTokenNameSpace ( Data storage self , string currency ) internal view returns ( address contractAddress ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; return self . Storage . getAddress ( id ) ; }",Get the contract interface address associated with token symbol
6453,"function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= SENC_HARD_CAP || now >= END_DATE , ""SENC hard cap rached OR End date reached"" ) ; require ( ! finalized , ""Donation not already finalized"" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= SENC_HARD_CAP ) { DONATION_WALLET . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; DONATION_WALLET . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , FOUNDATION_WALLET ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , FOUNDATION_WALLET ) ; finalized = true ; return finalized ; }",The ` finalize ( ) ` should only be called after donation hard cap reached or the campaign reached the final day .
6455,"function sellArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint priceForEachBlockWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = market . sellBlocks ( msg . sender , priceForEachBlockWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogSells ( id , fromX , fromY , toX , toY , priceForEachBlockWei ) ; }",lets a message sender to mark blocks for sale at price set for each block in wei
6456,"function onTransfer ( address _from , address _to , uint _amount ) external returns ( bool ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
6457,"function getPledgeDelegate ( uint64 idPledge , uint idxDelegate ) constant returns ( uint64 idDelegate , address addr , string name ) { Pledge storage p = findPledge ( idPledge ) ; idDelegate = p . delegationChain [ idxDelegate - 1 ] ; PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; addr = delegate . addr ; name = delegate . name ; }",Getter to find Delegate w/ the Pledge ID & the Delegate index
6458,"function setApprovalForAll ( address _operator , bool _approved ) onlyNonZeroAddress ( _operator ) external { ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }",This works even if sender does n't own any tokens at the time .
6459,function redeem ( uint _amount ) returns ( bool ) ;,Redeem ` _amount ` tokens back to the contract
6461,function unpause ( ) public onlyGameManager whenPaused { super . unpause ( ) ; },This is public rather than external so we can call super.unpause without using an expensive CALL .
6463,function unlockAccount ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = false ; },only the admin is allowed to unlock accounts .
6464,function getBulkBonus ( uint256 value ) view public returns ( uint256 ) { for ( uint8 i = uint8 ( bulkBonuses . length ) ; i > 0 ; i -- ) { uint8 idx = i - 1 ; if ( value >= bulkBonuses [ idx ] . minAmount ) { return value . mul ( baseRate ) . mul ( bulkBonuses [ idx ] . bonusPercent ) . div ( PERCENT_DIVIDER ) ; } } return 0 ; },Calculates a bulk bonus for a specified value of ether
6465,"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; allowance [ msg . sender ] [ _spender ] = allowance [ msg . sender ] [ _spender ] . add ( _amount ) ; return true ; }",Used to approve someone to send funds on your behalf
6468,"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""MG"" ; }","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata ."
6470,"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) external { }",Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
6471,function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) { _owner = identifierToOwner [ _deedId ] ; require ( _owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given deed .
6472,"function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }",Ask a new question and return the ID
6474,"function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }",Migrate tokens to the new token contract .
6475,function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address owner = tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; },Gets the owner of the specified token ID
6476,"function approve ( address spender , uint256 tokenAmount ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokenAmount ; emit Approval ( msg . sender , spender , tokenAmount ) ; return true ; }",Approve an address to send ` tokenAmount ` tokens to ` msg.sender ` ( make an allowance )
6478,"function getNext ( uint _count , address _contractAddress , uint _timestamp , uint _gasLimit , uint _gasPrice ) external view returns ( address [ ] addresses , uint [ ] timestamps , uint [ ] gasLimits , uint [ ] gasPrices , uint [ ] invokeGases , uint [ ] rewardAmounts ) ;",Unlike getTop this method return exact _count values .
6480,"function totalSupplyAt ( uint _blockNumber ) public view returns ( uint256 ) { return getValueAt ( totalSupplyHistory , _blockNumber ) ; }",Total amount of tokens at a specific ` _blockNumber ` .
6484,"function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time ) ; require ( quantity != 0 ) ; totalVestedBalance = safeAdd ( totalVestedBalance , quantity ) ; require ( totalVestedBalance <= havven . balanceOf ( this ) ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time ) ; totalVestedAccountBalance [ account ] = safeAdd ( totalVestedAccountBalance [ account ] , quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }",Add a new vesting entry at a given time and quantity to an account 's schedule .
6487,"function getOpinion ( uint256 _tokenId ) public view returns ( uint256 sellingPrice , address owner , address sponsor , address antisponsor , uint256 amountsponsored , uint256 amountantisponsored , uint8 acomment , uint256 timestamp , string opinionText ) { Opinion storage opinion = opinions [ _tokenId ] ; opinionText = opinion . text ; sellingPrice = opinionIndexToPrice [ _tokenId ] ; owner = opinionIndexToOwner [ _tokenId ] ; acomment = opinion . comment ; sponsor = opinion . sponsor ; antisponsor = opinion . antisponsor ; amountsponsored = opinion . totalsponsored ; amountantisponsored = opinion . totalantisponsored ; timestamp = opinion . timestamp ; }",Returns all the relevant information about a specific opinion .
6488,"function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable ) public returns ( uint ) { return issueAssetToAddress ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , msg . sender ) ; }",Issues new asset token on the platform .
6489,"function offerCanvasForSaleToAddress ( uint32 _canvasId , uint _minPrice , address _receiver ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , _receiver ) ; }",Offer canvas for sale to a given address .
6491,"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public hasMintPermission { doMint ( _tokenHolder , _amount , _operatorData ) ; }",Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
6493,"function burnNomins ( uint amount ) external optionalProxy { address sender = messageSender ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . burn ( sender , amount ) ; nominsIssued [ sender ] = safeSub ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }",Burn nomins to clear issued nomins/free havvens .
6494,"function _transferWithReference ( address _to , uint _value , string _reference ) internal returns ( bool ) { return _getAsset ( ) . __transferWithReference ( _to , _value , _reference , msg . sender ) ; }",Resolves asset implementation contract for the caller and forwards there arguments along with the caller address .
6497,"function burn ( address _holder , uint256 _amount ) external authP ( BURN_ROLE , arr ( _holder , _amount ) ) { token . destroyTokens ( _holder , _amount ) ; }","Burn ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens from ` _holder `"
6498,"function transfer ( address to , uint256 amount ) public returns ( bool success ) { mTransfer ( msg . sender , to , amount ) ; return true ; }",Send ` amount ` tokens to ` to ` from ` msg.sender `
6501,function setPrice ( uint _price ) onlyContractOwner external returns ( uint ) { price = _price ; return OK ; },Sets a price ( in wei ) for selling one token
6502,function getSaleDayNow ( ) view public returns ( uint8 ) { return getSaleDay ( now ) ; },How many 24 hour blocks have ellapsed since token sale start
6503,"function getReward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == 0 ) { return 0 ; } Commitment storage commitment = miners [ _miner ] ; int256 averageBlockReward = signedAverage ( commitment . onBlockReward , blockReward_ ) ; require ( 0 <= averageBlockReward ) ; uint256 effectiveBlockReward = uint256 ( averageBlockReward ) ; uint256 effectiveStake = average ( commitment . atStake , totalStake_ ) ; uint256 numberOfBlocks = block . number . sub ( commitment . onBlockNumber ) ; uint256 miningReward = numberOfBlocks . mul ( effectiveBlockReward ) . mul ( commitment . value ) . div ( effectiveStake ) ; return miningReward ; }",The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation )
6504,"function payTokensFromEscrow ( address _payer , address _receiver , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _receiver , _amount ) ; }",Pay from escrow of payer to available balance of receiever
6505,"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _token , _spender , _value , _fee , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by approvePreSigned
6507,"function proxyAccountingCreation ( address _owner , uint _pledgedAmount , uint _tokensToCreate ) public onlyOwner returns ( bool ) { doProxyAccounting ( _owner , _pledgedAmount , _tokensToCreate ) ; return true ; }","` proxyAccountingCreation ( ) ` allows owner to create tokens without sending ether via the contract Creates tokens , pledging an amount of eth to token holders but not sending it through the contract to the vault"
6509,"function claimTokens ( token _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract at any time
6512,function decimals ( ) public view returns ( uint8 ) { return 0 ; },Returns the number of decimals the token uses .
6513,"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenltkrecipiente spender = tokenltkrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it"
6515,"function computeNodeId ( bytes32 indexId , bytes32 id ) constant returns ( bytes32 ) { return GroveLib . computeNodeId ( indexId , id ) ; }","Computes the id for a node in a given Grove index which is sha3 ( indexId , id )"
6517,function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = RaidenToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; },Set ` _token_address ` as the token address to be used in the auction .
6518,"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; emit Create ( msg . sender , baseUnits ) ; }",Creates Bskt tokens in exchange for underlying tokens .
6519,"function transfer ( address _to , uint _value ) public notPaused { super . transfer ( _to , _value ) ; }",ERC20 transfer function overridden to disable transfers when paused
6520,function isService ( address _service ) public constant returns ( bool ) { },is the service in question '_service ' a registered service with this registry
6521,"function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , ""Blocking already exists"" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }",Adds a pair of addresses to manual blockings
6522,"function changeModuleBudget ( uint8 _moduleType , uint8 _moduleIndex , uint256 _budget ) public onlyOwner { require ( _moduleType != 0 , ""Module type cannot be zero"" ) ; require ( _moduleIndex < modules [ _moduleType ] . length , ""Incorrrect module index"" ) ; uint256 _currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress ) ; if ( _budget < _currentAllowance ) { require ( IERC20 ( polyToken ) . decreaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _currentAllowance . sub ( _budget ) ) , ""Insufficient balance to decreaseApproval"" ) ; } else { require ( IERC20 ( polyToken ) . increaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget . sub ( _currentAllowance ) ) , ""Insufficient balance to increaseApproval"" ) ; } emit LogModuleBudgetChanged ( _moduleType , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget ) ; }",allows owner to approve more POLY to one of the modules
6524,"function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; gameSettings [ gameIndex ] = nextGameSettings ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool , gameSettings [ gameIndex ] . rows , gameSettings [ gameIndex ] . cols , gameSettings [ gameIndex ] . activityTimer , gameSettings [ gameIndex ] . unclaimedTilePrice , gameSettings [ gameIndex ] . buyoutReferralBonusPercentage , gameSettings [ gameIndex ] . buyoutPrizePoolPercentage , gameSettings [ gameIndex ] . buyoutDividendPercentage , gameSettings [ gameIndex ] . buyoutFeePercentage ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; uint256 price = _calculateAndAssignBuyoutProceeds ( currentOwner , identifier , claimedSurroundingTiles ) ; require ( msg . value >= price ) ; _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . lastFlippedTile = identifier ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] = block . timestamp ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , block . timestamp + gameSettings [ gameIndex ] . activityTimer , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }",Buy the current owner out of the tile .
6526,"function setMaxSpend ( uint256 _maxSpend ) external onlyOwner returns ( bool ) { emit SetMaxSpend ( maxSpend , _maxSpend ) ; maxSpend = _maxSpend ; return true ; }",Sets a max amount to expend when performing the payment
6528,function getCommissionWithdrawn ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . paidCommissionIndex ; return _history . commissionCumulative [ _index ] ; },Returns total amount of commission that has been already paid ( added to pending withdrawals ) .
6529,"function migrationGetPlayer ( bytes32 boardHash , uint8 playerID ) constant isOwner public returns ( uint , bytes32 , address , uint , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; return ( playerID , p . playerName , p . playerAddress , p . score , p . score_unconfirmed , p . isActive ) ; }",Read player metadata for migration as contract owner
6530,"function setFxUSDBPSRate ( Data storage self , string currency , uint bpsRate ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fx.usd.rate' , currency ) ) ; require ( self . Storage . setUint ( id , bpsRate ) , ""Error: Unable to update account spending period."" ) ; return true ; }",Set the foreign currency exchange rate to USD in basis points
6531,"function getPrefixedHash ( address _message ) pure public returns ( bytes32 signHash ) { signHash = keccak256 ( ""\x19Ethereum Signed Message:\n20"" , _message ) ; }",Hash a hash with ` `` \x19Ethereum Signed Message : \n32 '' `
6532,"function calculatePointsBlock ( uint32 amount ) external { require ( gameFinishedTime == 0 ) ; require ( amount + lastCheckedToken <= tokens . length ) ; for ( uint256 i = lastCalculatedToken ; i < ( lastCalculatedToken + amount ) ; i ++ ) { uint16 points = PointsCalculator . calculateTokenPoints ( tokens [ i ] . matches , tokens [ i ] . bonusMatches , tokens [ i ] . extraStats , matchResults , extraStats , bonusMatches , starMatches ) ; tokenToPointsMap [ i ] = points ; } lastCalculatedToken += amount ; }",Sets the points of all the tokens between the last chunk set and the amount given .
6533,"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }",Generates ` _amount ` tokens that are assigned to ` _owner `
6538,"function ( ) payable stopOnPause { require ( now < deadline ) ; require ( msg . value >= minInvestment ) ; uint amount = msg . value ; ethBalances [ msg . sender ] += amount ; weiRaised += amount ; if ( ! fundingGoalReached && weiRaised >= fundingGoal ) { goalReached ( ) ; } uint ABIOAmount = amount / weiPerABIO ; abioToken . transfer ( msg . sender , ABIOAmount ) ; abioSold += ABIOAmount ; emit FundsReceived ( msg . sender , amount ) ; }",Called everytime we receive a contribution in ETH .
6539,"function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( securityTokenRegistry ) . isSecurityToken ( msg . sender ) ) { require ( registry [ _moduleFactory ] != 0 , ""ModuleFactory type should not be 0"" ) ; require ( verified [ _moduleFactory ] || ( IModuleFactory ( _moduleFactory ) . owner ( ) == ISecurityToken ( msg . sender ) . owner ( ) ) , ""Module factory is not verified as well as not called by the owner"" ) ; reputation [ _moduleFactory ] . push ( msg . sender ) ; emit LogModuleUsed ( _moduleFactory , msg . sender ) ; } }",Called by a security token to notify the registry it is using a module
6541,"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner , string message , uint256 previousPrice , address [ 7 ] previousOwners ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; message = emojiIndexToCustomMessage [ _tokenId ] ; previousPrice = emojiIndexToPreviousPrice [ _tokenId ] ; previousOwners = emojiIndexToPreviousOwners [ _tokenId ] ; }",Returns all the relevant information about a specific emoji .
6542,function flushEth ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; },Allows the owner to flush the eth .
6543,function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) ;,Get the ID of the attribute type at index ` index ` .
6544,function setTravelCore ( address _newTravelCore ) external onlyCEO whenPaused { travelCore = KydyTravelInterface ( _newTravelCore ) ; },We have a plan to add some fun features to the Dyverse .
6546,function setNomin ( Nomin _nomin ) external optionalProxy_onlyOwner { nomin = _nomin ; emitNominUpdated ( _nomin ) ; },Set the associated Nomin contract to collect fees from .
6548,"function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) == false , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , index : _attributeIDs . length , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }",Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
6549,"function mTransfer ( uint64 idSender , uint [ ] pledgesAmounts , uint64 idReceiver ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; transfer ( idSender , idPledge , amount , idReceiver ) ; } }",` mTransfer ` allows for multiple pledges to be transferred efficiently
6552,function currentSnapshotId ( ) public constant returns ( uint256 ) ;,upper bound of series of snapshotIds for which there 's a value in series
6553,function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; },Set address of upgrade target contract and enable upgrade process .
6554,"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;",Checks if the makeOrder price is reasonable and not manipulative
6556,function lockAccount ( address _owner ) public is_not_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = true ; },only the admin is allowed to lock accounts .
6557,"function allowance ( address tokenOwner , address spender ) public view returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }",Get the remaining allowance for a spender on a given address
6558,"function destroy ( address [ ] tokens ) onlyOwner public { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }",The called token contracts could try to re-enter this contract .
6559,"function getCompetitionStatusOfHopefuls ( ) view returns ( address [ ] fundAddrs , address [ ] fundManagers , bool [ ] areCompeting , bool [ ] areDisqualified ) { for ( uint i = 0 ; i <= hopefuls . length - 1 ; i ++ ) { fundAddrs [ i ] = hopefuls [ i ] . fund ; fundManagers [ i ] = hopefuls [ i ] . manager ; areCompeting [ i ] = hopefuls [ i ] . isCompeting ; areDisqualified [ i ] = hopefuls [ i ] . isDisqualified ; } return ( fundAddrs , fundManagers , areCompeting , areDisqualified ) ; }",Returns an array of fund addresses and an associated array of whether competing and whether disqualified
6560,"function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached ) { require ( treasury == msg . sender ) ; if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }",Lets treasury collect the funds if goal was reached .
6562,function proxyPayment ( address _owner ) external payable returns ( bool ) ;,Called when ` _owner ` sends ether to the MiniMe Token contract
6564,"function removeUsersFromGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; uint _groupMemberIndex = _group . memberAddress2index [ _user ] ; if ( _memberIndex == 0 || _groupMemberIndex == 0 ) { continue ; } if ( _groupMemberIndex != _groupMembersCount ) { uint _lastUserGlobalIndex = _group . index2globalIndex [ _groupMembersCount ] ; address _lastUser = index2memberAddress [ _lastUserGlobalIndex ] ; _group . index2globalIndex [ _groupMemberIndex ] = _lastUserGlobalIndex ; _group . memberAddress2index [ _lastUser ] = _groupMemberIndex ; } delete _group . memberAddress2index [ _user ] ; delete _group . index2globalIndex [ _groupMembersCount ] ; _groupMembersCount = _groupMembersCount . sub ( 1 ) ; _removeGroupFromMember ( _user , _groupName ) ; UserFromGroupRemoved ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }",Remove users in group Can be called only by contract owner
6565,"function transfer ( address _to , uint256 _value ) returns ( bool success ) ;",send ` _value ` token to ` _to ` from ` msg.sender `
6567,function getExitIndex ( uint64 slot ) private view returns ( uint256 ) { uint256 len = exitSlots . length ; for ( uint256 i = 0 ; i < len ; i ++ ) { if ( exitSlots [ i ] == slot ) return i ; } return 2 ** 65 ; },"If the slot 's exit is not found , a large number is returned to ensure the exit array access fails"
6568,"function withdrawalRange ( uint256 fromIndex , uint256 toIndex , address to ) public returns ( uint256 ) { uint256 loanId ; uint256 totalWithdraw = 0 ; for ( loanId = fromIndex ; loanId <= toIndex ; loanId ++ ) { Loan storage loan = loans [ loanId ] ; if ( loan . lender == msg . sender ) { totalWithdraw += loan . lenderBalance ; loan . lenderBalance = 0 ; } } require ( rcn . transfer ( to , totalWithdraw ) ) ; unlockTokens ( rcn , totalWithdraw ) ; return totalWithdraw ; }","Withdraw lender funds in batch , it walks by all the loans between the two index , and withdraws all the funds stored on that loans ."
6569,"function completeUnlock ( bytes32 _requestMsgHash , uint8 _recoveryByte1 , bytes32 _ecdsaR1 , bytes32 _ecdsaS1 , uint8 _recoveryByte2 , bytes32 _ecdsaR2 , bytes32 _ecdsaS2 ) public returns ( bool success ) { Request storage request = requestMap [ _requestMsgHash ] ; bytes32 lockId = request . lockId ; address callbackAddress = request . callbackAddress ; bytes4 callbackSelector = request . callbackSelector ; require ( callbackAddress != address ( 0 ) ) ; require ( request . idx > lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] ) ; address signer1 = ecrecover ( _requestMsgHash , _recoveryByte1 , _ecdsaR1 , _ecdsaS1 ) ; require ( signerSet [ signer1 ] ) ; address signer2 = ecrecover ( _requestMsgHash , _recoveryByte2 , _ecdsaR2 , _ecdsaS2 ) ; require ( signerSet [ signer2 ] ) ; require ( signer1 != signer2 ) ; if ( request . extended && ( ( block . timestamp - request . timestamp ) < extendedTimeLock ) ) { emit TimeLocked ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; return false ; } else if ( ( block . timestamp - request . timestamp ) < defaultTimeLock ) { emit TimeLocked ( request . timestamp + defaultTimeLock , _requestMsgHash ) ; return false ; } else { if ( address ( this ) . balance > 0 ) { success = msg . sender . send ( address ( this ) . balance ) ; } lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] = request . idx ; delete requestMap [ _requestMsgHash ] ; success = callbackAddress . call ( callbackSelector , lockId ) ; if ( success ) { emit Completed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } else { emit Failed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } } }",Completes a pending unlocking with two signatures .
6571,"function deposit ( address to , uint256 amount ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) returns ( bool ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; setAllowedTransferTo ( to , true ) ; LogDeposit ( to , amount ) ; Transfer ( address ( 0 ) , to , amount ) ; return true ; }",deposit 'amount ' of EUR-T to address 'to '
6572,"function lockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( ""BrickblockToken"" ) ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . add ( _amount ) ; totalLockedBBK = totalLockedBBK . add ( _amount ) ; require ( _bbk . transferFrom ( msg . sender , this , _amount ) ) ; emit BbkLocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }",Transfers BBK from an account owning BBK to this contract .
6573,"function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner public { require ( _mintedAmount >= 0 ) ; balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; totalSupply = totalSupply . add ( _mintedAmount ) ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }",Create ` _mintedAmount ` tokens and send it to ` _target `
6575,"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered ."
6576,"function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external { require ( isAttributeType ( ID ) , ""unable to set fee, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . jurisdictionFee = fee ; }","Set a required fee for a given attribute type ID ` ID ` and an amount of ` fee ` , to be paid to the owner of the jurisdiction upon assignment of attributes of the given type ."
6577,function setTimelock ( uint _newTimeLock ) onlyOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; },` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
6580,"function withdraw ( address _withdrawer , address _token , uint256 _amount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { bytes32 msgHash = keccak256 ( abi . encodePacked ( ""withdraw"" , _withdrawer , _token , _amount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _withdrawer , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; _withdraw ( _withdrawer , _token , _amount , _feeAsset , _feeAmount ) ; }",Withdraws ` _amount ` worth of ` _token ` s to the ` _withdrawer `
6582,"function approve ( address _spender , uint _value ) public returns ( bool ) ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
6585,"function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 , ""The arbitrator must have set a non-zero fee for the question"" ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitio . isFinalized ( question_id ) , ""The question must not have been finalized"" ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }","Request arbitration , freezing the question until we send submitAnswerByArbitrator"
6586,"function setLimited ( address target , bool isLimited ) ifAuthorised ifGeneralPartner { shareholders [ target ] . limited = isLimited ; SetLimited ( target , isLimited ) ; }","This sets member 's liability status , either to limited liability , or unlimited liability ."
6587,function updateMinimumPodSize ( uint256 _nextMinimumPodSize ) external onlyOwner { nextMinimumPodSize = _nextMinimumPodSize ; },Allows the contract owner to update the minimum pod size .
6589,"function frozenTransfer ( address _to , uint256 _value , uint thawTS , bool isKYCRequired ) external validAddress ( _to ) validUnixTS ( thawTS ) payloadSizeIs ( 4 * 32 ) privilegedAllowed onlySale ( msg . sender ) checkTransferInvariant ( msg . sender , _to ) returns ( bool ) { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; addFrozen ( _to , _value , thawTS , isKYCRequired ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }",Transfers tokens to a recipient and freezes it .
6590,"function mint ( address _to , uint _amount ) external onlyOwner { _mint ( _to , _amount ) ; }",Create some tokens and assign them to the given address can only be called by the smart contract owner
6591,"function _isValidSignatureAndData ( address account , bytes signature ) internal view returns ( bool ) { require ( msg . data . length > _SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - _SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , account , data ) ) , signature ) ; }",the signature parameter of the method being validated must be the `` last '' parameter
6592,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
6593,function orderTrader ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . trader ; },returns the trader of the given orderID .
6594,"function newProposal ( address _contractorManager , uint _contractorProposalID , uint _amount , bool _publicShareCreation , bool _tokenCreation , address _mainPartner , uint _initialSharePriceMultiplier , uint _inflationRate , uint _minutesFundingPeriod , uint _minutesDebatingPeriod ) payable returns ( uint ) ;",Function to make a proposal to pay a contractor or fund the Dao
6595,"function getCutie ( uint40 _id ) external view returns ( uint256 genes , uint40 birthTime , uint40 cooldownEndTime , uint40 momId , uint40 dadId , uint16 cooldownIndex , uint16 generation ) { Cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; birthTime = cutie . birthTime ; cooldownEndTime = cutie . cooldownEndTime ; momId = cutie . momId ; dadId = cutie . dadId ; cooldownIndex = cutie . cooldownIndex ; generation = cutie . generation ; }",Returns all the relevant information about a certain cutie .
6596,"function tokenFallback ( address , uint , bytes ) external whenNotPaused { require ( msg . sender == address ( token ) , ""AIRDROP_TOKEN_NOT_SUPPORTED"" ) ; }",Guards smart contract from accepting non-allowed tokens ( if they support ERC223 interface )
6597,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MisToken ) { MisToken newToken = new MisToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
6598,function getMasterFeeContract ( Data storage self ) internal view returns ( address masterFeeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; return self . Storage . getAddress ( id ) ; },Get the master fee contract set via the TokenIOAuthority contract
6599,function setInvitationReward ( uint256 _invitationReward ) public onlyOwner { invitationReward = _invitationReward ; emit InvitationRewardChanged ( _invitationReward ) ; },This function does not affect previously awarded invitation rewards
6600,function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( 0 ) ; },Init function i.e generalise function to maintain the structure of the module contract
6602,"function claimVestedTokens ( ) public { uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( msg . sender ) ; require ( amountVested > 0 ) ; Grant storage tokenGrant = tokenGrants [ msg . sender ] ; tokenGrant . monthsClaimed = uint16 ( add ( tokenGrant . monthsClaimed , monthsVested ) ) ; tokenGrant . totalClaimed = uint128 ( add ( tokenGrant . totalClaimed , amountVested ) ) ; require ( token . transfer ( msg . sender , amountVested ) ) ; emit GrantTokensClaimed ( msg . sender , amountVested ) ; }",Allows a grant recipient to claim their vested tokens .
6604,"function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _transfer ( getHolderId ( _from ) , _createHolderId ( _to ) , _value , _symbol , _reference , getHolderId ( _sender ) ) ; }",Prforms allowance transfer of asset balance between holders wallets .
6610,"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( _isIdle ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific Player via transferFrom ( ) .
6612,"function contractBatchTransfer ( address [ ] recipients , uint [ ] quantities ) external onlyOwner returns ( bool ) { return _batchTransfer ( this , recipients , quantities ) ; }","Performs ERC20 transfers from the contract address in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from the contract to ` recipients [ i ] ` ."
6613,"function setManager ( address _addr , address _newManager ) external { require ( getManager ( _addr ) == msg . sender , ""Not the manager"" ) ; managers [ _addr ] = _newManager == _addr ? 0 : _newManager ; emit ManagerChanged ( _addr , _newManager ) ; }",Sets the ` _newManager ` as manager for the ` _addr ` address .
6614,function setMinimumBidAmount ( uint _amount ) external onlyOwner { minimumBidAmount = _amount ; },Only for the owner of the contract .
6621,function closeMotion ( uint motionID ) external { require ( ( motionConfirming ( motionID ) && ! motionPasses ( motionID ) ) || motionWaiting ( motionID ) ) ; _closeMotion ( motionID ) ; },"If a motion has concluded , or if it lasted its full duration but not passed , then anyone may close it ."
6622,function optIn ( ) public returns ( bool ) { delete userOptOutVersion [ msg . sender ] ; return true ; },"Implicitly agree to upgrade to current and future asset implementation upgrades , until further explicit disagreement ."
6623,function isExistingHolding ( address who ) public view returns ( bool ) { Holding memory h = heldTokens [ who ] ; return ( h . quantity != 0 || h . releaseDate != 0 ) ; },"Check if a wallet is already in use , only new/fresh/clean wallets can hold tokens ."
6627,function changeEscapeCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; },Changes the address assigned to call ` escapeHatch ( ) `
6630,function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; },minimum amount of funding to consider the sale as successful ( in euro-cents )
6631,function burnRestTokens ( ) afterDeadline { require ( ! restTokensBurned ) ; abioToken . burnMyBalance ( ) ; restTokensBurned = true ; },Burns tokens leftover from an ICO round .
6632,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }","Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner ."
6634,"function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value >= minimumPayment ) ; uint256 tokenExchangeRate = calculateTokenExchangeRate ( ) ; require ( tokenExchangeRate > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) . div ( 100 ) ; require ( tokens <= maximumTokensToBuy ( ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( escFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimESC ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }",Create ` msg.value ` ETH worth of ESC
6636,"function transferOwnershipToGiver ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , 0 , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }","` transferOwnershipToGiver ` allows for the transfer of value back to the Giver , value is placed in a pledged state without being attached to a project , delegation chain , or time line ."
6637,"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ) ; }",Hash ( keccak256 ) of the payload used by setCOO
6638,"function transfer ( address _to , uint256 _value ) { require ( msg . sender == owner || now > 1509467422 ) ; _transfer ( msg . sender , _to , _value ) ; }",Send ` _value ` tokens to ` _to ` from your account
6639,function beneficiaryWithdraw ( ) external { require ( msg . sender == _beneficiary ) ; require ( _ended ) ; require ( ! _beneficiaryWithdrawn ) ; uint total = 0 ; for ( uint i = 0 ; i < 100 ; ++ i ) { total = total . add ( _topBids [ i ] . bid ) ; } _beneficiaryWithdrawn = true ; _beneficiary . transfer ( total ) ; },Withdraw the total of the top 100 bids into the beneficiary account
6641,"function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public returns ( bool ) ;",Make bulk transfer of tokens to many addresses
6642,"function metaTransferHash ( address _to , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaTransfer"" , _to , _amount , _nonce , _reward ) ) ; }",Return hash containing all of the information about the transfer ( ) metatransaction
6643,"function multiBuy ( address [ ] sellers , uint256 lastQuantity ) public payable { for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { buy ( sellers [ i ] , lastQuantity , to . price ) ; } else { buy ( sellers [ i ] , to . quantity , to . price ) ; } } }",Buy from multiple sellers at once to fill a single large order .
6644,"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }","challenge the provided proposal ID , and put tokens at stake to do so ."
6645,"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( allowed [ _from ] [ _to ] >= _amount ) ; uint256 _fee = validator . validateAndGetTransferFee ( owner , _from , _to , _amount ) ; store . transfer ( _from , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( _from , store . getSettingAddress ( ""feeReturnAddress"" ) , _fee ) ; allowed [ _from ] [ _to ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }",Transfer ` _amount ` of tokens ( must be sent as floating point number of token and decimal parts ) to ` _address ` from address ` _from ` without autoapproving
6646,function supplyICOContract ( address _addr ) public onlyOwner { require ( _addr != 0x0 ) ; ICOAddress = _addr ; ICO = ABIO_ICO ( _addr ) ; if ( ! fundingGoalReached && weiRaised + ICO . weiRaised ( ) >= fundingGoal ) { goalReached ( ) ; } finalDeadline = ICO . deadline ( ) ; },Called by dev to supply the address of the ICO ( which is created after the PreICO )
6647,"function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( plannedContribution , msg . value . sub ( plannedContribution ) ) ; }",Returns the contribution and refund value to be used when the transaction value is higher than the whitelisted contribution for the sender .
6648,function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= 37.5e24 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = msg . value . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; },Calculates how many ether will be used to generate the tokens in case the buyer sends more than the maximum balance but has some balance left and updates the balance of that buyer .
6649,"function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
6650,"function adjustInvestorCount ( InvestorDataStorage storage _investorData , address _from , address _to , uint256 _value , uint256 _balanceTo , uint256 _balanceFrom ) public { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( _balanceTo == 0 ) && ( _to != address ( 0 ) ) ) { _investorData . investorCount = ( _investorData . investorCount ) . add ( 1 ) ; } if ( _value == _balanceFrom ) { _investorData . investorCount = ( _investorData . investorCount ) . sub ( 1 ) ; } if ( ! _investorData . investorListed [ _to ] && ( _to != address ( 0 ) ) ) { _investorData . investors . push ( _to ) ; _investorData . investorListed [ _to ] = true ; } }",Keeps track of the number of non-zero token holders
6651,"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferOwnership ( msg . sender ) ; emit CreatedToken ( _tokenSymbol , address ( newToken ) ) ; return newToken ; }",Update the DApp by creating a new token with new functionalities the msg.sender becomes the owner of this clone token
6652,"function approveProposal ( uint _proposalId ) public onlyAdmins { require ( proposals . length > _proposalId ) ; require ( ! proposals [ _proposalId ] . denied ) ; Proposal storage p = proposals [ _proposalId ] ; require ( ! p . approved ) ; p . token = tokenFactory . createCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""NectarProposal-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""NP-"" , _proposalId ) , true ) ; p . approved = true ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit Approved ( _proposalId ) ; }",Admins are able to approve proposal that someone submitted
6653,"function _addToken ( address _to , uint256 _tokenId ) private { uint256 newTokenIndex = ownedTokens [ _to ] . length ; ownedTokens [ _to ] . push ( _tokenId ) ; require ( newTokenIndex == uint256 ( uint32 ( newTokenIndex ) ) , ""overflow"" ) ; tokenOwnerAndTokensIndex [ _tokenId ] = AddressAndTokenIndex ( { owner : _to , tokenIndex : uint32 ( newTokenIndex ) } ) ; }",Internal function to add a token ID to the list of a given address
6654,function changeAllowAllTransfers ( bool _allowAllTransfers ) public withPerm ( FLAGS ) { allowAllTransfers = _allowAllTransfers ; emit LogAllowAllTransfers ( _allowAllTransfers ) ; },"Used to change the flag true - It refers there are no transfer restrictions , for any addresses false - It refers transfers are restricted for all addresses ."
6657,"function isNotaryAdditionValid ( address order , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , responsesPercentage , notarizationFee , notarizationTermsOfService ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }",Checks if the notary 's signature to be added to the DataOrder is valid .
6658,"function withdraw ( address _recipient ) public returns ( bool ) { require ( shares [ _recipient ] > 0 ) ; require ( totalAtWithdrawal [ _recipient ] < totalReceived ) ; uint left = totalReceived . sub ( totalAtWithdrawal [ _recipient ] ) ; uint share = left . mul ( shares [ _recipient ] ) . div ( 10000 ) ; totalAtWithdrawal [ _recipient ] = totalReceived ; ERC20 ( holdingToken ) . transfer ( _recipient , share ) ; return true ; }",Method to withdraw shared part of received tokens for providen address
6659,"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }",Send `` _value '' tokens to `` _to '' from `` msg.sender '' .
6660,"function approve ( address _to , uint256 _deedId ) external payable ;","Set the `` approved taker '' for your deed , or revoke approval by setting the zero address ."
6661,"function transferFrom ( address from , address to , uint tokens ) public tokenTradingMustBeLive ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( from , to , tokens ) ; return true ; }",Transfer tokens from an address to another through an allowance made beforehand
6662,"function freezeAmount ( address target , uint256 _value ) onlyOwner public { require ( _value > 0 ) ; frozenAmount [ target ] = _value ; emit FrozenAmt ( target , _value ) ; }",Freeze ` _value ` of ` target ` balance
6663,function destroy ( ) public onlyOwner { selfdestruct ( owners [ 0 ] ) ; },Allows to destroy the contract and return the tokens to the owner .
6665,"function createSingleSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createSeedCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }",Creates a new Collectible and creates an auction for it .
6666,"function addChunk5ToWhiteList ( ) external onlyOwner { require ( ! chunk5IsAdded ) ; addToWhitelist ( 0x439f5420d4eD1DE8c982100Fcf808C5FcEeC1bFa , 1.25 ether ) ; addToWhitelist ( 0xfd5D41Dad5218C312d693a8b6b1128889cFFec43 , 1.25 ether ) ; addToWhitelist ( 0x1FBB99bf7E6e8920Fac8Ab371cEB5A90e0801656 , 1.5 ether ) ; addToWhitelist ( 0x6d767fE3e87b6Ffb762cd46138aaaB48a6788d06 , 1.5 ether ) ; addToWhitelist ( 0x9C299486fc9b5B1bA1dbE2d6D93E3580f9A64995 , 1.5 ether ) ; addToWhitelist ( 0x009e511c89e033142bdd1f34f7cad0f3e188696d , 2 ether ) ; addToWhitelist ( 0x25929fF98a1e8D7d1c14674bD883A24C26FB1df4 , 2 ether ) ; addToWhitelist ( 0x2a54850a5166d2fCC805B78A1D436b96e4477e09 , 2 ether ) ; addToWhitelist ( 0x3D212E369e08fB9D5585a35449595df044cdD7a4 , 2 ether ) ; addToWhitelist ( 0x417EcaE932D3bAE2d93a2af6dA91441d46532A7C , 2 ether ) ; addToWhitelist ( 0x53070A3A5faF50280563ea4fB4b5e6AcA53B7221 , 2 ether ) ; addToWhitelist ( 0x67314b5CdFD52A1D5c4794C02C5b3b2cc4bdc21B , 2 ether ) ; addToWhitelist ( 0x67fb2006dd8990de950d1eb41f07ff7f929c3bca , 2 ether ) ; addToWhitelist ( 0x76b3a5aad6aD161680F9e7C9dd09bA9626135765 , 2 ether ) ; addToWhitelist ( 0x77446d3Df1216B1e8Ea1913203B05F5cb182B112 , 2 ether ) ; addToWhitelist ( 0x788b7433ddf168544b2adae3c6aa416d3f6fa112 , 2 ether ) ; addToWhitelist ( 0x790310b3f668019056a8b811ced6e2a0af533660 , 2 ether ) ; addToWhitelist ( 0x7dD1b95E76F7893002E4FB9a533628994b703479 , 2 ether ) ; addToWhitelist ( 0x821578e6212651CAa996184404787ccC09C71014 , 2 ether ) ; addToWhitelist ( 0x8b91B39Ef4ae08bEacC128d3C2e19140AbD0245F , 2 ether ) ; addToWhitelist ( 0x8f566cdE6724DEA78756B8C252055e6eA7D3d7a4 , 2 ether ) ; addToWhitelist ( 0x90f7f982c2Ab40534e5E3bE449967B716ef04BB1 , 2 ether ) ; addToWhitelist ( 0x91FDae97a5a3Ba806fA3Eb8B3cd3F0bEE6431b77 , 2 ether ) ; addToWhitelist ( 0x99cf8060BaFca88C04Aa2Eace46CA880bE75F166 , 2 ether ) ; addToWhitelist ( 0xa099638b5CFE746C0B3DD1a3998051c2Ac1F3dC8 , 2 ether ) ; addToWhitelist ( 0xb9a2ACF30FB774881371F249928Cb48Ccc184bAC , 2 ether ) ; addToWhitelist ( 0xC301Fc1acCF9ab89Fa68Fd240dCDaa0Bd9a3658F , 2 ether ) ; addToWhitelist ( 0xc4f5bFad8Ec83Bcd4AB3b3a27266f08b4517f59B , 2 ether ) ; addToWhitelist ( 0xd1EA23d6713ca22cc1f2e10dc6FD8B1DfB65b563 , 2 ether ) ; addToWhitelist ( 0xd4F2ad288874653F09e3Cc522C1106692E30394C , 2 ether ) ; addToWhitelist ( 0xddF81dabe498118df262b1b907492b391211321e , 2 ether ) ; addToWhitelist ( 0xE4fBc54c0a08a5d0CD1EEBC8bf0Ea48fdBFd7E0c , 2 ether ) ; addToWhitelist ( 0xf42F3c005B1723782FC25E5771748a6A1fff5e03 , 2 ether ) ; addToWhitelist ( 0xff7ef21aC94961a3C9F71a3deFFfe2f58e102E1f , 2 ether ) ; addToWhitelist ( 0xa27A60769B426b1eEA3be951DF29D352B48ec5Da , 2.5 ether ) ; addToWhitelist ( 0xba334469f45f8e0ca1d61fa036fece3b4d5ec0f7 , 2.5 ether ) ; addToWhitelist ( 0xdE47f3C16cDb757027F61D07a44c881d2D32B161 , 2.5 ether ) ; addToWhitelist ( 0xfCD47A33207eD5a03390330Fd6EcFF2DFf8F5a2b , 2.5 ether ) ; addToWhitelist ( 0x27fcA80168B7eDC487B22F0F334BA922d1e26E2D , 3 ether ) ; addToWhitelist ( 0x36bd14eaf211d65164e1e0a2eab5c98b4b734875 , 3 ether ) ; addToWhitelist ( 0x3D1a96c1fE8D1281537c5A8C93A89215DF254d3f , 3 ether ) ; addToWhitelist ( 0x40ED9F03BFfFA1cB30E36910907cd55ac27Be05d , 3 ether ) ; addToWhitelist ( 0x5Da227c19913F4deEB64A6E7fE41B30B230161D2 , 3 ether ) ; addToWhitelist ( 0x7e443aA16aC53419CFd8056Bcc30b674864Ac55F , 3 ether ) ; addToWhitelist ( 0x80F30bAc95966922f1E8c66c0fD088959a00f15f , 3 ether ) ; addToWhitelist ( 0x8862004b5a7C21B8F771AF3213b79bD9b81f9DA0 , 3 ether ) ; addToWhitelist ( 0x904063eF93eEEd9584f6B0131F9FD047d7c3C28d , 3 ether ) ; addToWhitelist ( 0xa14aC1A9B3D52aBD0652C5Aca346099A6eb16b54 , 3 ether ) ; addToWhitelist ( 0xA2Ef14F0d1ae84609Cd104feB91EAeD4B39C4852 , 3 ether ) ; addToWhitelist ( 0xA4D1905ceF480Fb9089578F88D3C128cf386ebd5 , 3 ether ) ; addToWhitelist ( 0xa5D5404864E9eA3104ec6721CA08E563964Ae536 , 3 ether ) ; addToWhitelist ( 0xB3ADF1FB9c488DBB42378876ff4Fc2be4c1B4365 , 3 ether ) ; chunk5IsAdded = true ; }",Add chunk 5 / 7 to the whitelist
6667,"function computeIssuanceData ( uint preBalance , IssuanceData preIssuance ) internal view returns ( IssuanceData ) { uint currentBalanceSum = preIssuance . currentBalanceSum ; uint lastAverageBalance = preIssuance . lastAverageBalance ; uint lastModified = preIssuance . lastModified ; if ( lastModified < feePeriodStartTime ) { if ( lastModified < lastFeePeriodStartTime ) { lastAverageBalance = preBalance ; } else { uint timeUpToRollover = feePeriodStartTime - lastModified ; uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime ; uint lastBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , timeUpToRollover ) ) ; lastAverageBalance = lastBalanceSum / lastFeePeriodDuration ; } currentBalanceSum = safeMul ( preBalance , now - feePeriodStartTime ) ; } else { currentBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , now - lastModified ) ) ; } return IssuanceData ( currentBalanceSum , lastAverageBalance , now ) ; }",Compute the new IssuanceData on the old balance
6670,function darknodeOwner ( address darknodeID ) external view onlyOwner returns ( address ) { return darknodeRegistry [ darknodeID ] . owner ; },Returns the owner of a given darknode .
6671,"function offer_energy ( uint32 aday , uint32 aprice , uint64 aenergy , uint64 atimestamp ) onlyRegisteredProducers external { require ( aenergy >= kWh ) ; uint idx = bidsIndex [ msg . sender ] [ aday ] ; if ( ( bids . length > idx ) && ( bids [ idx ] . producer == msg . sender ) && ( bids [ idx ] . day == aday ) ) { require ( atimestamp > bids [ idx ] . timestamp ) ; emit BidRevoked ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; } idx = bids . length ; bidsIndex [ msg . sender ] [ aday ] = idx ; bids . push ( Bid ( { producer : msg . sender , day : aday , price : aprice , energy : aenergy , timestamp : atimestamp } ) ) ; emit BidMade ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; }",Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .
6672,function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; },maximum investments to be accepted during the sale ( in euro-cents )
6674,"function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }",set ` paused ` to the specified state
6675,"function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) ;",Send ` amount ` tokens to ` to ` from ` from ` on the condition it is approved by ` from `
6678,"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }",Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
6680,"function withdrawMarginPreSignedHashing ( address _investContract , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7701c52d ) , _investContract , _from , _value , _fee , _nonce , _validUntil ) ) ; }",Hash ( keccak256 ) of the payload used by withdrawMarginPreSigned
6684,"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) returns ( bool ) { require ( delegateDetails [ _delegate ] != bytes32 ( 0 ) , ""Delegate details not set"" ) ; perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit LogChangePermission ( _delegate , _module , _perm , _valid , now ) ; return true ; }",Use to provide/change the permission to the delegate corresponds to the module contract
6690,"function airdropMinting ( address [ ] _to_list , uint [ ] _values ) public { require ( msg . sender == owner ) ; require ( _to_list . length == _values . length ) ; for ( uint i = 0 ; i < _to_list . length ; i ++ ) { mintToken ( _to_list [ i ] , _values [ i ] ) ; } }",Will allow multiple minting within a single call to save gas .
6691,"function newRepo ( string _name , address _dev ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { return _newRepo ( _name , _dev ) ; }",Create new repo in registry with ` _name `
6693,"function ( ) external payable { assembly { let _poaTokenMaster := sload ( poaTokenMaster_slot ) calldatacopy ( 0x0 , 0x0 , calldatasize ) let result := delegatecall ( gas , _poaTokenMaster , 0x0 , calldatasize , 0x0 , 0 ) if iszero ( result ) { revert ( 0 , 0 ) } returndatacopy ( 0x0 , 0x0 , returndatasize ) return ( 0x0 , returndatasize ) } }",Fallback function for all proxied functions using `` delegatecall ( ) '' .
6696,"function burnFrom ( address _from , uint256 _value ) public onlyOwner returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` ."
6700,"function claimTokens ( address _token ) public onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }",This method can be used by the controller to extract mistakenly sent tokens to this contract .
6701,function renounceOwnership ( ) public onlyAdmin { burnAdmin = address ( 0 ) ; },Renouncing to ownership will leave the contract without an owner .
6702,"function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) ;",Used to return all delegates with a given permission and module
6705,"function proxyPayment ( address ) public payable returns ( bool ) { require ( msg . sender == address ( token ) , ERROR_PROXY_PAYMENT_WRONG_SENDER ) ; return false ; }",Called when ether is sent to the MiniMe Token contract
6706,"function buy ( address _to ) public validAddress ( _to ) isNotFinalized payable { uint256 _amount = msg . value ; assert ( _amount > 0 ) ; uint256 _tokens = _amount . mul ( rate ) ; assert ( totalSupply . add ( _tokens ) <= totalMaxBuy ) ; totalSupply = totalSupply . add ( _tokens ) ; totalETH = totalETH . add ( _amount ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _tokens ) ; wallet . transfer ( _amount ) ; Buy ( msg . sender , _to , rate , _tokens ) ; Transfer ( this , _to , _tokens ) ; FundTransfer ( msg . sender , _amount , true ) ; }",This function sends B2BK tokens to the specified address when sending ETH
6707,"function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }",Grant another address the right to transfer a specific Warrior via transferFrom ( ) .
6708,"function updateContract ( string _contractName , address _newAddress ) external onlyContractOwner ( ""ContractManager"" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( contracts [ _contractName ] != address ( 0 ) ) ; require ( _newAddress != address ( 0 ) ) ; address oldAddress = contracts [ _contractName ] ; contracts [ _contractName ] = _newAddress ; emit ContractUpdated ( oldAddress , _newAddress , _contractName ) ; }",Update an existing contract ( changing the address )
6709,function refund ( ) ;,Function to refund after the closing time with 'msg.sender ' as 'beneficiary '
6710,function destroy ( ) public onlyOwner { selfdestruct ( owner ) ; },Allows to destroy the contract and return the tokens to the owner .
6712,"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( nft [ _tokenId ] . owner == _from , ""from address must be owner of tokenId"" ) ; uint256 [ ] storage tokenList = ownerToTokenList [ _from ] ; assert ( tokenList . length > 0 ) ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { if ( tokenList [ i ] == _tokenId ) { tokenList [ i ] = tokenList [ tokenList . length - 1 ] ; delete tokenList [ tokenList . length - 1 ] ; tokenList . length -- ; break ; } } delete nft [ _tokenId ] . owner ; }",Use and override this function with caution .
6713,"function revealCeiling ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( ceilings [ revealedCeilings ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCeilings > 0 ) { require ( _limit >= ceilings [ revealedCeilings . sub ( 1 ) ] . limit ) ; } ceilings [ revealedCeilings ] . limit = _limit ; ceilings [ revealedCeilings ] . slopeFactor = _slopeFactor ; ceilings [ revealedCeilings ] . collectMinimum = _collectMinimum ; revealedCeilings = revealedCeilings . add ( 1 ) ; if ( _last ) { allRevealed = true ; } }",Anybody can reveal the next ceiling if he knows it .
6714,"function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin nonZeroAddress ( _recipient ) returns ( bool ) { require ( _tokenAddress != address ( this ) , ""token address can't be this contract"" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , ""token transfer failed"" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }",Allow us to transfer tokens that someone might 've accidentally sent to this contract
6715,function claim ( ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { return claimHalvingsSubsidies ( claimableHalvings ( ) ) ; },Claim all the unclaimed halving subsidies of a miner
6717,"function updateWhitelistedContribution ( uint256 plannedContribution ) private { whitelistedPlannedContributions = whitelistedPlannedContributions . sub ( plannedContribution ) ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , plannedContribution ) ; }","Updates the whitelistedPlannedContributions counter , subtracting the contribution about to be applied ."
6718,"function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }","owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded"
6722,function setFreezeOracle ( bool _frozen ) onlyOwner public { freezeOracle = _frozen ; },Allows owner to set oracle to ignore all Oraclize pricce updates
6724,"function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , ""Blocking already exists"" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }",Adds a pair of addresses to manual blockings
6726,"function transferWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , false ) ; return true ; }",transfers tokens in ERC20 compatible way using signature to recover token sender
6727,function tokenURI ( uint256 _tokenId ) external view returns ( string ) ;,A distinct Uniform Resource Identifier ( URI ) for a given asset .
6728,"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) public onlyController { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; bool verified = _updateTransfer ( _from , _to , _value , _data ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ForceTransfer ( msg . sender , _from , _to , _value , verified , _log ) ; emit Transfer ( _from , _to , _value ) ; }",Used by a controller to execute a forced transfer
6730,"function isAllowedAsset ( address asset , string currency ) public view returns ( bool allowed ) { if ( isTokenXContract ( asset , currency ) ) { return true ; } else { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; } }",Return boolean if the asset is an allowed stable asset for the corresponding currency
6731,function symbol ( ) external view returns ( string ) { return _symbol ; },An abbreviated name for NFTs in this contract
6732,"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) ;",Notifies the controller about a token transfer allowing the controller to react if desired
6733,function hasError ( ) public onlyManager whenPaused { error = true ; },This is public rather than external so it can be called by derived contracts .
6735,"function distributeBonuses ( uint _amount ) public onlyDistributionSource returns ( uint ) { ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE ) ; } if ( ! _bonusToken . transferFrom ( msg . sender , wallet , _amount ) ) { return _emitError ( PROFITEROLE_ERROR_TRANSFER_ERROR ) ; } if ( firstDepositDate == 0 ) { firstDepositDate = now ; } uint _lastDepositDate = lastDepositDate ; if ( _lastDepositDate != 0 ) { distributionDeposits [ _lastDepositDate ] . nextDepositDate = now ; } lastDepositDate = now ; distributionDeposits [ now ] = Deposit ( _amount , _amount , 0 ) ; Treasury ( treasury ) . addDistributionPeriod ( ) ; DepositPendingAdded ( _amount , msg . sender , now ) ; return OK ; }",Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .
6736,function ownerOf ( uint _tokenId ) external view returns ( address owner ) { owner = rabbitToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; },Returns the address currently assigned ownership of a given Rabbit .
6737,"function collectionOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return pixelcons [ tokenLookup [ _tokenId ] . tokenIndex ] . collectionIndex ; }",Get the collection index of PixelCon ` ( _tokenId ) `
6742,"function tokenURI ( uint256 _tokenId ) public view returns ( string ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; bytes8 pixelconName = pixelconNames [ lookupData . tokenIndex ] ; string memory finalTokenURI = tokenURITemplate ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<tokenId>"" , StringUtils . toHexString ( _tokenId , 32 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<tokenIndex>"" , StringUtils . toHexString ( uint256 ( lookupData . tokenIndex ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<name>"" , StringUtils . toHexString ( uint256 ( pixelconName ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<owner>"" , StringUtils . toHexString ( uint256 ( lookupData . owner ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<creator>"" , StringUtils . toHexString ( uint256 ( pixelcon . creator ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<dateCreated>"" , StringUtils . toHexString ( uint256 ( pixelcon . dateCreated ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<collectionIndex>"" , StringUtils . toHexString ( uint256 ( pixelcon . collectionIndex ) , 8 ) ) ; return finalTokenURI ; }",Get a distinct Uniform Resource Identifier ( URI ) for PixelCon ` ( _tokenId ) `
6743,function unpause ( ) public onlyCOO whenPaused { paused = false ; },This is public rather than external so it can be called by derived contracts .
6744,"function changeOwnership ( address _newOwner ) onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }",` owner ` can step down and assign some other address to this role
6746,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( frozen [ _from ] == false ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }",Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
6749,"function acceptOwnership ( ) public { require ( msg . sender == newOwner , ""You have not been selected as the new owner."" ) ; emit OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = address ( 0 ) ; }",The new owner accepts responsibility of contract ownership by using this function .
6750,"function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , checkpointId , _excluded , _name ) ; }","Creates a dividend and checkpoint for the dividend , specifying explicit excluded addresses"
6751,"function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }",Returns the amount of tokens approved by the owner that can be transferred to the spender 's account
6753,"function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; bytes32 identifier = getIdentifier ( index ) ; require ( identifierToIndex [ identifier ] == 0 ) ; identifierToIndex [ identifier ] = index ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }","Creates a loan request , the loan can be generated with any borrower and conditions ; if the borrower agrees it must call the `` approve '' function ."
6754,function isRefunded ( address _darknodeID ) public view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return registeredAt == 0 && deregisteredAt == 0 ; },Returns if a darknode is in the refunded state .
6755,"function cashBack ( address _to ) public { uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( now > crowdsaleEndTime && usd < softcapUSD ) ; require ( ethSent [ _to ] > 0 ) ; delete ethSent [ _to ] ; _to . transfer ( ethSent [ _to ] ) ; }",cashBack will be used in case of failed ICO All partitipants can receive their ETH back
6756,function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return _emitError ( USER_MANAGER_INVALID_INVOCATION ) ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; },Discard user registration Can be called only by contract owner
6757,"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order"
6758,"function pay ( address who ) external payable { require ( who != 0x0 ) ; require ( msg . value == fee ) ; require ( s_paid [ who ] . length < 10 ) ; s_paid [ who ] . push ( msg . sender ) ; Paid ( who , msg . sender ) ; treasury . transfer ( msg . value ) ; }",This method is used to pay for the fee .
6760,"function batchEscrowToTeamContract ( address _owner , uint32 [ ] _tokenIds ) public whenNotPaused { require ( teamContract != address ( 0 ) ) ; require ( msg . sender == address ( teamContract ) ) ; for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( _owner , _tokenId ) ) ; _transfer ( _owner , teamContract , _tokenId ) ; } }",Escrows all of the tokensIds passed by transfering ownership to the teamContract .
6761,"function setLocked ( address _target , uint _timeStamp ) public onlyAdmin returns ( bool ) { locked [ _target ] = _timeStamp ; emit LockStatus ( _target , _timeStamp ) ; return true ; }",_target - address you want to lock until _timeStamp - unix time
6762,function getCurrencyAddress ( ) external view returns ( address ) { return address ( 0 ) ; },Returns address of oracle currency ( 0x0 for ETH )
6763,function remainingCap ( ) private returns ( uint256 ) { return preSaleCap ; },Returns the Ether amount remaining until the hard-cap
6764,"function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; origin . transfer ( msg . value ) ; }","This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` ."
6765,"function approve ( address _spender , uint _value ) public returns ( bool success ) ;",` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
6769,function setPrivateSaleTokensSold ( uint tokens ) public onlyOwner { privateSalesTokensSold = tokens ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; },Set number of tokens sold on private round .
6771,function setFundingFueled ( ) external ;,Function used by the main partner to set the funding fueled
6773,"function mint ( address _investor , uint256 _amount ) public onlyModule ( STO_KEY , true ) checkGranularity ( _amount ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , ""Investor address should not be 0x"" ) ; adjustInvestorCount ( address ( 0 ) , _investor , _amount ) ; require ( verifyTransfer ( address ( 0 ) , _investor , _amount ) , ""Transfer is not valid"" ) ; adjustBalanceCheckpoints ( _investor ) ; adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _investor ] = balances [ _investor ] . add ( _amount ) ; emit Minted ( _investor , _amount ) ; emit Transfer ( address ( 0 ) , _investor , _amount ) ; return true ; }",mints new tokens and assigns them to the target _investor .
6774,function moveToNextCeiling ( ) public onlyOwner { currentIndex = currentIndex . add ( 1 ) ; },"Move to ceiling , used as a failsafe"
6776,function collectForREQBurning ( uint256 _amount ) internal { requestBurnerContract . transfer ( _amount ) ; },Sends fees to the request burning address .
6777,"function fillAndValidate ( OrderData data ) internal { exchange . fill . value ( msg . value ) ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce , data . v , data . r , data . s ) ; bytes32 orderHash ; ( orderHash , ) = getOrderHash ( data ) ; if ( ! exchange . fills ( orderHash ) ) { errorReporter . revertTx ( ""AirSwap: Order failed validation after execution"" ) ; } }","Calls the fill function at airSwap , then validates the order was filled"
6778,"function newChannel ( address client , address receiver , uint close_timeout , uint settle_timeout , uint audit_timeout , address auditor ) returns ( address ) { address new_channel_address = new ChannelContract ( this , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout , auditor ) ; ChannelNew ( new_channel_address , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout ) ; return new_channel_address ; }",Create a new channel from msg.sender to receiver
6779,"function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }","Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached"
6780,function setMetaData ( string _metadata ) onlyOwner public { metadata = _metadata ; },"Set a metadata string , expected to be JSON , containing things like arbitrator TOS address"
6781,"function getInstructions ( ) public view returns ( string ) { return ""Create a dividend which will be paid out to token holders proportional to their balances at the point the dividend is created"" ; }",Get the Instructions that helped to used the module
6782,"function proxyClaimTokens ( address receiverAddress ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > endTime + tokenClaimWaitingPeriod ) ; require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint num = ( tokenMultiplier * bids [ receiverAddress ] ) / finalPrice ; uint auctionTokensBalance = token . balanceOf ( address ( this ) ) ; if ( num > auctionTokensBalance ) { num = auctionTokensBalance ; } fundsClaimed += bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; require ( token . transfer ( receiverAddress , num ) ) ; ClaimedTokens ( receiverAddress , num ) ; if ( fundsClaimed == receivedWei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiverAddress ) >= num ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }",Claim auction tokens for ` receiverAddress ` after the auction has ended .
6783,"function destroyTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . destroyTokens ( _destination , _tokens ) ; }",Allows the owner to manually destroy some SHP to an address if something goes wrong
6785,function orderTrader ( bytes32 _orderID ) external view returns ( address ) ;,returns the trader of the given orderID .
6786,"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }",Decrease the amount of tokens that an owner allowed to a spender .
6787,function cancelPayment ( uint _idPayment ) onlyOwner external { require ( _idPayment < authorizedPayments . length ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( ! p . canceled ) ; require ( ! p . paid ) ; p . canceled = true ; emit PaymentCanceled ( _idPayment ) ; },` onlyOwner ` Cancel a payment all together
6788,function balanceOf ( address _owner ) public view validAddress ( _owner ) returns ( uint256 ) { return ownedTokens [ _owner ] . length ; },Get the balance of ` ( _owner ) `
6789,function initialize ( ) public onlyOwner { require ( initialized == false ) ; require ( tokensAvailable ( ) == CAP ) ; initialized = true ; },Initializes the Sale Required as we need to Ensure the pre-requirements are met .
6791,function finalizeCrowdsale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; claimEther ( ) ; },"Finalizes ICO : changes token ownership to founder , allows token transfers"
6792,"function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }",Send ` _amount ` tokens to ` _to ` from ` msg.sender `
6793,"function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit ChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }",Used to change the fee of the subscription cost
6795,"function updateTransfer ( uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { data . updateTransfer ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; TransferUpdated ( msg . sender , block . number ) ; }","Dispute the state after closing , called by the counterparty ( the participant who did not close the channel ) ."
6796,function getPledgeLevel ( Pledge p ) internal returns ( uint ) { if ( p . oldPledge == 0 ) return 0 ; Pledge storage oldN = findPledge ( p . oldPledge ) ; return getPledgeLevel ( oldN ) + 1 ; },A getter to find how many old `` parent '' pledges a specific Pledge had using a self-referential loop
6797,function ids ( address _service ) public constant returns ( uint256 serviceId ) { },"returns the id of a service address , if any"
6798,"function transfer ( address _to , uint _value ) returns ( bool success ) { }",send ` _value ` token to ` _to ` from ` msg.sender `
6799,"function acceptOwnership ( ) { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership"
6800,"function checkMerkleProof ( bytes32 _merkleRoot , bytes32 [ ] _proof , uint _position , bytes32 _leaf ) public pure returns ( bool ) { bytes32 _computedHash = _leaf ; uint _checkedPosition = _position ; for ( uint i = 0 ; i < _proof . length ; i += 1 ) { bytes32 _proofElement = _proof [ i ] ; if ( _checkedPosition % 2 == 0 ) { _computedHash = keccak256 ( abi . encodePacked ( _computedHash , _proofElement ) ) ; } else { _computedHash = keccak256 ( abi . encodePacked ( _proofElement , _computedHash ) ) ; } _checkedPosition /= 2 ; } return _computedHash == _merkleRoot ; }",Checks merkle proof based on the latest merkle root set up .
6801,"function extractTokens ( address _token , address _claimer ) onlyOwner public { if ( _token == 0x0 ) { _claimer . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( _claimer , balance ) ; ExtractedTokens ( _token , _claimer , balance ) ; }",This method can be used to extract mistakenly sent tokens to this contract .
6803,"function getCollection ( uint256 _collectionId ) public view returns ( uint256 id , string collectionName , uint256 [ ] editionIds ) { Collection storage collection = allCollections [ _collectionId - 1 ] ; id = collection . id ; collectionName = collection . name ; editionIds = collection . editionIds ; }",Returns all the relevant information about a specific collection .
6804,function distribute ( ) internal { if ( operatingAddress . balance < opThreshold ) { if ( address ( this ) . balance < ( opThreshold - operatingAddress . balance ) ) { operatingAddress . transfer ( address ( this ) . balance ) ; } else { operatingAddress . transfer ( opThreshold - operatingAddress . balance ) ; coldStorage . transfer ( address ( this ) . balance ) ; } } else { coldStorage . transfer ( address ( this ) . balance ) ; } },"Function that sends funds to either Cold Storage , Operating Address , or both based on the Operating Threshold ."
6805,function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { isEnded = true ; if ( tokensRaised < maxTokensRaised ) { token . burnTokens ( ) ; } Finalized ( ) ; } } },Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
6806,"function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenIsFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; emit LaunchContract ( msg . sender , true ) ; }","Used to launch the contract , and enabled token minting"
6808,"function setPrices ( uint256 newBuyPrice , uint256 newSellPrice ) onlyOwner public { buyPrice = newBuyPrice ; sellPrice = newSellPrice ; }",Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
6809,"function transferFrom ( address _from , address _to , uint256 _tokenId ) external canTransfer ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( tokenOwner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _to , _tokenId ) ; }",The caller is responsible to confirm that ` _to ` is capable of receiving NFTs or else they maybe be permanently lost .
6810,"function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; Transfer ( owner , 0 , amount ) ; }",Burns ` amount ` tokens from ` owner `
6811,"function accept ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; r . state = State . Accepted ; emit Accepted ( _requestId ) ; }",Function used by currency contracts to accept a request in the Core .
6812,"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }",Function to claim any token stuck on contract
6813,"function contributeToTokenGroup ( uint256 _tokenId ) external payable whenNotForking whenNotPaused { address userAdd = msg . sender ; require ( _addressNotNull ( userAdd ) ) ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; if ( ! group . exists ) { group . exists = true ; activeGroups += 1 ; } else { require ( group . addressToContributorArrIndex [ userAdd ] == 0 ) ; } if ( ! contributor . exists ) { userAddressToContributor [ userAdd ] . exists = true ; } else { require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] == 0 ) ; } require ( group . purchasePrice == 0 ) ; uint256 tokenPrice = linkedContract . priceOf ( _tokenId ) ; require ( msg . value >= uint256 ( SafeMath . div ( tokenPrice , MAX_CONTRIBUTION_SLOTS ) ) ) ; uint256 cIndex = tokenIndexToGroup [ _tokenId ] . contributorArr . push ( userAdd ) ; tokenIndexToGroup [ _tokenId ] . addressToContributorArrIndex [ userAdd ] = cIndex ; uint256 amountNeeded = SafeMath . sub ( tokenPrice , group . contributedBalance ) ; if ( msg . value > amountNeeded ) { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = amountNeeded ; tokenIndexToGroup [ _tokenId ] . contributedBalance += amountNeeded ; userAddressToContributor [ userAdd ] . withdrawableBalance += SafeMath . sub ( msg . value , amountNeeded ) ; FundsDeposited ( userAdd , SafeMath . sub ( msg . value , amountNeeded ) ) ; } else { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = msg . value ; tokenIndexToGroup [ _tokenId ] . contributedBalance += msg . value ; } uint256 gIndex = userAddressToContributor [ userAdd ] . groupArr . push ( _tokenId ) ; userAddressToContributor [ userAdd ] . tokenIdToGroupArrIndex [ _tokenId ] = gIndex ; JoinGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] ) ; if ( tokenIndexToGroup [ _tokenId ] . contributedBalance >= tokenPrice ) { _purchase ( _tokenId , tokenPrice ) ; } }",Allow user to contribute to _tokenId token group
6814,"function releaseEQUITokens ( bytes32 hash , uint8 v , bytes32 r , bytes32 s ) public whenNotPaused { require ( balances [ msg . sender ] > 0 ) ; uint256 amount = 0 ; for ( uint8 i = 0 ; i < ledger [ msg . sender ] . releaseTime . length ; i ++ ) { uint256 time = ledger [ msg . sender ] . releaseTime [ i ] ; if ( now >= time && ledger [ msg . sender ] . balance [ time ] > 0 ) { amount = ledger [ msg . sender ] . balance [ time ] ; ledger [ msg . sender ] . balance [ time ] = 0 ; continue ; } } if ( amount <= 0 || balances [ msg . sender ] < amount ) { revert ( ) ; } if ( isKYCRequired ) { require ( isWhitelistedAddress ( hash , v , r , s ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } }",Transfers tokens held by timelock to beneficiary .
6815,function withdraw ( uint256 _value ) private pure { _value = _value ; },Withdraws '_value ' in wei from the reserve address
6816,"function updateFromRegistry ( ) external onlyOwner { address _polymathRegistry = getAddress ( Encoder . getKey ( ""polymathRegistry"" ) ) ; set ( Encoder . getKey ( ""securityTokenRegistry"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""SecurityTokenRegistry"" ) ) ; set ( Encoder . getKey ( ""featureRegistry"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""FeatureRegistry"" ) ) ; set ( Encoder . getKey ( ""polyToken"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""PolyToken"" ) ) ; }",Stores the contract addresses of other key contracts from the PolymathRegistry
6817,function setConfirmationPeriod ( uint duration ) external onlyOwner { require ( MIN_CONFIRMATION_PERIOD <= duration && duration <= MAX_CONFIRMATION_PERIOD ) ; confirmationPeriod = duration ; },Set the confirmation period after a vote has concluded .
6819,"function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { require ( balanceOf [ _user ] >= _amount ) ; balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }",Burns ` _amount ` tokens from ` _owner `
6821,"function collectResources ( ) public onlyExistingUser { uint256 index = addressToUser [ msg . sender ] ; User storage user = users [ index ] ; uint256 [ ] storage factoriesIds = userToFactories [ addressToUser [ msg . sender ] ] ; for ( uint256 i = 0 ; i < factoriesIds . length ; i ++ ) { _collectResource ( factories [ factoriesIds [ i ] ] , user ) ; } }",function for collect all resources from all factories
6822,"function moveAllTokensToAddress ( bytes16 _uuid , address _address ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { uint256 accountBalance = balances [ _uuid ] ; removeTokensFromAccount ( _uuid , accountBalance ) ; rntToken . transfer ( _address , accountBalance ) ; tokens = tokens . sub ( accountBalance ) ; tokenTransfers [ _address ] = _uuid ; return true ; }",Function for withdrawal all tokens from Vault account to address .
6824,"function cancelVote ( uint motionID ) external { require ( ! motionConfirming ( motionID ) ) ; Vote senderVote = vote [ msg . sender ] [ motionID ] ; require ( senderVote != Vote . Abstention ) ; if ( motionVoting ( motionID ) ) { if ( senderVote == Vote . Yea ) { votesFor [ motionID ] = safeSub ( votesFor [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } else { votesAgainst [ motionID ] = safeSub ( votesAgainst [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } emit VoteCancelled ( msg . sender , motionID ) ; } delete voteWeight [ msg . sender ] [ motionID ] ; delete vote [ msg . sender ] [ motionID ] ; }",Cancel an existing vote by the sender on a motion to confiscate the target balance .
6825,"function claimPresaleTokens ( ) whenNotPaused external { require ( isPresaleFinalized == true ) ; uint256 senderEther = deposit . receivedEtherFrom ( msg . sender ) ; uint256 multiplier = 10 ** 18 ; senderEther = senderEther . mul ( multiplier ) ; uint256 tokenWei = pricingStrategy . oneTokenInWei ( ) ; uint256 tokensAmount = senderEther . div ( tokenWei ) ; require ( tokensAmount > 0 ) ; token . transferFrom ( owner , msg . sender , tokensAmount ) ; PresaleTokensClaimed ( tokensAmount ) ; }",Function for claiming tokens for presale investors .
6826,function closed ( ) constant returns ( uint ) { return data . closed ; },Returns the block number for when the channel was closed .
6827,"function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) revert ( ) ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) revert ( ) ; }",Transfer locked tokens to Decent.bet 's multisig wallet
6828,"function registerToken ( address tokenAddress , uint256 index ) external onlyAdmin { require ( index > 1 ) ; require ( tokenAddress2Id [ tokenAddress ] == 0 ) ; require ( tokenId2Address [ index ] == 0 ) ; tokenAddress2Id [ tokenAddress ] = index ; tokenId2Address [ index ] = tokenAddress ; }","add a new token into the token list , only admins"
6829,function nominateNewOwner ( address _owner ) public onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; },Nominate a new owner of this contract .
6830,function isBuyOrder ( bytes32 _orderID ) private view returns ( bool ) { uint64 tokens = orderDetails [ _orderID ] . tokens ; uint32 firstToken = uint32 ( tokens >> 32 ) ; uint32 secondaryToken = uint32 ( tokens ) ; return ( firstToken < secondaryToken ) ; },Order parity is set by the order tokens are listed .
6832,function ( ) public payable notPaused { proxyPayment ( msg . sender ) ; },"If anybody sends Ether directly to this contract , consider he is getting ATTs ."
6834,"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; emit AtomicSwapInitialised ( swapId ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }",First or second stage of atomic swap .
6837,function proxyPayment ( address _owner ) payable { doPayment ( _owner ) ; },` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the CampaignTokens created in an address of their choosing
6838,"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . subtract ( _value ) ; totalSupply_ = totalSupply_ . subtract ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }",Remove ` _value ` tokens from the system irreversibly
6839,function claimableHalvingsOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = currentHalving ( ) ; uint256 minerHalving = blockHalving ( miner . block ) ; if ( minerHalving == halving ) { return 0 ; } else { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { return halving . sub ( minerHalving ) . sub ( 1 ) ; } else { return halving . sub ( minerHalving ) ; } } },Computes the number of halvings claimable by the miner
6840,"function addScriptExecutor ( IEVMScriptExecutor _executor ) external auth ( REGISTRY_ADD_EXECUTOR_ROLE ) returns ( uint256 id ) { uint256 executorId = executorsNextIndex ++ ; executors [ executorId ] = ExecutorEntry ( _executor , true ) ; emit EnableExecutor ( executorId , _executor ) ; return executorId ; }",Add a new script executor with address ` _executor ` to the registry
6841,"function addPlayerToBoard ( bytes32 boardHash , bytes32 playerName ) public payable returns ( bool ) { require ( msg . value >= playerCost ) ; Board storage g = boards [ boardHash ] ; split ( g . boardOwner , msg . value ) ; uint newPlayerID = g . numPlayers ++ ; g . players [ newPlayerID ] = Player ( playerName , msg . sender , 0 , 0 , 1 ) ; return true ; }",Add a new player to an existing leaderboard
6842,function disableTransfers ( ) external onlyOwner { require ( transfersEnabled ) ; transfersEnabled = false ; DisableTransfers ( msg . sender ) ; },Disable all transfers in case of a vulnerability found in the contract or other systems .
6843,function ( ) external payable { require ( isContract ( controller ) ) ; require ( ITokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) == true ) ; },"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract"
6846,"function assignToEarlyBirds ( address [ ] earlyBirds , uint256 amount ) onlyOwner public { require ( amount > 0 ) ; for ( uint i = 0 ; i < earlyBirds . length ; i ++ ) _transfer ( msg . sender , earlyBirds [ i ] , amount * 10 ** 18 ) ; }",batch assign tokens to users registered in airdrops
6847,function name ( ) external view returns ( string _name ) ;,A descriptive name for a collection of NFTs in this contract
6848,"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }",from ` _from ` will be sended ` _value ` tokens to ` _to `
6849,function getAmountFida ( uint256 _weiAmount ) public view returns ( uint256 _fidaAmount ) { require ( _weiAmount != 0 ) ; _fidaAmount = _weiAmount . mul ( fidaPerEther ) . div ( 100000 ) ; return _fidaAmount ; },Amount of fida you would get for any amount in wei
6850,"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Distribution Failed: Countdown not finished yet"" ) ; }",Distirbutes a constant quantity of tokens to all the specified addresses
6851,"function approveAndCall ( address spender , uint256 amount , uint256 nonce , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }",` msg.sender ` approves ` spender ` to spend ` amount ` tokens on its behalf and notify the spender from your approve with your ` extraData ` data .
6852,function hasClosed ( ) public view returns ( bool ) { return ( totalTokensSold >= totalSaleAllocation ) || super . hasClosed ( ) ; },Signifies whether or not the private sale has ended .
6853,"function _freezeTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; freezed [ _to ] = freezed [ _to ] . add ( cst ) ; }",_freezeTranfer perform actual tokens transfer which will be freezed ( see also checkTransfer ( ) )
6854,function getChannelWith ( address partner ) constant returns ( address ) { return data . getChannelWith ( partner ) ; },Get the address of channel with a partner
6856,"function transferFrom ( address _from , address _to , uint256 _tokenId ) public ;",Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
6857,"function checkCooldown ( address _allower , address _allowee ) external constant returns ( uint256 remaining ) { if ( cooldown [ _allower ] [ _allowee ] > now ) { return ( cooldown [ _allower ] [ _allowee ] - now ) ; } else { return 0 ; } }",Check the cooldown remaining until the allowee can withdraw the balance
6858,"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ;",send ` tokens ` token to ` to ` from ` from ` on the condition it is approved by ` from `
6859,"function missingTokensFallback ( ) public { uint256 missingTokens = token . balanceOf ( this ) . sub ( totalFrozen ) ; require ( missingTokens > 0 ) ; TokenWithOwner tokenWithOwner = TokenWithOwner ( token ) ; token . safeTransfer ( tokenWithOwner . owner ( ) , missingTokens ) ; }",Transfers tokens of unknown holders to token contract owner .
6860,"function sell ( uint256 amount ) public { amount = amount * 10 ** uint256 ( decimals ) ; require ( this . balance >= amount / sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount / sellPrice ) ; }",Sell ` amount ` tokens to contract 10 ( decimals ) )
6861,function pauseContribution ( ) public onlyOwner { paused = true ; },Pauses the contribution if there is any issue
6864,function removeOwnership ( uint _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; },"Decentralizes the contract , this operation can not be undone"
6867,"function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenIsFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }",Reusable code to do sanity check of transfer variables
6868,"function setNextGame ( uint256 _price , uint256 _timeout , uint256 _minimumTimeout , uint256 _numberOfWagersToMinimumTimeout ) external onlyCFO { require ( _timeout >= _minimumTimeout ) ; nextPrice = _price ; nextTimeout = _timeout ; nextMinimumTimeout = _minimumTimeout ; nextNumberOfWagersToMinimumTimeout = _numberOfWagersToMinimumTimeout ; NextGame ( nextPrice , nextTimeout , nextMinimumTimeout , nextNumberOfWagersToMinimumTimeout ) ; }",Set the parameters for the next game .
6870,"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }",Helper function actually performing the sending of tokens .
6873,"function calculateFees ( Data storage self , address contractAddress , uint amount ) internal view returns ( uint calculatedFees ) { uint maxFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ) ; uint minFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ) ; uint bpsFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ) ; uint flatFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ) ; uint fees = ( ( amount . mul ( bpsFee ) ) . div ( 10000 ) ) . add ( flatFee ) ; if ( fees > maxFee ) { return maxFee ; } else if ( fees < minFee ) { return minFee ; } else { return fees ; } }",Set the frozen token balance for a given account
6874,function convertToEther ( uint256 _value ) private pure returns ( uint256 ) { return _value * FIXED_RATE / 10 ** 18 ; },The ` convertToEther ( ) ` converts value of SENC Tokens to Ether based on pegged rate .
6875,"function upgrade ( uint256 _value ) public { UpgradeState _state = getUpgradeState ( ) ; require ( _state == UpgradeState . ReadyToUpgrade || _state == UpgradeState . Upgrading , ""State must be correct for upgrade"" ) ; require ( _value > 0 , ""Upgrade value must be greater than zero"" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; totalUpgraded = totalUpgraded . add ( _value ) ; upgradeAgent . upgradeFrom ( msg . sender , _value ) ; emit Upgrade ( msg . sender , upgradeAgent , _value ) ; }",Allow the token holder to upgrade some of their tokens to the new contract .
6876,"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) { return true ; }","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed"
6877,"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) external returns ( bool success ) ;","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` ."
6878,"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] . sub ( 1 ) ; delete idToOwner [ _tokenId ] ; }",Use and override this function with caution .
